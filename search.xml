<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[共享单车体验]]></title>
      <url>http://noparkinghere.win/2017/04/10/2017/2017-04-10-%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>大学时在南京上的学，时隔多年没有去这座城市了，今天去南京某学校转了一圈，让人最大的感触应该算是共享单车。仔细想一下，似乎大学生永远都是新鲜事物的主力军，而每几年大学生活就会有翻天覆地的变化，从开始有电脑，到网络的普及，从开始有手机到智能机的普及，从校园一卡通到移动支付的普及等等，今年也许最流行的要数共享单车了。</p>
<p>共享自行车这个项目其实已经被运营了很多年了，早在7,8年前，很多城市就有了政府组织的市民代步车，几年前我在南邮也见到了校园共享车。共享单车在学生中流行不是没有理由的，主要的原因应该可以归结为以下几点：</p>
<ul>
<li>很多校园比较大，占地 2/3 千亩的学校，上一节课往往要走很远，学生去食堂出校门也比较远，因此自行车往往成必备，首先可以看出学生是有这个市场需求的。</li>
<li>一些学校地处偏远，交通不便，学生去做公交地铁需要走几公里路，共享单车也帮解决了这个问题。</li>
<li>学生自己购车价格不便宜，并且存在被偷的风险。</li>
</ul>
<p>以前我一直都是用摩拜单车，骑行的距离比较短。今天在学校中，主要还是看到了 ofo 和摩拜单车。下面就两者，说下体验和差别：</p>
<h3 id="ofo"><a href="#ofo" class="headerlink" title="ofo"></a>ofo</h3><p>ofo 的创业团队是一群大学生，他们也是瞄准了大学生在自行车上面的需求，也是国内最早做共享单车的，但随着节能减排的推广，以及很多人发现短途旅行骑车比公交更合适，现在共享单车也已经在普通大众中火了起来。</p>
<p>ofo 的车是传统自行车，采用的是密码锁，用户上传车牌号，服务器下发密码，用户通过密码解锁就可以骑车了。ofo 车的优点是骑起来轻松，坐起来也舒服些，缺点是采用传统轮胎，维护成本高，校园中大量的 ofo 车轮胎没有气，车子无法解锁，晚上回来的时候，大量的人在找 ofo 的车，但很少有人能够找到可用的。另外 ofo 车不带定位系统，你只能随缘找车，骑车。</p>
<h3 id="摩拜单车"><a href="#摩拜单车" class="headerlink" title="摩拜单车"></a>摩拜单车</h3><p>相比 ofo ，摩拜的创业过程则完全不同，摩拜是有着明确的市场定位以及丰富市场经验的一群人做的一个项目。从一开始摩拜就是定位城市共享单车，目的是解决最后市民出行“最后一公里问题”。让大家可以骑车锻炼身体，短途旅行不坐公交，不开私家车。摩拜单车全部是都是只能车，自带 GPS 定位，能够通过远程验证解锁，轮胎不需要打气维护，自带充电装置等等。优点是，我们很容易找到摩拜的车，解锁成功率也很高，车的利用率高损坏较少，外观时尚漂亮（听到周围有女生评价比较喜欢摩拜的外观）。缺点，车身太过笨重，非打气轮胎让骑行十分艰难，上坡基本上骑不上去，路不太平整的地段骑车相当痛苦。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们可以看出看出摩拜和 ofo 截然不同的特点，两者各有利弊。而最新的消息现实 ofo 已经在出智能车了，最新的 ofo 车会配备北斗锁，通过北斗导航定位单车，然后同时也能够提供简单的通讯功能。希望未来的单车可以具备：定位，手机解锁，轻便，车身可调节等特点。</p>
<p>提供另外一点设想，共享单车的主要目的是共享和出行，对于一些每天需要使用单车的人来说，目前一次 1 元左右价格仍然显得昂贵，希望未来可以提供包月或者包年服务，基本可以以等同于自己购买自行车的价格来使用共享单车。对于特定的人群如：学生等，可以提供 10/月的服务，这样既减少的学生买车被偷的风险，又可以让车的使用率活起来，现金直接到位。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[PC下的C项目开发工具]]></title>
      <url>http://noparkinghere.win/2017/04/07/2017/2017-04-07-pc%E4%B8%8B%E7%9A%84c%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>这篇文章主要讲述基于 x86 下的 C 项目开发工具，对于 ARM 等其他平台的开发不再本文的谈论范围内。</p>
<p>C 语言问世已经有 40 年的时间了，40 年足够一个婴儿步入壮年，现在的程序语言可谓百花齐放，对于老式的 C 由于主要在做嵌入式开发，往往缺少一个 x86 平台下的调试器，VS 支持 VC，而 VC 则是兼容 C 语言的，可能能够调试 C 的程序，但是 VS 由于主要支持的是 VC，对 C 的语法也都是基于 C++ 的，一些问题无法显现出来，而即便可以支持 C 语言，可能是 C89 的标准，不支持新的语法格式。老牌的 GDB 虽说功能极度强大，但是只能说是神器，命令行的操作方式，让新手或者即便不是新手也很难将这个工具用的好，反正我是用一次忘一次，且用起来很麻烦。</p>
<p>我要找的工具是需要具备 GDB 的功能，同时又具备友好的 GUI 交互的，中间我试用过 ddd，可惜该工具也太过古老了，图形界面和现在的风格完全不符合，并且一些功能用起来有点莫名其妙，然后就没再作进一步的研究了。除了 ddd 我还尝试过 Kdevelop，然而该软件过于小众，虽然有文档，但问题会频繁出现，且缺少相关的 FAQ，windows 下的 Kdevelop 更是几乎没有查有意义的参考解答。</p>
<p>偶然在 stackoverflow 看到 Eclipse CDT 是可以调试 C/C++ 项目的，其调用的工具就是 GDB，能够将 GDB 命令的输出结果转成 GUI 的界面清晰陈列给用户，注意本文只是提供一种我个人认为比较好的方式，其他内容可以参考下面的链接。</p>
<p>Eclipse 算是一个老牌的 IDE 了，可以嵌入一些开发组件，让它能够完成你的工作，其大名在 JAVA 界可能比较火些。Eclipse 支持多个平台的开发，同时载入调试工具也可以选用多种多个平台的工具。</p>
<p>目前使用 Eclipse 调试 C 程序感觉都比较良好，能够自动帮列出函数中变量的值，内存中的地址等等信息，基本上完全继承了 GDB 的强大之处。目前刚刚开始研究 Eclipse 还并不是特别熟悉，后续会进一步挖掘 GDB 这个调试工具。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="https://www.ibm.com/developerworks/library/os-eclipse-cdt-debug2/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/library/os-eclipse-cdt-debug2/index.html</a><br><a href="http://www.eclipse.org/cdt/downloads.php" target="_blank" rel="external">http://www.eclipse.org/cdt/downloads.php</a><br><a href="http://stackoverflow.com/questions/79023/is-there-a-c-gdb-gui-for-linux" target="_blank" rel="external">http://stackoverflow.com/questions/79023/is-there-a-c-gdb-gui-for-linux</a><br><a href="http://wiki.jikexueyuan.com/project/eclipse/eclipse-run-configuration.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/eclipse/eclipse-run-configuration.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[kindle 使用技巧总结]]></title>
      <url>http://noparkinghere.win/2017/04/06/2017/2017-04-06-kindle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>kindle 是亚马逊出品的一个阅读产品，这几年在阅读界可以说是异常的火爆，改变了很多人的阅读习惯。kindle 本身可以代表一个跨平台的软件，其支持 windows，Android，IOS等；同时，kindle 也可以算是亚马逊推出的一款电子产品。</p>
<p>kindle 的优点是可以支持多个平台，同步你的阅读记录，打开平板或者 kindle 硬件可以直接阅读你的书籍，挡在公交车上或者外出时，也可以随时用手机阅读。</p>
<p>kindle 的成功主要源于电纸书这个产品，电纸书采用的是不发光的仿真纸质屏幕，可以让你阅读时减少眼睛的疲惫感。最关键的一点是，你可以在 kindle 上轻松地找到大量阅读资源。</p>
<h3 id="获取资源方式"><a href="#获取资源方式" class="headerlink" title="获取资源方式"></a>获取资源方式</h3><p>kindle 的阅读资源获取可以分为以下是那种方式：</p>
<h4 id="官方商城"><a href="#官方商城" class="headerlink" title="官方商城"></a>官方商城</h4><p>通过官方的 kindle 阅读商城，我们可以购买电子书籍，一般的电子书籍往往都不是免费的，当然这些书籍要比实体书籍便宜不少。</p>
<h4 id="数据线传输"><a href="#数据线传输" class="headerlink" title="数据线传输"></a>数据线传输</h4><p>可以将你自己的电子书通过 USB 数据线传入 kindle 中，这也是一种比较好的方法，你可以自己从网上找到你需要的电子书，然后将他们在 kindle 中查看， kindle 原生支持 TXT,PDF,MOBI,AZW，一般 MOBI 格式表现最佳，我们也优先选择这个格式。</p>
<h4 id="邮箱推送"><a href="#邮箱推送" class="headerlink" title="邮箱推送"></a>邮箱推送</h4><p>邮箱推送应该是 kindle 最方便的一点，你可以将你的内容通过邮箱直接发送到你的 kindle 设备/软件中。</p>
<p>具体操作如下：登录亚马逊的官网-&gt;在我的账户中点击管理我的内容和设备-&gt;设置-&gt;添加认可的电子邮箱-&gt;使用认可的电子邮箱发送电子书文件到设备邮箱中。</p>
<p>当您使用〖发送至Kindle〗电子邮箱发送个人文件时，您的文件会自动保存到Kindle图书馆中。你每个 kindle 设备都会对应一个不同的“〖发送至Kindle〗电子邮箱”，因此当你需要发送文件时，需看清除要发送到哪个设备上，而每个设备对应的电子邮箱地址是可以任意修改的。</p>
<p>当且只当你发送的目标设备联网后，亚马逊服务器能够读取你设备上具备的文件信息，其他设备才可以同步该设备上的已有文档，否则的话，未被发送的设备是不会显示这些文件的。</p>
<h3 id="资源下载网站"><a href="#资源下载网站" class="headerlink" title="资源下载网站"></a>资源下载网站</h3><p>目前市面上有很多提供 kindle 方式，我们罗列出三种方式。</p>
<h4 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h4><p>通过网盘的检索方式，我们可以使用<a href="http://www.xilinjie.com" target="_blank" rel="external">西林街</a>对书籍进行搜索，一般有可能能够找到对应的电子书籍，但检索效率不高。</p>
<h4 id="微信推送"><a href="#微信推送" class="headerlink" title="微信推送"></a>微信推送</h4><p>市面有很多提供电子书服务的微信公号，如：kindle图书馆之类的，这种服务号一般推送起来也比较方便，服务号绑定目标邮箱地址（上面提到的kindle 设备邮箱），亚马逊官网信任你的推送地址。然后在服务号中输入书名，打开推送即可。这种服务号，往往新书需要办理会员，或者推送本书有所限制。</p>
<h4 id="网址推送"><a href="#网址推送" class="headerlink" title="网址推送"></a>网址推送</h4><p>和微信推送类似，也有一些网站可以提供 kindle 电子书本地下载以及邮箱推送服务，需要操作的步骤和微信推送基本相同：信任邮箱，设备邮箱地址。这边推荐一个网站：<a href="http://www.kindlepush.com" target="_blank" rel="external">kindle推</a>。同时可以阅读知乎的一篇有关<a href="https://www.zhihu.com/question/20093221" target="_blank" rel="external">如何获取电子书资源的文章</a>，文末的参考网址同样值得一看。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>随着科技的发展，人们的生活越来越多的被改变，而 kindle 让阅读变的随处可行，让你可以随时查看字词解释，不久的将来也许消耗资源的纸质书籍将会真正被电子书籍所取代。</p>
<blockquote>
<p>参考链接：<br><a href="https://www.zhihu.com/question/19712951" target="_blank" rel="external">https://www.zhihu.com/question/19712951</a><br><a href="https://www.zhihu.com/question/20093221" target="_blank" rel="external">https://www.zhihu.com/question/20093221</a><br><a href="https://www.zhihu.com/question/31313562" target="_blank" rel="external">https://www.zhihu.com/question/31313562</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯传读后感]]></title>
      <url>http://noparkinghere.win/2017/04/05/2017/2017-04-05-%E8%85%BE%E8%AE%AF%E4%BC%A0%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      <content type="html"><![CDATA[<p>上周末阅读完的一本书，之前写过一篇阅读初感，总的来说这本书值得一看，但并不是让人特别满意。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-23-腾讯传读后初感/1.jpg" alt=""></p>
<a id="more"></a>
<p>下面说一下阅读这本书的感受吧，该书的前 2/3 可以让人阅读起来特别的轻松，仿佛真的是赋予了腾讯人物的形象，一点点的阐述它的诞生，成长，壮大。值得一看的是作者文笔顺畅，让人如阅读一本小说般的轻松自如；并且，书中的内容时间也都是基于事实，人物的陈述，基本上不会被作者主管意识所带偏。</p>
<p>然而，后 1/3 腾讯从立足互联网后，如何从壮大到争霸这一段就写的相当混乱了，腾讯这家公司很不同于别的公司，每个部门都相当于一个独立的个体，鼓励竞争和内部创业，但作者在写多条主线时却不能得心应手，往往写的很混乱，每个点都是带过一笔，却又不详细深究，而这一段内容甚至不如网络上所找到的详细。一个巨无霸公司的单身，并不可能仅是依靠那么几个人，而腾讯显然在多个业务领域都是领先于竞争对手的，而另外部分领域如：搜索，网购又是最终失败了的。作者只是简单地详尽的阐述出，游戏，IP，音乐领域为何成功，没能将代表人物起到的贡献列出来；而对搜索，网购等如何失败又没有进行分析和解答。</p>
<p>作者开篇时提及，该书花费了作者多年的时间考察，采访，耗费了大量的心血才最终完成，但我只想说，也许早期的作者在写这本书时，还没有微信，没有移动互联网，开始一两年的时间，作者是尽心尽责地去做访谈，做调研，思考和分析的，可以看出全书前一半内容写的很是认真的。后一半，随着移动互联网发达起来，自媒体，微创业等越来越普及，作者安奈不住心思好好写作了，开始写的越来越急，内容也越来越乱，经不起推敲了。文章中甚至可以看出有一部分内容已经有过调研或者采访，却没能把内容完整的呈现给作者，而最后的更是越写越快，急着结束了。</p>
<p>总的来说，该书还是要比其他的自传写的好，全篇前 2/3 很值得一读的，虽然后面确实写的不咋的，但也基本上将 1998-2016 表述完整了。</p>
<p>有关腾讯这家企业，之所以能够发展到今天，我想主要依靠五点：</p>
<ul>
<li>危机意识：腾讯仅是依靠 QQ 这种 Windows 平台下的入门级应用起家的，依托于其他平台，如：中国移动，微软等等，即便拥有数亿用户，但自始至终，它都缺乏安全感，任何的风吹草动都可以击垮它。一旦被用户抛弃它就什么都没有了，所以腾讯数十年如一日，始终在扩展自己的业务，不断想着通过其他手段来赚钱。如果微信不属于腾讯的话，可以说，腾讯的市值只有现在的三分之一不到，而微信也只是腾讯多个基于手机通讯 APP 内部创新项目中的一个。</li>
<li>把握时局：对于中国这种市场能够明察秋毫，QQ 并非国内最早的 IM 软件，但只有它活下来了，因为早期别的 IM 软件都很大，而国内带宽小，腾讯 QQ 可以做到就只有 1M 不到，这显然更加符合国内的市场环境，且这么多年来，腾讯的产品始终符合国情和市场环境。短信服务，拥抱移动梦网等让 QQ 赚到了第一桶金，手机需要软件，腾讯立马可以做出一个微信（更加适合移动互联网的软件）。</li>
<li>产品优良：马化腾自诩为产品经理，可以看出在腾讯在产品上面确实是做到精益求精的，尽管 QQ 看上去仍然这么幼稚，但它就是击败了 MSN ，有着很多别人没有或者很久才加上去的适用功能。腾讯这家公司的产品虽然被很多人说抄袭，但不得不说他们产品就是能够做的好，这家公司也总是：别人先创新，我抄袭后再超越对手（走别人的路，让别人无路可走）。举两个移动端的例子，微信功能很强大，但可以兼容各种手机，对于三四年前的手机也能够流畅运行，较少卡顿，而支付宝，淘宝等，手机开启后可能会卡顿很久才能正常工作，另外同为后台开启，微信的耗电比支付宝，淘宝都少的多。支付宝，淘宝其实也不是特别差，比京东手机 APP 要好不少，但和微信比缺失差的颇多。再举个例子，最近比价热门的手游王者荣耀，这种游戏对手机配置要求还是比较高的，最起码我三年前的手机刚开始是玩不了的，但让人惊奇的是，这个游戏出来一年后，经过不断的优化，竟然同一款手机现在可以比较流畅的玩这个游戏了。</li>
<li>模式创新：无可厚非，腾讯赚钱主要就来自收费模式的创新，通过 Q 币购买虚拟物品，充值会员，提供 QQ 秀，空间正版音乐，正版免费漫画等等。这些中有的寻求到了直接变现的方法，而有的则慢慢培养用户习惯，希望之后可以创造更多的财富值。</li>
<li>市场导向：腾讯做的产品从来都是以市场为驱动进行追逐的，就如同乔布斯说的那样：杰出的艺术家创造，伟大的艺术家剽窃。很多人将马化腾比作中国版的比尔盖茨，同样都等着别人先做小白鼠，他们在后面仔细观察，然后再后发制人干掉先驱垄断市场。而腾讯所有的产品都是必须要有市场价值和意义的，在这家公司不谈情怀，即便 QQ 早期的设计者喜欢 linux 所以采用了企鹅作为图标，但 QQ 自始至终都没有一个 linux 版本的，因为小众的用户对他们来说缺乏意义。</li>
</ul>
<p>个人认为腾讯的成功可以归功于上面几点，以上五点只分析它自身的成功原因，当然资本运作也可以算，但每家成功的公司都具备这点，不会单独列出来提及。另外开放策略，个人认为和腾讯的成功关系并不大，腾讯只不过不再想成为万夫所指，所以才勉强开放，而事实上，它自家的产品就足够优秀，往往领先合作者一大截，但打着开放的口号，自己吃肉总给留点汤给别人吧，所以腾讯才将自己 1/10 左右给合作伙伴做。而事实上我认为，很多投资的公司，做的远不如腾讯，京东的手机 APP 是我目前为止用的最烂的应用，且腾讯入股后，这家公司就再也没有什么长进了。同为入股公司，搜狗在拿下了 SOSO 还有拥有了腾讯多个软件入口后，反而市场表现还不如出道没多久的360搜索和神马搜索。近年来创业成功的公司，如：美团，滴滴等，都应该感谢 360，也是自 3Q 大战之后，腾讯开始不再明目张胆的抄袭搞垮对手了。</p>
<p>虽然腾讯这家公司在业界的口碑一直不佳，一直在模仿，从未有创新，但无可否认，这家公司确实极具实力，在国际科技巨头中也有一席之地，现如今和百度比起来，在无论是决策还是产品上都不可同日而语。而同阿里比的话，两者都算是各有特色，阿里拥有着良好的口碑和情怀，且自身的业务体量很大，但想要做大布局，有腾讯这样的对手在，确实极为困难。现如今腾讯已经完成了当年陈天桥的梦想，真正将这家公司打造成了在线生活–网络迪士尼。</p>
<p>竞争的世界很残酷，未来的互联网更是如此，我们永远看不清未来究竟会发生什么，也许明天人工智能会成为新的科技革命，今天我们所不耻的百度会成为最大的巨头，今天风光无两的大公司会纷纷倒下，未来就是因为无法预测，我们才格外期待吧，期待明天的腾讯也可以带给我们不同。</p>
<hr>
<p>写作时间：20:00-21:30</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-我是英雄]]></title>
      <url>http://noparkinghere.win/2017/04/04/2017/2017-04-04-%E5%BD%B1%E8%AF%84-%E6%88%91%E6%98%AF%E8%8B%B1%E9%9B%84/</url>
      <content type="html"><![CDATA[<p>晚上看了一部僵尸题材的电影：《我是英雄》，说起这个题材其实早就被电影游戏玩烂了，欧美的僵尸片可以说没有 100 部也有 50 部了。</p>
<p>欧美僵尸题材中最出名的应该算是《生化危机》系列了，这部电影从大约十年前就开始连载了，前段时间有出了第六部。欧美可以说已经把这个题材真的玩烂了，这种电影往往都是在凑剧情，炫特效，这么多年过来，仍然在走着动作特效片，一般的观众大都也审美疲劳了。即便最新的《生化危机6》也是有着冗余的动作场景和特效场景，全片一大半时间在彰显特技，因此评分不可能特别高。</p>
<a id="more"></a>
<p>亚洲现在也开始拍僵尸片了，前段时间比较火的《釜山行》就是这个题材的典型，该片算是近几年来最成功的商业片了，剧情很完整的刻画了人性，且内容不拖沓，很充实，当然结局不算完美。</p>
<p>今天看得《我是英雄》，是日本的一部僵尸片，整体观影是不如《釜山行》的，虽然可以说和《釜山行》一样，是平凡人面对僵尸的各种人性百态，但该片太对得起名字了，真的叫《我是英雄》，全片的主角光环太过严重，给人的感觉就是想要将一个胆小无能的普通人塑造成英雄，然后刚好想到了僵尸题材，然后就硬套上去了，虽然说《釜山行》也是将亲情题材和僵尸进行整合，但人家不违背常识和逻辑，各个地方衔接的都恰到好处。</p>
<p>整体来看，《我是英雄》对于观影要求不高的人来说可以看看，和《釜山行》以及《寄生兽》这种另类题材片还有着不少的差距。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-乘风破浪]]></title>
      <url>http://noparkinghere.win/2017/04/03/2017/2017-04-03-%E5%BD%B1%E8%AF%84-%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA/</url>
      <content type="html"><![CDATA[<p>今晚观看了电影《乘风破浪》，这部电影是今年春节的贺岁片，听看过的人都说算是贺岁电影中比较不错的了，当然这个前提也会死基于现在这么差的国内电影水准的。</p>
<p>《乘风破浪》是韩寒的第二部作品，第一部是几年前的一个公路片，主题和风格上，两者基本保持一致。在这部电影中，也是能够看到韩寒作为一个导演是有着很大的进步的。</p>
<a id="more"></a>
<p>《乘风破浪》主要内容是一个年轻人穿越回过去，见证了自己的父亲和母亲的一段历史，通过亲眼所见来消除父子多年的矛盾和不睦。其实这种主题的电影已经被玩过很多次了，之前也看过欧美的小短片，有过这种教育题材的视频。</p>
<p>该电影之所以觉得不错，应该可以归功于以下几点：</p>
<ul>
<li>剧情三关比较的真，随着这总题材被玩的很多，但玩的好的并不多。</li>
<li>演员演技都还比较到位，剧中的演员都可以说是实力派的明星。</li>
<li>轻戏剧类型，太过承重的文艺/故事片很难让人耐心看下去，如：白日焰火等</li>
</ul>
<p>总结下来，这部电影还是值得茶前饭后一看的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[GithubPage+Hexo搭建博客]]></title>
      <url>http://noparkinghere.win/2017/04/02/2017/2017-04-02-GithubPage+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>个人博客是使用 githubpage+jekyll 搭建的，且博客已经工作有半年了，但由于期初的模板没有找好，加上一些其他的问题，导致博客看起来比较凌乱，这边给出另外一个 GithubPage+Hexo 的博客搭建方法供大家参考，本文操作系统主要使用的是 ubuntu 16.04，使用其他 linux 发行版的用户，可以参考本文。附上最终效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-14-githubpage-hexo搭建博客/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-14-githubpage-hexo搭建博客/2.png" alt=""></p>
<a id="more"></a>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h4><p>Node.js 是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。</p>
<ul>
<li>安装 nodejs ： sudo apt-get install nodejs , 注意 ubuntu 16.04 使用：sudo apt install nodejs</li>
<li>安装 npm ： sudo apt-get install npm ， 注意 ubuntu 16.04 使用：sudo apt install npm</li>
</ul>
<p>需要安装 nrm ， nrm 是 npm 的资源管理器，借助各个工具可以方便快捷地对 npm 的源进行管理。另外，由于国内网络环境原因在使用 npm 默认下载源的时候不仅速度非常慢而且常常会超时，因此这里还手动指定了从淘宝源下载。<code>sudo npm install nrm -g --registry https://registry.npm.taobao.org</code>，<code>nrm use taobao</code>（如果出现无法找到 node 则执行： <code>sudo  ln -s /usr/bin/nodejs /usr/bin/node</code> ）</p>
<h4 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h4><p>这边步骤在多篇博文中都有详细描述，这边就不再累述了，可以直接搜索引擎搜索，或者在本博客的其他文章中找到。</p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。接下来我们开始使用 Hexo 搭建博客。</p>
<ul>
<li>sudo npm install hexo-cli -g 或者 sudo npm install -g hexo</li>
<li>如果以上命令遇到错误或者警告，则更新 npm 版本，<code>sudo npm i npm -g</code></li>
<li>创建并进入目录 Hexo ：<code>mkdir Hexo &amp;&amp; cd Hexo</code></li>
<li>使用 hexo 生成博客框架。依次执行如下命令(hexo init blog 过程可能会比较慢，需要耐心等待。)：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ hexo init blog</div><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ npm install</div><div class="line">$ hexo generate (hexo generate 为我们生成了静态文件存储于 public 文件夹之下，并且在一开始默认情况下执行这句将会为我们生成一个 Hello World 的页面。)</div><div class="line">$ hexo server (通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 。)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：hexo 中的 generate, server, dpoly 等操作都可以简写为首字母，所以 hexo generate 等同于 hexo g ，hexo server 等同于 hexo s，。</p>
<h3 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h3><p>通过 tree | less 可以查看以下 blog 的目录结构，主要的几个文件和目录的作用分别如下：</p>
<ul>
<li><code>_config.yml</code> ：配置文件，可以修改网站的主题、标题、作者等信息。</li>
<li><code>public</code> ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。</li>
<li><code>scaffolds/</code> ：模板文件，当要给博客添加新文章的时候，将根据对应的模板进行创建。</li>
<li><code>source/</code> ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 <code>_posts</code> 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 <code>_posts</code> 目录底会自带一个 hello-world.md 的文件。</li>
<li><code>themes/</code> ：主题文件，自带默认主题 landscape 。</li>
</ul>
<h3 id="操作指导"><a href="#操作指导" class="headerlink" title="操作指导"></a>操作指导</h3><h4 id="文章创建"><a href="#文章创建" class="headerlink" title="文章创建"></a>文章创建</h4><p><code>hexo new [layout] &lt;filename&gt;</code> 其中 layout 为可选参数，指定了新创建的文件布局，默认为 post 文件。 filename 为必填参数，指定了文件名，如果文件名中有空格则需要把文件名用引号”” 包裹起来。例如： 终端输入：  <code>hexo new &quot;我的第一篇文章&quot;</code> ，这时候我们发现 hexo 在 <code>source/_post</code> 目录之下创建了一个 我的第一篇文章.md 的文件。打开该文件进行编辑。我们也可以通过 atom 等常用的 markdown 编辑工具直接在 <code>source/_post</code> 目录下创建文章进行编辑即可。刷新浏览器就可以看到我们博客更新的内容了。</p>
<p>至此我们基本配置好了本地 hexo 服务，能够自己写点内容了。</p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><ul>
<li>在 hexo/source 目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为<code>https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/</code> 图片名称。 注意目录必须为 <code>hexo/source</code>，且图片文件夹为 img ，否则通过 hexo generate 可能无法生成目标图片。</li>
<li>也可以使用<a href="http://tc.ffsky.net/" target="_blank" rel="external">图床</a>外链来存储图片。</li>
</ul>
<h3 id="部署到-github-page"><a href="#部署到-github-page" class="headerlink" title="部署到 github page"></a>部署到 github page</h3><p>访问 github，创建库 <code>git账户名.github.io</code> ， 这一这个名字是固定的，一般的库没法修改跳转地址，只能显示为 github page 。</p>
<p>将远程库同步到本地，<code>git clone [你的仓库的 url]</code>，本地会多出一个 <code>git账户名.github.io</code> 的文件夹，然后把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>由于访问网页最终都是访问的 html 文件，因此这边需要通过本地 hexo generate 工具生成所需的 html 页面代码，然后每次将你的 html 页面覆盖到 github 的项目中去。</p>
<p>执行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">cp -R public/* [你的仓库名]</div><div class="line"><span class="built_in">cd</span> [你的仓库名]</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">'update blog'</span></div><div class="line">git push</div></pre></td></tr></table></figure></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>注意，实际上 github page 是可以自己按照 jekyll 的方式将源码生成 html 文件的，但是 对于 hexo 等其他源码，如果需要展示出来，则必须本地生成 html 代码，然后把生成的代码部署到服务器上面才行，这边我们可以使用如上面的方式（将 public 目录下面生成的 html 文件直接复制到服务器的根目录下）， hexo 提供了更加人性化的方式，通过 hexo deploy 可以一键完成部署（无需在通过 push 手动推送了），每次部署的步骤，可按以下两步：</p>
<ul>
<li>修改 该配置文件：vim <code>_config.yml</code>，执行如下命令才能使用 git 部署 <code>npm install hexo-deployer-git --save</code>:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repository: https://github.com/username/username.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p><em>注：type: git 老版本可能是 github，repository 后也可以采用 ssh 的地址，https 每次需要输入密码，而 ssh 需要配置好公钥私钥免密码。</em></p>
<ul>
<li>执行以下命令无需手动将代码 push 上去<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
</li>
</ul>
<p>以上步骤虽然看起来貌似繁琐，但实际可以写成 bash 脚本，这样每次就会自动生成 public 自动复制以及上传了。</p>
<h4 id="CNAME-配置"><a href="#CNAME-配置" class="headerlink" title="CNAME 配置"></a>CNAME 配置</h4><p>github page 可以使用上面提供的网址也可以让每次访问时跳转自己的域名地址，一般 github page 需要在根目录下新建一个 CNAME 文件，其中写下你的域名地址如：<code>www.google.com</code>。</p>
<p>因为 hexo 每次需要生成好文件再上传，这边将 CNAME 文件放入 source 目录下，每次 hexo g &amp;&amp; hexo generate 后则会上传 CNAME 到 github page了。</p>
<h3 id="扩展补充"><a href="#扩展补充" class="headerlink" title="扩展补充"></a>扩展补充</h3><p>上述虽然配置完成了 hexo 博客，但博客功能过于简单，使用起来不方便，可以添加图片，摘要，标签页与分类页等内容。</p>
<h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>下载并解压缩 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT 主题</a></p>
<p><code>wget http://labfile.oss.aliyuncs.com/courses/700/next.zip &amp;&amp; unzip next.zip</code></p>
<p>需要将主题文件放入 Hexo/blog/themes 下，打开 <code>../blog/_config.yml</code> 修改 theme 后的内容就可以更改主题了。这会博客就套上了我们的新模板了。但是我们发现博客菜单上的文字是英文的于是我们还要重新配置以下，让主题以中文的方式显示。再次编辑 <code>_config.yml</code> 文件，将 language 项设置为 zh-Hans 。</p>
<p>注意更改主题后每次需要重启 <code>hexo server</code> 服务才可以刷新网页。</p>
<p><em>到 github 上面搜索，可以找到更多出色的主题，这儿给出一个<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">主题汇总</a>。</em></p>
<h3 id="hexo-小结"><a href="#hexo-小结" class="headerlink" title="hexo 小结"></a>hexo 小结</h3><p>hexo 比 jekyll 布局更简单，更加容易操作，但每次需要本地生成 html 然后上传同步，虽然这不是问题，可以用脚本实现，但对于图片等内容，需要依赖第三方图床就显得很是无奈了。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用 Hexo 部署了数月，今天出现了新问题，今天又出现了新问题，hexo 部署无法推送到 github 上，疑似该问题出现了有一段时间了，<code>npm install hexo-deployer-git --save</code> 的插件读取了 <code>_config.yml</code> 文件的内容，但是上传到 github 时，出现错误，本来应该上传 public 内容，但是这边会上传文件夹中的全部内容。</p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/" target="_blank" rel="external">http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/</a><br><a href="http://www.runoob.com/w3cnote/git-guide.html" target="_blank" rel="external">http://www.runoob.com/w3cnote/git-guide.html</a><br><a href="http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</a><br><a href="http://blog.csdn.net/u012307002/article/details/51298705" target="_blank" rel="external">http://blog.csdn.net/u012307002/article/details/51298705</a><br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">https://www.zhihu.com/question/24422335</a><br><a href="http://www.jianshu.com/p/1d427e888dda" target="_blank" rel="external">http://www.jianshu.com/p/1d427e888dda</a><br><a href="http://www.jianshu.com/p/f4dce0e76886" target="_blank" rel="external">http://www.jianshu.com/p/f4dce0e76886</a><br><a href="http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</a><br><a href="http://www.jianshu.com/p/2b9f202c13fd" target="_blank" rel="external">http://www.jianshu.com/p/2b9f202c13fd</a><br><a href="http://c4fun.cn/blog/2014/03/03/use-hexo-blog/" target="_blank" rel="external">http://c4fun.cn/blog/2014/03/03/use-hexo-blog/</a><br><a href="http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[跑步一周的体验]]></title>
      <url>http://noparkinghere.win/2017/04/01/2017/2017-04-01-%E8%B7%91%E6%AD%A5%E4%B8%80%E5%91%A8%E7%9A%84%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>在三月的月初，我开始有计划的参加一些运动，最开始的时候，每天完成一组 seven（某知名手机 APP 的组合运动）。个人一直很羡慕那些能够长跑，能够跑马拉松的人，于是试着开始跑步，可惜由于太久没参加运动，以及缺乏运动常识，导致我第一次跑步就受伤了，之后有两周的时间左脚一走路就剧痛。</p>
<p>在这周一开始，我觉得休息的差不多了，于是又开始跑步的计划，这周总共跑了 4 次，每次距离都在 1KM 左右，时间也都在 5 分多钟，个人感觉还是比较满意的。算上最开始的一次，这段时间总共有 5 次，下面说下我在这段时间的经验总结，也许对于刚跑起来的你有所启迪：</p>
<a id="more"></a>
<h3 id="慢速"><a href="#慢速" class="headerlink" title="慢速"></a>慢速</h3><p>速度一定要慢，期初的跑步，由于并不是比谁跑的快，更不是比时间，对新手来说，能够完成既定的目标距离就是成功。由于长时间没运动，我第一次跑步冲的太快，导致跑了一半不到就没后劲了，后面完全是靠痛苦的死撑下来的，跑完步站都站不起来，且口中全是血腥味，肌肉拉伤了。这种状况显然是得不偿失的，对身体有损害，且很长一段时间不能在运动，运动讲究的还是循序渐进，可耻循序发展。</p>
<p>因此，通过总结，我这边得出，对于初学者，很久没有运动的人，一开始跑步距离控制在 1KM 左右，并且你需要尽可能慢的控制自己的速度，甚至可能和你走的速度差不多，你需要做的仅仅是出点汗，再最后一段距离时，稍微坚持下就可以完成目标。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>运动前一定要做好热身运动，建议在 1min 左右的时间，推荐办法可以是做脚踝关节的拉伸，如：跪坐在脚上，拉伸可以减少你运动过程可能造成的损伤。但注意不要作任何稍剧烈的运动，初学者的体质往往都是亚健康或者缺乏锻炼人群，也许一组 seven 下来,你就已经不能跑完你的目标了。</p>
<p>一双好的鞋对跑步来说至关重要，我第一次跑步时，穿的鞋偏紧，这种鞋平时穿着不太走动无所谓，一旦跑步就很致命了。跑步首先注意要有一双合脚的鞋，具备的基本条件是舒适和宽松，这样也会减少你受伤的可能性；另外推荐在舒适的基础上，最好还要买大一号的鞋，因为长跑后，脚会明显的肿胀，原本合适的鞋这时候往往就不合适了。</p>
<p>跑步前脱去外套，对于这种季节来说可能一开始偏冷，但一旦跑起来你必然会出一身汗，所以这点也是必须的。</p>
<p>使用相应的跑步电子产品，相关的电子产品很多，如运动手环，手机 APP 悦跑圈等，这些软件都能够帮你记录运动数据，跑完回看信息，能够帮你总结提高。</p>
<h3 id="呼吸"><a href="#呼吸" class="headerlink" title="呼吸"></a>呼吸</h3><p>跑步的呼吸节奏也是很重要的，虽然我是个初学者，但尝试过在意呼吸节奏时，往往能够介绍你跑步过程中的乏力疲惫感，能够让你速度更快，跑的更远。呼吸我这边的建议是：尽可能减少每分钟呼吸的频率，而增加每次呼吸的周期（时间长度）。</p>
<h3 id="休息"><a href="#休息" class="headerlink" title="休息"></a>休息</h3><p>跑步完成后，可以在走相应的一段距离，这边建议 500M-1KM 。跑完步身上有大量的热量，在室外的话，慢走，可以帮助你将热量散去。另外，慢走一段距离有益于你平复自己的身体和心理状态。</p>
<p>初学者跑步多少会有点体力不足的，虽然说跑步能够增强体质，减少睡眠，让身心更加健康有活力等等。但这边我要泼个冷水，长期的锻炼才会有以上的功效，刚开始锻炼只会让你身心俱疲，每次锻炼耗尽体能，往往还会给你第二天带来负面影响。</p>
<p>因此，就我最近的观察体验来说，初学者应该在原有的基础上增加睡眠时间，睡眠可以帮助你更快的进行肌肉的修复，你不该一开始就对运动有误解，且抱有太高的期望。另外，运动确实能够有效的增加你深度睡眠状态的，于情于理，你都该让自己更好的休息，只有这样你才可以良性循环，让运动坚持下来。</p>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>在运动时，对于初学者，我们要保持精神的集中，不该去听歌或者分散精力做别的事情。因为我们刚刚开始跑步，我们的每次运动都可以带来新的不同感受，所以我们需要精神集中在跑步这件事上面，如：调整步伐，让自己消耗更少的体力走的更快；现阶段什么样的速度比较适合你；你计划跑多远，以什么样的速度能够达成目标等等。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>跑步我只是个初学者，还有很多地方需要不断的更新改进，希望自己能够越跑越远，达成自己想要的目标。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[assert调试机制]]></title>
      <url>http://noparkinghere.win/2017/03/31/2017/2017-03-31-assert%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>程序的调试排错往往会占用整个工作的绝大多数时间，很多高级语言都拥有一整套的调试方法。C 语言虽然比较底层，但在调试程序时，也可以使用我之前推荐的 GDB等调试工具，但很多高手绝对不会仅依赖于调试工具，大多数人还是喜欢在开发时用 assert 来排查错误，而开发结束后，更有一些人会使用更加高效完整的日志库等来监控可能出现的 bug。</p>
<h3 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C 标准库"></a>C 标准库</h3><p>C 标准库中自带了 assert.h 这个文件，可以说前人在使用时已经将排错考虑细致了，我们加入这个功能后即可以直接使用 assert 进行调试了，函数声明：<code>void assert(int expression);</code> expression 这可以是一个变量或任何 C 表达式。如果 expression 为 TRUE，assert() 不执行任何动作。如果 expression 为 FALSE，assert() 会在标准错误 stderr 上显示错误消息，并中止程序执行。实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> a;</div><div class="line"></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"请输入一个整数值： "</span>);</div><div class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</div><div class="line">   assert(a &gt;= <span class="number">10</span>);</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"输入的整数是： %d\n"</span>, a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">请输入一个整数值： <span class="number">2</span></div><div class="line">a: a.c:<span class="number">22</span>: main: Assertion `a &gt;= <span class="number">10'</span> failed.</div><div class="line">[<span class="number">1</span>]    <span class="number">9632</span> <span class="built_in">abort</span> (core dumped)  ./a</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>网上查了下，没能找到 assert 标准库的函数原型，于是自己写了个简易版本的 assert ：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define assert(<span class="name">expr</span>) ((<span class="name">void</span>)((<span class="name">expr</span>) || (<span class="name">_assert</span>(<span class="name">__FILE__</span>,__LINE__),<span class="number">0</span>)))</div><div class="line"></div><div class="line">void _assert(<span class="name">const</span> char *file, int line)</div><div class="line">&#123;</div><div class="line">    printf("%s:%d", file, line);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="MCU-自带库-assert-实现"><a href="#MCU-自带库-assert-实现" class="headerlink" title="MCU 自带库 assert 实现"></a>MCU 自带库 assert 实现</h3><p>这边我们以国内广泛使用的 stm32 v3.5.0 官方库为例，使用STM32库函数的时候，你会发现带参数的库函数前面都有assert_param语句。</p>
<p>assert_param语句是用于程序开发的时候，调试用的检测语句。默认是不开启的，你可以无视它的存在。但是，当你在调试程序的时候，可以打开这个检测机制，调试完了再关闭。具体代码如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Exported macro <span class="comment">------------------------------------------------------------*/</span></div><div class="line"><span class="comment">#ifdef  USE_FULL_ASSERT</span></div><div class="line"></div><div class="line">/**</div><div class="line">  * @brief  The assert_param macro <span class="keyword">is</span> used <span class="keyword">for</span> function's parameters check.</div><div class="line">  * @param  expr: If expr <span class="keyword">is</span> <span class="literal">false</span>, <span class="keyword">it</span> calls assert_failed function which reports </div><div class="line">  *         <span class="keyword">the</span> <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">file</span> <span class="keyword">and</span> <span class="keyword">the</span> source line <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">the</span> call </div><div class="line">  *         <span class="keyword">that</span> failed. If expr <span class="keyword">is</span> <span class="literal">true</span>, <span class="keyword">it</span> returns no value.</div><div class="line">  * @retval None</div><div class="line">  */</div><div class="line">  <span class="comment">#define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span></div><div class="line">/* Exported functions <span class="comment">------------------------------------------------------- */</span></div><div class="line">  void assert_failed(uint8_t* <span class="built_in">file</span>, uint32_t line);</div><div class="line"><span class="comment">#else</span></div><div class="line">  <span class="comment">#define assert_param(expr) ((void)0)</span></div><div class="line"><span class="comment">#endif /* USE_FULL_ASSERT */</span></div></pre></td></tr></table></figure>
<p>如果我们想要使用 assert_param 就需要定义加入 <code>#define USE_FULL_ASSERT</code> 语句，另外我们可以发现 assert 判定失败时会调用 assert_failed() 函数，但值得注意的是， ST 的固件库中没有预留这个函数的原型，因此我们需要手动创建这个 assert_failed 函数，以下提供一个可供参考的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/* </span></div><div class="line">		注意：编译器 Build Output 栏是不会报错的，这边使用的是 MCU 数据如何输出，</div><div class="line">		需要根据具体情况分析，一般 MCU 都会把结果输出到串口。 </div><div class="line">	 */</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Wrong parameters value: file %s on line %d\r\n"</span>, file, line); </div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外 assert_failed()/_assert 函数基本上是所有判定失败后都需要调用的函数，具体要根据你平台提供的库而定，有些 MCU 平台是预留了 assert_failed 这种函数的，你不需要重新定义，只需要略加补充方法即可。例如 EFM32 提供的 assert 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG_EFM) || defined(DEBUG_EFM_USER)</span></div><div class="line"></div><div class="line"><span class="comment">/* Due to footprint considerations, we only pass file name and line number, */</span></div><div class="line"><span class="comment">/* not the assert expression (nor function name (C99)) */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assertEFM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EFM_ASSERT(expr)    ((expr) ? ((void)0) : assertEFM(__FILE__, __LINE__))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EFM_ASSERT(expr)    ((void)(expr))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assertEFM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span></div><div class="line">&#123;</div><div class="line">  (<span class="keyword">void</span>)file;  <span class="comment">/* Unused parameter */</span></div><div class="line">  (<span class="keyword">void</span>)line;  <span class="comment">/* Unused parameter */</span></div><div class="line"></div><div class="line">  <span class="comment">/* 预留用来定制你需要的操作 */</span></div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">  &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>assert 调用基本上大同小异，错误时直接终止程序或者死循环，同时能够提供代码出错位置即可。开发时，不适用 assert 也是可以满足绝大多数需求的，但这时你往往需要自己写语句让错误输出出来，assert 仅是提供了一个更加便捷的操作方式而已。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.runoob.com/cprogramming/c-macro-assert.html" target="_blank" rel="external">http://www.runoob.com/cprogramming/c-macro-assert.html</a><br><a href="http://www.rationmcu.com/stm32/1508.html" target="_blank" rel="external">http://www.rationmcu.com/stm32/1508.html</a></p>
</blockquote>
<hr>
<p>写作时间：21:38-22:17</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-最终幻想15]]></title>
      <url>http://noparkinghere.win/2017/03/30/2017/2017-03-30-%E5%BD%B1%E8%AF%84-%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B315/</url>
      <content type="html"><![CDATA[<p>有段时间没看电影了，前几天偶然在豆瓣上面看到《最终幻想15》正在上映，于是从网上下载下来，今晚看了下。</p>
<p>就特效而言，该片还是可圈可点的，这部电影的特效应该算是顶级的水准了，一些景物建筑场景往往让你很难分辨出真伪。然而，该片的特效并非无人能及，虽然说是目前这种系列里面最顶级的，但也存在很多的不足。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-30-最终幻想15-影评/1.jpg" alt=""></p>
<a id="more"></a>
<p>首先，和前作比，这部电影制作特效上面肯定是有很大进步的，但进步并不多，前两部作品可以说是在 CG 电影领域颠覆性的，甩开竞争对手几条街，具备很多超前的黑科技，这部作品并没能在 3D 领域和同行拉开差距。</p>
<p>虽然算是力作，比国内的《爵迹》之流特效好不少，但随着现在 3D 动画越来越成熟，国内的一些作品和欧美的其他作品在部分表现上面甚至要好过《最终幻想15》。《最终幻想15》的动作场景过多，且一些地方人物动作不连冠，这点表现的甚至不如国内《画江湖》系列，虽然这种不连冠的场景很少，但总感觉怪怪的。另外作品对光阴的处理老实说进步不大，虽然人物细节已经很多了，但光阴反射处理的一般，因此人物总会缺少真实感，这方面和迪士尼的一些动画还是有差距的。</p>
<p>值得吐槽的还是剧情吧，老是说看完没明白讲的内涵是什么，虽然《最终幻想系列》作品一直以来都有着超前/另类的价值观，但前两部多少还是可以接受的，这部就真的不明觉厉了，剧情的评价就是：人物塑造糟糕的不行，各种迷一样的动机，内奸多到爆，最后帝国灭亡了。如果剧情只是这样，我觉得还可以，最起码主题就是陈述一个国家是如果自取灭亡的，国王是怎么搬起石头砸自己的脚的。关键价值观还是帝国灭亡才是一个开始，主角守卫国土，结局已经不能用语言来表达了。</p>
<p>以上内容并非我写的混乱，而是这部作品前奏还算 OK，中间表现也凑活，后半段全是选特效再编排了一个迷一样的结局（明明都亡国了，却好像刚建国一样）。如果，以上内容都是续集的铺垫，那还可以稍加谅解，但终究而言一部如此混乱的电影还是很难带给观众舒适的感受的。</p>
<hr>
<p>写作时间：19:30-22:00</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言回调函数]]></title>
      <url>http://noparkinghere.win/2017/03/29/2017/2017-03-29-c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>使用 C 语言编程时，一般可以将函数调用增加一层封装，这样做可以让函数的使用更加灵活多变。</p>
<p>回调函数可以让函数功能调用起来更加的灵活，以下几种方式则是 C 语言中，实现代码重用的方法，他们由简单到灵活，也都是存在特定的使用背景的。</p>
<h3 id="宏定义封装"><a href="#宏定义封装" class="headerlink" title="宏定义封装"></a>宏定义封装</h3><p><code>＃define MacroFunction() Afunction(a, b, c)</code> 将Afunction(a, b, c)的常用用法作为一个整体进行封装，这种封装形式，在后续使用时，如果需要修改值的话，可以直接修改<code>＃define MacroFunction() Bfunction(a, b, c)</code> 而无需再进行其他操作。但同时也存在问题，如果我们需要将一半的 Afunction(a, b, c) 改为 Bfunction(a, b, c) 就较为麻烦，如果采用这种方式的话就只能一个个查看替换了。遇到这种情况时，下一种方法是更好的选择。</p>
<a id="more"></a>
<h3 id="静态入口函数"><a href="#静态入口函数" class="headerlink" title="静态入口函数"></a>静态入口函数</h3><p>静态的入口函数，保证函数名相同，利用标志位调用子函数。这样的典型应用很多，比如说网卡驱动里面有一个入口函数Nilan（int FunctionCode，Para*）。具体的参数是什么记不清楚了。不过NiLan的主体是这样的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Long Nila（int FunctionCode，Para*）</div><div class="line">&#123;</div><div class="line">   Switch(FunctionCode)</div><div class="line">   &#123;</div><div class="line">	   Case SendPacket: send(….)</div><div class="line">	   Case ReceivePacket: receive(…)</div><div class="line">	   ...</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写到这里大家明白什么意思了吧。保证相同的函数名就是说：网卡驱动是和pNA+协议栈互连的，那么如何保证pNA+协议栈和不同的驱动都兼容呢，一个简单的办法就是仅仅使用一个入口函数。</p>
<p>另外即便是一些初学者在写程序时，也会潜移默化地使用这种方法，如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int Fun(int flag)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (flag == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		A<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flag &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		B<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		C<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过改变如果函数的参数值，来调用内部的各个函数。这样的做法是可以进化的：如果以后想调用新的函数，增加相应的函数参数值就好了。</p>
<p>层与层之间的互连接口是很小的（这里是一个入口函数），一般是采用名字解析的办法而不是具体的函数调用（利用FunctionCode调用函数，Nilan仅仅实现名字解析的功能）。</p>
<h3 id="回调-CALLBACK-函数"><a href="#回调-CALLBACK-函数" class="headerlink" title="回调(CALLBACK)函数"></a>回调(CALLBACK)函数</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>回调函数才是本文的重点，它比上面的两种方法更加灵活，定制性更强。它使得一个函数可以在不重新编译的情况下实现功能的添加。一般使用回调函数可能存在有以下两点问题：</p>
<ul>
<li>效率降低：回调函数使用了函数指针，一般会先访问函数指针找到函数存放的实际地址，然后才是真正的函数调用，同直接调用函数比，多了一个寻址函数存储位置的过程（普通函数在编译时已经转换成了地址常亮，而函数指正仍然作为一个变量使用）。性能问题现在已经不做过多的考虑，指正调用本身就比较快，且现在机器性能都过剩。</li>
<li>会导致程序的“支离破碎”：在程序中，你读到一个函数指针的时候，并不知道这个函数指针指向的是哪个函数，调用食会让程序碎片化严重。这点我暂时还不是太明了。</li>
</ul>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>使用回调函数可以把调用者与被调用者分开。调用者不关心谁是被调用者，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</p>
<h4 id="有关函数指针"><a href="#有关函数指针" class="headerlink" title="有关函数指针"></a>有关函数指针</h4><p>回调函数并不属于 C 语言最基本的用法，应该算是 C 语言使用的一个技巧，可以让 C 操作起来更加灵活，但灵活的代价就是你要对 C 语言比价熟悉，函数指针，指针函数等能够区分清除。</p>
<p>函数指针是指向函数的指针变量，即本质是一个指针变量。指向函数的指针包含了函数的地址，可以通过它来调用函数。声明格式如下：类型说明符 (*函数名)(参数)。</p>
<p>注意：函数名本身就是代表着指针/地址，因此并不需要再去取地址，使用 &amp;/* 是没有太大的意义的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void (*fptr)();</div><div class="line">void Function(void)</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 以下两句等价 */</div><div class="line">fptr=&amp;Function;</div><div class="line">fptr=Function;</div><div class="line"></div><div class="line">/* 以下两句等价 */</div><div class="line">x=(*fptr)();</div><div class="line">x=fptr();</div></pre></td></tr></table></figure></p>
<p><strong>虽然 <code>fptr=&amp;Function; 和 x=(*fptr)();</code>写起来都更加复杂，但是有些程序员倾向于使用这种格式，因为它明确指出是通过指针而非函数名来调用函数的，这边我也推荐使用这种写法。</strong></p>
<h4 id="常规步骤"><a href="#常规步骤" class="headerlink" title="常规步骤"></a>常规步骤</h4><p>一般编写这一系列回调及主调函数时，可以分为以下几个步骤：</p>
<ul>
<li>定义指向回调函数的类型，使用 typedef，如：<code>typedef int (*typefun)(int);</code> 表示 typefun 类型指向了类似于 <code>int Test(int num)</code> 这样的一个函数。</li>
<li>调用回调函数的函数，有个形参类型为 typefun，代表我们使用这个函数时，会将回调函数作为参数传递给这个函数。</li>
<li>开始调用，将回调函数的地址（即函数名）作为实参直接传递给调用回调函数的这个主调函数。</li>
</ul>
<p><strong>认真分析，我们可以发现，回调函数的使用就是传递了函数的地址，与传递普通变量的地址并没有实质的区别。</strong></p>
<h3 id="案例具体分析"><a href="#案例具体分析" class="headerlink" title="案例具体分析"></a>案例具体分析</h3><p>下面举个回调函数的简单实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*typefun)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> num)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"The %d th charactor is: %c/n"</span>, i, (<span class="keyword">char</span>)(<span class="string">'a'</span> + i%<span class="number">26</span>));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caller</span><span class="params">(<span class="keyword">int</span> n, typefun ptr)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 也能写成这样: void Caller(int n, int (*ptr)(int)) ,typedef 定义更加方便使用</span></div><div class="line">	(*ptr)(n);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	Caller(<span class="number">30</span>, Test); <span class="comment">//相当于调用Test2(30);</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的例子过于简单，并没有多大的实际意义，但我们通过这样的例子可以看出回调函数和上面讲述的静态入口函数都是在原本的函数上面多加了一层封装，为了让函数调用起来更加灵活多变。</p>
<p>更进一步，利用回调函数，C 语言能够实现很多技巧性的操作，下面扩充一个例子，用回调函数来实现的一个简单泛型程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/* 以下的泛型只是举例，如果需要比较浮点型，字符型则需要补充完善回调函数 */</div><div class="line"></div><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line">typedef int (*cmp)(void *, void *);</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    char *name;</div><div class="line">    <span class="built_in">float</span> score;</div><div class="line">&#125; stru_member, *pstru_member;</div><div class="line"></div><div class="line">void *Max(void *p[], int len, cmp fun)</div><div class="line">&#123;</div><div class="line">    void *res = p[0];</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; len; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ((*fun)(p[i], res))		// 这边等价于 <span class="keyword">if</span> (fun(p[i], res))</div><div class="line">        &#123;</div><div class="line">            res = p[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int comp(int *a, int *b)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (*a &gt; *b)</div><div class="line">        <span class="built_in">return</span> 1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int mcomp(pstru_member a, pstru_member b)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (a-&gt;score &gt; b-&gt;score)</div><div class="line">        <span class="built_in">return</span> 1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int *pres;</div><div class="line">    int data[5] = &#123;1, 12, 30, 4, 5&#125;;</div><div class="line">    int *pdata[5] = &#123;&amp;data[0], &amp;data[1], &amp;data[2], &amp;data[3], &amp;data[4]&#125;;</div><div class="line">    pres = Max((void **)pdata, 5, (cmp)&amp;comp);		// 这边等价于 pres = Max((void **)pdata, 5, (cmp)comp);	</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pres);</div><div class="line"></div><div class="line">    stru_member mem[3] = &#123;&#123;<span class="string">"no.1"</span>, 99.6&#125;, &#123;<span class="string">"no.2"</span>, 91.4&#125;, &#123;<span class="string">"no.3"</span>, 95.5&#125;&#125;;</div><div class="line">    pstru_member pmem[3] = &#123;&amp;mem[0], &amp;mem[1], &amp;mem[2]&#125;;</div><div class="line">    pstru_member pres2 = Max((void **)pmem, 3, (cmp)&amp;mcomp);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s:%f\n"</span>, pres2-&gt;name, pres2-&gt;score);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><p>软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调和异步调用。同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。同步调用是三者当中最简单的，而回调又常常是异步调用的基础。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-29-c语言回调函数/1.gif" alt=""></p>
<p>这几种调用方式并不完全是 C 语言中的常用方式，往往我们需要加入一些小技巧才可以完成这些功能的实现。</p>
<h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>现在有 A B C 三个事件，首先，A 事件完成了才可以触发 B 事件，然后 B 事件完成了，才可以触发 C 事件。这中间，如果 A 事件休眠了一段时间，B 也不得不等待，同样 B 出了问题，C 会等待 A 和 B 更长时间。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> A complete</div><div class="line"><span class="keyword">do</span> B</div><div class="line"><span class="keyword">else</span> </div><div class="line"><span class="built_in">wait</span> A</div><div class="line"></div><div class="line"><span class="keyword">if</span> B complete</div><div class="line"><span class="keyword">do</span> C</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">wait</span> B</div></pre></td></tr></table></figure></p>
<p>这种就是典型的阻塞机制，无论如何我们只能等待上一个任务的完成，如果没有完成我们只能继续等待，这样造成的问题是，我们一直在浪费系统资源。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">void</span></span>)</div><div class="line">&#123;</div><div class="line">    int temp = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(!temp)&#123;  </div><div class="line">      temp = wait(funA());  </div><div class="line">    &#125;    </div><div class="line">    temp = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(!temp)&#123;  </div><div class="line">      temp = wait(funB());  </div><div class="line">    &#125;  </div><div class="line">    temp = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(!temp)&#123;  </div><div class="line">      temp = wait(funC());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。</p>
<p>对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。</p>
<p>大家应该看到了，有两种做法，一种是先发送信号（执行回调函数），然后继续执行下面的代码。同样可以先执行代码再发送信号。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> A <span class="keyword">Message</span>  </div><div class="line">send <span class="keyword">to</span> b   </div><div class="line"><span class="keyword">do</span> A  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> B <span class="keyword">Message</span> From b  </div><div class="line"><span class="keyword">do</span> B  </div><div class="line">send <span class="keyword">to</span> c  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> B complete  </div><div class="line"><span class="keyword">do</span> C  </div><div class="line"><span class="keyword">message</span> from c</div></pre></td></tr></table></figure>
<p>这种就是在函数的参数中带有一个其他函数指针，当需要的时候我们可以通过函数指针名进行调用其他函数即发送消息到其他函数。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">A</span></span>, callback)</div><div class="line">&#123;  </div><div class="line">   callback();  </div><div class="line">   funA();  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void callback()</div><div class="line">&#123;  </div><div class="line">   funB();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">F tell A  </div><div class="line">  <span class="keyword">do</span> A  </div><div class="line">  <span class="keyword">time</span> <span class="number">2</span> hours  </div><div class="line">  <span class="keyword">if</span> A <span class="keyword">complete</span> Report <span class="keyword">to</span> F  </div><div class="line">F tell B  </div><div class="line">  <span class="keyword">do</span> B  </div><div class="line"> <span class="keyword">time</span> <span class="number">1</span> hours  </div><div class="line">  <span class="keyword">if</span> B <span class="keyword">complete</span> Report <span class="keyword">to</span> F  </div><div class="line">F tell C  </div><div class="line">  <span class="keyword">do</span> C  </div><div class="line"> <span class="keyword">time</span> <span class="number">1.5</span> hours  </div><div class="line">  <span class="keyword">if</span> C <span class="keyword">complete</span> Report <span class="keyword">to</span> F  </div><div class="line">F tell D  </div><div class="line">  <span class="keyword">do</span> D  </div><div class="line">  <span class="keyword">time</span> <span class="number">3</span> hours  </div><div class="line">  <span class="keyword">if</span> D <span class="keyword">complete</span> Report <span class="keyword">to</span> F</div></pre></td></tr></table></figure>
<p>四个程序虽然有先后次序整体上看是依次执行的，但是执行的过程中，我们并不会因为前面的代码没有执行完，而不执行。</p>
<p><em>回调函数在 C 语言中太过常用，往往一些高级的操作都需要使用这个技巧，后续还会更新一些关于回调函数技巧使用的一些文章。</em></p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://c.biancheng.net/cpp/html/1202.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/1202.html</a><br><a href="http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="external">http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html</a><br><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">https://www.zhihu.com/question/19801131</a><br><a href="http://blog.csdn.net/tzshlyt/article/details/52993282" target="_blank" rel="external">http://blog.csdn.net/tzshlyt/article/details/52993282</a><br><a href="http://www.cnblogs.com/kunhu/p/3713370.html" target="_blank" rel="external">http://www.cnblogs.com/kunhu/p/3713370.html</a><br><a href="http://www.cnblogs.com/kunhu/p/3700610.html" target="_blank" rel="external">http://www.cnblogs.com/kunhu/p/3700610.html</a><br><a href="http://blog.csdn.net/dan_blog/article/details/7897852" target="_blank" rel="external">http://blog.csdn.net/dan_blog/article/details/7897852</a><br><a href="http://bbs.bccn.net/thread-457131-1-1.html" target="_blank" rel="external">http://bbs.bccn.net/thread-457131-1-1.html</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-callback/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-callback/</a><br><a href="http://xenyinzen.wikidot.com/reship:080123-8" target="_blank" rel="external">http://xenyinzen.wikidot.com/reship:080123-8</a></p>
</blockquote>
<hr>
<p>写作时间：21:39-22:56</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言来实现面向对象编程]]></title>
      <url>http://noparkinghere.win/2017/03/29/2017/2017-03-29-c%E8%AF%AD%E8%A8%80%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>阅读本文之前先要对 C 语言有个比较深入的认识，能够灵活的使用指针，结构体，回调函数等。</p>
<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="external">http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[GDB使用小结]]></title>
      <url>http://noparkinghere.win/2017/03/28/2017/2017-03-28-gdb%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近研究了下 GDB，这是一款调试工具中的神器，其实很久以前就有涉及过这款软件，但是由于交互不直观，太多的命令，操作较为复杂等原因，因此我一直以来都很少使用这个工具，实在没办法的时候往往也都是采用插入输出来排查错误。</p>
<p>百度百科的介绍如下：UNIX及UNIX-like下的调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在 UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。</p>
<h3 id="前期操作"><a href="#前期操作" class="headerlink" title="前期操作"></a>前期操作</h3><ul>
<li>使用命令：<code>gcc -g -o test test.c</code> 生成可运行程序，注意：在编译时要加上-g选项，生成的可执行文件才能用gdb进行源码级调试。</li>
<li>使用 <code>gdb test</code> 正式进入调试过程。</li>
</ul>
<a id="more"></a>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>进入调试过程后，才能够开始用 gdb 这个工具对程序的运行状态进行控制和观察。具体操作步骤如下：</p>
<ul>
<li>run（或r）： 从头开始连续运行程序，和不适用 GDB 直接执行程序效果一致。</li>
<li>start ： 开始执行程序，停在main函数第一行语句前面等待命令。</li>
<li>backtrace（或bt）： 查看各级函数调用及参数。</li>
<li>frame（或f）： 帧编号 选择栈帧。</li>
<li>finish 连续运行到当前函数返回为止，然后停下来等待命令。</li>
<li>list（或l）： 列出源代码，接着上次的位置往下列，每次列10行；list+行号 ： 列出从第几行开始的源代码；list+函数名 列出某个函数的源代码。</li>
<li>next（或n）： 执行下一行语句，和 step 的区别在于，不进入子函数。</li>
<li>step（或s）： 执行下一行语句，如果有函数调用则进入到函数中。</li>
<li>break（或b）： 行号 在某一行设置断点；break 函数名 在某个函数开头设置断点；<code>break x if y</code> 设置条件断点，注意 break 加入条件语句往往比较常用，能够更加准确的调到循环语句的第 n 步。</li>
<li>delete breakpoints ： 断点号 删除断点。</li>
<li>disable breakpoints 断点号 禁用断点。</li>
<li>continue（或c）： 从当前位置开始连续运行程序，被 break 后一般可以使用该语句。</li>
<li>set var ： 修改变量的值，可以在任何地方使用改制重新修改某一个变量值，更加方便监测和判断。</li>
<li>print（或p）： 打印表达式的值，通过表达式可以修改变量的值或者调用函数。</li>
<li>display+变量名 ： 跟踪查看某个变量，每次停下来都显示它的值。</li>
<li>undisplay 跟踪显示号 取消跟踪显示。</li>
<li>info（或i）+locals ： 查看当前栈帧局部变量的值，使用该命令前，先用 backtrace 命令（简写为bt）查看函数调用的栈帧，再用 frame（或f）选择栈帧；info（或i） breakpoints 查看当前设置了哪些断点。</li>
<li>watch ： 设置观察点，可以具体的查看数组的某个值，如：watch input[5]。</li>
<li>info（或i）watchpoints : 查看当前设置了哪些观察点。</li>
<li>x ： 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量。可以查看越界的一些信息，如定义 tmp 数组长度为 5，通过 watch 可以查看 tmp[5] tmp[6] 等的数据。</li>
<li>quit（或q）： 退出gdb调试环境。</li>
</ul>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>由于真正开始研究接触 GDB 时间不长，原本是想这个 IDE 来监控的，可惜找不到体积小巧，功能强大的，所以还是决定研究下 GDB，这边仅能够基本操作 GDB，后续有什么新的发现，会继续补充。</p>
<hr>
<p>To be continued…</p>
<p>写作时间：21:50-22:28</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Kdevelop 使用问题]]></title>
      <url>http://noparkinghere.win/2017/03/27/2017/2017-03-27-kdevelop-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>在使用 C 语言想要做些测试时，往往找不到比较好的调试工具，一般 C 语言现在都会作为 C++ 附带的内容，很多现代编译器都不再单独列出来了。另一方面，keil 之类的软件虽然专业使用 C 语言做开发，但他们往往都是交叉编译的，不提供 windows 平台下的开发，可能可以选择编译器，但目前来说我没有找到。</p>
<p>之前写过一篇文章<strong>notepad++和MinGW</strong>也是介绍如何将 notepad++ 配置为一个简易的 C 语言开发工具的，但比较遗憾的是，这个仅能算是一个简单的 C 语言开发工具， notepad++ 暂时还没有发现如何能够编译一个大的工程。另外做项目开发的话，调试相当重要，很可能需要要借助于 GDB 之类的工具监控数据。</p>
<p>今天发现了一款名为 Kdevelop 的 IDE，Kdevelop 是一个开源软件，且支持多种编程语言，体积不大，也能够接收。然而由于该软件过于小众化，目前仍然没有发现如何在 windows 下编译调试 C 程序。</p>
<p>暂时问题比较多，可能需要一段时间才能够解决这个问题，目前能够查到的有关 Kdevelop 的内容一般都是 linux 下的，另外 <a href="https://userbase.kde.org/KDevelop4/Manual/WindowsSetup" target="_blank" rel="external">Kdevelop 官网</a>关于 windows 下软件的配置也不够详细，仅有环境变量配置，而且是否配置成功有关现象等也描述含糊。</p>
<a id="more"></a>
<hr>
<p>本文先写个大概，未必能够解决这个问题，且软件过于小众，如果能够发现更佳的调试工具，应该就不会更新了。</p>
<p>本文暂时不会再接着更新，参考查阅了多个网站，都显示 Kdevelop 太过小众，虽然有文档，但问题会频繁出现，且缺少相关的 FAQ，windows 下的 Kdevelop 更是几乎没有查到任何相关内容。</p>
<p>C 的开发工具已经使用了 eclipse-CDT ，该软件可以直接调用 GDB 并提供一个友好的 GUI 调试界面，相关内容可以查看我的文章。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[能做和做好]]></title>
      <url>http://noparkinghere.win/2017/03/26/2017/2017-03-26-%E8%83%BD%E5%81%9A%E5%92%8C%E5%81%9A%E5%A5%BD/</url>
      <content type="html"><![CDATA[<a id="more"></a>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力月小结]]></title>
      <url>http://noparkinghere.win/2017/03/26/2017/2017-03-26-%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>定期的总结十分重要，以后可能会两-四周写一次总结性文章。</p>
<h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>最近一周，状态十分的差，主要表现在不但没有达成之前的目标，而且反而退步了，之前的日程如下：</p>
<ul>
<li>洗漱+准备早餐 7:00-7:20</li>
<li>学习英语 7:20-8:00</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00 后开始上英语课</li>
<li>上课后，一组 seven </li>
<li>17:30 之后阅读推荐书籍</li>
<li>看书到 18:10 以后</li>
<li>18:30 吃晚餐</li>
<li>一般 19:30 左右才开始写文章，写作时间不固定，技术类文章 2h 大概完成个初稿，随笔类文章一般在 1h 左右</li>
<li>其他时间任意安排</li>
<li>23:00 前休息</li>
</ul>
<a id="more"></a>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>这周时间状态急转直下，目前的状态却是：</p>
<ul>
<li>7:30-8:00 扇贝英语的学习，单词，听力，新闻等，效果奇差，因为赶时间，往往将原来至少需要 50 分钟的任务压缩到了半小时不到。</li>
<li>8:00-8:15 吃早餐，去公司</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-18:30 加班或者上网闲逛，白天效率不高，导致这段时间会浪费时间</li>
<li>18:00-19:30 晚餐、散步时间</li>
<li>19:30-23:00 事实上这段时间，只完成了简书一篇文章的内容，而这篇文章也只用了不到一个小时，另外有一组 seven，其他时间不知道都都去哪儿了。</li>
<li>23:30 左右入睡</li>
</ul>
<p>仔细分析这周为何不但不进步，反而退步了？</p>
<ul>
<li>这周不再上英语课了，导致 17:00 不回宿舍，相关一系列任务如：上课，阅读，seven 整个这一个半小时的任务完全紊乱了。</li>
<li>和同时一起搭伙，吃饭时间变动了，效率也变低了，最主要晚上吃的太多等原因导致睡眠不好。</li>
<li>由于晚上睡眠不好，一般只有 1h 的深度睡眠，早上疲乏，无法完成早上任务，白天工作效率也不高。</li>
<li>待在宿舍就学习方面而言，不是太习惯看书，需要重点改掉这个毛病，另外网络差，电脑键盘差配置不同，以及吃临时容易分心等问题都让时间不知觉的溜走了。</li>
<li>看一本《腾讯传》的书，每天事实上也没看多久，但因为上述所有计划都紊乱了，导致晚上虽然只看了 1/2h 但却占用了别的时间，一步错步步错。</li>
<li>身体不适，由于睡眠还有之前脚肌肉拉伤引起的一系列问题。</li>
</ul>
<h3 id="下周"><a href="#下周" class="headerlink" title="下周"></a>下周</h3><p>下周一定要回归到原来的节奏上，严格执行，不断优化调整自己的状态，大致如下：</p>
<ul>
<li>洗漱+准备早餐 7:00-7:20</li>
<li>学习英语 7:20-8:00</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00 后开始上英语课</li>
<li>上课后，一组 seven </li>
<li>17:30 之后阅读推荐书籍</li>
<li>看书到 18:10 以后</li>
<li>18:30-19:30 吃晚餐，散步</li>
<li>19:30-21:00 学习时间</li>
<li>21:00-21:30 运动时间，跑步或者哑铃</li>
<li>21:30-22:30 写作，控制在一个小时之内</li>
<li>23:00 前休息</li>
</ul>
<p>严格的执行，虽然精神上面比较疲乏，但最起码都还可以完成，不会像这周这样全部混乱，之后的计划还会不断地修正，希望自己可以锻炼良好的身体素质，另外也能有个高效的学习习惯。</p>
<hr>
<p>写作时间：21:15-22:10</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待TIM]]></title>
      <url>http://noparkinghere.win/2017/03/25/2017/2017-03-25-tim-%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>腾讯是一家 98 年成立的公司，早期靠 PC 端 qq 起家，数年前移动互联网普及后，又依靠微信再次巩固了自己霸主的低位，数十年来在即时通讯领域无论是国内还是国际上都几乎没有公司可以与之匹敌，2016 年底，腾讯又低调的推出了 TIM 这款 IM (即时通讯)软件。</p>
<h3 id="TIM-的过去"><a href="#TIM-的过去" class="headerlink" title="TIM 的过去"></a>TIM 的过去</h3><p>早在 MSN 进入中国的时候起，腾讯就一直想要进入商务通讯领域，虽然说 qq 在商务领域一直占有着 50% 左右的市场，但过多的消息提示和广告弹窗让用户往往不厌其烦，加之期初的 qq 设计以及受众人群向来都是低幼化群体（低年龄，低收入，低地位）。因此中产阶层和都市白领历来对 qq 不屑一顾，即便 MSN 再难用，他们也会觉得具备高品味。而 qq 占用的 50% 市场也主要是中小型企业，主要得益于 qq 强大的功能和市场。</p>
<p>早在十多年前，腾讯就开始布局商用 IM 领域，这么多年也推出过多款 PC 端 IM 产品，如： RTX，TM，企业微信等。</p>
<p>RTX 一般是局域网自建服务器使用，虽然是十多年前的版本，但基本功能都具备，算是一个成熟的产品，目前仍然有些中小型公司内部正在使用，但值得一提的是 RTX 仅是内部使用，虽然 RTX 在腾讯能够找到 2015 等新版本，但在企业内部不会受到太大重视，往往很多企业还在用最早期的版本，同样腾讯也不指望通过它能够获得多少实际收益。</p>
<p>TM 算是 qq 的一个变种，也是腾讯从普通消费市场走向商业市场的一次试水，TM 直接导入了 qq 数据，在 qq 的基础上，将图标和界面进行了修饰，让整体看起来更加商务化些，同时加入了名片等根据商业气息的功能。但较为遗憾的是，同 qq 相比，TM 只能算是阉割版的 qq，无法起到不可或缺的作用，更糟糕的是 多年的摸索，TM 仍没有摸索出一套自己的商业发展道路。因此，对于这种需要一定人力物力，却没法建立自己存在感的产品，往往只能不了了之。</p>
<a id="more"></a>
<h3 id="TIM-的现在"><a href="#TIM-的现在" class="headerlink" title="TIM 的现在"></a>TIM 的现在</h3><p>介绍完上面内容 ，下面主角登场。TIM 是由腾讯在 2016 年 11 月发布的客户端应用，TIM 是针对办公场景的 IM 客户端应用程序，TIM 是轻聊的 QQ，更方便办公,TIM 用在 QQ 轻聊版的基础上加入了协同办公服务的支持，而且可使用 QQ 号登录，好友、消息完全同步，支持多人在线编辑 Word、Excel 文档等。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-25-tim-使用/1.png" alt=""></p>
<p>我们可以仔细分析下 TIM 的特点：</p>
<ul>
<li>TIM 的联系人直接通过 qq 进行导入，因此仅作为 IM 软件的话，你是可以用 TIM 代替 qq 的。</li>
<li>TIM 在 PC 端使用常规 qq 完全不同的登录风格界面，这种将 风格和布局更加紧凑，更适合办公使用。</li>
<li>TIM 在 手机端界面基本和 qq 保持风格一致，目前来看手机在办公领域仍然不能作为主流。</li>
<li>TIM 用于商务办公，因此继承了 TM 的特点，有许多商务办公的特质，如：无广告，qq 空间，会员之类的增值服务，也没有 qq 秀，qq宠物等低幼化功能。</li>
<li>TIM 可以将非工作联系了进行隐藏，对使用 qq 没有任何影响。</li>
<li>TIM 推出了在线文档编辑的功能，可以将传统 office 套件下的 word 和 excel 搬到浏览器下多人协同办公，这似乎是 TIM 向 SAAS（软件即服务）进军的一个信号。</li>
</ul>
<p>TIM 可以看作是 TM 的复活产品，之所以复活，很大一部分原因是因为网络版的 office 套件，受 Google Drive 的影响，SAAS 越来越受到追捧，而目前国内看来，并没有发现一款可以媲美 Google Drive 套件的产品，腾讯这次又是通过对一个创新领域的抄袭加上微创新来实现弯道超车，之所以成为微创新，主要因为和国外相比，国内用户往往更倾向 IM+邮箱，在线协同办公+ IM 能够带来比在线协同办公+邮箱更佳的体验。</p>
<p>就目前来看，在线文档编辑的功能应该可以算是给部分企业提供便捷的，毕竟一方面正版 office 软件价格昂贵，另一方面多人协同编辑极具优势。但 TIM 离一个真正能够吸引用户的商业产品而言，仍然有不少的路要走：</p>
<ul>
<li>协同办公的功能仍然不够丰富。就目前看来 TIM 可以拿得出手的协同办公主要有三个：远程协助，word，excel。但无论是数量还是质量都和 Google Drive 差距颇大， Google Drive 得益于应用市场，可以提供更多的第三方应用；TIM 的 word 和 excel 目前都只具备最基础的功能，而 Google Drive 的产品已经基本上可以代替 Microsoft office 了。</li>
<li>TIM 仍未能切住用户的痛点。使用 qq 谈业务的用户，最看重的往往是聊天记录，因此不少用户都开开通超级 qq 会员来保存聊天记录，目前看来 TIM 还无法做到这点。</li>
<li>qq 一直缺乏上下级管理权限。虽然受员工喜欢，但却不受老板待见，TIM 只是将 qq 的功能导入过来，仍然没能够解决老板管理员工的问题，不能讨好管理钱包的人，也就不能真正走入商业市场。</li>
<li>未能将微信联系人也整合进 TIM。qq 和 微信同为腾讯的产品，微信因为用户量更广，因此在办公领域也占有一席之地，TIM 仅是将 qq 的数据导入过来，却没有将微信的数据也导入下来，同时挂“qq+微信”和 同时挂“TIM+微信”好像并没有区别。</li>
<li>手机版本的 TIM 同之前腾讯的 QQi，QQ轻聊版等无论是界面还是功能都没有什么区别，甚至说手机版的 TIM 和 QQ 本身也没什么不同，如果 TIM 和之前的 TM 一样，可有可无的话，注定活不久，即便是手机端也同样如此。</li>
</ul>
<h3 id="TIM-的将来"><a href="#TIM-的将来" class="headerlink" title="TIM 的将来"></a>TIM 的将来</h3><p>腾讯向来喜欢在某些市场成熟了再后发制人，而腾讯的这类产品一般也会悄悄的上线，等大家察觉的时候，往往他已经是一家独大了。下面是我个人对 TIM 的一些看法，TIM 可以通过将 qq 会员具备的一些功能，SAAS，其他一些附加功能一起打包出租给商业用户来谋求一杯羹，预测 TIM 可能的发展方向：</p>
<ul>
<li>初期，同当年的微信背靠 qq 导入流量一样，TIM 会依靠 qq 和微信来导入商业用户的流量，同时如果能够将微信和 qq 的通讯功能合二为一，在办公领域往往比较让人待见。腾讯在商用领域根基薄弱，但通过 qq 和微信的话，可以让他有个无痛的过渡期。</li>
<li>中期，会进一步完成从 IM 软件到 SAAS 的转换，TIM 会提供 office 办公套件，腾讯云，在线 OA 系统等多种服务，这阶段主要靠用户来挖掘服务内容和形式，不断的改进自身的产品。</li>
<li>后期，加入 BOSS 管理账号，这个阶段 TIM 已经不再依赖微信和 qq 了，BOSS 的账号可以对其他子账号拥有绝对的权限，查聊天记录，授权，删号等等，由于 SAAS 也日趋成熟，可以走上商业化的发展道路。各家公司如果需要使用 TIM 的 BOSS 账号，SAAS 的增值服务，就需要向腾讯付费。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TIM 究竟会走什么样的道路目前还尚未清晰，或许几年后 TIM 会成为 办公领域的一匹黑马引领国内新的云办公潮流，又或者 TIM 终将如他的爹 TM 一样被用户所淡忘，而纵观腾讯历史，也有过多次失利，但却几乎没有过同一战场失利两次的经历，因此 TIM 的发展还是多少让人有些期待的。</p>
<hr>
<p>写作时间：21:15-22:56</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[混乱局面下的中国手机市场]]></title>
      <url>http://noparkinghere.win/2017/03/24/2017/2017-03-24-%E6%B7%B7%E4%B9%B1%E5%B1%80%E9%9D%A2%E4%B8%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E6%89%8B%E6%9C%BA%E5%B8%82%E5%9C%BA/</url>
      <content type="html"><![CDATA[<p>今天正值周五，也是华为上半年发布旗舰手机的日子。从华为开始做手机时，我就一直用的他家手机，包括，荣耀1，荣耀2，荣耀3，荣耀6。然而透过数据不难发现，只到荣耀6，之所以如此，很大的原因在我这个手机买了将近 3 年，至今仍在使用。这边也许很多人会褒奖它质量好，然而，现在换手机的人大多数并非是因为手机坏了，之所以我不去换手机根本原因在于市面上找不到满意的产品。</p>
<p>今天的发布会，一如以往，我并没有特地去看，我也并非一个真正的花粉，这些年见证了很多手机厂商潮起潮落，更多的是对这个市场已经麻木。</p>
<a id="more"></a>
<p>回归正题，本文题为“混乱局面下的中国手机市场”，之所以混乱是因为各大厂家都不知道该做出怎样的产品。目前手机市场的萧条可以分为以下几点：</p>
<ul>
<li>产品互相抄袭：显然今天 P10 的发布就是对 iphone 6 外观的抄袭，虽然实现了自身的突破，如色彩多样化，窄边框高屏占比等，但一丑遮所有，外观上的娘性，注定了整个产品缺少特色，而任何一个微创新几乎都被各家模范和抄袭。</li>
<li>模式抄袭：从互联网营销到饥饿营销，从线下推广到巨资广告。代表互联网的小米和代表线下的 OV 基本上被各大模仿者抄了个遍。产品上做不出文章，就都开始在渠道上下功夫，虽说是本木导致，但也没办法。</li>
<li>产品长久缺乏创新：从 iPhone 的指纹识别之后，基本上手机市场再无刚需创新了。无论是 3D 按压和OLED 节能，还是 IP67和红魔识别，都并非能给普通用户带来实际价值的创新。仅凭这些就让很多人失去了对手机数码产品的兴趣，更无法让老用户又购买新机的欲望。</li>
<li>一年 32 场演唱会：说来并非玩笑，去年华为，小米，魅族，几乎都是隔三差五就会开场发布会，每家一年光手机就发布了 20 多款。魅族去年 n 多场演唱会，发布的手机几乎都找不到任何差别；华为今年更是不断的推出一款又一款的青（yan）春（ge）版手机。</li>
<li>手机厂家的迷茫：智能手机催生了一次智能普及的科技革命，在经过过去 10 年的发展，早已成熟，如今可以增长的份额越来越少，OV 两家在年初时就已经对今年的市场不抱有太高的期望，而各家厂家也无法拿出有诚意的产品。开发布会，打广告，提供智能设备，加入 AI 技术等等都是期望在探（mi）索（mang）中可以找出一条活路。</li>
</ul>
<p>PC 在手机的冲击下，早已没落多年，透过手机，我们可以看到目前主流的科技市场。我们有理由相信，苹果引爆了移动互联网让我们可以安度 08 年的金融危机，但自 07 年智能手机发布到现在已经过去了十年时间，根据以往的经验可以判断一场革命可以让市场振兴繁荣 10 年，而我们下一个 10 年又在哪儿呢？会是人工智能吗？而这真的会是一场属于大家的繁荣吗？</p>
<hr>
<p>写作时间：22:15-22:55</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯传读后初感]]></title>
      <url>http://noparkinghere.win/2017/03/23/2017/2017-03-23-%E8%85%BE%E8%AE%AF%E4%BC%A0%E8%AF%BB%E5%90%8E%E5%88%9D%E6%84%9F/</url>
      <content type="html"><![CDATA[<p>最近阅读了《腾讯传》这本书，顾名思义，该书是一本传记类书籍，主角是腾讯公司。这本书刚看了 1/3，但还是想把就该书而言的读后感写出来，本文不会讨论书中的情节，仅仅描述为何这个书与众不同。</p>
<p>我个人大约是小学快毕业的时候开始阅读课外书籍的，至今也有十多年的时间了，过去个人比较偏爱小说，现在也阅读了一些技能类书籍和传记文学作品。</p>
<p>之前我也阅读过一些个人传记，但往往都不是很满意的，本身对这类书不是太偏好，然后阅读的过程往往都是比较艰辛的，需要耐下心来，一点点的读，往往一本这类书籍都会看个十天半月，但结果却更糟糕，上次读的书是一本介绍马云的，阅读的过程就很艰辛，花了好多天时间，然后读完才发现上了当，全书都是在神话吹捧主角，完全和不符合开头所谓的绝对客观真相，另外书中对细节负面消息后续谈论极少。</p>
<p>《腾讯传》这本书给我的感受就极为特别，像是在看一本小说，让人想一探接下来的情节。书以一个时间轴，通过所有的事情，每个和腾讯相关人的事情侧面的刻画腾讯的成长过程，一步步的给你展现出这段历史，书中也将很多被神话疯传的谣言给去掉了，平实的把一些真相讲出来。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-23-腾讯传读后初感/1.jpg" alt=""></p>
<a id="more"></a>
<p>既然这本书值得一览，那总是有些可圈可点之处的，这边列出我的看法：</p>
<ul>
<li>首先，作者：吴晓波，应该算是有点名气的作家了。能够将这样一类书，写成仅靠内容就吸引人的，可以键作者写作功底了得，文章的语言平实，可以将故事婉婉道来，而一些事件的介绍又不缺诙谐幽默。</li>
<li>其次，每节开头均有两段引用语，国外学者的文字，预示着科技给生活的改变，而故事相关人物的引用语则预示接下来剧情的主要矛盾点。</li>
<li>再者，故事主角的腾讯，所有其他人物都是配角，每个人都不自带主角光环，都有睿哲的一面，又往往包含一些失误的地方，文章就目前来看，写的都还算客观。</li>
<li>另外，文章以腾讯为背景，穿插了很多时间线，各家互联网公司都会在小说中，轮番出场，全书更像是一本中国互联网的历史书籍，看这本书更像是我们这代人在缅怀过去。</li>
<li>最后，腾讯传以平实的语言去讲述这样一个公司的成长壮大，从有到无的过程，代入感很强，所有的描述都只是为了讲述这件事，仅会在某些地方穿插一些作者的观点，并不会左右读者的思维，且这些结论性内容过度都极为自然，实属不易。</li>
</ul>
<p>在我个人看来，这本书是很值得一阅的，详细的书评，在完成阅读后再写上。</p>
<hr>
<p>写作时间：21:52-22:15</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待多说关闭服务]]></title>
      <url>http://noparkinghere.win/2017/03/22/2017/2017-03-22-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%A4%9A%E8%AF%B4%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>今天浏览个人博客时，无意中发现多说有一栏通知，期初还以为是个人授权到期，点开一看吓了一跳：<strong><a href="http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241" target="_blank" rel="external">重要通知: 多说即将关闭</a></strong>。有些遗憾，毕竟算是国内首屈一指的网站评论系统了，然而细想一下，又觉得理所当然。</p>
<h3 id="多说简介"><a href="#多说简介" class="headerlink" title="多说简介"></a>多说简介</h3><p>多说是一款追求极致体验的社会化评论框，可以用微博、QQ、人人、豆瓣等帐号登录并评论。多说帮助用户搭建更活跃，更互动的评论平台，功能强大且永久免费。它正在改变网站与用户之间，用户与用户之间的互动方式。这个专门基于社交网络的评论系统，能够轻松的帮网站主搭建自己互动性极强的社区，让留言的用户都有“家”的感觉。</p>
<p>官方简介如下：</p>
<p>让评论更活跃、互动性更强的评论系统，永久免费且容易安装用微博、QQ、人人、豆瓣等帐号轻松评论和分享<br>智能识别垃圾评论、稳步提升网站流量。</p>
<a id="more"></a>
<h3 id="关闭原因"><a href="#关闭原因" class="headerlink" title="关闭原因"></a>关闭原因</h3><p>一年前，我个人开始把多说加到自己的博客上面的，但现在看来，是时候将其下架了。去年年底的时候 GFW 开始拦截 disqus 后，很多用户也只用选用国内的一些评论系统了，目前来看，多说关闭的并不是突发事情，在过去一年到现在多说的评论系统经常会突发各种问题，比如无法评论，无法加载，无法显示某些功能等等，现在看来那时就已经初现端倪了。</p>
<p>评论一个业务/服务为何会关闭，最主要的原因就是赚不到钱，去年争议比较大的网站同样如此，虽然大片的用户在使用，但就是因为赚不到钱，加上 ZF 打压，所以诸如华为云，360网盘等等就顺水推舟都关闭了自己的服务，反观百度网盘作为重灾区依旧能够生龙活虎，不难发现，问题本质就是出在钱上面。多说在国内没能够找到真正的付费用户，因此不难想象他最终的命运。</p>
<p>国内大多数软件/服务都是抄袭的国外的，这边我们并不讨论抄袭这个问题，因为抄袭的好的软件也有很多成功的典型，如：qq，qq空间，新浪微博等等，甚至很多公司都再他们的祖先倒下后还能够创造意想不到的市场效益。多说同样是一款本土化的国外软件，然而，他并没有那么幸运走到最后。</p>
<p>分析原因大致如下：</p>
<ul>
<li>国内网络公司更加注重利益，因此更多的是把东西捏在自己手上，只有用户在自己手上才放心踏实，因此可以看到国内的几乎没有评论系统的商业用户，加上国内的开发人员很多，大小网站都有自己的一套评论系统，这显然就决定了多说难以转到商业用户的钱。</li>
<li>国内自己搭建个人博客的一般知识层次都不会太差，通常也都会翻墙，多少看得懂英语，与其用多说，很多人更愿意使用 disqus，因此普通用户流量不足，跟无法产生更多的消费用户。</li>
<li>一个模仿者却还没有始祖做的出色，可能多说之前做过一些特色功能，但我很不幸没有看到，至少在体验上面来说除了引入了国内的社交平台授权外，其他无论在界面美观，易用性，功能上面都不如 disqus。未能根据国内用户的习惯进行更多尝试，自身不够优秀的前提下，做再多别的也是枉然。</li>
<li>ZF 压力，由于某些特殊的原因，国内对网民言论等进行了史上最严格的监管，多说本身因为管理经营上比较开放，因此很多为未备案的网站都可以使用多说，而这点无疑是和国情相背的。</li>
</ul>
<h3 id="其他可能"><a href="#其他可能" class="headerlink" title="其他可能"></a>其他可能</h3><p>以下为个人的一些看法，国内评论系统一般为博客用户使用，然而百度等国内网站在搜索文章时往往都很少能够检索到博客中的内容，相反百度文库，百度百科，知乎等等商业网站会排在首位具备更高的曝光度。多说完全在可以在满足市场的前提下，开辟自己的博客/文章导航网站，分类推荐各种文章，可以链接到各个博客或者经过协商授权后，将文章截取归类后重新整理出来，并附上原文链接。然后可以通过广告点击赚钱，当然这种归类的模式有点类似现在比较知名的码字网站简书之类的，但区别在于可以支持更多的私人博客，同时他也可以对小白用户开发，提供在线 markdown 写文，把私人博客内容和无博客在线用户两者结合在一些，同时站内也可以同做一个自己的搜索引擎，专门搜索个人博客和网络博客中的内容。</p>
<blockquote>
<p>参考链接：<br><a href="http://baike.baidu.com/link?url=HUxf8KHqE-r6ah0eo8w9FpAssSFtHcF2rWQEmEhnJlQ-fA0pdp74W4gbV2rHrt-pgN5ci4tzznb5sZZQ4Zj8cndR3COZeeXpEGxRAAsJFyO" target="_blank" rel="external">http://baike.baidu.com/link?url=HUxf8KHqE-r6ah0eo8w9FpAssSFtHcF2rWQEmEhnJlQ-fA0pdp74W4gbV2rHrt-pgN5ci4tzznb5sZZQ4Zj8cndR3COZeeXpEGxRAAsJFyO</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MCU内/外部启振]]></title>
      <url>http://noparkinghere.win/2017/03/21/2017/2017-03-21-mcu%E5%86%85-%E5%A4%96%E9%83%A8%E5%90%AF%E6%8C%AF/</url>
      <content type="html"><![CDATA[<p>振荡电路相当于 MCU 的心脏，需要为 MCU 提供频率和脉冲，因此一个精准可靠的振荡电路对于 MCU 来说相当重要。</p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>振荡电路一般可以分为：LC振荡器，RC振荡器，晶体振荡器。</p>
<ul>
<li>LC振荡器：LC振荡电路主要用来产生高频正弦信号，一般在1MHz以上。它与RC振荡电路的不同之处在于它由电感和电容组成。所以命名为LC振荡器。</li>
<li>RC振荡器：若用电阻，电容元件组成选频网络，就称为RC振荡器，一般用来产生1Hz-1MHz的低频信号。RC选频网络的选频作用不如LC谐振荡回路，故RC振荡器的波形和稳定度比LC振荡器差。</li>
<li>晶体振荡器：晶体振荡器是指从一块石英晶体上按一定方位角切下薄片（简称为晶片），石英晶体谐振器，简称为石英晶体或晶体、晶振；而在封装内部添加IC组成振荡电路的晶体元件称为晶体振荡器。其产品一般用金属外壳封装，也有用玻璃壳、陶瓷或塑料封装的。</li>
</ul>
<p><em>根据以上三种可以设计出多种不同的电路。</em></p>
<a id="more"></a>
<h3 id="晶振和振子"><a href="#晶振和振子" class="headerlink" title="晶振和振子"></a>晶振和振子</h3><p>晶体全称叫晶体谐振器(crystal resonator)，是一种谐振器，具有压电特性,不能输出信号。</p>
<p>晶振全称叫晶体振荡器(crystal oscillator)，是一种振荡器，振荡电路由晶体、主振有源器件、主振电容等元器件组成，能够输出信号。通常我们所指晶振时往往喜欢用 crystal 其实这是不准确，而国外有的文档却喜欢用 oscillator，一般在表述时，两者其实是一个东西。</p>
<p>MCU 自带的内部振荡器，一般是 RCO （RC-oscillator），而外部配置的振荡电路可以是 RCO （RC-oscillator），也可以是有源晶振 XO（crystal resonator）。</p>
<p>使用RC振荡是电容充放电；而使用晶振振荡时，晶振也是电容性质，它比RC振荡的电流大，如果你摸过正在工作的各种晶振，会发现有些晶振发热，而RC振荡从无发热现象；这在各种单片机中都适用。相对于单片机电路，使用外部晶振更耗电一些，因为外部晶振分为无源和有源，当用有源时，功耗那是明显高的，因为有源外部晶振需要从电源吸取能量。</p>
<p>但使用内部晶振虽然能耗低，但晶振的稳定度和频率控制的都很差，很多都达到了 5% 以上的误差，仅作为不精准的定时简单的使用还可以，稍严格一些的场景都无法满足要求。</p>
<p>使用内部振荡器往往可以配置 RCO 让 MCU 获得某些/某段特定的时钟频率，灵活度更高些；而使用外部晶振的话，一般晶振频率是固定的，MCU 仅能够对该频率进行分频或者倍频。</p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://www.eetrend.com/blog/100024294" target="_blank" rel="external">http://www.eetrend.com/blog/100024294</a><br><a href="https://zhidao.baidu.com/question/464742897.html" target="_blank" rel="external">https://zhidao.baidu.com/question/464742897.html</a><br><a href="http://blog.csdn.net/qq_29350001/article/details/51142250" target="_blank" rel="external">http://blog.csdn.net/qq_29350001/article/details/51142250</a><br><a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E6%8C%AF%E8%8D%A1%E5%99%A8" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E6%8C%AF%E8%8D%A1%E5%99%A8</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[accessport问题总结]]></title>
      <url>http://noparkinghere.win/2017/03/21/2017/2017-03-21-accessport%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AccessPort 是一款用于 PC 机串口(RS232)调试、监控的软件，作用于驱动层之前，可以和其他串口工具同时使用，监控串口的通讯数据。特点：</p>
<ul>
<li>监控串口：具有端口监控功能，可以监控、拦截、保存所收发的数据（ NT/2K/XP/Vista/Win7）。</li>
<li>串口调试：支持常用的串口操作功能，支持大数据量的收发、保存，支持自动发送。</li>
<li>动态变参：在不改变当前所打开端口的情况下，能动态改变端口参数（如：波特率、校验位、流控制等）。</li>
<li>双模编辑：数据发送区内嵌十六进制编辑器（类似 UltraEdit），支持十六进制&lt;=&gt;文本双模式切换编辑，支持 unicode。</li>
<li>国际版本：国际版，支持多国语言。</li>
<li>无需安装：界面友好，方便易用。</li>
</ul>
<a id="more"></a>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>用于串口调试，支持常用的 110-256000 波特率，支持自定义波特率。</li>
<li>能以字符或十六进制接收或发送任何数据，能发送、接收任意大小的文件。</li>
<li>在不改变当前所打开端口的情况下，能动态改变端口参数（如：波特率、校验位、流控<br>制等）。</li>
<li>数据发送区可实时编辑、发送文本数据。</li>
<li>能将所接收的原始数据以及显示数据分别保存。</li>
<li>数据发送区允许设置发送周期，自动发送数据。</li>
<li>可调试的端口范围是 COM1-COM255，支持扩展端口(USB&lt;-&gt;RS232)。</li>
<li>可设置字体、文字颜色、背景颜色。</li>
<li>允许将发送区的数据在接收区回显，模拟终端操作。</li>
<li>允许发送区数据以回车键作为发送操作信号。</li>
<li>Terminal 模式支持自动应答功能，支持 Hex、 Text、浮点数等类型。</li>
<li>Terminal 模式支持预定义数据发送，支持 Hex、 Text、浮点数等类型。</li>
<li>Monitor 模式支持彩色文本显示,便于更好的区分、观察数据.</li>
<li>允许 Monitor 模式下拦截到的数据以十六进制或字符方式显示。</li>
<li>允许接收区在接收到的数据后添加回车字符(CRLF)，便于观察数据。</li>
<li>可将 Terminal 模式下接收到的数据按照十六进制文本方式导出到文件或剪贴板。</li>
<li>允许保存程序环境变量。</li>
<li>定义热键，方便操作。</li>
<li>国际版，支持多国语言。</li>
<li>数据发送区内嵌十六进制编辑器，支持 unicode。</li>
<li>支持串口监控功能，可以监控串口设置以及收发的数据。</li>
<li>在线自动更新提示功能，当有可用新版本时提示用户下载。</li>
<li>本程序线程安全，可以同时启动多个副本调试多个串口。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>AccessPort 通常不作为串口调试工具使用，虽然你也可以直接用该软件来监控串口数据，但一般因为 AccessPort 可以运行在驱动层之上，所以往往我们用 AccessPort 来监控你上位机软件调用驱动的一些操作。AccessPort 本身不会占用串口，因为它不会像其他串口工具一样去进行数据收发，而仅作为监控你驱动层被调用的一种工具。</p>
<p>一般而言需要先开启 AccessPort 的监控功能，然后再开启你的上位机软件，这样 AccessPort 才可以监控你的软件。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>关闭 AccessPort 需要格外的小心，说白了 AccessPort 类似通过某种不合法的途径来获取你正常软件调用驱动时的状态，因此会有系统崩溃蓝屏的风险，注意做好数据备份。</p>
<p>值得注意的是，停止 AccessPort 监控或者关闭该软件时会可能系统崩溃，这时，你需要注意软件关闭的先后顺序，一般我们可以试下以下几种方法：</p>
<ul>
<li>插入串口/usb 时，关闭 AccessPort 。</li>
<li>拔掉串口/usb 时，关闭 AccessPort 。</li>
<li>先关闭上位机软件，再关闭 AccessPort 。</li>
<li>先关闭 AccessPort，再关闭上位机软件 。</li>
</ul>
<p>以上几种方式，需要逐一尝试，不同的电脑出现的情况不同，但基本是上面中的某一种/几种情况不会发生系统崩溃，具体原因据称可能是根据你使用的 usb 转串口的驱动（不同的 usb 转换芯片有不同的驱动）有关系。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[我眼中的写作]]></title>
      <url>http://noparkinghere.win/2017/03/19/2017/2017-03-19-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%86%99%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>大约是一年前，开始搭建自己的博客，然后陆续开始码字，去年写作的题目有大约 80 多个，虽然只完成了大概一半左右，但毕竟刚开始写作算是有个好的开始。一方面个人博客主要写的是技术博客，有的内容自己没有切身实践过也不敢太轻易下结论，而有的内容仍然在不断更新中，因此不可能将所有文章都写完，另外一方面也认识到写作确实算是比较消耗时间的，没有足够的时间很难写出让自己满意的文章。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-19-我眼中的写作/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="写作的内容"><a href="#写作的内容" class="headerlink" title="写作的内容"></a>写作的内容</h3><p>小时候上语文课老师就让大家写日记，写周记，当时一直感觉很痛苦，然而现在让我码字已经不再有这种感觉了，相反很多时候我会觉得时间不够用，加入这个写作训练营很大的成都上是为了每天可以挤出更多的时间，完成之前的一些写作内容，以及可以提高下自己的写作能力。为何年少时找不到素材可写，现在又会有很多东西需要去写呢？最重要的应该是经历，一个孩子每天过着：学校–家，两点一线的生活，周而复始。你设想下，在这样的生活下如何能写出绚烂多彩的日记而不是流水账呢？</p>
<p>每个成年人都有权力选择自己想要的生活的，因此我们完全可以为自己创造条件来经历不一样的自我。例举几个写作题材的例子：</p>
<ul>
<li>如果你今天是骑行了，你可以写一篇文章说明下健身有意身体，骑行让自己有怎样不同体验。视角不同写作内容也不会相同，同样是骑行，因为路上现在有很多租借单车，透过单车你也可以讨论今年单车为何变得越来越火了。</li>
<li>比如你周末心血来潮，学了下几年来一直想学的 PS，你同样可以写个教程，把你做的某个案例总结出来，虽然你可以只是模仿的别人的，但每个人在做的时候必定会有不同，可能某个细节原教程没说的清楚，你可以文章中重点强调下，再比如，你根据原教程，做了些微创意等，也都可以写出来。</li>
<li>出行旅游这个基本不用说，攻略，照片，景点评价基本上人人都可以写出超长的连载文章。</li>
<li>突然对美食有兴趣，周末做了一道菜，同样可以配上图文教程，详细写下步骤，最后总结出优点和不足等等。</li>
<li>工作上的一些问题更是有太多的可写内容，从为人处世到技术难题，从创业心得到失业感想等等。</li>
<li>兴趣爱好永远是写作的最佳话题，对音乐/绘画/电子产品/军事等感兴趣，都可以让你写出独到的见解和十分有价值的内容。</li>
</ul>
<h3 id="写作的意义"><a href="#写作的意义" class="headerlink" title="写作的意义"></a>写作的意义</h3><p>就我个人的观点来说，写作和做其他事情一样，最重要的一点是有意义（或者说有价值），有价值又可以分为两点，对自己有价值或者对他人有价值。</p>
<p>我写文章的主要初衷是记录自己一些工作学习上面的内容，可以说我最本质上写作的目的就是对自己有价值，遇到一个问题，或者解决了一个问题，都会把他记录下来，下次如果再面对这种问题时，可以快速的查阅自己以前总结的文章，类似用文字来代替大脑，帮我做更多详细的记录，通过这些问题我可以提高自己的工作学习效率。</p>
<p>提一下另外一点对他人有价值。我写的文章虽然说初衷是为了帮助自己做知识的管理，但既然发布到网上了，也是希望更多的网友在遇到和我同样问题的时候，能够通过我的文章找到解决办法，少走一些歪路。很多网络作家写小说是希望他人可以得到愉悦，写影评也是希望让别人更懂这部电影或者不让浪费时间看这部电影，类似的例子也是不胜枚举。</p>
<h3 id="回看作品"><a href="#回看作品" class="headerlink" title="回看作品"></a>回看作品</h3><p>每次写完基本上都会回看自己的内容，这样一方面可以修改一些明显的语法字词错误，另外有新的灵感也可以补充一些内容。如果是隔了很久的一篇文章，又有了新发现，需要补充，这时候还会把全文再重新阅读一遍，文章结构上面可能还会重构，甚至会重写。复看的过程很重要，是一个真正提高自己的过程。</p>
<hr>
<p>写作时间：19:50-20:30</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[别人眼中的运动--参考]]></title>
      <url>http://noparkinghere.win/2017/03/18/2017/2017-03-18-%E5%88%AB%E4%BA%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%BF%90%E5%8A%A8-%E5%8F%82%E8%80%83/</url>
      <content type="html"><![CDATA[<p>最近几年越来越多的人将健身看作是头等大事，而保持健康的最佳途径无外乎三点：饮食，作息，运动。因此，国内健身运动也变得越来越火，基本上已经达到了全民健身的地步。本人因为工作原因还有其他内在原因，一直运动较少，最近加入了运动训练营，希望可以养成运动健身的习惯，针对我们运动族的大神<a href="http://www.jianshu.com/u/cbece912d4e9" target="_blank" rel="external">@Janetff</a>进行了一些请教，本文将内容梳理总结下来。</p>
<h3 id="人物介绍"><a href="#人物介绍" class="headerlink" title="人物介绍"></a>人物介绍</h3><ul>
<li>姓名：得姐</li>
<li>坐标：包容性很强的深圳</li>
<li>生日：5.29</li>
<li>职业：永远的学生</li>
<li>擅长领域：运动，营养，迷路</li>
<li>朋友对自己的总结：认真的逗比</li>
<li>今年最想实现的目标：完成西藏尼泊尔深度游</li>
<li>去年有什么值得骄傲的事情：跟自控力lab成长一年，从三分钟热度重度患者成功转型，并通过自身状态影响改变一批人；完成两次全马</li>
<li>进群最想做什么：带领大家养成良好的运动习惯，收获健康，努力过成自己想要的模样</li>
<li>对于运动你想说的是：运动会让你发现不一样的自己</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-18-别人眼中的运动-参考/1.jpg" alt=""></p>
<a id="more"></a>
<p><strong>详细的问题内容如下：</strong></p>
<h3 id="工作日作息安排"><a href="#工作日作息安排" class="headerlink" title="工作日作息安排"></a>工作日作息安排</h3><ul>
<li>5:00-5:30 起床+煮早餐</li>
<li>5:30-6:30 跑步+看书+冥想</li>
<li>6:30-7:30 冲凉，做饭，化妆</li>
<li>7:30-7:50 吃早餐</li>
<li>8:00-8.30 上班途中听书或新闻</li>
<li>8:30-12:00 上午工作时间</li>
<li>12:30 健身房撸铁/看电影+午休</li>
<li>14:30-17:30上班</li>
<li>18:30 吃晚饭</li>
<li>19:30 打拳/听课/应酬</li>
<li>11:30 睡觉（最近正在调整早睡）</li>
</ul>
<h3 id="休息日作息安排"><a href="#休息日作息安排" class="headerlink" title="休息日作息安排"></a>休息日作息安排</h3><ul>
<li>5:30 起床跑步，长距离跑步</li>
<li>8:00 冲凉吃早餐</li>
<li>10:00-15:00 图书馆</li>
<li>16:00 约饭或逛街</li>
</ul>
<p><em>休息日有时候也许会短途城市周边游</em></p>
<h3 id="每天才睡-5-6-小时，会不会睡眠不足"><a href="#每天才睡-5-6-小时，会不会睡眠不足" class="headerlink" title="每天才睡 5/6 小时，会不会睡眠不足"></a>每天才睡 5/6 小时，会不会睡眠不足</h3><p>平时会进行冥想恢复精神，中午也会少量的休息，会在某个特定的周末好好休息一下，但是发现根本睡不了那么多。</p>
<p>笔者注：很多大神都睡眠比较少，有的甚至只睡 3/4 小时，但他们仍然能够每天保持高的工作效率和活力。也许坚持长期健身确实可以比较好的改善你体质，让你不再那么容易疲乏。</p>
<h3 id="减肥健身之前的作息"><a href="#减肥健身之前的作息" class="headerlink" title="减肥健身之前的作息"></a>减肥健身之前的作息</h3><p>一句话：<strong>之前的作息时间是黑白颠倒。</strong></p>
<p>笔者注：通过上文已经可以看出，一个良好的作息对生活的改善有多么重要，改变之前的<a href="http://www.jianshu.com/u/cbece912d4e9" target="_blank" rel="external">@Janetff</a>我见到过，但现在的她绝对是女神级别的，虽然她自称年级大，但我们都比较怀疑她是不是 95 后，甚至 99 年的组友都觉得她比自己小。</p>
<h3 id="改变的缘由"><a href="#改变的缘由" class="headerlink" title="改变的缘由"></a>改变的缘由</h3><p>失恋</p>
<p>笔者注：很多人发生巨大改变会是因为一些事情的刺激，而对于生活如常的普通人，想要做出改变确实可能往往会缺少恒心和毅力，因此做出改变的这一步也许对大多数人是最困难的一步。</p>
<h3 id="现在的生活给自己带来了怎样的改变？"><a href="#现在的生活给自己带来了怎样的改变？" class="headerlink" title="现在的生活给自己带来了怎样的改变？"></a>现在的生活给自己带来了怎样的改变？</h3><p>这样改变的结果就是每天都感觉比别人多活了几个小时，精神状态保持很好，不再乱发脾气，爱上看书。</p>
<h3 id="像我这样的没有运动基础，明年年初想跑半马，如何制定方案"><a href="#像我这样的没有运动基础，明年年初想跑半马，如何制定方案" class="headerlink" title="像我这样的没有运动基础，明年年初想跑半马，如何制定方案"></a>像我这样的没有运动基础，明年年初想跑半马，如何制定方案</h3><p>首先根据自身情况，运动不是一蹴而就的，没有运动基础的话，两三个月就想跑几十公里是很不现实的，将近一年的时间慢慢积累是可行的。零运动基础，之前没有跑过步的话，可以先从快走和慢跑之间切换，开始时，每天跑两公里，跑不动了就换快走，然后周末进行一次三公里的尝试，最开始需要提升一下心肺功能。运动的第一步就是先跑起来，行动起来，再坚持下来，只有行动起来才有可能进行后期的训练。每次跑完后，记录下感觉，我再给你进行后期的调整。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对现代人来说运动可以说是<strong>饮食，作息，运动</strong>三者中最重要的，因为通过运动我们可以调整作息，通过运动我们可以改善饮食习惯。我也亲眼所见周围有不少人因为运动让自己改变了多年的恶习，精神面貌也越来越好了，因此下一步在我脚肌肉拉伤恢复后，就准备行动起来了，希望来年这个时候，我也可以真正成为运动族的一员。</p>
<hr>
<p>写作时间：20:36-21:47</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[英语表述问答]]></title>
      <url>http://noparkinghere.win/2017/03/17/2017/2017-03-17-%E8%8B%B1%E8%AF%AD%E8%A1%A8%E8%BF%B0%E9%97%AE%E7%AD%94/</url>
      <content type="html"><![CDATA[<p>本内容的主要出处是扇贝的<a href="https://www.shanbay.com/web/ask/answers/" target="_blank" rel="external">你问我答</a>。</p>
<h3 id="“at-the-eleventh-hour”居然不是“在十一点”的意思？"><a href="#“at-the-eleventh-hour”居然不是“在十一点”的意思？" class="headerlink" title="“at the eleventh hour”居然不是“在十一点”的意思？"></a>“at the eleventh hour”居然不是“在十一点”的意思？</h3><p>“the eleventh hour”指的是“最后关头；最后时刻”，所以“at the eleventh hour”表示“在最后的关头”，真的不是“在十一点”的意思啦！比如，“At the eleventh hour, the hero appeared and saved the life of the heroine.”就是“在最后时刻，男主角出现，救了女主角”的意思。</p>
<h3 id="你知道“张三李四”怎么说吗？"><a href="#你知道“张三李四”怎么说吗？" class="headerlink" title="你知道“张三李四”怎么说吗？"></a>你知道“张三李四”怎么说吗？</h3><p>中文里的“张三”“李四”都是假设的名字，表示“无关紧要的人；普通人”，而“Tom”“Dick”“Harry”在英语文化里，都是极其常见的男性名字，三个名字连在一起“Tom, Dick, and/or Harry”就可以表示“普通人；随便什么人”，和中文的“张三李四”十分契合。比如，“This painting is not for every Tom, Dick and Harry.”就是说“这幅画曲高和寡，不是随便什么张三李四都看得懂”的意思。</p>
<h3 id="你知道“紫色”为何高贵吗？"><a href="#你知道“紫色”为何高贵吗？" class="headerlink" title="你知道“紫色”为何高贵吗？"></a>你知道“紫色”为何高贵吗？</h3><p>在古代，紫色染料提取自一种珍贵的海螺，这种海螺数量稀少，加上整个制作工艺非常繁琐，所以，紫色布料十分昂贵，成为权力和财富的代名词以及皇家王室的特供。“born to the purple”就表示“出身皇室”。很好，高贵端庄优雅矜持，我想我要开始喜欢紫色了～</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[健康饮食]]></title>
      <url>http://noparkinghere.win/2017/03/16/2017/2017-03-16-%E5%81%A5%E5%BA%B7%E9%A5%AE%E9%A3%9F/</url>
      <content type="html"><![CDATA[<p><em>本文内容，来自今晚听的荔枝微课，是由得姐传授的健康饮食经验，总结下来的笔记。</em></p>
<p>每个人体质不同，有些人吃多少都不会胖，相反他们还需要增肥，而有的人一吃就会胖，需要不断地节制。</p>
<h3 id="肥胖原因"><a href="#肥胖原因" class="headerlink" title="肥胖原因"></a>肥胖原因</h3><p>现在人的肥胖有各种原因，懒惰，吃货，出差，不愿浪费粮食等等。</p>
<h4 id="多出来的那一口"><a href="#多出来的那一口" class="headerlink" title="多出来的那一口"></a>多出来的那一口</h4><p>不愿浪费粮食，多出了的一口饭往往最后会强撑着吃下去，这个会是生活中很多人一条比较常见的习惯，虽然是小习惯，但往往我们很多人会每次吃饭都多出来那一部分，每次都不舍得扔掉，然后强行塞给已经吃饱了的胃，而健康饮食的过程中很多人是一般不会吃的完全饱的，更何况是你吃多出来的那一口呢？！而往往很多人，因为这几毛钱多出来的那一口，日积月累多长出了几十斤的肉，然后又由于各种肥胖病，由不得不去健身，去找教练，这一去都是几千块，真所谓得不偿失。</p>
<p>这边并不是提倡浪费粮食，你能够做到做的和吃的刚好均衡这样是最好的。而事实上，我们很难把握这个度数，往往做一顿饭并不只会你一个人吃，所以经常会做多，往往我们抱着这种思想，多了可以留到下一顿，但事实是我们毫无节制的拼命吃，最后多了并不多，然后就思索当然的认为多一点大家分了吧。</p>
<p>每顿饭，我们宁可少做，别多做，现代人并非像过去人，因为各种原因，所有必须要多吃，比如：需要付出大量的体力劳动吃饱了才有力气干活，这顿不吃没准就没有下一顿了等等。现代人往往都会实物过剩，因此我们每顿可以做出尽可能少的食物，虽然你没有吃饱，但你绝对不饿，而且健康的饮食就是保持 7 分饱的程度，另外长时间保持这种饮食习惯，久而久之也会让你的饭量随之而减少。最后，健康饮食是提倡多顿少量，如果你正餐没能吃饱，之后也可能通过水果饼干等补充体力。</p>
<a id="more"></a>
<h4 id="基因因素"><a href="#基因因素" class="headerlink" title="基因因素"></a>基因因素</h4><p>脂肪易储存这是由人类祖先决定，在食物匮乏的时代，让能够储存脂肪的人更加容易活下来，因为大量的脂肪存储不仅可以抵御寒冷，而且在没有食物的时间可以幸存到下次捕猎。</p>
<p>女性比男性更容易长胖，也是由基因间接决定，通常来说，女性普遍比较偏静，而男性偏动，因此在摄入同样多的能量时，男性同胞往往可以比女性燃烧更多的脂肪，因此会稍瘦于女性。</p>
<p>谈到基因问题的时候，我们首先要正视自己肥胖的问题，首先肥胖并非不正常的，而恰恰相反，你吃多少能够存储多少，这正证明了你惊人的生存力，只是时代不一样了，这个时代不缺乏粮食，而我们以瘦为美，因此我们需要和自己的身体做斗争，为了不让脂肪可以存储下来，我们一般可以通过两点：1.摄取更加少量的食物。2.让脂肪燃烧掉。而这两点一般就是我们所指的健康减肥。</p>
<p>其他因素这边就不一一累述。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>网络有很多减肥：21 天减肥法，苹果减肥法，段餐减肥法等等，且很多不负责网站会各种标题党，让你误以为真。我们需要做的就是总结经验，找到一种适合自己的饮食方法和训练方案，无论是减肥还是增肌，一定要拥有一个健康的饮食结构。欲速则不达，你越快的减肥，身体越会表达不满。</p>
<p>人体的三大能量物质：蛋白质，碳水化合物和脂肪，这边大家上生物课都听过，就不对这三种物质做详细解释。</p>
<p>碳水化合物选择：低 GI （血糖生成指数）食物为主，如：多吃红豆，全麦粉，玉米，紫薯，土豆等，减脂的朋友多吃粗粮瘦肉代替粳米和五花肉。低 GI 食物在胃中消化慢，不容易被吸收，血糖不容易升高，不容易饿。虽然碳水化合物对肥胖有很大的影响，但健康饮食不能断粮，人体大脑需要他们来提供能量，没有他们你会无精打采失去健康，我们只需要杜绝添加剂和外加糖即可。如果每 100g 食物中，糖超过 15g 则属于高糖食物，工作学习很容易糖超标，限制糖的摄入量是减肥的关键。</p>
<p>蛋白质：蛋白质并不能给人体供能，但是能够提供 20 多种氨基酸，蛋白质不会引起血糖波动，但会帮助人体新陈代谢，需要注意选择优质蛋白和烹饪方式，减脂远离油炸食品。</p>
<p>脂肪：脂肪可以分为：饱和脂肪，不饱和脂肪。饱和脂肪主要来自动物的肉和内脏，日常生活中难免摄入饱和脂肪，但可以尽量少用食用油，不饱和脂肪来自于干果，鱼类，对心血管有利，反式脂肪也属于不饱和脂肪，但对人体有害，减肥一定要戒除甜品，奶油等。饱和脂肪过高容易造成动脉堵塞，一份中份爆米花的饱和脂肪 &gt;  培根+鸡蛋+巨无霸汉堡+牛排。脂肪推荐：橄榄油，花生油，椰子油，核桃，鱼油胶囊，杏仁等。</p>
<p>具体摄入量为多少，男性为两份下图，女性为一份下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-16-健康饮食/1.jpg" alt=""></p>
<ul>
<li>手掌决定蛋白质分量</li>
<li>拳头决定蔬菜分量</li>
<li>手掌环形区域决定碳水化合物的分量</li>
<li>大拇指决定脂肪分量</li>
</ul>
<h3 id="餐饮"><a href="#餐饮" class="headerlink" title="餐饮"></a>餐饮</h3><p>早餐：粥/无糖豆浆+玉米/鸡蛋+苹果</p>
<p>应酬餐：保持理性，少动筷子多聊天，先喝汤，再吃粥，然后蔬菜，最后吃肉。一口肉三口菜，先吃容易消化的物品，一半以上的菜多吃凉拌清蒸少油，不点或者少点煎炸菜品，用汤水代替碳酸饮料。点餐可以不推脱先点自己能吃的热量少的菜，再由别人点餐，免得没有东西可以吃。</p>
<h3 id="增重增肌"><a href="#增重增肌" class="headerlink" title="增重增肌"></a>增重增肌</h3><p>多吃复合类的碳水化合物，如：米饭，面条，麦片，玉米，红薯，足够蛋白质，如：牛肉，鱼虾等营养价值高的东西，可以选择小吃多餐，每天 4-6 顿。除了注意饮食一定要注意训练，增肌，需要做力量训练，减少消耗比价大的有氧运动。</p>
<h3 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h3><p>讲究营养和健身锻炼的目的，保证营养平衡，优先选择热量低营养含量高的食物，坚持以粗，素，淡，果和蔬菜为主的杂粮的方式，而且少吃经过腌，熏，炸，烤的食物，食物经过加工的越多，营养破坏越多。</p>
<p>进食时间，控制在 15-20 分钟左右，食物细嚼慢咽。学会看营养成分表，不吃多糖多盐的食物。</p>
<p>空腹晨跑，身体素质不好不要轻易尝试，建议服用氨基酸，保护肌肉，提高基础代谢。</p>
<p>运动前后如何吃，运动前 1h-1.5h 少吃点，刚吃饱至少留 0.5h 消化时间，少喝水和太多纤维，否则容易胃胀和肌肉抽筋。运动后要补充碳水化合物做补充。</p>
<p>长期健康的关键：均衡饮食，定期运动，乐观心态，充足睡眠，足够水分。切勿急功近利，循序渐进的塑身。</p>
<hr>
<p>文章由于听的是语音，很多内容和图片整理起来太过繁琐，且个人没有运动基础，不怎么会归类。详细内容可以咨询 @<a href="http://www.jianshu.com/u/cbece912d4e9" target="_blank" rel="external">Janetff</a></p>
<p>写作时间：20:30-22:30</p>
<p>To be continued…</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[新版射雕英雄传有多好，现在的电视剧就有多烂]]></title>
      <url>http://noparkinghere.win/2017/03/14/2017/2017-03-14-%E6%96%B0%E7%89%88%E5%B0%84%E9%9B%95%E8%8B%B1%E9%9B%84%E4%BC%A0%E6%9C%89%E5%A4%9A%E5%A5%BD%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%94%B5%E8%A7%86%E5%89%A7%E5%B0%B1%E6%9C%89%E5%A4%9A%E7%83%82/</url>
      <content type="html"><![CDATA[<p>今年年初的时候看了某网站的独播剧，新版《射雕英雄传》，当时看了几集感觉还可以，，上周末休息，一下子看了接下来的几集，总的来说对这个片子影响不错，剧情比较遵从原著，内容详实，道具场景不敷衍，打斗场景也还看得过去，里面随便一个配角都是老戏骨，演的也都是代入感强可圈可点。主角黄蓉，演的确实算是这么多版黄蓉里面绝对可以名列前茅的，郭靖演的还行，但没啥亮点。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-14-新版射雕英雄传有多好，现在的电视剧就有多烂/1.jpg" alt=""></p>
<p>如果你觉得本文是要推销这部电视剧，那你就大错特错了，本文是要通过这部剧来说下目前中国的影视作品。说实在的，我上一次完整看的新版国产电视剧应该是搜狐的自制剧《无心法师》，差不多也是一两年前的作品了，该部电视剧也算是良心作品。回想起来这两年其实国产电视剧一直爆发着惊人的产量，然而这个质量嘛，我也就呵呵了。</p>
<a id="more"></a>
<p>首先说下前段时间比较火的《三生三世十里桃花》，为了有始有终，这部电视剧完整的看了第一集和最后一集，中间别人在看的时候拐了两眼。当看完第一集的时候，我当时发了一个状态吐槽了下，而事实确实是我看完第一集后就默默地关了视频，重新将 10 年前的《风云1》拿出来看了一遍，差不多过年期间将《风云1》完整的看一遍。以前没有发现现在电视剧和过去的差距，看完《风云1》之后发现电视剧塑造的每个人物的形象性格都是有缘由的，人物的选择命运等等都有着很强的相关性，剧情的逻辑性前后联系也很紧密，没有莫名其妙的剧情，人物的武功境界也都是循序渐进能够看出每个人之间的差别差距，通过努力之后的进步。</p>
<p>而反观现在的电视剧，从《三生三世十里桃花》开始，第一个场景，某女 VS 某男，这也能算是神仙？就这种比逗？导演组这是在逗我吗？90 年代的《天龙八部》都比这个有气势的多。再来看下去年的《诛仙》，男主角无脑开挂，每次一发怒就爆表，每次打斗都只用一下，每次都没看出他哪儿有进步。《花千骨》里面的虫子是从《蓝猫淘气三千问》里面跑出来的吧？</p>
<p>当然利益驱动是很能够理解的，虽然导演组也知道拍的剧情很脑残，无内涵，模板都用烂了，明星又涨价了，哪有钱做特效哇？还得花钱打广告呢，花钱开发手游呢。通过上述种种，我们不难发现为何现在的演员都演成面瘫了，现在的特效为啥都是5毛钱的了。</p>
<p>说到模板我们由不得不提现在现在主流模板剧情了，如果你是一个电视剧导演，但如果你连玛丽苏的模板格式都不能够信手拈来，那估计在影视圈都是没有立足之地的。我们可以说下常用的玛丽苏模板形式：单纯萌新女主出厂–&gt;恋上绝壁厉害的男主–&gt;女主因傻白甜被多名”优秀”的男同胞爱慕–&gt;万恶的女二千方百计迫害女主–&gt;多名男配为女主赴汤蹈火，但女主只钟情男主–&gt;女主被女二迫害后，突然变得强大，反过来干掉了女二–&gt;男女主历经坎坷，中间尽可能多的赚泪点–&gt;最终男女主走在了一起，过上神仙眷侣的日子。</p>
<p>由于通过大数据的分析，各方面统计，目前 75% 以上泡剧的都为女性同胞，而男性大都看电影，玩游戏等等，所以不能看出为了博取绝大多数的用户需求，各大导演苦练玛丽苏技能，期待有着一日能够拿出自己的玛丽苏代表作品，而这些剧情中间尤以《花千骨》，《三生三世十里桃花》最为出名，当然早期的《甄嬛传》等也可以归类为这种作品，但毕竟那时模板尚未成型，且该剧在当时还有部分亮点的。</p>
<p>除了玛丽苏的模板，小鲜肉也算是一个广大女性同步喜爱的模板，该作品的影子就更是随处可见了，且使用门槛更低，这边就不做剧情陈述。</p>
<p>目前电视剧虽然产量众多，但每年值得一看的太少，很多用户也渐渐的发现现在国产动漫的层次都会比电视剧深刻不少，画质，内涵，声优等等也都迎来了前所未有的高质量，这边不得不为国产电视剧默哀三分钟。</p>
<p>回到这部电视剧，其实新版《射雕英雄传》放在 5 年以前，并不能算是一部优秀的电视剧，甚至很多人会很不屑这样的翻拍片，许多人哼之以鼻，一天到晚翻拍有意思吗？然而怎么也想不到 5 年以后的今天很多人却也会津津有味看着翻拍剧，只因为看遍热播电视剧却发现实在没有一个能够看得下去的，能够不是看了第一集就可以猜出结尾的。</p>
<hr>
<p>写作时间：21:10-22:33</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力lab周总结]]></title>
      <url>http://noparkinghere.win/2017/03/13/2017/2017-03-13-%E8%87%AA%E6%8E%A7%E5%8A%9Blab%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>参加自控力lab训练营有了两周时间，也完成了十多篇的文章，总的来说有所进步，目前完成任务包括：每日英语学习，写作，锻炼。仅是这些的话，之前一个星期就已经能够做到，但由于作息时间不当，很多事情完成的不够好，甚至形成了恶性循环，这周部分内容还是有所改善的。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>目前每天的任务基本可以比较好的完成，且这周将 seven 运动的时间提前了，这样夜间不会再仓促了。写作效率等方面有了显著的提高，基本可以控制一篇文章从理清思路到完成在 1h 之内，一些不需要查找资料的甚至半小时内可以完成。作息时间刚刚开始起步，希望可以坚持做到早上完成单词新闻等的学习，不将英语学习留到晚上。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>时间没能够得到充分有效的利用，很多时候，尤其是晚上没能很好的把握时间，事实每晚至少还是可以抽出 1h 以上的时间学习研究的，但往往都会浪费不少的时间摸手机，或者无目的地闲逛网页。下阶段会增加时间的有效利用率，可以考虑加入番茄工作法等，另外杜绝摸手机的习惯。</p>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>参加训练营之初，是写过计划的，现在会对最终目标进行些调整：</p>
<ul>
<li>6:30 左右 前起床</li>
<li>6:30-7:00 晨练等内容，买早餐</li>
<li>7:00-8:00 扇贝英语的学习，单词，听力，新闻等</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-17:20 在线英语学习</li>
<li>17:20-18:00/18:20 阅读推荐书籍</li>
<li>18:00/18:20-19:00 晚餐、散步时间</li>
<li>19:00-21:30 自我学习时间，完成相应学习计划</li>
<li>21:40-22:40 将时间尽量控制的短</li>
<li>23:00 左右入睡</li>
</ul>
<hr>
<p>写作时间：19:50-20:32，9:30-10:00，总时长超过一个半小时。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-盛开的樱花林下]]></title>
      <url>http://noparkinghere.win/2017/03/12/2017/2017-03-12-%E5%BD%B1%E8%AF%84-%E7%9B%9B%E5%BC%80%E7%9A%84%E6%A8%B1%E8%8A%B1%E6%9E%97%E4%B8%8B/</url>
      <content type="html"><![CDATA[<p>同样这部动漫也是受简书笔友 @见月酱 毒害推荐，说实在的这个动漫相当难找，百度百科只介绍了这本小说，并附带了提及有该小说的动漫电影，却没有对电影做任何的介绍，而豆瓣上面也只能搜到这本小说，对电影也为做提及。通过多次查找，最终通过某网盘搜索引擎搜到了该视频。</p>
<p>完整的分上下两章看完了这部电影/视频，看完后最大的感受就是乱入和故弄玄虚。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-12-影评-盛开的樱花林下/1.jpg" alt=""></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>山贼本身还算善良的，只抢钱财不杀人，但意外之下杀了人抢了一个女人。 那女人先用背自己，捡发簪开始试探山贼，通过种种事情山贼被该女人操纵了，开始犯道德上的错误，他杀那堆老婆，不过这样也越来越接近那个女人了，这个山贼虽然还保有一丝心灵不安，但是这个来自未知世界的女人对他来讲诱惑力太大了，女人让他们一起去了京城，进一步，又诱惑山贼去杀人，每天山贼通过杀人，带人头回来来取悦该女人。在京城的一段时间，山贼慢慢了解了未知的事实，发现不是那么回事，想要回到山林，结果女人还是利用了他的无防范，准备先安抚再作打算。视频埋下伏笔，女人留条子给野猪妹说“我很快会回来”。但是偶尔路经山贼最害怕的樱花树下 正值落英缤纷，在接天接地自然野生而存在的男主所掌控的世界，这突然而现的妖艳樱花绝对是山林间很奇怪的存在。让男人突然意识到女人是个妖怪，然后在樱花树下将女人给掐死了。</p>
<a id="more"></a>
<h3 id="乱入"><a href="#乱入" class="headerlink" title="乱入"></a>乱入</h3><p>该电影是一部以古代日本为题材的作品，但中间为了搞怪，卖萌和轻松，会穿插许多现代设备，如耳机，手机，照片等等，让人看的尴尬症都犯了。全剧情本身是投入着血腥诡异的特点的，但中间往往喜欢突然插入这种搞怪的元素，未免让我感觉是不是入错了片场。</p>
<h3 id="故作玄虚"><a href="#故作玄虚" class="headerlink" title="故作玄虚"></a>故作玄虚</h3><p>电影的前面整个内容还可以看，虽然说有点血腥暴力重口味，但至少主线内容还能够体现是一个一身武艺的乡野村夫被一个腹黑女调教成了刽子手。结局的剧情就很诡异了，让人感觉是强行要和樱花扯上关系，山贼每次遇到樱花都会无缘无故的恐惧这本身作品中就没有交代清楚，最后一场樱花树下的镜头更是特意混淆观众，留下了三组镜头，伴随着三种可能的结局：</p>
<ol>
<li>樱花树下，男人清楚的认识，原来女人是女鬼，于是把女人掐死了。</li>
<li>女人被山贼掐死后，男人发现是自己惧怕樱花产生了幻觉，把自己爱的女人当成女鬼给掐死了。</li>
<li>最后一幕镜头是只有男人一个人倒在樱花树下，也可以想成，男人产生了幻觉，实际上自己被女人给弄死在了樱花树下。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>据说电影是为了透露樱花不仅仅是表现浪漫，在古代樱花往往显现着血腥诡异等，但总的来说，该作品三观不正，主线混乱，没有给出一个完整值得一看的剧情和主题，不推荐去看，当然你也未必能够找得到片源。</p>
<hr>
<p>写作时间：20:30-21:05</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[透过分时租赁车看未来的交通]]></title>
      <url>http://noparkinghere.win/2017/03/11/2017/2017-03-11-%E9%80%8F%E8%BF%87%E5%88%86%E6%97%B6%E7%A7%9F%E8%B5%81%E8%BD%A6%E7%9C%8B%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BA%A4%E9%80%9A/</url>
      <content type="html"><![CDATA[<p>最近几个月共享交通工具都特别火热，无论是共享汽车还是共享单车都焕发着蓬勃生机。先不说用户对这些共享交通工具的看法，仅是减少私家车使用，鼓励人们绿色出行，以及资本市场的认可，政府的支持等等就可以看出，共享出行这块虽然刚刚起步，但还是有很大的市场环境的。</p>
<p>今天同事办了一张分时租赁的汽车卡，带我一起去体验了把。关于汽车的具体信息，办理手续等等我了解的不是太清楚，这边仅仅就我知道的一些做个说明，租赁大概分为以下步骤：</p>
<ul>
<li>手机 APP 就附近或者指定地点查找汽车，如果有的话，可以选择一辆你要预约的汽车，APP 上面会有汽车的相关信息。</li>
<li>到达汽车附近，仔细查看你的车，有没有什么损坏或者问题。</li>
<li>将充电电源拔掉，外部刷卡（类似ETC），提车。</li>
<li>自己驾驶出行，费用为 30元/h，按照分钟进行计费，0.5元/min。</li>
<li>还车，需要按照指定要求，例如关闭发动机，关闭车灯，接上充电桩，手机 APP 检测通过方还车成功。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-11-透过分时租赁车看未来的交通/1.jpg" alt="timg.jpg"></p>
<h3 id="个人体验"><a href="#个人体验" class="headerlink" title="个人体验"></a>个人体验</h3><h4 id="快"><a href="#快" class="headerlink" title="快"></a>快</h4><p>快可以有两点说明，一个是预约方便，拿车快；另一个是纯电动汽车，速度快。就驾驶体验而言，这个车还是感觉可以的，抛开外观等其他因素，仅汽车行驶而言，体验可以达到 15 万左右的汽车级别。虽然车身比一般两厢的车还要少不少，但因为是纯电动的汽车，车前身可以节省不少的空间，因此车厢乘坐空间还是很宽裕的，中控全触摸屏，手刹等也全都是电子控制。另外驾驶速度快，驾驶过程安静无声，给汽车的体验可以说加分不少。</p>
<h4 id="繁"><a href="#繁" class="headerlink" title="繁"></a>繁</h4><p>借车方便，开车和还车不易，这方面主要还是全自动话没有管控原因，对于没用过这个车的人，第一次入手而且还是电动汽车，刚上来你就不知道如何解锁，然后解锁晚，不仔细阅读说明书，你不知道手刹的按钮在哪儿，手刹松开还要二次启动等等，虽然中控做的很智能现代化，但对于开惯老式车的人无疑还是有个适应过程的，而这个过程往往缺少专人指点。由于汽车是联网监控的，还车时，如果你运气不好，也会花不少时间，多项检测指标，检测不通过，你得反复启动尝试才行。</p>
<h4 id="乱"><a href="#乱" class="headerlink" title="乱"></a>乱</h4><p>乱可以体现在很多地方，首先是租赁汽车，前一个使用者可能会把车子弄得一团糟，其次，还车地点也乱，APP 好不容易查到一个还车点，结果发现是被私人或者单位占领了，比如某企业合作，或者在公安局里面，且这些地方保安都不让你停进去。最后一点，就是车子存在违规违章损坏等等可能引起的纠纷实际很难落实到位，很多开这个车的，可能只有驾照很少开车，这就存在安全隐患，其次，车辆缺少监管措施，很可能还存在无证驾驶的情况。</p>
<h3 id="预见"><a href="#预见" class="headerlink" title="预见"></a>预见</h3><p>现在，由于私家车越来越多，城市建设跟不上，可用停车位明显不足，大量机动车的使用，也带来了很多的安全隐患，而共享出行恰恰可以解决这些问题，虽然刚刚起步，仍然存在诸多的不足，但随着几个核心技术的成熟和发展，在未来几年内，可能会成为我们出行的一种主流方式。</p>
<p>共享出行，可以说是一整套的解决方案，至少会包括：监控，无人驾驶，线下维护，网络分析调度等等。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-11-透过分时租赁车看未来的交通/2.jpg" alt="timg.jpg"></p>
<p>我们可以设想以下，在未来的某一天，我们准备出门时，只需要打开智能设备，提前预约一辆车到楼下，通过控制中心的调度，根据你的时间，会安排附近有空闲时间的一辆车自动开到你的出发地点，你看到车后，直接可以上车，出发，无人驾驶系统，会将你准确的送到目的地，如果你采取慢行模式（价格更加便宜，允许中途载人），汽车会中途载其他乘客，到达目的地后，你直接下车， APP 自动付费。共享汽车接送完所有乘客后，发现有一个故障，会关闭接客服务，自动到最近维修点去维护。维护完成后继续工作，已经进入夜晚，需要用车已经不是那么多，大部分车驶入郊区维护充电，为城市节省资源和空间；少部分车继续在各个街道巡逻，为乘客提供及时的便捷服务。</p>
<hr>
<p>写作时间：21:05-22:15</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[PDF内容获取]]></title>
      <url>http://noparkinghere.win/2017/03/08/2017/2017-03-08-pdf%E5%86%85%E5%AE%B9%E8%8E%B7%E5%8F%96/</url>
      <content type="html"><![CDATA[<p>其实 PDF 转 word 已经不算是什么新兴技术了，大约 10 年左右的时候，我在网上通过一些本地转换工具/在线转换工具，以及汉王OCR等软件，就已经可以把 PDF 导成 word 或者获取 PDF 文件中的绝大多数内容了。而随着软件技术的不断发展，最近的一些新兴软件在转换效率等上面也做的越来越出色，目前大多数的 PDF 文档几乎都可以完美转换成 word 格式。</p>
<p>在正文之前，首先安利一个 PDF 软件，国内出名的算是<strong>福昕阅读器</strong>了，该软件的特点就是速度快，占用资源少，功能多（虽然他也有很多缺点，但和同类 PDF 软件比已经可以甩开别人好几条街了）。这边就 PDF 中的内容获取，我们可以分为三类，以下针对他们也会一一详细介绍。</p>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p>并不是每个人都需要获取 PDF 文件中全部内容的，很多时候我们在阅读一个 PDF 文档时，也许只是需要摘录他的一句话，或者获取一小段文字。这个时候往往可以在 PDF 中直接选中这段文字，右击或使用快捷键复制。但往往有些人会特意为难我们，他们会在自己的 PDF 文件上面进行加密，让你只能阅读文件，却没法对文件内容进行任何复制，标注等操作。如果遇到这种问题，可以使用我这边提供的一个小工具，<a href="https://pan.baidu.com/s/1qY6RaSc" target="_blank" rel="external">pdfunlocker</a>，如果无法解密，可以去找新版的软件。。</p>
<p>这边介绍两个比较好用的 PDF 小工具：<a href="https://pan.baidu.com/s/1o8Gy34A" target="_blank" rel="external">FreePic2Pdf+PdgCntEditor</a>。解锁后的文件很多会丢失目录，可以通过软件 PdgCntEditor 获取文档目录编辑。同时 FreePic2Pdf 软件（批量将图片导出成 PDF 文档）可以和 PdgCntEditor 一起使用，</p>
<a id="more"></a>
<h3 id="文字转成-word"><a href="#文字转成-word" class="headerlink" title="文字转成 word"></a>文字转成 word</h3><p>虽然计算机发展了很多年，但仍然有不少人会使用 word 来进行排版和编辑。他们也希望所有获得的文档都是 word 类格式（包括 .doc .docx等等）的，这样他们就可以对文档中的内容进行任意的增删改查了，虽然说 PDF 出现就是为了规范格式，让一般人无法轻易的对其中的内容做修改，但仍然有很多人乐此不疲的想这么做。PDF 转 word 的软件可以说是相当繁多且良莠不齐，这边我们只推荐一款： PDF-to-Word 该软件网上很容易找到，这边就不给出链接了，当然其他还有很多可以将 PDF 转成 word 的工具，如在线网站 <a href="https://smallpdf.com/pdf-to-word" target="_blank" rel="external">smallpdf</a>， <a href="https://www.pdftoword.com/" target="_blank" rel="external">nitropdf</a>等等。</p>
<h3 id="图片转-word"><a href="#图片转-word" class="headerlink" title="图片转 word"></a>图片转 word</h3><p>并不是所有的 PDF 都可以轻易转成 word，以上那类 PDF 转 word 的软件，很多都只适用于文字的转换，换言之，就是本来文字内容你就是可以选择的，软件要做的只是讲文字内容自动复制出来，进行重新排版，然后生成 word 文件给你看。但现在很多 PDF 文件的内容都不是文字格式的，很多内容是扫描件，或者是手工拍的照片，更有胜者将文字转成了图片在导入到 PDF 中。这些无疑都增加了你导出内容的难度，然而，这些问题也只能难道过去你的，对 OCR 技术如此成熟的今天，只要不是手写内容，基本上都可以 100% 的识别出来。下面我们介绍下几款这种软件：</p>
<ul>
<li>汉王 OCR：好像是 05 的一款软件，国内比较早涉及这款领域的一个软件，识别率不是很高，但也基本可以识别，优点是不要联网，可以离线直接使用。</li>
<li>Google drive：你可以把 Google 邮箱中的内容直接通过 Google drive 打开，右击 PDF 用 word 打开，然后你会惊奇的发现，PDF 中图片的内容已经变成了可以编辑的文字了。目前而言，Google drive 中的 PDF 插件是用户体验最好的一种方式，几乎可以满足所有的 PDF 转 word 编辑，然而使用该服务需要联网，因此你需要科学上网。</li>
<li>oneNote：Microsoft office 全家桶中的一员大将，oneNote 中自带 OCR 功能，你可以在插入中找到找到它，这个软件 windows 7 中好像是没有的，其他最新系统到底面不免费就不得而知了。</li>
<li>WPS：该软件大家应该也比较熟悉，算是国内 office 软件的霸主了。用 WPS 打开你的 PDF 文档，最上方就会出现 word 转 pdf 的选项，以及图片转文字功能，对于辨识度较高的图片常规读取里面的内容是没问题，但该功能算是 WPS 的一个增值服务，如果需要转成 word 或者识别度好，则是需要会员服务的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上这些软件都是一看就会用的软件，这边不再具体给出软件的教程，如有疑问可以自己多尝试，或者直接网络搜索。</p>
<hr>
<p>写作时间：21:00-22:08</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[输出均匀的PWM脉冲]]></title>
      <url>http://noparkinghere.win/2017/03/08/2017/2017-03-08-%E8%BE%93%E5%87%BA%E5%9D%87%E5%8C%80%E7%9A%84pwm%E8%84%89%E5%86%B2/</url>
      <content type="html"><![CDATA[<p>PWM 脉冲输出方式千奇百怪，这边主要是要求两点：</p>
<ul>
<li>输出指定个数的 PWM 脉冲</li>
<li>让指定个数的 PWM 脉冲，尽可能均匀的分布在一定的时间内。</li>
</ul>
<p>首先假设 1s 内需要输出 n 个脉冲（n &lt; 100，且 n 是个变量），需要在 1s 内让这 n 个脉冲尽可能均匀的分布，这边提供 3 种解决方法，供参考。</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>每次需要发送脉冲时，重新设定 PWM 的参数，这边占空比可以固定为 50%，但周期需要更改，如脉冲变为 20， 则周期就设定为 50ms，这样的好处是操作起来简单灵活，每次需要发送脉冲时，直接修改 PWM 占空比，然后重启开启定时器，但存在问题是 PWM 设置和开启需要一定的时间，无法确保 1s 内一定能够把脉冲输出完毕。当然我们可以通过进一步缩短周期时间，如需要产生 20 个脉冲，我们可以将周期设置为 45ms，这样在 900ms 内一定可以将脉冲输出完毕。这样缺失算是基本上解决这类问题了，但如果你的系统对时间进度要求较高的话，你的 PWM 定时器和程序执行的定时器很难做到同步。</p>
<p>这边提供另外一种思路，我们采用 PWM 定时器，来完成整个程序周期的调度，例如，我们设定 PWM 周期为 10ms ，然后通过 PWM 定时 100 个周期，进行一次主程序的扫描（1s），这样的话，主程序和脉冲输出就可以做到完全的同步了。以下两种方法，都是基于这种时钟基础做的操作。</p>
<a id="more"></a>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>首先我们确定了 PWM 周期是 10ms，我们可以将 1s 这个时间片进一步划分，分成 20 个 50ms，在这 50ms 中，让每次打出一定数量的脉冲个数，例如，80个脉冲，则每个 50ms 需要输出 4 个脉冲，因为 PWM 周期是 10ms，所以这边输出的 4 个脉冲会占据 50ms 的前 40ms，这样看起来也基本算是分散的比较均匀了。进行这种处理时，需要注意的是余数，如 99 这个的余数，我们需要认为的通过算法，讲余数均匀的插入到，每个点后面。这种方法，同样是存在某些缺点的，缺点是需要把时间片分的比较细，如果你将 1s 分成 5 份的话，在输出 10 个波形时，会发现虽然整体上看 PWM 波还算是均匀，但每个时间片中，PWM 波是紧挨着的，具体如下：<code>110000000000000000001100000000000000000011...</code> 显而易见， 1 的分配在大时间 1s 中是均匀的，但小时间 200ms 中是紧挨着的。但如果分配的比较细致，如上面所示分成 20 个时间片的话，无疑又会增加主程序扫描和判定的次数。</p>
<h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>采用查表的方式，有时看似最简单的方式，往往说不定是最有效的，由于这边需要输出的脉冲情况数并不是太多（100种情况），我们可以将这 100 种情况下的每个 PWM 周期（也是 100 个状态）全部列出来，用 100*100bit来保存你的数据，100bit 可以用 13kbyte 保存，这样差不多占用 1.3k 的代码段。然后我们每次进入 PWM 中断，判断下一个 PWM 周期是否需要开启 PWM 信号。这样可以更加精准地控制 PWM 输出，且减少计算量，但相应的，我们至少额外的 13kbyte 的 flash 空间来存储我们的数据，这也算是一种典型的时间换空间的方法。如果通过查表的方法来输出 PWM ，我们需要手动写一个计算程序来生成这样的表格。这边提供一个思路：如果输出 12 个 PWM 波，我们可以通过计算 (100-12)/12 得出每个 1 后面需要加入的 0 个数，然后通过 (100-12)%12 得到余数，从前往后，每个 1 后面再补 1 个 0 ，值到没有余数全部补完。</p>
<p>以上三种方法各有利弊，具体看你系统的需要而定。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）人类有三个大脑？——“脑的三位一体”理论 ]]></title>
      <url>http://noparkinghere.win/2017/03/08/2017/2017-03-08-%EF%BC%88%E8%BD%AC%EF%BC%89%E4%BA%BA%E7%B1%BB%E6%9C%89%E4%B8%89%E4%B8%AA%E5%A4%A7%E8%84%91%EF%BC%9F%E2%80%94%E2%80%94%E2%80%9C%E8%84%91%E7%9A%84%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93%E2%80%9D%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p><em>本文是转载文章，可以参考<a href="http://blog.sina.com.cn/s/blog_663d9a1f0101f4gs.html" target="_blank" rel="external">原文链接</a></em></p>
<p>保罗.麦克里恩提出的“脑的三位一体”假设</p>
<ul>
<li>爬行动物脑</li>
<li>边缘系统（古哺乳动物脑）</li>
<li>新皮质（新哺乳动物脑）</li>
</ul>
<p>神经学专家保罗.麦克里恩提出假设，设想人类颅腔内的脑并非只有一个，而是三个。这三个脑作为人类进化不同阶段的产物，按照出现顺序依次覆盖在已有的脑层之上，如同考古遗址一样，保罗称其为“人脑的三位一体”构造。麦克里恩现在是位于美国马里兰州浦尔斯维的“脑进化与行为”实验室的主管，他说这三个脑的运行机制就像“三台互联的生物电脑，各自拥有独立的智能、主体性、时空感与记忆”。他将这三个脑分别称作新皮质或新哺乳动物脑，边缘系统或古哺乳动物脑，以及爬行动物脑，即脑干和小脑（见上图）。每个脑通过神经与其他两个相连，但各自作为独立的系统分别运行，各司其职。</p>
<a id="more"></a>
<p>该假设已经成为了一个颇具影响力的脑研究范式，催生了对人脑功能机制的从新思考。在此之前，研究者们认为新皮质作为人脑的最高层，控制着其他的低端脑层。麦克里恩否定了这一说法，指出，控制情感的边缘系统，虽然生理上位于新皮质之下，但在必要的时候能够干扰甚至阻止新皮质高阶精神功能的实现。</p>
<p>有趣的是，许多带有神秘色彩、年代久远的灵性修行团体也宣扬过与此类似的观点，比如“意识的三种境界”，甚至同样有人提出过“三个不同的大脑”一说。例如葛吉夫，他曾经称人类是“有三个大脑的生物”，他们分别掌控着人的意识、灵魂和身体。卡巴拉教、柏拉图主义，以及其他一些地方也可以见到类似的观点，他们基本上都提出了“意识—脑袋（真实的大脑）”、“灵魂—心脏”、“身体—腹腔”这类功能与器官的对应关系。我们不由想到了脉轮范式（chakra，音译为：查克拉），它与以上那些说法一脉相承且更加细化，认为人类的身体或脊椎一侧依次分布着若干个穴位，分别与不同的意识节点相对应。</p>
<p>爬行动物脑.  旧皮质，又称原始（爬行动物）脑或“基础脑”，包括脑干和小脑，是最先出现的脑成分，麦克里恩称其为“R-复合区”。它由脑干—延髓、脑桥、小脑、中脑，以及最古老的基底核——苍白球与嗅球组成。对于爬行动物来说，脑干和小脑对物种行为起着控制作用，出于这个原因，人们把旧皮质称为“爬行动物脑”。在爬行动物脑操控下，人与蛇、蜥蜴有着相同的行为模式：呆板、偏执、冲动、一成不变、多疑妄想，如同“在记忆里烙下了祖先们在蛮荒时代的生存印记”。无休止地复制着相同的行为方式，从不会从以前的错误中学习教训（与室利．阿罗频多所说的机械心灵相对应）。这个大脑控制着身体的肌肉、平衡与自动机能，诸如呼吸与心跳。大脑的这个部分一直保持活跃状态，即使在深度睡眠中也不会休息。</p>
<p>边缘系统（古哺乳动物脑）.  1952年麦克里恩第一次创造了“边缘系统”这个词，用来指代大脑中间的部分，这部分同样可以称作旧大脑皮层或中间脑（古哺乳动物脑），与大部分尤其是进化早期的哺乳动物脑相对应。位于边缘系统的古哺乳动物脑，与情感、直觉、哺育、搏斗、逃避、以及性行为紧密相关。如麦克里恩所察，情感系统一向是爱恨分明的，一件事物要么“宜人”要么“不宜”，没有中间状态。在恶劣的环境中，正是依赖这种简单的“趋利避害”原则，生存才得到保证。</p>
<p>当这部分大脑受到弱电流的刺激，多种情绪（恐惧、欢乐、愤怒、愉悦、痛苦等等）便会滋生。虽然各类情绪在特定位置存留的时间很短暂，但整个边缘系统却似乎是孕育情绪、注意力以及情感（情绪主导）记忆的主要温床。从生理上看，边缘系统包括下丘脑、海马体以及杏仁核。它帮助人类判断事物的基本价值（例如，你对某物是持肯定还是否定态度，佛教称此为vedena—“感”）和特别之处（例如，什么吸引了你的注意力），还有助于人类感知不确定性因素，进行创造性活动。边缘系统与新皮质有着千丝万缕的深入连接，二者联合操控着脑功能的发挥，任何一方都无法独立垄断人脑运行。<br>麦克里恩提出，教条化与偏执狂、自卑感、对欲望的合理化等行为倾向都可以在边缘系统中找到生物学基础。他认为边缘系统中蕴含的力量如果全部爆发，危险性实在不容小觑。按照他的理解，发出价值判断指令的指挥室，往往不是处于更高进化阶段的新皮质，而是边缘系统中相对低阶的古哺乳动物脑。前者产生的想法好不好，正确与否，都由后者来加以判断。</p>
<p>新皮质，大脑、脑皮质，或者换个词：新皮层，就是我们所知道的高级脑或理性脑，它几乎将左右脑半球（由一种进化较新的皮质类型组成，称为新皮质）全部囊括在内，还包括了一些皮层下的神经元组群。脑皮质对应的是灵长类哺乳动物脑，人类当然包括在内。正是脑皮质中所具有的高阶认知功能，令人类从动物群体中脱颖而出，麦克里恩将脑皮质称作是“发明创造之母，抽象思维之父”。人类大脑中，新皮质占据了整个脑容量的三分之二，而其他动物种类虽然也有新皮质，但是相对来说很小，少有甚至没有褶皱（意味着新皮质的表面积、复杂度与发达程度）。老鼠失去了脑皮质，仍然可以正常活动（至少从表面上看是如此），而人类一旦失去脑皮质，那他将与蔬菜无异。</p>
<p>脑皮质分为左右两个半球，就是为人们所熟知的的左右脑。左侧的脑皮质控制着身体的右侧，右侧的脑皮质控制着身体的左侧。并且，右脑更多地决定了人的空间感、抽象思维、音乐感与艺术性，而左脑则更多控制着人的线性逻辑，理性思考与言语能力。</p>
<p>鱼脑不重，但鱼类和比它低等的无脊椎动物都有一条脊索或脊髓。原始的鱼类在脊髓前端有一个小小的隆起，这就是鱼脑。较高级的鱼类的隆起变得更大些，但仍然不重于 1克或2克。这个隆起相当于高等动物的后脑，或脑干以及中脑部分。现代鱼类的脑多半为中脑，前脑极小。现代两栖类和爬虫类的脑则恰恰相反（见图5）。最原始脊椎动物的头骨化石内模显示，现代脑的主要部分（如后脑、中脑和前脑）业已形成。五亿年前，在原始沧海里邀游着一种鱼类动物，名叫甲胄鱼（Ostracoderms）和盾皮鱼（Placoderms）。现在仍可以辨认出来，这种动物脑的主要部分与现代脑是相似的。但它们的相应体积、各部组成意义及其早期功能肯定与现代的脑截然不同。有关脑后来进化最引人注目的见解，就是叙述覆盖在脊髓、后脑和中脑上面的另外三层连续堆积及其功能的特化。脑的每一步进化都保留着原有部分，但其功能必须被新层控制，同时具有新功能的新层又增殖出来。国立精神保健研究所脑进化和脑行为研究室主任麦克莱恩（PauIMaclean）是当代这一论点的主要阐述者。麦克莱恩著作的特点之一是包罗万象。他研究了从蜥蜴到鼠猴多种动物；另一个特点是，他和同事们仔细研究了这些动物的社会行为和其他行为，以便扩大成果，弄清脑的哪些部位控制着哪种行为。</p>
<p>带着粗鲁面部表情的鼠猴却有一种礼仪，这种礼仪常常表现在它们相互致意的时候。雄猴龇牙咧嘴、喀啦喀啦摇晃笼子铁杆，发出令人毛骨悚然的尖叫，翘起腿，裸露出勃起的阴茎。这种行为在现代人公共场合里彼视为极端野蛮的行为，而在鼠猴群落中，却是一种相当精细的行为，并用于表明其占有优势的等级地位。</p>
<p>麦克莱恩发现，鼠猴的一小部脑损伤能制止这种行为出现。与此同时，大量的他种行为包括性和好斗行为则不受任何影响。损伤中所涉及到的部分是前脑的最古老部分，是人和其他灵长目、哺乳类和爬虫类祖先所共有的部分。非灵长目哺乳类和爬虫类动物类似的定型行为似乎都控制在脑的这一相同部位。如爬虫这一组成部分受到损伤，除这种定型行为外，象行走或奔跑等自动型行为都可能减弱。</p>
<p>经常发现灵长目动物性的行为同所处的支配地位有关。在日本的猕猴中还保留着社会等级。日常的交配活动又在不断地加固这一等级差异，地位低卑的雄猴对动情期的雌猴表现出谦卑而又富有性的柔情，并有礼貌地让身份较高的雄猴首先交配。这种交配活动是常见的，但却又是敷衍了事的。似乎没有什么性的内容，只是作为一种表明在这一复杂的社会集群中各自所处不同地位的通俗象征。</p>
<p>当研究鼠猴行为时，我们考察了名叫卡斯珀的雄猴。它在这个集群中占支配地位，又是最活跃的表现者。尽管它表现在生殖方面的求偶夸耀行为要占整个集群此种行为的三分之二，但它主要是在雄性成猴面前显耀自己。从未见过卡斯珀与雌猴的交配行为。事实表明，它的主要动机是建树支配地位，对它来说寻求性欲满足的动机是无足轻重的。事实也说明，当两种功能活动可能涉及到同一器官系统时，它们却是完全独立的。研究这一集群的科学家们断定：就组群等级而论，生殖表现被看成是最有成效的社会标志，并已被定型化了，好象具有“我是主”的含意。这很可能源于性活动，但主要用于社会交往，与单纯的生殖活动是有所区别的。换而言之，生殖上的求偶夸耀行为是一种来源于性行为，但用于社会目的而不是生殖意图的定型行为。在1976年的电视谈话中，节目的主持人询问一名职业足球队员，如果你们队员在更衣室内都赤身裸体，是否感到难为情？他马上回答：“不，个别队员和打水的人除外，我们都很坦然，一点也不觉得难为情，正如平常我们相互在说，‘伙计，让我们看看你穿了些什么’时一样轻松自如。”</p>
<p>各种研究证实了性、攻击和支配地位之间存在着行为与神经解剖结构的联系。狮虎和其他动物交配定型行为在早期是很难跟打仗行动区分开来的。驯养的狮虎有时呜呜吼叫，用其爪慢慢地搜索着室内物品或轻轻地抚摸着人的皮肤，这些都是屡见不鲜的事。用性来建树和保持支配地位时常明显地见于同性恋和异性恋常例中（当然不是此类惯例中的唯一因素），同时也表现在许多猥亵的言词里。攻击这个动词在英语和其他语言中是最常见的。动物往往把攻击行为看作是非凡的愉快。在考察“Agression”这个动词的来源时，发现它的英语形式可能来自德语和中古荷兰语动词“Fokken”，意为攻击。这个词在其他方面的费解用法可以理解为猕猴象征语言的等同动词，只是句首的主语“我”字没有说出来，但双方还是理解的，这种做法和其他许多类似的表达方式好象同原始人的交媾定型行为一样。但据我们看，原始人的这种行为可能比猴出现得更早，这要倒回几亿年的地理时间。</p>
<p>根据鼠猴试验，麦克莱恩发展了被他称之为三位一体脑结构和脑进化的具有脸力的脑模式。他说，我们是通过三种完全不同的智力观点来观察我们自己和周围世界的。脑的三分之二是没有语言能力的。麦克莱恩认为，人脑就象三台有内在联系的生物电子计算机。每台计算机都有自己的特殊智力、自己的主观性、时间空间概念、自己的记忆、发电机和其他功能。脑的每一部分都能适应单独较大范围的进化。据说脑的三个组成部分在神经结构和功能上都是有区别的，它们的神经化学递质多巴胺和胆碱酯酶的含量完全不一样。最远古时人脑组成部分是脊髓、构成后脑的髓质和脑桥以及中脑。麦克莱恩把脊髓、后脑和中脑统称为神经框架。它含有生殖和自身保护的基本神经结构，包括心脏调节、血液循环和呼吸等结构，鱼和两栖动物的脑基本如此。如果按麦克莱恩的观点去解释，那么丧失了前脑的爬虫动物或较高等动物，就象一辆无人驾驶的车辆，没有方向目标，也无法开动。</p>
<p>我认为癫痫大发作，实质上可以看成是由于脑内电暴丧失了脑认识功能的驾驶者造成的。此时患者除神经框架外完全处于瞬息无效状态。这种损伤使受残者暂时又回到几亿年前的状态。我们至今还使用古希腊人对疾病的命名，古希腊人认识到了疾病的深奥特性，但他们却把疾病说成是上帝给予的惩罚。</p>
<p>麦克莱恩对三种神经框架的驾驶者进行了分门归类。它们之中的最古老部分都围绕着中脑（中脑主要由神经解剖学家称为的嗅觉沟回、层状体和苍白球等三部分组成）。中脑是我们同哺乳类和爬虫类共有的，它很可能是从几亿年前进化来的，麦克莱恩把它称之为爬虫复合体（R-complex，相当于蚯蚓部——译注）。围绕着爬虫复合体的是边缘系统，之所以这样命名是日为它毗邻在大脑皮层下（我们的臂和腿称作四肢，四肢对机体其余部分来说是边缘）。边缘系统是我们同哺乳动物共有的，也是我们同爬虫类共有的，但不那么完善精细，这大约进化了一亿多年或五千万年以上。最后就是覆盖在脑的其余部分上的显然是最新进化的堆积物——新皮质，同高级动物和灵长目动物一样，人的新皮质相当大。越发达的哺乳动物其新皮质增长越大，新皮质进化得最出色的是人（还有海豚、鲸鱼），这大概已有几千万年的进化史了。可当人出现后的近几百万年大大加快了这一进化速度。图6展示的是人脑示意图，三种当代哺乳动物的边缘系统和新皮质的对比在图5中已展示过。三位一体脑的观点同上章研究过的脑重与体重比率而得出的结论显然是一致的。哺乳动物、灵长目动物（特别是人）的出现总要伴随着脑在进化上的大范围飞跃。</p>
<p>很难通过改变脑的深层组织结构达到进化。深层的任何变化可能都是致命的，但是通过在旧系统上面增殖新系统可以达到根本的变化。这使人想起了十九世纪德国解剖学家黑克尔（Ernst Hacckel）称之为重演的学说。这个学说经历了不同时期学术上的肯定或否定。黑克尔认为，在胚胎发展中动物趋向于重复或重演我们祖先在进化中所遵循的程序。确实胎儿在子宫内发育中，在尚未呈现出人形之前, 经历了同鱼、爬虫动物和非灵长目哺乳动物非常相似的阶段。胎儿在鱼的阶段时还存有鳃裂。鳃裂对于依靠脐带得到滋养的胚胎来说是绝对无用的。在人的胚胎学中，脐带是完全必要的。既然鳃裂对我们的祖先是必不可少的，在变成人时胎儿经历了鳃裂阶段。胎儿的脑也是由内向外发展的，并大致经过下列顺序：神经框架，爬虫复合体，边缘系统和新皮质（见图29人脑的胚胎发育）。</p>
<p>重演的原因可理解为：自然选择对个体起作用，对种不产生影响，更不能影响受精卵和胎儿，这样一来新的进化变异都要出现在产后。胎儿可能具有象哺乳动物鳃裂这样的特性。鳃裂在胎儿出生后是完全无用的。由于它对胎儿没有什么严重影响，而且在出生前就消失了，所以鳃裂在胎儿时期保存下来是无关紧要的。人的胎儿鳃裂不是古代鱼的遗迹，而是鱼胚胎的遗迹。许多器官系统不是通过增加或保存的方式，而是通过变更旧的系统进展的。例如，把翅变成腿，腿变成鳍状肢或翅膀，或脚变成手、再变成脚，皮脂腺变成乳腺，鳃弓变成耳骨，鲨鱼鳞变成鱼牙等等。引起这种增殖和保留原有结构功能的原因有两个：一是由于新旧功能的同时需要：二是因为无法把符合幸存者的旧系统保留下去。</p>
<p>阐明这种进化本质的例子是很多的，几乎是随手可取。现在让我们再举一个例子吧。比如说考究一下植物为什么是绿色？绿色植物的光合作用利用太阳光谱中的红光紫光来分解水，生成糖类和植物体中的其他物质。太阳辐射的光谱中，黄光和绿光要多于红光和紫光。但以叶绿素为光合作用色素的植物排斥了最为丰富的光线黄光和绿光。许多植物看来“注意”到了这点，但是已经为时过迟了，因为它们已经进行了恰如其分的适应变化。现在已有了反射红光吸收黄绿光的其他色素，如类胡萝卜素，藻胆色素，真是尽善尽美，应有尽有！但是否有了新的光合色素植物就抛弃了叶绿素呢？图8展示了红藻的光合作用，植物的条纹结构里含有叶绿素，紧贴着这些条纹的小球含贮着使红藻呈现红色的藻胆色素。这些植物一成不变地把从绿光黄光中获取的能量传给叶绿色素，叶绿色素尽管不能吸收光，但它能在所有植物的光合作用中起到沟通光和化学过程之间的间隙作用。这样大自然就不可能抛弃叶绿素而再用更好的色素取代之。叶绿素已经纵横织成了生命之帛。具有附加色素的植物确实是多种多样的，附加色素更有效用，但叶绿素还是起作用。尽管它的可信赖性有所降低，它仍是光合过程中的核心。我想脑的进化也是如此进行的。脑的深层和古老部分仍然在起作用。</p>
<h4 id="爬虫复合体"><a href="#爬虫复合体" class="headerlink" title="爬虫复合体"></a>爬虫复合体</h4><p>如果上述观点是正确的，我们就应想到人脑的爬虫复合体在某种意义上还执行着恐龙的功能，人脑的边缘皮质还存在着美洲狮和树獭的思想活动。毫无疑问，脑每进化一步都伴随着脑的原有组成部分的生理学变化。在中脑等部位一定能见到爬虫复合体的进化。我们还知道，脑的多种功能控制在脑的不同部位。假如新皮质下的脑组成部分没有相当大的扩延，仍执行远古祖先头脑的功能，我们就会为此而感到惊慌失措。</p>
<p>麦克莱恩指出，爬虫复合体在攻击行为、保卫领域、礼仪和建立社会等级差异中起着重要作用。尽管偶尔也表现出更高的功能，但在我看来上述作用恰恰是现代人在官场中多种政治行为的特征。当然这并不否认新皮质在美国参议两院政治会议中所起的作用。不管怎么说，礼仪上的大量交往都是通过语言进行的，因而最终还要归结于新皮质的功能。究竟有多少区别于我们所说所想的实际行为可用爬虫的术语描述，这是引人入胜的。我们平时经常谈到“冷血”动物，就是指爬虫而言。</p>
<p>美国哲学家兰格（Susanne Langer）风趣地描述了这种思想部分的超前作用，写道：“人生是充满礼仪的，渗透着动物习俗的。生命是理智和礼仪、知识和宗教、散文和诗歌、事实和幻想的综合体。礼仪象艺术一样，它是人日常经验抽象的总结。礼仪不是在脑的古老部分，而是在皮质内产生的，一旦新皮质发育成人的状态，这种礼仪就成了皮质的基本功能了。”从各种资料来看，爬虫复合体是脑的原始部分，这看来已是无可非议的事实了。我想进一步了解爬虫动物的脑对人行为影响这一论点的社会含意。假如官僚政治的行为彻底地受爬虫复合体控制，这是否就意味着人的未来是没有希望了呢？人的新皮质约占脑重的85％，同脑干、爬虫复合体和边缘系统相比，这确实是一个重要特征。神经解剖学、政治历史和内省，这一切都提供了证据，证实人类完全能够抵制沉溺于爬虫脑的每个冲动的强烈欲望。如美国“人权法案”不可能不经大脑思考，而只是靠爬虫复合体记录构想出来的。我们人能抵制那种一味盲从地遵循遗传学上的既定行为，这正是我们高于他种动物的不同之处，也恰恰是我们的可塑性和漫长童年的特点。如果把三位一体脑看成是人类如何正确活动的楷模，然而却忽略人的本质组成部分，尤其是忽略我们人的礼仪和等级制度行为，那是没有什么益处的。相反，这种模式应能帮助我们理解人是怎么回事（我不敢断言，许多精神病，即青春期痴呆的精神分裂症的礼仪行为是否是由于爬虫复合体内的某些中枢活动过度的结果，或是由于起抑制爬虫复合体功能的大脑新皮质部位障碍造成的。同样我也不知道青少年常见的礼仪行为是否是因其新皮质还不完全发达的结果）。</p>
<p>在一次奇妙的旅行中，切斯特顿（Chesterton）写道：“你可以摆脱外国的法律约束，但你逃脱不了事物本身的自然法则。不要尽做那种振奋人心的三角越狱。如果三角形超越了它的三条边，那它就要有个悲惨的结局。但不是所有的三角形都是等边的。调整三位一体脑的每个组成部分的相关作用，这完全是我们能够办到的。”</p>
<h4 id="边缘系统"><a href="#边缘系统" class="headerlink" title="边缘系统"></a>边缘系统</h4><p>边缘系统看来是产生激情，即特别激动的情感部位。这使人立即想起关于爬虫复合体的另一种看法：它的特点并不表现于极为矛盾的强烈感情，而是对受其基因和脑支配的某些行为表现出顺从平静的默许。</p>
<p>边缘系统的电流放电有时能引起同精神病相似的症状或引起因服幻觉药而出现的类似症状。事实上许多治疗精神病药物都作用在边缘系统上。可能边缘系统能控制兴奋、恐惧以及多种人所特有的又往往是难以捉摸的感情。</p>
<p>垂体，这个影响其他腺体、控制人的内分泌系统的脑垂体是边缘区的本质部分。因内分泌不平衡造成情绪波动的特性给我们提供了有关边缘系统同思维状态联系的重要启示。在边缘系统里有一种很小的杏仁状的内含物，叫做杏仁体，它和攻击、恐惧行为息息相关。电刺激杏仁体可以激起温顺的家畜出现令人难以置信的恐惧和狂燥状态。当杏仁体切除后出现这样一种情况，猫发现小白鼠也要吓得发抖；反之，象山猫这种本性凶猛的动物倒变得温顺起来，容许人们喜爱抚摸。边缘系统机能失常的人可以产生无缘无故的狂怒、恐惧和脆弱感情。常态的过度刺激可以产生同样的后果：患这种病的机体出现不适当的莫名其妙的感觉，他们被看成疯痴。</p>
<p>至少象脑垂体、杏仁体和下丘脑这些边缘内分泌系统的一些确定感情作用是由小分子的激素蛋白质形成的。这种蛋白质由上述组织分泌出来，井影响脑的其他区域。大概人所共知的是脑垂体蛋白质——促肾上腺皮质激素（ACTH），它可直接影响到可见的象滞留、焦虑、注意力广度等多种神经功能。通过实验在脑第三室可测出某些小分子的下丘脑蛋白质。脑第三室是边缘系统的一个部位，它把下丘脑和视丘联系起来。</p>
<p>有充分理由可以认为利他主义的行为起源于边缘系统。的确，除极个别的例外（主要是社会领域），哺乳类和鸟类是唯一倾注全力照料幼雏的生物。这是一种通过条件允许的长期适应性，利用哺乳类和灵长目动物大脑的大量信息处理能力而进化发展的结果，似乎是哺乳动物首创了性爱* 。</p>
<p>强烈感情的逐渐形成主要表现在哺乳动物身上，鸟类的进化程度较小，许多动物的行为证实了这一见解。我想，家畜对人的依附性是毫无疑问的。众所周知，当拿走幼畜时，许多哺乳动物的母畜表现出明显的伤感。那么人们想知道这种感情效力究竟有多大？马是否也有少许的爱国热情？狗是否也有象人那样具有对宗教心醉神迷的感情？同我们没有交往的某些动物是否也有某种强烈费解的感情？</p>
<p>边缘系统的最原始部分是嗅觉皮质。它同嗅觉有关，它的萦回感情特性为大多数人所熟知。我们的记忆和回想能力的主要组成部分位于边缘系统内的一种结构——海马内（位于侧脑室下角底的中央部的曲形构造——译注），海马损害将引起严重的记忆减退已确切地证实了这一点。H·M（相当汉语中“某某”，因不便写出患者的姓名——译注）是一位有长期癫痫发作和惊厥史的病人，在他的海马附近的整个区域施行切除术，试图减少其癫痫发作次数和疾病的严重程度。手术后病人立刻变得健忘，但他仍保持良好的感觉功能，并能学会新的运动技能，也许还能进行某些感性学习，但几乎忘记了前几个小时所学到的一切。他本人的感觉是：“在我看来每天都是孤立存在的，无论什么样的愉快我都享有过，什么样的忧伤我都尝受了”。他把他的生活说成是一种辨认不出方向的迷惑感觉的继续扩大。应该说这种感觉也是我们许多人睡梦初醒时的共同感受，那时我们很难回忆起到底发生了什么事。确实，尽管这种损害严重，在海马切除后，其智商（IQ） （通过对给定的一些问题的口答来确定智力，这种智力测验结果用“智商”表示，智商就是用这种测定方法测出的“智力年龄”与“实际年龄”的比值——译注）有所改进。他能敏锐的分辨出不同的气味，但很难说出味源的名称，他对性活动已明显地失去了兴趣。</p>
<p>另一个病例是一个年轻的航空兵，他在同一个军人击剑决斗中，一块微薄的剑片飞入右鼻孔，刺穿了靠近上面的一小部分边缘系统，从而导致记忆的严重衰退，类似H·M病例，但不如H·M病情那么严重。他的感性知识和智力能力并没受什么明显的影响，但在语言材料方面的记忆减退特别明显。事故似乎使他变得对疼痛反应迟钝，他赤脚在巡洋舰炽热的金属甲板上踱来踱去，同他一起的乘客吵嚷说有一种烧焦皮肤的难闻气味之后，他才意识到他的脚已被烧伤。作为他本人即不知疼痛，也嗅不到烧焦的气味。</p>
<p>从这样的病例中不难看出，象哺乳动物这种复杂性活动是受三位一体脑的三个组成部分——爬虫复合体、边缘系统和新皮质同时控制的（我们已提到有关爬虫复合体和边缘系统在性活动中的复杂情况，同牵连到新皮质的复杂情况很容易通过内省获得证实）。</p>
<p>旧边缘系统的一段是专门用于口述和手势功能的。它的另一段用于性功能。性和嗅觉在很早以前就有关联，昆虫高度发展了性和嗅觉的联系，但这一情况也使我们远古的祖先透彻理解到依赖嗅觉的重要性，同时也看出了其不利方面。</p>
<p>我曾目睹一个试验，在试验中，用一条细金属丝将绿蝇头部联到一个示波器上，此示波器能以一种图形方式显示出由绿蝇嗅觉系统产生的任何电冲动（为了有机会观察到嗅觉设备，将绿蝇头部截断，由于刚截断不久，因而其头脑还能具有许多功能作用）。</p>
<p>试验者在绿蝇前面散发各种气味，包括令人讨厌不快的、但又没有明显影响的气体，如氨。这时在示波器萤光屏上留下的图线是水平伸展的，接着在断头的绿蝇前飘放微量的由这种雌性绿蝇放出的性引诱气味，此时在屏上呈现出垂直的尖峰脉冲。撤掉此种雌性引诱气味，绿蝇几乎嗅不到任何气味，绿蝇的嗅觉对此种性引诱分子非常敏感。</p>
<p>这种嗅觉功能的特化对昆虫来说是常见的。假如每秒钟仅有大约40个雌性引诱分子碰到蚕蛾轻软的触觉，它也会觉察出来。每个雌性蚕蛾每秒钟仅需释放出百分之一毫克的性引诱物，就足够引诱大约一立方英里范围内的每个雄蚕，这是蚕虫之所以幸存的原囚。</p>
<p>最奇妙的还是用气味寻求配偶和传种。例如，冬天在地下打洞的南非甲虫，当春回大地时，甲虫钻出地面，但雄性甲虫比雌性甲虫早几个星期从地里踉踉跄跄地爬出。在南非的同一地区，业已演变的兰花放出一种同雌性甲虫性引诱物相同的香味，事实上，兰花放出的气味产生了与雌性甲虫性引诱物功能基本相同的分子。加之雄性甲虫长期在地下视力很差，而兰花花瓣的构形又发生了演变，这对辨认能力缺乏的甲虫来说，兰花花瓣在性感官形态上又很象雌性甲虫。几周中雄性甲虫在兰花丛中恣意狂欢，心醉神迷。最后雌性甲虫从地里钻出，我们可以想象出雌性甲虫因身心受到伤害会产生多大的义愤。与此同时兰花却已通过多情的雄性甲虫进行了传粉，雄性甲虫窘迫不堪但又尽力传延本种后代，这样雄雌性甲虫都得以幸存了（顺便说一句，如兰花的迷惑力不是很强，这对兰花本身是有益的；但反过来说，如没有甲虫的自身繁殖的性活动，兰花因无媒介传粉也会陷入绝境）。这样一来，我们就发现了一条纯属嗅觉性刺激的界限。还有另外一条界限，那就是，既然每只雌性甲虫产生相同的性引诱物，雄性甲虫就不易同它心目中的雌性甲虫产生性交往。当雄性昆虫可能竭力表现自己去诱引雌性，或者同无异性伴侣的甲虫为竞争雌性而展开相互衔咬下颌骨搏斗，雌性引诱物在交配时的中心作用似乎减少了昆虫性选择的范围。</p>
<p>寻求配偶的另外方法已被爬虫动物、鸟类和哺乳动物所发展。但性同嗅觉的联系，在高等动物神经解剖结构上以及在人经历的轶事中都很明显地证实了这一点。我有时想知道除臭剂，尤其是女性除臭剂是否试图有意识地刺激人们联想起其他别的事情。</p>
<h4 id="新皮质"><a href="#新皮质" class="headerlink" title="新皮质"></a>新皮质</h4><p>假如鱼的前脑遭到损害，这将导致它丧失原有的主动谨慎的特性。对于高等动物来说，这种较复杂的特性似乎就位于新皮质内，这也是人的多种典型的感性认识功能部位。我们通常将其划分四个主要区或者说是四个叶来进行探究的。这四个叶是额叶、顶叶、颞叶和枕叶。新皮质中各个部位彼此相通，据现在所知它同脑下皮质的神经联系还是不少的，但这决不能说新皮质的各个部分是实际的功能单位。每个叶肯定具有许多不同功能，某些功能可能是几个叶或两个叶共有的。在其他功能中额叶好象是同深思熟虑和行动调节有关；顶叶同空间感觉以及大脑同身体其余部分问的信息交换有关；颞叶与各种复杂的感性认识有联系；枕叶同视觉、同人与其他灵长日动物占优势的感官有关系。</p>
<p>几十年来风行一时的神经生理学家认为，前脑后面的额叶是典型的预感和部署未来的功能部位。但近来的著作表明，情况并非如此简单。马萨诸塞州理工学院美国神经生理学家托伊伯（Hans Lukas Teuber）调查研究了大量额叶损残（在战争中受伤或击伤）的病例。他发现不少额叶损伤几乎对行为没有明显影响。不过在严重损残额叶的病理学中，“病人并不完全缺乏预料事件过程的能力，但不能在同那些事件关系中把自己设想成潜在动因”。托伊伯强调指出额叶可能同运动原和认识的预感，尤其是同随意运动造成的影响有关。额叶也似乎同视觉以及双足直立行走有关。这种额叶因执行人的特殊功能可能以两种途径进化。如果说额叶能控制预料未来的功能，那它也必然是产生关心和焦虑的情感部位。这就是为什么切断额叶能减少焦虑的原因。前额叶切开术必定会使患者大大减低人特有的能力。我们为预知未来所付出的代价就是对未来的忧虑，因而预测灾难不可能是一件令人宽慰的事。遇事总是过分乐观的人要比凶事预言者幸福的多。自然界预言凶事对幸存者来说是必需的。控制展现未来的学说起源于伦理学、魔法、科学和法典，预见灾祸的好处就在于能采取措施去防范它，牺牲眼前暂短利益换得未来长远好处是这种预见的结果。在物质丰富的社会里才能形成对社会和技术发明所必需的空闲时间。</p>
<p>可猜测出额叶的其他重要功能就是使人类双足直立行走。在额叶没有进化之前，人的直立姿势不可能出现。有关这一点详见以后章节。双足直立行走解放了双手，以便用双手操作，从而导致人类文化和哲学特性的较大增长，困此如果很客观他讲，文明可能就是额叶的产物。</p>
<p>来自眼睛的视觉信息传到人脑后主要在头的后部枕叶里定位，听觉印象定位于太阳穴内颞叶上部。据一些不完全的证据表明，盲人、聋哑人的新皮质的上述部位很不发达。枕叶损残，如枪伤经常引起视觉障碍，受残者可能在其他方面正常无疾，但只能用外围视力观察。在正常视觉中枢里觉察到暗点实点隐隐浮现在他的眼前，在其他病例中伴随而来的是离奇古怪的知觉，其中包括几何学上的视界内正规草写浮动障碍和“视力发作”，当发作时，患者会把在其右下方地板上的物体误认为在其左上方空中浮动的图象，物象在患者眼里颠转了180度。通过对称计算因各种枕叶损伤而造成的视力障碍，可以详尽地用图表示出枕叶的哪些部分负责执行哪种视力功能。青年人的脑好象能自身修复，并圆满地将这一功能活动转送到邻近区域，永久性的视力减弱似乎很少发生在青年人身上。</p>
<p>联系听觉和视觉刺激的能力定位于颞叶。颞叶损伤可以产生失语症，即不能意识所说的言语。值得注意的是脑损伤的病人可以完全胜任口语，但不能全部胜任书写文字；反过来也是如此，他们可能会写、但不能阅读；能读数字，但读不了字母；能准确叫出事物的名称，但不能识别颜色。新皮质有着惊人的功能分类，这种分工与阅读、书写或认字、识数等这些常识性见解相反，但活动是完全相似的。到目前为止，还有些未经证实的脑损伤报告。这种损伤仅仅引起不能理解被动语态或介词词组，或所有格结构。（虚拟语气的部位总有一天会找到的。是否拉丁人将变得格外富有天资，而说英语的民族在脑解剖结构的较小部分上将大大地缺乏变化？）各种抽象概念包括语法学的语言部分似乎惊人地同脑的特殊区域毗连相通。</p>
<p>在一个病例中，颞叶损残可引起患者辨认面目的严重障碍，甚至患者不能认出其直系亲属的面貌。图11中所描绘的面目图，患者说，人脸“可能”是个苹果。他并请求让他证实这种解释是合理的。他把口说成是苹果上的切口，把鼻子看作是在表面上凸起的苹果把，把眼睛认为是虫眼。相同的病人能完美的认出素描的房子以及其他非生物。广泛的试验表明，右颞叶损害可形成典型性的语言记忆丧失，我们具有阅读、绘画、在立体的三个方向标定自己以及恰当使用符号等能力，所有这些能力如果不是同语言的使用有关，大概就是同语言的发展有关。这些能力又会因近于头脑顶部的顶叶损残而遭到严重减弱。一位军人在战时其顶叶很大一部分被子弹穿通，他整整一年不能判断他的脚是否穿上了拖鞋，而且很难辨认出他所在医院、病室和病床。尽管如此，最后他还是痊愈了。</p>
<p>顶叶内新皮质角回（顶下叶的一个脑回——译注）的损害引起失读证，不能辨认印刷单词。顶叶看来与人的符号语言有关。在所有脑损伤中，顶叶损残造成智力极大衰退，这可以通过日常生活活动测试出来。</p>
<p>新皮质抽象概念中主要还是人的符号语言，尤其是读、写和计算。这些看来需要颞叶、顶叶、额叶，也许还需有枕叶的协调活动。但不是所有的符号语言都属于新皮质的。蜜蜂（没有一点新皮质）具有精美的舞蹈语言，用以在获得食物方向和距离方面彼此传递信息。澳大利亚昆虫学家弗里希（Karl von Frisch）首先发现了这一点。这是一种夸大的手势语言，实际上是蜜蜂找到食物时动作的模拟。这点有时同我们人的动作相似，如我们向电冰箱走了儿步，腹部冲着电冰箱，一下擦痛肚皮，那时我们就会伸舌摇头表示遗憾。应该说舞蹈语言的词汇量是极其有限的，可能仅有几十个单词。年轻人在童年时期所经历的学习几乎都是新皮质的功能活动。</p>
<p>大部分嗅觉过程是在边缘系统内进行的，与此同时也有一些发生在新皮质内。相同功能的划分似乎也适用于记忆。边缘系统的主要部分除嗅觉皮质外，正如我们所说的那样，都是海马皮质。当嗅觉皮质得到训练时，尽管效力很低，动物还能嗅到。这是脑功能多余信息的又一例证。还有一些证据表明，现代人嗅觉的短期记忆存储在海马里。海马的原功能可能是专管嗅觉的短期记忆，这对追逐捕食动物或寻找异性是有用的。但如人的两侧海马损残，正如H·M病例一样，引起各种短期记忆的极度减弱。这种病的患者不能连续不断地逐字记忆，很明显，海马和额叶都与人的短期记忆有关。</p>
<p>这方面的多种有趣结论之一，就是脑的长短期记忆大量储存在脑的不同部位。标准的条件作用——巴甫洛夫试验狗当听到铃响时分泌唾液的能力似乎就位于边缘系统。这是一种长期记忆，但却是极其有限的。很有经验的人其长期记忆都存储在新皮质内，这与他深思熟虑的性格是一致的，当我们逐渐衰老时，我们能回忆起童年时生动琐碎的往事，却会忘记人们刚对我们所讲的一切。这种现象是由于我们在长期和短期记忆上都出现些障碍。问题就出在这两者之间的联系上。我们很难把新材料存送到长期记忆里去。彭菲尔德认为，这种存贮能力的丧失是由于动脉硬化或其他体内功能失调而引起的老年人海马供血不足的结果。</p>
<p>这样，老年人（或不太老的人）在存贮短期记忆上可能严重衰退，但在其他方面他们却是相当机灵，在智力上也是敏捷的*。</p>
<p>这种现象表明，在脑的不同部分定位的长短期记忆之间是有着明显区别的。快餐馆的女服务员所能记住的信息量是令人佩服的。她能准确无误地将这些信息传告厨师，但一小时后这些信息就完全消失。这是什么原因呢？这个原因是女服务员仅把信息存储在短期记忆里了，而没有再努力把这种信息进一步存贮到长期记忆中。</p>
<p>回忆机制大概是很复杂的。一种共同的感觉就是在我们长期记忆里记住一些东西，如一个单词、一个名字、一副面孔、一种体会，我们发觉这些东西不能马上被回想起来。尽管我们如何冥思苦想，仍不能回忆起来。如果我们从侧面想想，回想某些稍有关联的周围事项，便常常能自动回忆出来。（这方面与人的视力也有些相似。当我们直接观察一个模糊不清的物体时，比如说星星，我们常用视网膜中央小窝，这个具有最敏锐的、细胞密度最大的、称作圆锥细胞的视网膜部分。当我们稍微转移视力，象我们说话时斜视一下物体时那样，我们就发挥了视网膜杆状细胞的作用，这种细胞对朦胧的光照很敏感，这样就能看出昏暗的星光。）为什么歪着头思考就能促进记忆的恢复呢？要了解这个问题是件颇有趣味的事。这只能认为是使用不同的神经途径来联想记忆痕迹的结果，但这说明不了脑的操纵管理因此就格外有效了。</p>
<p>我们都做过那种栩栩如生、毛骨悚然、寓意深远的梦，或相反有过一些清晰难忘的梦境；我们也都有过从梦中醒悟的感受。如果你默默自语“清晨时我一定能记住这个梦”，次日连个梦影都记不起来，顶多不过是一种印象模糊不清的痕迹而已。另一方面，如果我们对做的梦感受很深，捅醒身边的妻子，告诉她所梦到的一切，这样一来，次日清晨就能不费吹灰之力独立回想起梦情。同样，如果不嫌麻烦，爬起来把梦情写下来，次日早晨醒来时，无需参照记录就能清清楚楚地回想起梦情。记电话号码也是同样道理，如果别人告诉我号码，我只想着这一点，那我很可能忘记号码或数位串换，如果高声重复几遍或把号码记下来，那就能清清楚楚地回忆起来，这确实意味着大脑里有个特定部位专门记忆声音和影象，但并不记忆思想。远古时代首先存储在人脑里的记忆并不是一些富有哲理的思想，而是那些爬虫动物的嘶嘶叫声以及骤然俯冲下来扑食的鹰的影象。我不知道是否那种对于声音影象的记忆出现在我们所产生的许多想法之前。</p>
<h3 id="关于人的本质"><a href="#关于人的本质" class="headerlink" title="关于人的本质"></a>关于人的本质</h3><p>不管三位一体脑模式的功能定位如何引人入胜，但我要再次强调，如一味坚持认为脑功能的完全分工也是过分简单化。人的仪式，情感行为一定受新皮质的抽象推理的强烈影响。现已对纯属宗教信仰的真实性进行了分析论证，证明等级行为在哲理上也是正当无咎的，正如霍贝斯（ThomasHobbes）论证国王神圣权利那样。同样，人以外的动物，有的动物甚至连灵长目都不是，但却能表现出少许的分析能力。自然对于海豚我也有同样的印象，正如在我的著作《宇宙联系》中所阐述的那样。</p>
<p>然而，只要我们头脑里还存有要求停止某些行为的禁锢时，我们就把生活中礼仪、等级领域看成是受爬虫复合体的强烈影响，并认为是与我们的爬虫动物祖先共有的；我们认为生活中的利他主义、感情和宗教领域在相当大的程度上位于边缘系统，并与我们非灵长目的哺乳动物（可能还有鸟类）祖先共有，认为理性是新皮质的一种功能，并在某种程度上同高级灵长目动物以及象海豚鲸鱼这种鲸目动物所共有。当礼仪、感情和推理是我们人本质的重要领域时，抽象的联想力和推理能力几乎是人独有的特征。好奇心和解决问题的迫切愿望就是我们人类感情的标志。数学、科学、技术、音乐、艺术——这些比通常包括在“人文学科”范围更广泛一点的学科都是人所特有的活动。就“人文学科”这个词的通常用法来说，它好象是研究人的观察力，但这肯定是一种特别狭义的理解，实际上数学既是诗歌也是人文学，鲸鱼和海豚同人一样具有“人道”。</p>
<p>三位一体的脑模式来源于有关比较神经解剖学和行为的研究。但对人种来说，直诚的内省不是不可知的。如果三位一体的脑模式是正确的话，我希望在人类自我认识的历史中，对这一模式能得到某些启示。弗洛伊德（Sismund Freud）把人的精神状态划分为三种：“本我”（id）、自我”（ego)、“超我”（Superego)。这又使人们联想起广泛周知的三位一体脑的假说。爬虫复合体的攻击和性的行为同弗洛伊德描述的“以德”是完全一致的（在拉丁词中是“it”，即人的兽性）。但据我所知，弗洛伊德在描述“以德”时，并没强调爬虫复合体的礼仪和社会等级范畴。他把感情说成是“自我”功能。尤其是“无边无际的灵性感受”，对弗洛伊德来说，这是宗教神灵的等同词，但是“超我”却根本没有被说成是抽象推理部分，而是内在的社会和亲本结构。我们可以设想这一部分在三位一体的脑中具有较多的爬虫复合体的功能。这样一来，我只能勉强地根据三位一体的脑模式来描述人的三种心理状态。</p>
<p>可能较恰当的隐喻是弗洛伊德的思维划分法，他将思维分为有意识的、前意识的和无意识的三种。前意识是潜在的、但能发掘的功能；无意识是被抑制或是没有显示出来的功能；这是存在于各个心理组成部分中的张力。弗洛伊德在谈到人时，他认为人的神经官能症的能力是其文化发展能力的相对应面。他将无意识功能称为“原始过程”。</p>
<p>在《柏拉图对话集》的《费德鲁斯》（Phaedrus）一节中，可以得出有关人心理隐喻的一种论点。苏格拉底把人的灵魂同双轮马拉战车联系起来。这辆战车由黑白两匹马向不同方向牵拉着，而驾车人却无力地驾驭着。这个隐喻同麦克莱恩的神经框架的比喻是极其相似的。两匹马喻比爬虫复合体和边缘系统，歪歪斜斜疾驰的双马战车的驾驭者意指新皮质。可在另一个隐喻中，弗洛伊德把自我功能说成是一匹难驾驭马的骑乘者。弗洛伊德和柏拉图的隐喻都强调了心理组成部分之间的张力，各组成部分相当大的独立性，以及表征人的状态的观点，这点我以后还要讲到的。由于三个组成部分之间存有神经解剖联系，三位一体脑本身必定象费德鲁斯的双轮马车一样是个隐喻而已，但这可能将被证实，这是一个用处很大、含义极深的隐喻。</p>
<h3 id="人脑揭秘"><a href="#人脑揭秘" class="headerlink" title="人脑揭秘"></a>人脑揭秘</h3><p>您所能想到的每种动物都有脑，无论是哺乳类、鸟类、爬行类、鱼类，还是两栖类。但人脑是独一无二的，它让我们能够思考、计划、说话、想象……脑真是一个奇妙的器官。</p>
<p>脑的作用有很多：<br>控制体温、血压、心率和呼吸。<br>接受由您的感官（视觉、嗅觉、听觉、味觉等）感受到的大量外界信息。<br>控制行走、说话、站立或坐等身体运动。<br>使您能够思考、做梦、推理和体验感情。<br>所有这些活动都是由一小颗花耶菜大小的器官来协调、控制和调节的，这个器官就是：脑。<br>人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论<br>人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论</p>
<p>人脑揭秘<br>人类有三个大脑？——“脑的三位一体”理论<br>人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论<br>人体的脑、脊髓以及周围神经构成了一个精密复杂的综合信息处理及控制系统。研究脑和神经系统的学科叫做神经科学或神经生物学。由于神经科学涉及的领域较广，加之脑和神经系统比较复杂，因此本文将从基本知识入手，为您概述这一奇妙的器官。<br>在本文中，我们将了解脑的结构及其各组成部分的功能。通过大致地了解人脑，您将能够理解运动控制、视觉信号处理、听觉信号处理、感知、学习、记忆、情感等概念，我们将在以后的章节中详细阐述这些概念。<br>神经元结构<br>脑由大约1000亿个称为神经元的神经细胞组成。神经元有强大的电化学信号采集和传送能力——这恰好类似于计算机中的电路和电线。神经元细胞有着和其他细胞一样的特征和结构, 但其电化学特征使其能够远距离（可达几米）相互传递信号。<br>神经元的基本组成部分有三个：<br>细胞体——这个主要组成部分含有细胞必需的所有成分，如细胞核（含DNA）、内质网和核糖体（用于合成蛋白）、线粒体（用于生成能量）。如果细胞体死亡，神经元就会死亡。<br>轴突——神经细胞的长索状突出部分，沿着细胞传递电化学信息（神经冲动或动作电位）。<br>根据神经元种类，轴突可能覆盖着一层薄膜，即髓鞘，就像是绝缘电线。髓鞘由脂肪组成，可加快神经冲动沿轴突传播。有髓鞘的神经元主要位于周围神经（感觉和运动神经元）中，而无髓鞘的神经元则位于脑和脊髓中。<br>树突或神经末梢——神经细胞的树枝状细小突出，可与其他细胞连接，实现神经元之间的信息传递并感知环境。树突可以位于细胞的一端或两端。</p>
<p>基本神经元结构<br>神经元大小各异。例如，手指中的单个感觉神经元的轴突会延伸至整个手臂，而脑中的神经元可能只延伸几毫米。神经元依据功能的不同，其形状也各有不同。控制肌肉收缩的运动神经元，一端是细胞体，中间是长轴突，另一端则是树突；而感觉神经元两端都有树突，中间由长轴突连接，轴突上还连接着细胞体。</p>
<p>几种类型的神经元：运动神经元、感觉神经元、皮质锥体细胞<br>几种类型的神经元：运动神经元、感觉神经元、皮质锥体细胞</p>
<p>神经元的功能也各有不同：<br>感觉神经元将外部机体（末梢）信号传递到中枢神经系统。<br>运动神经元将中枢神经系统的信号传递到外部机体（肌肉、皮肤、腺体）。<br>感受器感知环境信号（化学物质、光线、声音、触碰），并将这些信息进行编码，转换成可由运动神经元传导的电化学信号。<br>中间神经元连接脑和脊髓中的各种神经元。<br>最简单的神经通路是单突触（单联接）反射通路，如膝跳反射。医生用叩诊锤敲击膝盖的特定部位时，感受器通过感觉神经元将信号传送到脊髓；感觉神经元再将信息传递给控制腿部肌肉的运动神经元；神经冲动沿运动神经元传递并刺激对应肌肉进行收缩。该反应是一种肌肉反射，过程十分快速，并不涉及脑。人类有很多类似的基本（hard-wired）反射，但随着任务越来越复杂，反射通路的“线路”也更错综复杂并且需要用到脑。<br>最简单的生物神经系统可能仅仅由反射通路构成。例如，叶状软体蜗虫和无脊椎动物都没有集中式脑，它们仅有由松散连接的神经元组成的简单反射通路。叶状软体蜗虫拥有一种单个神经元相互联系形成、遍布全身的神经网。<br>多数无脊椎动物（如龙虾）拥有多个简单“脑”，即由神经细胞聚集组成神经节。每个神经节都通过反射通路控制其对应节段的感觉和运动功能，同时神经节之间相互连接形成简单的神经系统。随着神经系统的进化，神经节链进化为更集中的简单脑。</p>
<p>脑的主要分区<br>脊髓<br>脑干<br>小脑<br>前脑<br>间脑——丘脑、下丘脑<br>脑皮质<br>脑由无脊椎动物的神经节进化而来。无论是何种动物，脑都可分为以下几个部分：</p>
<p>脑干——脑干由髓质（上端脊髓的膨大部分）、脑桥和中脑组成（低等动物只有髓质）。脑干控制反射、自动功能（如心率，血压）、肢体运动和内脏功能（消化、排尿）。<br>小脑——小脑整合来自前庭系统的位置和运动信息，并用这些信息协调肢体运动。<br>下丘脑和脑垂体——控制内脏功能、体温，以及进食、饮水、性反应、攻击及愉悦等行为反应。<br>大脑（也叫做脑皮质或简称皮质）——大脑由皮质、大纤维束（胼胝体）和一些深部结构（基底神经节、杏仁核、海马）组成。它整合来自所有感觉器官的信息、激发运动功能、控制情感、保存记忆和思维过程（情感表达和思考在高等动物中更为普遍）。</p>
<p>脑部对比图形</p>
<p>从鱼类到人类，您会发现皮质越来越大，所占比例也越来越大，并且出现褶皱。增大的皮质负责更高等级的功能，例如信息处理、语言、思维和记忆。另外，叫做丘脑的部分将来自脑干和脊髓的信息传递到脑皮质。<br>人体内的“鱼脑”？<br>低等动物（鱼类、两栖类、爬行类、鸟类）的“思维活动”很少，它们更关心觅食、进食、饮水、睡眠、繁殖和自我保护等日常活动。因此，它们的脑主要由控制这些功能的区域组成。我们也可以完成这些功能，所以我们的体内也有一个“爬行动物”的脑。</p>
<p>脑的下部是脑干和颅神经。<br>脑的下部是脑干和颅神经。</p>
<p>低等动物的脑</p>
<p>低级脑的基本组成部分包括脊髓、脑干和间脑（小脑和皮质同样存在，但在稍后部分讨论）。每个结构中都有名为髓核的神经细胞中枢，它们均有特定功能（呼吸、调节心率、睡眠）。</p>
<p>脊髓<br>脊髓可以看作是与脑分离的器官，或者仅是脑干向下的延伸部分。它含有来自于身体的感觉和运动反射通路，以及脑的上行和下行通路。脊髓中含有不依赖于脑的反射通路，如膝跳反射中的那样。</p>
<p>髓质——包含用于调节血压和呼吸的髓核，还包含用于传递由感觉器官发出的、源自颅神经的信息的髓核。<br>脑桥——脑桥含有将来自小脑的运动位置信息传递至皮质的髓核，也有与呼吸、味觉、睡眠相关的髓核。<br>中脑——中脑的髓核联系脑中与运动功能（小脑、基底神经节、大脑皮质）、眼部运动、听力控制有关的各个部分。其中一部分叫做黑质，与自主运动有关。当其功能丧失时就会发生帕金森氏病的震颤性运动。<br>丘脑——丘脑将外来的感觉通路传递到大脑皮质的相应区域，决定哪些感觉信息传导到意识以及哪些信号参与小脑、基底神经节、皮质之间的运动信息交换。<br>脑垂体——脑垂体含有控制脑垂体分泌激素的髓核。这些中枢支配有性繁殖、进食、饮水、生长、母性行为（如哺乳动物泌乳）。脑垂体还参与绝大多数行为，包括与日夜循环相关的生物“钟”（昼夜节律）。</p>
<p>低级脑的内部视图<br>低级脑的内部视图</p>
<p>小脑位于脑桥的后上方，并褶皱形成许多叶。它接收来自脊髓的感觉神经信息、来自皮质和基底神经节的运动信息，以及来自前庭系统的位置信息。然后小脑将这些信息进行整合并影响从脑出发的输出运动通路，以协调运动。为说明这一点，请伸手触摸身前的某一点，如计算机显示器——手会完成一个顺滑的动作。如果小脑受损，这个动作将变得非常僵硬，因为皮质会发出一系列导向目标点的肌肉微缩信号。小脑也会参与语言表达（控制唇部和喉部肌肉的细微收缩），以及其他认知功能。</p>
<p>人脑主要内部结构<br>高等动物的脑</p>
<p>大脑是人脑中最大的组成部分。皮质内包含有所有接受和处理感觉信号、触发运动、分析信息、推理和表达情感的中枢。分管这些功能的中枢位于皮质的不同区域。了解皮质各区域的功能前，让我们先了解一下各区域的分布。<br>大脑皮质的主要部分<br>皮质占据了人脑外表面的主要部分。脑的表面积约为1500到2000平方厘米，相当于一到两页报纸。将这么大的表面积装进颅骨时，皮质会发生折叠，形成褶（脑回）和沟（脑沟）。几条大的脑沟将皮质分为下述几叶：前叶、顶叶、枕叶和颞叶，每种叶均有不同功能。</p>
<p>将鼠标移到人脑各部分的标签上，可以看到其在人脑中对应的位置。<br>从上往下看时，一条大脑沟（大脑纵裂）将人脑分为左右两个半球。左右半球通过一束称为胼胝体的白质纤维结构进行信息交流。同时，两侧颞叶还通过靠近脑后部另一束称为前连合的纤维进行交流。</p>
<p>人脑主要内部结构-</p>
<p>如果能看到大脑的切面图，就可以发现一条脑沟将胼胝体以上的皮质区分为两半，这条脑沟称为扣带沟。扣带沟和胼胝体之间的区域叫做扣带回，又称为边缘系统或边缘叶。大脑内部是基底神经节、杏仁核和海马。<br>硬线连接：大脑之间的连接</p>
<p>大脑之间的连接是“硬线连接”，正如高楼或飞机用电线进行硬线连接一样。在脑中，所有连接均由神经元构成，通过皮质各叶中的中枢连接感受传入通路和运动传出通路，这些皮质中枢与人脑的其他区域之间也有连接。<br>大脑的某些区域具有特定功能：<br>顶叶——顶叶负责接收和处理所有的躯体感觉信号（触觉、痛觉）。<br>由脊髓分出的纤维，经过丘脑分配，到达顶叶各区域。<br>这些连接在顶叶内构成了一幅机体表面的“地图”，称为脑投射图。<br>脑投射图看起来有些奇怪，因为每个区域在图中按照感觉神经元连接的数目显示，与该区域的实际大小无关。（有关是什么决定了脑投射图的详细信息，请参见What Does Your “Homunculus” Look Like?Mapping Your Brain）</p>
<p>脑投射图，一幅机体的感受“地图”。脑投射图看起来有些奇怪，因为每个区域在图中按照感觉神经元连接的数目显示，与该区域的实际大小无关。<br>脑投射图，一幅机体的感受“地图”。脑投射图看起来有些奇怪，因为每个区域在图中按照感觉神经元连接的数目显示，与该区域的实际大小无关。</p>
<ul>
<li>顶叶后部（靠近颞叶的区域）有一块称为韦尼克氏区的区域，该区域对于理解与语言相关的感觉（听觉和视觉）信息非常重要。这块区域的损伤会造成“感觉性失语”，即患者不能理解语言的内容，但是可以发出声音。</li>
<li>额叶——额叶与运动（包括语言）和认知功能有关。</li>
<li>脑部的运动中枢（中央前回）位于额叶尾部、顶叶前方。它接收顶叶躯体感觉的连接信号，处理、触发运动功能。和顶叶中的脑投射图一样，中央前回也有运动区域的投射图（有关详细信息，请参见A Science Odyssey:You Try It - Probe the Brain Activity）。</li>
<li>额叶左侧有块区域，称为布罗卡氏区，控制用于发出声音的肌肉（嘴、唇和喉）。这块区域的损伤会造成“运动性失语”，即患者可以理解语言的内容，但只能发出无意义或模糊的声音。</li>
<li>额叶其他区域与联想功能（思维、学习和记忆）。</li>
</ul>
<p>脑功能区域模式图</p>
<ul>
<li>枕叶——枕叶负责接收和处理从眼睛直接传送过来的视觉信息，并将这些信息与顶叶（韦尼克氏区）和运动- 皮质（额叶）相关联。其功能之一在于处理从眼睛晶状体角膜投射到视网膜上的倒置图像。</li>
<li>颞叶——颞叶处理来自耳朵的听觉信息，并将之与顶叶的韦尼克氏区、额叶的运动皮质相关联。</li>
<li>脑岛——脑岛影响脑干的自动功能。比如，屏住呼吸时，脑岛的神经冲动会抑制髓质的呼吸中枢，脑岛同时还处理味觉信息。</li>
<li>海马——海马位于颞叶内，对短时记忆非常重要。</li>
<li>杏仁核——杏仁核位于颞叶内，控制社会行为、性行为以及其他情绪。</li>
<li>基底神经节——基底神经节与小脑共同协作，调控精细运动，例如指尖动作。</li>
<li>边缘系统——边缘系统控制情绪性行为和内脏肌肉（消化道和体腔器官的肌肉）的运动。<br>脑里面的水分</li>
</ul>
<p>脑和脊髓包裹着一系列坚韧的脑脊膜，可保护这些器官，避免其受到颅骨和脊柱的擦伤。同时，脑和脊髓还漂浮在颅骨和脊柱内的脑脊液中，以增强保护。这种缓冲液体由脑中的脉络丛组织产生，流经一系列腔室（脑室），最后，从脑部流出，沿脊髓流下。脑脊液与供血之间由血脑屏障隔开。</p>
<p>脑室系统<br>脑室系统</p>
<p>正如您所见，人脑是一个复杂精密、高度分化的器官，它控制机体的一切行为。在您了解了人脑的解剖结构之后，可以参阅其他文章，以了解其特定功能。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影评--阿修罗]]></title>
      <url>http://noparkinghere.win/2017/03/06/2017/2017-03-06-%E5%BD%B1%E8%AF%84-%E9%98%BF%E4%BF%AE%E7%BD%97/</url>
      <content type="html"><![CDATA[<p>简书笔友 @见月酱 美女的一篇文章让我知道了这部争议较大的电影，由于个人对这些新奇题材有着特殊的偏好，几乎各种受争议的禁片，限制级片，小众剧情片等，都会特地去看一遍。</p>
<p>首先看这部片子可谓是一波三折，最初也是简友推荐 B 站可以在线观影，然后去看了下，看一点点，发现一直无法显示人物配音，但背景声音很大，虽然画质和背景都不错，但没配音显然看不下去，于是尝试着去找片源，找了多个资源网站，奈何叫<strong>阿修罗</strong>这个名字的片子实在太多，不知道下载哪个，于是通过咨询等多次尝试终于刷新页面可以播放有配音的视频了。但天色不早该休息了，结果第二天尝试打开又没有声音了，之后试过多次，各种原因，反正最后在第 5 天（也就是昨天）才将该电影在手机上面看完的。</p>
<p>言归正传，这边说下该电影的观后感吧，该电影给人的留下了算是比较深刻的印象：画质出众，内容写实，寓意深刻。</p>
<h3 id="画质出众"><a href="#画质出众" class="headerlink" title="画质出众"></a>画质出众</h3><p>作为一部日本动漫来讲，出色的画质，配音可以说已经是司空见惯了，但并不是每部电影都能够将主题与画质相融合的，这部电影，就画质，配乐，配音等而言，都算是很出彩的，人物设计整体偏灰暗，当然中间部分场景特意渲染的唯美，但也是为了凸显这种反差，日本声优配音等都可以甩开国漫好几条街，这部电影的配音也很到位，尤其是片头的一段。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-06-影评-阿修罗/1.png" alt=""></p>
<a id="more"></a>
<h3 id="内容写实"><a href="#内容写实" class="headerlink" title="内容写实"></a>内容写实</h3><p>电影《阿修罗》是由1970年的漫画改编而来的电影，在2012年上映。时隔四十多年才被动画化，但上映之后仍是引起了巨大的争议。内容写实，主要体现在题材过于血腥，将卖女儿，食人肉，食子等有背现代社会价值观的内容搬上大银幕，这些题材出现让很多观众无法接收。就这方面题材表现而言这部动画，还是比较到位的，不似某些误导人的国内作品（男女主角牵个手就怀孕了，女英雄大吼一声就把敌人撕了）虽然说动画拍摄部分，已经有意的将这些镜头给过滤掉了，仅仅通过血或者他人的话语来表现这些情节，但这边我个人认为剧情内的表现都还算完整，可以接收。</p>
<h3 id="寓意深刻"><a href="#寓意深刻" class="headerlink" title="寓意深刻"></a>寓意深刻</h3><p>同一部作品，见仁见智。个人认为这部作品的寓意深刻，可以多多方面多个人物进行探讨：</p>
<ul>
<li>阿修罗的母亲，首先可以看出是一个充满母性的人物，但由于日久的极度饥饿，丧失了理智，对自己的孩子（阿修罗）下手了。前后反差之大不禁让人唏嘘，这边我们可以探讨下，该母亲在面对突发状况时，如遇到恶犬等袭击自己的孩子，可以冒着危险，去抵挡。有一点点食物时，虽然自己也吃不饱，但仍然会给自己孩子喂奶。然而当数日，日积月累的饥饿已经让自己丧失了思考能力的时候，不得不说人饥饿的本性也会掩盖其他所有的一切，尤其是当这种侵蚀并非一撮而就的时候。我们通过前面可以发现，有理由相信该母亲是爱孩子，为了孩子可以不惜生命，但当饥饿到已经没有力气去思考的时候，又会如何呢？</li>
<li>若狭是个善良漂亮的女孩子，看似善良温婉的背后却看出一颗坚强的内心。最初应该是表现在他待阿修罗，白天需要干农活，傍晚或者夜间需要背着阿修罗给他弄吃的等等，这种体力劳动并不轻松。第二次表现在她和对象约会，约会的过程被阿修罗撞见了，然后为了保护她的对象，毅然决然的赶走了阿修罗，这种艰难取舍的心理并不容易做到，首先她自己清楚什么最重要，能够立下决定可见她是个果断坚定的人。最后一点表现在若狭的死，蝼蚁尚且偷生，但有原则的人恰逢乱世一般都容易短命，通过若狭这个人物我们可以看到现代教育的影子，若狭如果生活在现在一定会是家长眼中的好孩子，领导眼里的好下属，但也仅此而已，高尚的教育+坚定的原则在特殊时候也许反而会毁了一个人；若狭的死同时可以让我们看出，对于自己不想活的人，即便他人在努力也无法挽救你，阿修罗的眼泪恰是这段结局最好的证明。</li>
<li>阿修罗这个人物是里面刻画最简单的人物，他唯一的目标就是吃掉活物，让自己生存。而恰恰是这种目标同人类社会的价值观相违背，引发出了一堆的事端。当人们日子丰衣足食的时候，所有人都鄙视指责破坏者（阿修罗吃人肉），而当天灾人怨颗粒无收时，这种为了几斗米折腰（卖女儿，沦为鹰犬，偷东西，吃人头等）却还要带着虚伪面具的行为无疑在影片结尾极具讽刺。人生而杀生，食肉，让自己活下来是人性（动物）的本能，阿修罗从小经历了人生的疾苦，同时也见到了若狭恪守人性的光辉，最终入世出世遁入佛门。</li>
</ul>
<hr>
<p>写作时间：21:30-22:33</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关闭朋友圈，你将获得什么？]]></title>
      <url>http://noparkinghere.win/2017/03/06/2017/2017-03-06-%E5%85%B3%E9%97%AD%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%8C%E4%BD%A0%E5%B0%86%E8%8E%B7%E5%BE%97%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>偶然看到<a href="http://www.jianshu.com/p/409982e5ecb1" target="_blank" rel="external">关掉朋友圈的一年，我用手机记录了什么（春夏篇）</a>文章，突然想起来自己关闭微信朋友圈这个功能也有很长一段时间了（实在想不起来是什么时候关闭的），于是萌生了写这篇文章的兴趣，谈论这个问题前，我们先讨论一个问题：<strong>开通朋友圈，你获得了什么？</strong></p>
<h3 id="开通朋友圈，你获得了什么？"><a href="#开通朋友圈，你获得了什么？" class="headerlink" title="开通朋友圈，你获得了什么？"></a>开通朋友圈，你获得了什么？</h3><p>很多人每天花大量的时间刷朋友圈，有人是经常自己发朋友圈，而有的人却是默默的只看别人发布的内容。那么又有多少人考虑过朋友圈给你带来了什么呢？</p>
<ul>
<li>刷存在感（秀恩爱，晒美食，炫富，旅游，晒娃，等），经常发布朋友圈内容的人，往往需要博取别人的关注，来满足自己的虚荣心。</li>
<li>无聊的人打发时间，经常可以刷朋友圈，看看别人美好的生活，然后再自己意淫一下。</li>
<li>看别人分享的文章内容，增长自己的见识，关注热点。</li>
<li>靠朋友圈赚钱，发广告等。</li>
<li>获取最新的广告咨询，没准哪家店铺又出了新活动呢！</li>
<li>通过朋友圈别人的分享，学习新知识技能。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-06-关闭朋友圈，你将获得什么？/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="你确认你获得的不是假象？"><a href="#你确认你获得的不是假象？" class="headerlink" title="你确认你获得的不是假象？"></a>你确认你获得的不是假象？</h3><p>然而以上六点只能作为还在逛朋友圈的你安慰自己又浪费了半个小时的借口，当然，如果你最不缺的就是时间，可以当我没说。如果还有耐心看完此文，我们从以上 6 点一个个的进行分析。</p>
<h4 id="刷存在感"><a href="#刷存在感" class="headerlink" title="刷存在感"></a>刷存在感</h4><p>刷存在感，确实对于某些人来说可以得到心灵上面的满足，让自己成为朋友圈中的焦点（虽然舞台不大，但同样当了回明星）。但对于现代社会来说未必是好事，通过一些技术手段，有心之人很容易获取你的个人信息，包括并不仅限于照片，电话，地理位置，爱好，作息等。没准你的照片早已被挂上了多个交友网站了呢，或者被别人冒名使用了。部分人连身份证等信息也轻易泄露，网络可以搜出来身份证扫描件号码，都已被绑定了 5 个以上的微信号，除此之外，你的用户数据也会被各大商家（包括并不限于腾讯）拿去做了数据挖掘和分析，因此无论是腾讯推送给你的朋友圈广告，还是你经常收到的房产电话，都不仅是偶然。</p>
<h4 id="打发时间"><a href="#打发时间" class="headerlink" title="打发时间"></a>打发时间</h4><p>对于这种爱好的话，我也没有什么好说的，但觉得长此以往不利于个人的身心健康，回归现实世界，多出去走走，你会发现生活更美好。</p>
<h4 id="和时代接轨"><a href="#和时代接轨" class="headerlink" title="和时代接轨"></a>和时代接轨</h4><p>首先，你的朋友未必就在事发现场，你的朋友圈未必都是记者和狗仔，我相信大多数人的朋友圈对时事热点的更新远远没有新闻或者微博来的即时。每天花点时间去看看新闻也许你会发现你获得信息会更多，而不必时不时地担心又读到了一篇谣言。</p>
<h4 id="广告赚钱"><a href="#广告赚钱" class="headerlink" title="广告赚钱"></a>广告赚钱</h4><p>毕竟不是做这一行的，不清楚靠在朋友圈发广告到底可以引来多少关注和收益，但我清楚的了解，绝大多数人对朋友圈的广告都是很厌烦的。如果你的广告确确实实可以带给别人价值，那么建议可以去开通一个微信公共账号，发一些高品质的广告，而不是在朋友圈时时刻刻广告刷屏。</p>
<h4 id="获取广告"><a href="#获取广告" class="headerlink" title="获取广告"></a>获取广告</h4><p>O2O 时代，使用微信线下做生意，线上提供最新的咨询，这种模式还是广受欢迎的，因此许多人也许确实需要获取一些店家咨询和信息，但靠朋友圈发广告信息，用户看到的几率有多大？就目前我知道的线上信息一般有是那种都比朋友圈更加高效主流，其一是建立微信群，定期发通知；其二，公共账号发布消息；其三，群发消息。</p>
<h4 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h4><p>姑且不谈朋友圈的谣言有多少，我们讨论下朋友圈的信息对你有用的究竟有多少，微信定位是代替手机通讯录，因此，微信的好友可以说全是你的社交上面认识的人。而现代社会分工很详细明确，社交好友在工作，技能，生活阶层等方方面面可以说都和你有着千差万别，即便你有部分具备你需求技能的朋友，但可能他们未必会发朋友圈或者很少发朋友圈，因此通过朋友圈来学习东西现在是最不环保的。如果有学习的需求，可以去各种在线教育平台，了解一些问题可以去知乎，认识更多志同道合的朋友也可以通过社交媒体，微信公共账号可是个可以获得最新咨询和观点的绝佳平台。</p>
<h3 id="关闭朋友圈，你将获得什么？"><a href="#关闭朋友圈，你将获得什么？" class="headerlink" title="关闭朋友圈，你将获得什么？"></a>关闭朋友圈，你将获得什么？</h3><p>听说朋友圈已经去掉了小红点功能，没去考察过，不知道是不是真的。关闭了朋友圈，你能够获得的好处多多，最显而易见的两点就是：专注和时间。</p>
<p>朋友圈虽然占用的时间并不多，但一些人可能有刷朋友圈的强迫症，即便没有你什么事情，你也会一拿起手机就习惯性地刷新下朋友圈。长此以往不利于你注意力的集中，且会断断续续的浪费你很多可以完成别的事情的时间。</p>
<p>往其他方面讲，关闭朋友圈后，你再也不必看到某些人天天自恋晒照了，再也不会刷到一条条广告，以及看到腾讯广告中其他好友各种装逼言论了，毋容置疑，你的世界会清静下来很多。</p>
<p>最后这边再补充一点，朋友圈某好友，经常会发布自己的美照，但某次聊天意外发现其实她朋友圈一般都是关闭的，只是在想要晒照的时候会手动开启下朋友圈发张图。这件事告诉我们，大家的时间都很金贵，你在刷着别人的朋友圈时，没准别人其实并没有关注你们，她的分享也许只是 APP 自动生成，或者一键转载，她发的照片或者只是为了花一分钟过把自拍瘾。当你在忙着刷着别人朋友圈内容时，别人或许早已关闭了朋友圈，让自己全身心地投入到工作生活中去了。</p>
<hr>
<p>写作时间：21:10-22:27</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力lab--运动]]></title>
      <url>http://noparkinghere.win/2017/03/05/2017/2017-03-05-%E8%87%AA%E6%8E%A7%E5%8A%9Blab-%E8%BF%90%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>随着最近十多年来经济的发展和人民生活物质越来越充足，如何提高生活品质开始成为越来越多人所追求的目标。人民不再需要多吃养起肉来才可以抵挡随时可能到来的饥寒，相反越来越多的人因为食物的充足而暴饮暴食，他们的体重从起走上了不归路。健康饮食，锻炼身体成了最近几年全民关注的话题。</p>
<p>最近加入了运动训练营，主要目的是培养自己的运动习惯，改掉一些不良的毛病，这几年下来，由于个人从事电脑方面的工作，一天到晚坐着盯着电脑（从早到晚），下班后，甚至还会玩玩游戏，看看视频，或者再盯着电脑学点东西。虽然早就意识到这样的习惯肯定有问题，但奈何自己之前也没什么运动习惯/爱好。想跑步锻炼身体，但找不到合适的场景和氛围，之前做了几次，后来也就没下文了。其他的一些运动项目，貌似也需要的条件过多，自己并不能满足。思来想去，最终加入了这个训练营，也期望借此可以养成每天运动的小目标。</p>
<h3 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h3><p>截止写本文开始，已经完成该运动训练营三天，这边说下感受，参加之前对此次训练可以说是零认识，不知道锻炼什么，也不知道锻炼多久等等。加入三天后，目前是以 seven 作为每日必备的锻炼目标，其他内容根据个人喜好而选择不做强求。</p>
<p>经过三天的训练，我发现 seven 确实可以算是一个优秀的 APP ，之前虽然下载过不少这种软件，但没怎么用过，首先 seven 设定每次的锻炼时长为 7 分多钟，这个时长让大多数人都可以接收，毕竟也就上个厕所，喝杯茶的时间，如果是十多分钟或者二十分钟的话，每次完成运动就需要算好自己是否有连续的这么长时间可以利用。此外，seven 的一次训练多组动作，动作难度也不大，一般人都能够完成，且动作之间有数秒休息，动作的不断切换让人可以感觉到这种节奏感和活力，往往更加能够激发人去运动。</p>
<p>由于太长时间没有运动，这几天做完一组 seven 还是会感觉全身酸痛，但精神状态很不错。就目前我的状态而言，这款软件还是很适合我的，每天花费少量的时间并且能够培养运动习惯。</p>
<p>说完运动类 APP 再来说下队友，一个锻炼注定的乏味无聊的，在小组中，给自己找了个队友，两人一起互相监督，坚持运动会好很多。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-05-自控力lab-运动/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="计划安排"><a href="#计划安排" class="headerlink" title="计划安排"></a>计划安排</h3><ul>
<li>每天一组 seven 运动。</li>
<li>快走+慢跑，具体里程根据身体情况而定，天晴时，一周至少两次，一次 0.5h 以内。</li>
<li>不跑步时，锻炼哑铃，每周至少两次，一次 0.5h 以内。</li>
</ul>
<h3 id="运动军令状"><a href="#运动军令状" class="headerlink" title="运动军令状"></a>运动军令状</h3><p>本人在此郑重承诺，在第五期运动训练营期间，本人将全力以赴，永不放弃，确保在此期间达到以下目标：每日坚持锻炼，完成上述计划安排，养成良好的运动习惯。</p>
<p>如有未达到目标，就破费请队友吃一顿大餐以做惩罚。如达到目标，将让队友请我吃一顿大餐已做奖励。百分百对自己的承诺负责，绝不食言！**</p>
<p>兑现日：2017/05/10 请 201705F029紫荆~魔都 监督。</p>
<p>本人签字：damon</p>
<p><strong>军令如山，势必达成！</strong></p>
<p>_加油！加油！加油！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力周总结]]></title>
      <url>http://noparkinghere.win/2017/03/04/2017/2017-03-04-%E8%87%AA%E6%8E%A7%E5%8A%9B%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>参加<strong>自控力lab</strong>的训练营有了一周的时间，且写作这边也完成了 6 篇，运动训练进行了 3 天。这篇文章算是一篇周总结吧。</p>
<p>应该来说这周的进展还是比较混乱或者失败的，首先是作息时间并没能够有效的改善，反而因为写作/运动任务等导致时间更加不够了，晚上也更忙了。可以看出计划的安排略显不合理，或者个人精力不够新动力欠缺。</p>
<h3 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h3><p>下面讲详细叙述下情况目前一段时间的时间表：</p>
<ul>
<li>工作日 17:00 后开始上英语课</li>
<li>17:30 之后阅读推荐书籍</li>
<li>看完书后一般在 18:10-18:30 去吃晚餐，晚餐加散步在 1h 左右</li>
<li>一般 19:30 左右才开始写文章，写作时间不固定，技术类文章 2h 大概完成个初稿，随笔类文章一般在 1h 左右</li>
<li>由于刚开始参加自控力lab，且报了多个训练营，第一周连续多日网上直播课程或者上课，且一般都需要一个多小时，约从 20:30-21:30/22:00 中间这一段时间也忙不了别的事情（即便写作效率也很低）</li>
<li>课程结束后，群聊或者私聊等又会占用部分时间，不知不觉，下一个任务就得在 22:30 之后才可以开始执行了</li>
<li>22:30 开始学英语单词等内容，一般占用 1h </li>
<li>运动 seven 的时间 10 分钟左右</li>
<li>洗漱等杂务，最终基本上也在 00:00 以后了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-04-自控力周总结/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h3><ul>
<li>训练营课程内容所花费的时间是绝对可以优化的，可以其他时间采用回放等方式获取信息。</li>
<li>目前需要插入运动时间（跑步等内容），初期设想是 20:30 之后，这段时间可以课程时间进行错开，跑完步后花时间回听课程会更好</li>
<li>学习时间，除了以上安排的内容外，个人设想是晚上还要有 2h 左右的学习时间。</li>
<li>英语的学习内容较多，算是长期打卡的一个任务了，但占用时间未免过多，且都拖拉到睡觉前，一方面不利于休息，另外一方面效率不高，后续可以安排到早上完成任务。</li>
<li>起床时间过晚，一直恶有性循环显然是不明智的，下一阶段，最主围绕早睡早起为主，只有这个实现了，其他目标才有可能达成。</li>
<li>每日写作学习时间需要更专注些，切勿在聊天时写作，在看视频时背单词等等，专注至少可以让效率提升一倍。</li>
<li>每天的写作时间可以控制在 1.5h 小于这个时间的话，可以为第二天写作做准备，合理控制时间，不超过这个时间。</li>
</ul>
<hr>
<p>写作时间：21:15-22:00</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[搜索资源必备网站]]></title>
      <url>http://noparkinghere.win/2017/03/03/2017/2017-03-03-%E6%90%9C%E7%B4%A2%E8%B5%84%E6%BA%90%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>又是一个周末，今天的文章准备总结一下个人的在搜索资源上面的一些技巧，作为一个网龄超过 10 年的用户，我也算是经历了互联网的几个发展阶段，多年上网的经历也让我对互联网查找资源颇有一番心得。</p>
<p>其实查找资源并非一件容易的事情，尤其是对如今这个版权至上的年代而言，要想找一些自己想要的电影资源，学习视频，小说书籍等已经变得很不容易了。如果你觉得麻烦，又土豪的话花钱去观看那些阉割版的视频当然也没有问题。</p>
<h3 id="历史回顾"><a href="#历史回顾" class="headerlink" title="历史回顾"></a>历史回顾</h3><p>互联网找资源也算是分为多个发展阶段，这边我只从我开始接触互联网的时候谈起。起初互联网可以说是缺乏监管甚至是没有监管的，那时候各种网站随便上，银行也没有自己的网站，淘宝，优酷等网站也起步没多久。</p>
<p>那时候找资源可以通过百度去直接搜索，想要什么东西，基本都可以通过迅雷或者网际快车下载到，一些种子资源也可以通过电驴进行直接搜索。起初的 VeryCD 上面有不少的教程电影等等，几乎互联网上面见得了光的资源都可以在 VeryCD 上面下载到。百度可以搜索盗版软件等也很多，随便一搜就可以搜到不少的破解软件，访问国外的网站也都是可以，只是可能速度不会太快。后来随着视频网站等的崛起，慢慢的人们更加喜欢看在线视频了，但画质不高，不少提供资源的网站仍然可以下载高清的片源。</p>
<p>然而，事情不可能总是一如既往的美好，随着监管力量的进入，一条条壁垒被架设起来，最出名的当然属于 GFW ，这边不详细讨论。随着这两年对互联网监管力量的加大，只是偶然找找资源的小伙伴们也发现，很多资源过去能够搜到，现在基本上搜不出来了，或者搜出来无法访问。百度网盘中的内容不能再查看了，360云盘等多家网盘相继倒闭了。很多人一时无所适从，不知道能够去哪儿找资源了，因为他们只会用百度，然而百度作为业界最良心的一家公司，搜娱乐八卦还有广告的技术绝对登峰造极。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-03-搜索资源必备网站/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h3><p>好了，言归正传，这边推荐一些搜索资源比较给力的搜索引擎或网站:</p>
<ul>
<li><a href="http://www.loldytt.com/" target="_blank" rel="external">LOL电影天堂</a>：一个搜索电影资源的好网站，片源不算太多，但重要的是更新比较的及时，弹出广告也相对较少。</li>
<li><a href="http://www.lbldy.com/" target="_blank" rel="external">龙部落</a>：也是一个视频搜索网站，专注于最新电视剧，电影等。</li>
<li><a href="http://www.verycd.com/sto/datum/" target="_blank" rel="external">VeryCD</a>：老牌的搜索网站了，网站经过多次波折，多次整改，最终算是幸存了下来，但相关资料资源没有提供版权出处的话均被不提供下载，这边又不得不提它的克隆网站<a href="http://www.xuexi111.com/" target="_blank" rel="external">学习库</a>，你可以认为该网站就是 VeryCD 的完整版。</li>
<li><a href="http://www.panduoduo.net/" target="_blank" rel="external">盘多多</a>：一个比较出众的网盘搜索工具，主要收录的视频教程较多，通过该网站可以找到绝大多数公开的视频教程。</li>
<li><a href="http://pan.ape8.cn/" target="_blank" rel="external">百度网盘搜索引擎</a>：主要是针对百度网盘进行资源的检索，搜索到资源的几率还行。</li>
<li><a href="http://www.xilinjie.com/" target="_blank" rel="external">西林街</a>：同样是一个搜索资源的工具，不同的是，该网站主要是捕捉其他网站的搜索结果，然后讲内容呈现出来，基本上不被和谐的资源，绝大多数在该网站是能够被找到的，查找一些老电影等还是比较给力的。</li>
<li><a href="http://www.zoudupai.com/" target="_blank" rel="external">走读派</a>:可以用来搜索一些电子书记，资源不多，但还算可以</li>
<li><a href="http://www.kindlepush.com/main" target="_blank" rel="external">kindle推</a>：爱阅读的小伙伴十之八九都有个 kindle ，这个网站主要就是提供 kindle 书籍的资源，按照教程可以将书记直接推送到 kindle 上。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>暂时就只介绍这么多，知道以上这么多网站差不多已经可以检索到国内互联网的大多数教程，书籍，影片了。这边不准备推荐种子搜索的网站（大多数不正规，非法，随时无法访问），或者国外的网站，毕竟大多数人无法访问。补充说明下，如果你需要检索学术工作相关的文档之类的，建议还是科学上网，使用<a href="http://www.Google.com" target="_blank" rel="external">谷歌</a>，你会惊奇的发现，百度找了几天都找不到，甚至要付费的文档，谷歌一搜就出现在第一个。</p>
<hr>
<p>写作时间：21:30-22:52</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[70天读写计划安排]]></title>
      <url>http://noparkinghere.win/2017/03/01/2017/2017-03-01-70%E5%A4%A9%E5%86%99%E4%BD%9C%E8%AE%A1%E5%88%92%E5%AE%89%E6%8E%92/</url>
      <content type="html"><![CDATA[<p>报名参加<strong>自控力读写训练营</strong>，主要目的是：希望提高写作技巧，效率和养成写作习惯，以及认识更多有趣的朋友，希望 70 天后能够达成我所设想的目标。</p>
<p><em>下面详细说下读和写的安排计划：</em></p>
<h3 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-01-70天写作计划安排/1.jpg" alt=""></p>
<a id="more"></a>
<p>随话说，没有输入就没有输出，婴儿在学会说之前也都会有较长一段时间的沉默期，因为他们只有将输入（大人说的话）转换为自己的认知才可能创造输出（说话）。几乎任何人都不可能凭空创造出与这个世界完全不同的东西，当今几乎社会所有的创新都是站在了前人的肩膀上。</p>
<p>个人认为相比于看视频，听广播而言，阅读是更好的一种输入方式，因为它可以给你更多的想象和思考。想要有好的输入，选择阅读的书籍至关重要，下面列出我选择的书单：</p>
<ul>
<li>《自控力 》：1-10周，每周按后面练习完成相关计划</li>
<li>《月亮和六便士》：1-10周，慢慢阅读</li>
<li>《写出我心：普通人如何通过写作表达自己》：1-2周阅读</li>
<li>《微习惯》：3-4周阅读</li>
<li>《哈弗虚拟写作课：怎样讲一个好故事》：5-6周阅读</li>
<li>《超级阅读术》：7-8周阅读</li>
</ul>
<p>预留两周时间，总结思考之前阅读的内容。</p>
<h3 id="写作计划"><a href="#写作计划" class="headerlink" title="写作计划"></a>写作计划</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-01-70天写作计划安排/2.png" alt=""></p>
<p>输出和输入同样重要，通常我们输入的目的就是为了更好的输出，而输出又可以反作用于输入，能够更好的总结自己创造新的价值。这边来说说个人的读写安排吧，参加这个集训营之前写过大半年的文章，最开始的设想是想要将去年准备写的一些文章给整理写完，去年一共大概有超过 80 篇文章，但真正整理写完的估计 1/2 都不到，之前个人写文一般都还是集中在自学学习和研究的计算机领域，因此文章的题材也多是技术类，这类文章的特点就是需要不断查找翻阅大量的资料，然后实验验证排查，最终将自己的理解总结出来。</p>
<h3 id="主要写作"><a href="#主要写作" class="headerlink" title="主要写作"></a>主要写作</h3><p>上面已经描述过，个人的状况，因此 70 的集训营个人读写会以补全之前的技术博客文章为主，涉及：编程，操作系统，软件安装，软件教程等等。</p>
<h3 id="辅助写作"><a href="#辅助写作" class="headerlink" title="辅助写作"></a>辅助写作</h3><p>辅助写作的文章题材可以各式各样，为了锻炼自己的写作能力，也会去尝试不同的题材，大致有：</p>
<ul>
<li>书籍读后感</li>
<li>电视，电影观后感</li>
<li>电子产品吐槽</li>
<li>当前一些实事的看法</li>
<li>过往学习经验的总结</li>
</ul>
<hr>
<h3 id="今日小结："><a href="#今日小结：" class="headerlink" title="今日小结："></a>今日小结：</h3><p>中途看了好几条微信消息，虽然今天完成文章较快不到 1h，但毕竟内容不多，这样的文章全神贯注，应该可以控制在半小时之内的，还有提高的空间。</p>
<p>写作时间：19:39-20:25</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）程序的内存分配方式 for c/c++]]></title>
      <url>http://noparkinghere.win/2017/03/01/2017/2017-03-01-%EF%BC%88%E8%BD%AC%EF%BC%89%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-for-c-c/</url>
      <content type="html"><![CDATA[<p>本篇文转载文章，博主只进行了简单的排版和少量的修改，可以查看<a href="http://lib.csdn.net/article/c/41000" target="_blank" rel="external">原文出处</a>，另外文章的内容仍然不是阐述的很清晰，关于 C 和内存的关系也查看过很多资料很多内容描述的都不太一样，暂时认为本文写的还算详细可取，因此转载过来。</p>
<h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><p>内存分配方式有三种：</p>
<ul>
<li>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</li>
<li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</li>
</ul>
<a id="more"></a>
<h3 id="程序的内存空间"><a href="#程序的内存空间" class="headerlink" title="程序的内存空间"></a>程序的内存空间</h3><p>一个程序将操作系统分配给其运行的内存块分为4个区域，下面为<strong>程序内存空间</strong>:</p>
<ul>
<li>代码区(code area)    </li>
<li>全局数据区(data area)</li>
<li>堆区(heap area)</li>
<li>栈区(stack area)</li>
</ul>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分:</p>
<ul>
<li>栈区（stack）：由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。</li>
<li>堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。</li>
<li>全局区（静态区）（static）：存放全局变量、静态数据、常量。程序结束后由系统释放。</li>
<li>文字常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放。</li>
<li>程序代码区：存放函数体（类成员函数和全局函数）的二进制代码。</li>
</ul>
<p>下面给出例子程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></div><div class="line">	<span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> b; <span class="comment">//栈</span></div><div class="line">	<span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈</span></div><div class="line">	<span class="keyword">char</span> *p2; <span class="comment">//栈</span></div><div class="line">	<span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456在常量区，p3在栈上。</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></div><div class="line">	p1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</div><div class="line">	p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</div><div class="line">	<span class="comment">//分配得来得和字节的区域就在堆区。</span></div><div class="line">	<span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="堆与栈的比较"><a href="#堆与栈的比较" class="headerlink" title="堆与栈的比较"></a>堆与栈的比较</h3><h4 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h4><ul>
<li>stack: 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间。</li>
<li>heap: 需要程序员自己申请，并指明大小，在C中malloc函数，C++中是new运算符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); p1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</div><div class="line">如p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</div><div class="line">但是注意p1、p2本身是在栈中的。</div></pre></td></tr></table></figure>
<h4 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h4><ul>
<li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li>
</ul>
<p>对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。</p>
<p>由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h4 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h4><ul>
<li>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。</li>
<li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li>
</ul>
<h4 id="申请效率的比较"><a href="#申请效率的比较" class="headerlink" title="申请效率的比较"></a>申请效率的比较</h4><ul>
<li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li>
<li>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</li>
</ul>
<p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是栈，而是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。</p>
<h4 id="堆和栈中的存储内容"><a href="#堆和栈中的存储内容" class="headerlink" title="堆和栈中的存储内容"></a>堆和栈中的存储内容</h4><ul>
<li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li>
<li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li>
</ul>
<h4 id="存取效率的比较"><a href="#存取效率的比较" class="headerlink" title="存取效率的比较"></a>存取效率的比较</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char <span class="built_in">s1</span>[] = <span class="string">"a"</span><span class="comment">;</span></div><div class="line">char *<span class="built_in">s2</span> = <span class="string">"b"</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<p>a是在运行时刻赋值的；而b是在编译时就确定的；但是，在以后的存取中，<strong>在栈上的数组比指针所指向的字符串(例如堆)快。</strong> 比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> a = <span class="number">1</span>;</div><div class="line">	<span class="keyword">char</span> c[] = <span class="string">"1234567890"</span>;</div><div class="line">	<span class="keyword">char</span> *p =<span class="string">"1234567890"</span>;</div><div class="line">	a = c[<span class="number">1</span>];</div><div class="line">	a = p[<span class="number">1</span>];</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的汇编代码:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>: a = c[<span class="number">1</span>];</div><div class="line"><span class="symbol">00401067 </span><span class="number">8</span>A <span class="number">4D</span> F1 mov cl,byte ptr [ebp-<span class="number">0</span>Fh]</div><div class="line"><span class="number">0040106</span>A <span class="number">88</span> <span class="number">4D</span> FC mov byte ptr [ebp-<span class="number">4</span>],cl</div><div class="line"><span class="number">11</span>: a = p[<span class="number">1</span>];</div><div class="line"><span class="number">0040106D</span> <span class="number">8</span>B <span class="number">55</span> EC mov edx,dword ptr [ebp-<span class="number">14</span>h]</div><div class="line"><span class="symbol">00401070 </span><span class="number">8</span>A <span class="number">42</span> <span class="number">01</span> mov al,byte ptr [edx+<span class="number">1</span>]</div><div class="line"><span class="symbol">00401073 </span><span class="number">88</span> <span class="number">45</span> FC mov byte ptr [ebp-<span class="number">4</span>],al</div></pre></td></tr></table></figure></p>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>堆和栈的主要区别有以下几点：</p>
<ul>
<li>管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</li>
<li>空间大小不同：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。</li>
<li>碎片问题不同：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。</li>
<li>生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</li>
<li>分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li>
<li>分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</li>
</ul>
<p>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址， EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p>
<p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。</p>
<h3 id="new-delete与malloc-free比较"><a href="#new-delete与malloc-free比较" class="headerlink" title="new/delete与malloc/free比较"></a>new/delete与malloc/free比较</h3><p>从C++角度上说，使用new分配堆空间可以调用类的构造函数，而malloc()函数仅仅是一个函数调用，它不会调用构造函数，它所接受的参数是一个unsigned long类型。同样，delete在释放堆空间之前会调用析构函数，而free函数则不会。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="built_in">Time</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="built_in">Time</span>(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">string</span>);</div><div class="line">		~<span class="built_in">Time</span>()</div><div class="line">		&#123;</div><div class="line">			cout&lt;&lt;<span class="string">"call Time's destructor by:"</span>&lt;&lt;name&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">	　　<span class="built_in">int</span> <span class="built_in">hour</span>;</div><div class="line">	　　<span class="built_in">int</span> min;</div><div class="line">	　　<span class="built_in">int</span> sec;</div><div class="line">	　　<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Time</span>::<span class="built_in">Time</span>(<span class="built_in">int</span> h,<span class="built_in">int</span> m,<span class="built_in">int</span> s,<span class="built_in">string</span> n)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">hour</span>=h;</div><div class="line">	min=m;</div><div class="line">	sec=s;</div><div class="line">	name=n;</div><div class="line">	cout&lt;&lt;<span class="string">"call Time's constructor by:"</span>&lt;&lt;name&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="built_in">Time</span> *t1;</div><div class="line">	t1=(<span class="built_in">Time</span>*)malloc(sizeof(<span class="built_in">Time</span>));</div><div class="line">	free(t1);</div><div class="line">	<span class="built_in">Time</span> *t2;</div><div class="line">	t2=<span class="keyword">new</span> <span class="built_in">Time</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">"t2"</span>);</div><div class="line">	delete t2;</div><div class="line">	system(<span class="string">"PAUSE"</span>);</div><div class="line">	return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　call Time<span class="string">'s constructor by:t2</span></div><div class="line">　　call Time's <span class="function"><span class="keyword">destructor</span> <span class="title">by</span>:</span>t2</div></pre></td></tr></table></figure></p>
<p>从结果可以看出，使用new/delete可以调用对象的构造函数与析构函数，并且示例中调用的是一个非默认构造函数。但在堆上分配对象数组时，只能调用默认构造函数，不能调用其他任何构造函数。</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/u010070526/article/details/41748043" target="_blank" rel="external">http://blog.csdn.net/u010070526/article/details/41748043</a><br><a href="http://lib.csdn.net/article/c/41000" target="_blank" rel="external">http://lib.csdn.net/article/c/41000</a><br><a href="http://blog.csdn.net/wellhead/article/details/4506180" target="_blank" rel="external">http://blog.csdn.net/wellhead/article/details/4506180</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[wget下载整个网站]]></title>
      <url>http://noparkinghere.win/2017/03/01/2017/2017-03-01-wget%E4%B8%8B%E8%BD%BD%E6%95%B4%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>当我们看到一个优秀的网站，但上网却不是太方便的时候，往往将网页保存下来，然后离线浏览是最佳选择，但是对于一些教程，因为目录下的文章较多，有的动辄上百篇文章，无疑一个个保存网页肯定效率低下不现实。这边我们推荐使用 wget 这个工具来获取保存整个网站/目录下的内容。</p>
<p>需要下载某个目录下面的所有文件。命令如下</p>
<p><code>wget -c -r -np -k -L -p www.xxx.org/pub/path/</code></p>
<p>在下载时。有用到外部域名的图片或连接。如果需要同时下载就要用-H参数。</p>
<p>例如： <code>wget -c -r -np -k -L -p http://akaedu.github.io/book/</code></p>
<a id="more"></a>
<p>或者也可以使用如下方式：</p>
<p>wget –no-check-certificate –recursive –no-clobber –domains website.org –no-parent www.website.org/xxx</p>
<p>–recursive 现在整个网站</p>
<p>–domains 指定下载的域，将不会下载其它域的文件</p>
<p>​–no-parent 不下载父链接的内容，很重要，能减少不必要的循环</p>
<p>–no-clobber 不重复下载一个文件​</p>
<p>​–no-check-certificate 不检查网站认证信息</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.sina.com.cn/s/blog_4ddef8f80102vtq2.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4ddef8f80102vtq2.html</a><br><a href="http://www.cnblogs.com/lidp/archive/2010/03/02/1696447.html" target="_blank" rel="external">http://www.cnblogs.com/lidp/archive/2010/03/02/1696447.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力学习日计划表]]></title>
      <url>http://noparkinghere.win/2017/02/28/2017/2017-02-28-%E8%87%AA%E6%8E%A7%E5%8A%9B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%A1%E5%88%92%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="70-天工作日计划表："><a href="#70-天工作日计划表：" class="headerlink" title="70 天工作日计划表："></a>70 天工作日计划表：</h3><ul>
<li>6:50左右 前起床</li>
<li>7:00-7:30 出门，散步，买早餐</li>
<li>7:30-8:00 扇贝单词，高效率 0.5h 完成，其他扇贝任务日碎片时间中完成。</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-17:20 在线英语学习</li>
<li>17:20-18:00/18:20 阅读推荐书籍</li>
<li>18:00/18:20-19:00 晚餐、散步时间</li>
<li>19:00-20:30 完成相关写作内容</li>
<li>20:30-21:00 运动时间</li>
<li>21:00-21:15 洗漱</li>
<li>21:15-22:45 自我学习时间，完成相应学习计划</li>
<li>22:45-23:15 休息娱乐，看一集美剧或动漫</li>
<li>23:20之前 入睡</li>
</ul>
<p>10 周阅读 6本书籍，&lt;自控力&gt;按章节计划内容执行，其他书籍两周阅读一本。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-02-28-自控力学习日计划表/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h3><p><em>以上内容，当然对于现在的我来说是不可能完成的，否则的话，我应该已经算是一个高自控力的达人了，上述内容算是 70 天的一个目标，计划是 8-9 周可以达成该目标，最后一周可以确切的执行该目标。</em></p>
<ul>
<li>07:50左右 前起床</li>
<li>08:00-08:15 吃早饭，去公司</li>
<li>08:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-17:20 在线英语学习</li>
<li>18:00-19:30 晚餐、散步和休息时间</li>
<li>19:30-22:30 学习或者娱乐</li>
<li>22:30-23:59 扇贝英语</li>
<li>00:30左右 入睡</li>
</ul>
<p>目前基本上可以保证英语的学习时间，其他时间不能固定，因为工作等原因，个人极度缺乏锻炼，因此后续锻炼身体将会作为重点提高项目。</p>
<h3 id="拟定计划"><a href="#拟定计划" class="headerlink" title="拟定计划"></a>拟定计划</h3><p>经过分析，暂时会分为 5 个阶梯步骤来完成，其中每两周作为一个阶段，循序渐进的接近最终的目标，涉及范围：作息，运动，自学，英语。</p>
<h4 id="第一阶段（02-28-03-05）"><a href="#第一阶段（02-28-03-05）" class="headerlink" title="第一阶段（02.28-03.05）"></a>第一阶段（02.28-03.05）</h4><ul>
<li>更改作息时间：7:30左右起床，23:50之前入睡</li>
<li>早晨完成部分英语单词的学习，剩余内容晚上完成</li>
<li>每天锻炼半小时</li>
<li>傍晚阅读推荐书籍半小时以上</li>
<li>每天一篇文章</li>
<li>其余时间暂时不做限定</li>
</ul>
<p>完成情况：作息时间未能按计划完成，每天完成了一组 seven 运动，阅读时间基本上满足要求，每天完成了一篇写作。</p>
<p>小结：仍然需要很多进行改进，但第一周作为摸索阶段，要求不宜过高。</p>
<h4 id="第二阶段（03-05-03-19）"><a href="#第二阶段（03-05-03-19）" class="headerlink" title="第二阶段（03.05-03.19）"></a>第二阶段（03.05-03.19）</h4><ul>
<li>修改作息时间，7:30左右起床</li>
<li>早晨完成一组 seven </li>
<li>17:00-18:20 上英语课和阅读</li>
<li>两个小时的学习时间</li>
<li>晚上 9:30 前完成 写作计划</li>
<li>完成当日写作内容</li>
<li>23:30左右入睡</li>
</ul>
<hr>
<p>待定…</p>
<h3 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h3><p>为了达成计划，需要不断的完善自己，充分利用各种技巧。</p>
<hr>
<p>写作时间：7:30-8:20，9:30-10:00，总时长超过一个半小时。<br>写作同时忙别的，不够专注，需要改正。</p>
<p>未完待续…</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何更好地用简书写作]]></title>
      <url>http://noparkinghere.win/2017/02/27/2017/2017-02-27-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%94%A8%E7%AE%80%E4%B9%A6%E5%86%99%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>出于个人想提高个人写作技巧和培养写作习惯的目的，所以加入了<strong>自控力lab</strong>的小组 70 天的计划。虽然在简书上面已经混迹多日，但却没能发现一个简书阅读写作的说明书。在加入这个写作计划前，个人开通了博客，且部分文章也发在了简书这个平台上面了。基于上述原因，个人准备写一个简书的写作使用说明，以供各位简书新人参考。</p>
<p><em>推荐各位如果有条件的话，最好采用网页版编辑文字，效率高，体验佳。</em></p>
<h3 id="Markdown-带来优质的写作体验"><a href="#Markdown-带来优质的写作体验" class="headerlink" title="Markdown 带来优质的写作体验"></a>Markdown 带来优质的写作体验</h3><p>之所以使用简书这个平台，很大一部分原因是简书拥有其他博客所不具备的良好的阅读和写作体验。简书之所以能够带来良好的写作体验是因为支持目前十分流行的 Markdown 语法。</p>
<p>默认简书使用的是富文本编辑方式，这种方式的特点是能够类似于 word 之类的软件，生成很多花哨的内容，但是书写起来极为复杂，如：<code>{\[rtf](http://baike.baidu.com/view/18817.htm)1\ansi\ansicpg936\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fmodern\fprq6\fcharset134 \&#39;cb\&#39;ce\&#39;cc\&#39;e5;}}{\*\generator Msftedit 5.41.21.2500;}\viewkind4\uc1\pard\lang2052\f0\fs20 Hello World!\par}</code> 很显然这样的书写方式一般只能借助工具进行排版，但是 Markdown解决了这样的问题。</p>
<p>Markdown 的优点就是文章所有排版都通过文字符号来完成，且一学就会，只要有一个 Markdown 解析器，就可以达到你的排版效果，跨平台，易移植，不需要依赖 word 等排版工具，同时 Markdown 写出来的文章也可以通过一些转换工具，直接转成 PDF 文档。</p>
<p>听起来 Markdown 好像很高端，但确实非常简单易学，这边再提供一个<a href="http://www.zealer.com/post/725.html" target="_blank" rel="external">Markdown体验视频</a>，视频仅供娱乐参考，介绍的不系统不详细，下面将会详细介绍下 Markdown 语法。为了让大伙儿学起来不困难，这边只会挑常用的一些语法进行陈述。</p>
<p>简书默认是上述提及的富文本编辑方式，如果使用 Markdown 语法的话，需要先设置下，在个人页面基础设置中选用 Markdown 即可，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img//2017-02-27-如何更好地用简书写作/1.png" alt="设置"></p>
<a id="more"></a>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>Markdown 通过 <code>#</code> 来表示标题的等级，具体如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line"></div><div class="line">## 二级标题</div><div class="line"></div><div class="line">### 三级标题</div><div class="line"></div><div class="line">。。。。。。</div></pre></td></tr></table></figure>
<p>这边建议大家从三级标题开始沿用，一级标题就是你文章的题目，已经被文章所占用，二级标题和一级标题样式大小区分不是太明显，且多个平台上面二级标题都会过大，产生一种很奇怪的布局效果。</p>
<h4 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h4><p>通过使用 <code>**加粗**</code> 这种样式，可以将一个一段文字进行加粗设置，学会了这个，你再也不需要每次选中文字，然后点工具栏的加粗工具了。</p>
<h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>有粗体的样式，自然就有斜体，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法，如：<code>*斜体*</code></p>
<p><strong>以上粗体和斜体，需要注意 <code>*</code> 前后切勿加入空格，否则可能会无法转换格式。</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>在 Markdown 下，列表的显示只需要在文字前加上 - 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。<strong>注意：一定要加空格。</strong></p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>现在码字写文章，一般都讲究图文并茂的书写，一个好的图片往往才是吸引别人点开你文章的要素，markdown 当然也具备载入图片的功能啦！具体格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">图片</span>](<span class="link">http://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png</span>)</div></pre></td></tr></table></figure>
<p>很长的一段是不是很吓人？其实就分三部分：</p>
<ul>
<li><code>!</code> 代表这边引用的是图片</li>
<li><code>[]</code> 中代表的是图片的名称，可以不填</li>
<li><code>()</code> 中才是真正图片的链接地址</li>
</ul>
<p>所以就是这种格式： <code>![](网上链接)</code>。</p>
<p>简书有个很好的特点就是，你所使用的外链图片在文章发表后会转存为简书的图片，能够完全不影响阅读体验，同时，你的文章再次编辑或者打包下载时，里面的外链原始地址不会更改。</p>
<p><em>以下为扩展内容，一般写作的话不一定用的上，不需要详细了解：</em></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>注意用 <code>|</code> 分隔符号隔开，<code>|</code> 前后可以加入或不加入空格，<code>-</code> 个数不限，第二行的内容不能少，下面是具体案例语法格式：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">学号 |<span class="string"> 姓名 </span>|<span class="string"> 分数</span></div><div class="line">- |<span class="string"> - </span>|<span class="string"> -</span></div><div class="line">小明 |<span class="string"> 男 </span>|<span class="string"> 75</span></div><div class="line">小红 |<span class="string"> 女 </span>|<span class="string"> 79</span></div><div class="line">小陆 |<span class="string"> 男 </span>|<span class="string"> 92</span></div></pre></td></tr></table></figure>
<p>实际呈现效果如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>分割线的语法只需要另起一行，连续输入三个星号 <em>*</em> 即可。</p>
<h4 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h4><p>插入链接与插入图片的语法很像，区别在一个 <code>!</code> 号，格式为：<code>[文字](网上链接)</code>。</p>
<h4 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h4><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 <code>把中间的代码包裹起来，如</code>code`，你可以使用 `` 将包括内容，特殊内容就不会自动转换格式了。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>如果你需要引用一小段别处的句子，那么就要用引用的格式：<code>&gt; 例如这样</code></p>
<p><code>只需要在文本前加入 &gt; 这种尖括号（大于号）即可。</code></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当然简书也并非尽善尽美，在 Markdown 的体验效果上面还是存在不少的缺陷的，比如：</p>
<ul>
<li>书写时无法对的标记符进行高亮突出</li>
<li>无法自动补充你下一个符号如：引用，列表等</li>
<li>缺少一键生成格式的快捷键</li>
<li>预览无法与文章做到实时同步，预览内容过长需要手动去上下拖动，无法跟随同步。</li>
<li>Markdown 实际生成的页面显示布局虽然还算不错，但仍然可以进一步提高。</li>
</ul>
<p>因此如果你对 Markdown 很偏爱的话，可以使用第三方的编辑工具编辑后再粘贴到简书，或者期待简书下一个版本的更新。多说无意，这边直接给出本文原稿的下载链接，有兴趣的朋友可以直接下载<a href="https://raw.githubusercontent.com/noparkinghere/blog.github.io/master/source/_posts/2017/2017-02-27-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%94%A8%E7%AE%80%E4%B9%A6%E5%86%99%E4%BD%9C.md" target="_blank" rel="external">本文原稿</a>，然后复制到简书的编辑器中预览编辑查看效果。</p>
<h3 id="分屏预览技巧"><a href="#分屏预览技巧" class="headerlink" title="分屏预览技巧"></a>分屏预览技巧</h3><p>码字时，通过点击简书右上角的一个预览按钮，即可完成分配预览，如下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-02-27-如何更好地用简书写作/2.png" alt=""></p>
<h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>不久前，也就是 2017 年开始，简书的经过了大改版，在原有体验的基础上面，增加了夜间模式，具体操作如下：点击你简书页面右上角的 Aa 图标（头像左边），点击第一个选项就可以设置为夜间模式。</p>
<h3 id="博客文章迁移"><a href="#博客文章迁移" class="headerlink" title="博客文章迁移"></a>博客文章迁移</h3><p>很多时候博客类网站由于经营不善等原因，都存在一定的可能面临关闭或者倒闭，知名案例请问<strong>度娘</strong>。简书的所提供的方式，是目前为止，我所见到的最简洁人性化的解决方案，<code>点击头像-&gt;设置-&gt;账号管理-&gt;打包下载文章</code> 。下载后文章是一个压缩文件，里面所有的内容，就是你码字的内容，如果你采用的是 markdown 语法，你们你可以讲文章直接上传到任何支持 markdown 语法的网站，即可完成博客迁移，无需进行重新排版等操作。</p>
<hr>
<p>以上内容，主要适合于初次接触简书的用户码字，对于简书的老司机来说应该已经算是家常便饭了吧。看完全文，如有不明白的话，可以参考最下方的教程链接，也可以私信我或者加我微信号（见我个人空间的微信二维码）。</p>
<p>统计写作初稿时间：8:30pm-10:30pm 时间消耗较长，写作能力急需提高。</p>
<blockquote>
<p>参考资料：<br><a href="http://sspai.com/25137" target="_blank" rel="external">http://sspai.com/25137</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[按键防抖]]></title>
      <url>http://noparkinghere.win/2017/02/21/2017/2017-02-21-%E6%8C%89%E9%94%AE%E9%98%B2%E6%8A%96/</url>
      <content type="html"><![CDATA[<p><em>目前市面上按键繁多，有传统的机械按键也有目前比较流行的电容式触摸按键，这边所讨论的按键是传统使用的机械按键，并非新型的触摸电容按键。</em></p>
<p>通常按键所用的开关都是机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上就稳定的接通，在断开时也不会一下子彻底断开，而是在闭合和断开的瞬间伴随了一连串的抖动，如下图所示：</p>
<blockquote>
<p>参考链接：<br><a href="http://c.biancheng.net/cpp/html/1901.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/1901.html</a><br><a href="http://www.amobbs.com/thread-543529-1-1.html" target="_blank" rel="external">http://www.amobbs.com/thread-543529-1-1.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[linux-shadowsocks全局代理]]></title>
      <url>http://noparkinghere.win/2017/01/25/2017/2017-01-25-ss-linux%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>windows 直接下载 ss 终端，稍加设置即可完成全局代理，linux 用户如果需要让某个软件可以使用 ss 一般都需要连接端口才行。例如本地 ss 配置为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"server_port"</span>:1800,</div><div class="line"><span class="string">"local_port"</span>:1080,</div></pre></td></tr></table></figure></p>
<h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><p>这边就相当于将本地的 127.0.0.1:1080 和 server_ip:1800 建立了连接关系。因此软件如果需要使用 vps 上面搭建的 ss 服务的话，则需要让该软件使用的协议连接到 127.0.0.1:1080 上。之前在 vps-shadowsocks 中介绍的 chrome 插件 SwitchyOmega 就是使用 SOCKS5 协议连接到 127.0.0.1:1080 上，让所有数据通过 SOCKS5 协议，然后从 127.0.0.1:1080 进行收发。</p>
<p>可以看出如果我们需要让其他软件也能够使用 ss 则需要让他们也能够使用 127.0.0.1:1080 代理服务器，然而不幸的是，大多数软件并不支持代理服务的功能， windows 平台下的软件很多可以通过设置 IE 代理让其他软件使用代理服务（原理是：大多数软件都会优先读取 IE 的代理设置，再访问网络）。</p>
<a id="more"></a>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>linux 下有个软件： proxychains 解决了我们的所有问题，该软件可以通过 <code>sudo apt-get install proxychains</code> 下载安装，一般为 3.1 版本。当然也可以去下载安装<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">源码</a>，源码安装版本较新，需要自行编译安装，一般为 4.x 版本。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>man proxychains 我们可以看到 proxychains 读取的配置文件地址，这边我们自定义 ~/.proxychains/proxychains.conf 文件，写入如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">ins.conf  VER 3.1</div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.</span></div><div class="line"><span class="comment">#   </span></div><div class="line"></div><div class="line"><span class="comment"># The option below identifies how the ProxyList is treated.</span></div><div class="line"><span class="comment"># only one option should be uncommented at time,</span></div><div class="line"><span class="comment"># otherwise the last appearing option will be accepted</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#dynamic_chain</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Dynamic - Each connection will be done via chained proxies</span></div><div class="line"><span class="comment"># all proxies chained in the order as they appear in the list</span></div><div class="line"><span class="comment"># at least one proxy must be online to play in chain</span></div><div class="line"><span class="comment"># (dead proxies are skipped)</span></div><div class="line"><span class="comment"># otherwise EINTR is returned to the app</span></div><div class="line"><span class="comment">#</span></div><div class="line">strict_chain</div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Strict - Each connection will be done via chained proxies</span></div><div class="line"><span class="comment"># all proxies chained in the order as they appear in the list</span></div><div class="line"><span class="comment"># all proxies must be online to play in chain</span></div><div class="line"><span class="comment"># otherwise EINTR is returned to the app</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#random_chain</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Random - Each connection will be done via random proxy</span></div><div class="line"><span class="comment"># (or proxy chain, see  chain_len) from the list.</span></div><div class="line"><span class="comment"># this option is good to test your IDS :)</span></div><div class="line"></div><div class="line"><span class="comment"># Make sense only if random_chain</span></div><div class="line"><span class="comment">#chain_len = 2</span></div><div class="line"></div><div class="line"><span class="comment"># Quiet mode (no output from library)</span></div><div class="line"><span class="comment">#quiet_mode</span></div><div class="line"></div><div class="line"><span class="comment"># Proxy DNS requests - no leak for DNS data</span></div><div class="line">proxy_dns </div><div class="line"></div><div class="line"><span class="comment"># Some timeouts in milliseconds</span></div><div class="line">tcp_read_time_out 15000</div><div class="line">tcp_connect_time_out 8000</div><div class="line"></div><div class="line"><span class="comment"># ProxyList format</span></div><div class="line"><span class="comment">#       type  host  port [user pass]</span></div><div class="line"><span class="comment">#       (values separated by 'tab' or 'blank')</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#        Examples:</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#               socks5192.168.67.781080lamersecret</span></div><div class="line"><span class="comment">#       http192.168.89.38080justuhidden</span></div><div class="line"><span class="comment">#       socks4192.168.1.491080</span></div><div class="line"><span class="comment">#           http192.168.39.938080</span></div><div class="line"><span class="comment">#       </span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#       proxy types: http, socks4, socks5</span></div><div class="line"><span class="comment">#        ( auth types supported: "basic"-http  "user/pass"-socks  )</span></div><div class="line"><span class="comment">#</span></div><div class="line">[ProxyList]</div><div class="line"><span class="comment"># add proxy here ...</span></div><div class="line"><span class="comment"># meanwile</span></div><div class="line"><span class="comment"># defaults set to "tor"</span></div><div class="line">socks5 127.0.0.1 1080</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>输入 <code>proxychains curl www.google.com</code> 命令，我们可以看到提示内容，如果一直等待或者无法访问则代表设置失败。这是一种方法通过 proxychains + 命令。</li>
</ul>
<p><strong>这边值得注意的是使用 <code>proxychains curl www.google.com</code> 命令，博主一开始使用的是  <code>proxychains ping www.google.com</code> 一直无法 ping 通，也一致认为自己配置的有问题，后来才发现： ping 命令本身不调用 http ，socks5 等协议，ping也属于一个通信协议，是 TCP/IP 协议的一部分。而诸如：  http ，socks5，ssh 等都是基于 TCP/IP 或者 UPD 之上的协议，所以验证的时候一定要当心注意了使用其他调用 socks5 协议的软件才可以验证。</strong></p>
<ul>
<li>输入 <code>proxychains bash</code> 我们可以建立一个新的 shell 基于这个 shell 运行的所有命令和软件都会通过 <code>127.0.0.1:1080</code> 转发数据。</li>
</ul>
<p><strong>通过 proxychains 打开的软件，在使用时都会有详细的网络连接信息。</strong></p>
<p>补充一个问题：如果使用时出现 <code>ERROR: ld.so: object &#39;libproxychains.so.3&#39; from LD_PRELOAD cannot be preloaded: ignored.</code> 原因是无法找到 libproxychains.so.3 文件，可以通过 <code>find /usr/lib/ -name libproxychains.so.3</code> 找到具体路径，然后 <code>export LD_PRELOAD=你找到的路径</code> 。</p>
<h3 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h3><p>基于 <code>proxychains bash</code> 开启的所有软件都可以通过 ss 来访问外网，而这个 terminal 可以相当于是全局代理的，当然如果你需要设置整个系统都全局代理的话，应该也是可以修改 linux 下面的源码的，让密码认证通过后，启用的 login-bash 采用 proxychains 方式启用。这边未做详细研究，理论上可能可行。</p>
<hr>
<p><em>个人对网络研究很欠缺，如有错误还望指正。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.tuicool.com/articles/rUNFF3" target="_blank" rel="external">http://www.tuicool.com/articles/rUNFF3</a><br><a href="http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded" target="_blank" rel="external">http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded</a><br><a href="http://blog.csdn.net/yusiguyuan/article/details/24269129" target="_blank" rel="external">http://blog.csdn.net/yusiguyuan/article/details/24269129</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）中文技术文档的写作规范]]></title>
      <url>http://noparkinghere.win/2017/01/05/2017/2017-01-05-%EF%BC%88%E8%BD%AC%EF%BC%89%E4%B8%AD%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>这篇文章转自<a href="https://github.com/noparkinghere/document-style-guide" target="_blank" rel="external">阮一峰老师的 github 项目</a>，写博客也有一段时间了，也不断地修改格式排版等内容，但始终缺乏一个规范标准，直到看到这篇文章。文章中写的内容个人觉得大都算是在情在理，很适合像我这样用 markdown 写博客的人去遵循。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>标题分为四级。</p>
<ul>
<li>一级标题：文章的标题</li>
<li>二级标题：文章主要部分的大标题</li>
<li>三级标题：二级标题下面一级的小标题</li>
<li>四级标题：三级标题下面某一方面的小标题</li>
</ul>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul>
<li>一级标题下，不能直接出现三级标题。</li>
<li>标题要避免孤立编号（即同级标题只有一个）。</li>
<li>下级标题不重复上一级标题的内容。</li>
<li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li>
</ul>
<a id="more"></a>
<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h2 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h2><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：本文介绍如何快速启动Windows系统。</div><div class="line"></div><div class="line">正确：本文介绍如何快速启动 Windows 系统。</div></pre></td></tr></table></figure>
<p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">正确：<span class="number">2011</span>年<span class="number">5</span>月<span class="number">15</span>日，我订购了<span class="number">5</span>台笔记本电脑与<span class="number">10</span>台平板电脑。</div><div class="line"></div><div class="line">正确：<span class="number">2011</span> 年 <span class="number">5</span> 月 <span class="number">15</span> 日，我订购了 <span class="number">5</span> 台笔记本电脑与 <span class="number">10</span> 台平板电脑。</div></pre></td></tr></table></figure>
<p>半角的百分号，视同阿拉伯数字。</p>
<p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：一部容量为 <span class="number">16</span> GB 的智能手机</div><div class="line"></div><div class="line">正确：一部容量为 <span class="number">16</span>GB 的智能手机</div></pre></td></tr></table></figure>
<p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：他的电脑是 MacBook Air 。</div><div class="line"></div><div class="line">正确：他的电脑是 MacBook Air。</div></pre></td></tr></table></figure>
<h2 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h2><ul>
<li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li>
<li>尽量使用简单句和并列句，避免使用复合句。</li>
</ul>
<h2 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h2><p>尽量不使用被动语态，改为使用主动语态。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：假如此软件尚未被安装，</div><div class="line"></div><div class="line">正确：假如尚未安装这个软件，</div></pre></td></tr></table></figure>
<p>不使用非正式的语言风格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</div><div class="line"></div><div class="line">正确：无法参加本次活动，我深感遗憾。</div></pre></td></tr></table></figure>
<p>用对“的”、“地”、“得”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">她露出了开心的笑容。</div><div class="line">（形容词＋的＋名词）</div><div class="line"></div><div class="line">她开心地笑了。</div><div class="line">（副词＋地＋动词）</div><div class="line"></div><div class="line">她笑得很开心。</div><div class="line">（动词＋得＋副词）</div></pre></td></tr></table></figure>
<p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</div><div class="line"></div><div class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</div></pre></td></tr></table></figure>
<p>名词前不要使用过多的形式词。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</div><div class="line"></div><div class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</div></pre></td></tr></table></figure>
<p>单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</div><div class="line"></div><div class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</div></pre></td></tr></table></figure>
<p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：请确认没有接通装置的电源。</div><div class="line"></div><div class="line">正确：请确认装置的电源已关闭。</div></pre></td></tr></table></figure>
<p>避免使用双重否定句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：没有删除权限的用户，不能删除此文件。</div><div class="line"></div><div class="line">正确：用户必须拥有删除权限，才能删除此文件。</div></pre></td></tr></table></figure>
<h2 id="英文处理"><a href="#英文处理" class="headerlink" title="英文处理"></a>英文处理</h2><p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">英文：⋯information stored <span class="keyword">in</span> random <span class="keyword">access</span> memory (RAMs)⋯</div><div class="line"></div><div class="line">中文：……存储在随机存取存储器（RAM）里的信息……</div></pre></td></tr></table></figure>
<p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">U<span class="selector-class">.S</span><span class="selector-class">.A</span>.</div><div class="line">Apple, Inc.</div></pre></td></tr></table></figure>
<p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">英文：<span class="number">5</span> minutes later⋯</div><div class="line"></div><div class="line">中文：<span class="number">5</span> 分钟过去了⋯⋯</div></pre></td></tr></table></figure>
<p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">英文：<span class="keyword">He</span> published <span class="keyword">an</span> article entitled <span class="string">"The Future of the Aviation"</span>.</div><div class="line"></div><div class="line">中文：他发表了一篇名为《航空业的未来》的文章。</div></pre></td></tr></table></figure>
<p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</div></pre></td></tr></table></figure>
<p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">“American Association <span class="keyword">of</span> Physicists <span class="keyword">in</span> Medicine”（美国医学物理学家协会）是专有名词，需要大写。</div><div class="line"></div><div class="line">“online <span class="keyword">transaction</span> processing”（在线事务处理）不是专有名词，不应大写。</div></pre></td></tr></table></figure>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><ul>
<li>一个段落只能有一个主题，或一个中心句子。</li>
<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>
<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>
<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>
<li>段落之间使用一个空行隔开。</li>
<li>段落开头不要留出空白字符。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用第三方内容时，应注明出处。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">One <span class="keyword">man</span>’s constant <span class="keyword">is</span> another <span class="keyword">man</span>’s variable. — Alan Perlis</div></pre></td></tr></table></figure>
<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本文转载自 WikiQuote</div></pre></td></tr></table></figure>
<p>使用外部图片时，必须在图片下方或文末标明来源。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本文部分图片来自 Wikipedia</div></pre></td></tr></table></figure>
<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="半角数字"><a href="#半角数字" class="headerlink" title="半角数字"></a>半角数字</h2><p>数字一律使用半角形式，不得使用全角形式。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误： 这件商品的价格是１０００元。</div><div class="line"></div><div class="line">正确： 这件商品的价格是 <span class="number">1000</span> 元。</div></pre></td></tr></table></figure>
<h2 id="千分号"><a href="#千分号" class="headerlink" title="千分号"></a>千分号</h2><p>数值为千位以上，应添加千分号（半角逗号）。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XXX 公司的实收资本为 RMB1,<span class="number">258</span>,<span class="number">000</span>。</div></pre></td></tr></table></figure>
<p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p>
<p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p>
<h2 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h2><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$<span class="number">1</span>,<span class="number">000</span></div><div class="line"><span class="number">1</span>,<span class="number">000</span> 美元</div></pre></td></tr></table></figure>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p>
<p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正确：<span class="number">132</span>kg～<span class="number">234</span>kg</div><div class="line">错误：<span class="number">132</span>～<span class="number">234</span>kg</div><div class="line"></div><div class="line">正确：<span class="number">67</span>%～<span class="number">89</span>%</div><div class="line">错误：<span class="number">67</span>～<span class="number">89</span>%</div></pre></td></tr></table></figure>
<h2 id="变化程度的表示法"><a href="#变化程度的表示法" class="headerlink" title="变化程度的表示法"></a>变化程度的表示法</h2><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">增加到过去的两倍</div><div class="line">（过去为一，现在为二）</div><div class="line"></div><div class="line">增加了两倍</div><div class="line">（过去为一，现在为三）</div></pre></td></tr></table></figure>
<p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">降低到百分之八十</div><div class="line">（定额是一百，现在是八十）</div><div class="line"></div><div class="line">降低了百分之八十</div><div class="line">（原来是一百，现在是二十）</div></pre></td></tr></table></figure>
<p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>
<h1 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h1><h2 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h2><ul>
<li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li>
<li>如果整句为英文，则该句使用英文/半角标点。</li>
<li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li>
</ul>
<h2 id="句号"><a href="#句号" class="headerlink" title="句号"></a>句号</h2><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p>
<p>句子末尾用括号加注时，句号应在括号之外。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：关于文件的输出，请参照第 <span class="number">1.3</span> 节（见第 <span class="number">26</span> 页。）</div><div class="line"></div><div class="line">正确：关于文件的输出，请参照第 <span class="number">1.3</span> 节（见第 <span class="number">26</span> 页）。</div></pre></td></tr></table></figure>
<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><p>逗号<code>，</code>表示句子内部的一般性停顿。</p>
<p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>
<h2 id="顿号"><a href="#顿号" class="headerlink" title="顿号"></a>顿号</h2><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</div><div class="line"></div><div class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</div></pre></td></tr></table></figure>
<p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook <span class="keyword">and</span> other components.</div></pre></td></tr></table></figure>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</div></pre></td></tr></table></figure>
<p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</div></pre></td></tr></table></figure>
<h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</div></pre></td></tr></table></figure>
<h2 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h2><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</div></pre></td></tr></table></figure>
<p>表示时间时，应使用半角冒号（<code>:</code>）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：早上 8<span class="selector-pseudo">:00</span></div></pre></td></tr></table></figure>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>
<p>省略号不应与“等”这个词一起使用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</div><div class="line"></div><div class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</div><div class="line"></div><div class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</div></pre></td></tr></table></figure>
<h2 id="感叹号"><a href="#感叹号" class="headerlink" title="感叹号"></a>感叹号</h2><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p>
<p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>
<h2 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h2><p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</div></pre></td></tr></table></figure>
<h2 id="连接号"><a href="#连接号" class="headerlink" title="连接号"></a>连接号</h2><p>连接号用于连接两个类似的词。</p>
<p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>
<ul>
<li>两个名词的复合</li>
<li>图表编号</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">例句：氧化-还原反应</div><div class="line"></div><div class="line">例句：图 <span class="number">1</span><span class="number">-1</span></div></pre></td></tr></table></figure>
<p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>
<ul>
<li>数值范围（例如日期、时间或数字）</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：<span class="number">2009</span> 年～<span class="number">2011</span> 年</div></pre></td></tr></table></figure>
<p>注意，波浪连接号前后两个值都应该加上单位。</p>
<p>波浪连接号也可以用汉字“至”代替。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：周围温度：<span class="number">-20</span>°C 至 <span class="number">-10</span>°C</div></pre></td></tr></table></figure>
<h1 id="章节结构"><a href="#章节结构" class="headerlink" title="章节结构"></a>章节结构</h1><p>软件手册是一部完整的书，建议采用下面的结构。</p>
<ul>
<li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li>
<li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li>
<li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul>
<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>
<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>
<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>
</ul>
</li>
<li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li>
<li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件API的逐一介绍</li>
<li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li>
<li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul>
<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>
<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>
<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>
<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>
<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>
</ul>
</li>
</ul>
<p><strong>范例</strong></p>
<ul>
<li><a href="http://redux.js.org/index.html" target="_blank" rel="external">Redux 手册</a></li>
<li><a href="http://flight-manual.atom.io/" target="_blank" rel="external">Atom 手册</a></li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p><a href="http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html" target="_blank" rel="external">产品手册中文写作规范</a>, by 华为<br><a href="http://docs.daocloud.io/write-docs/format" target="_blank" rel="external">写作规范和格式规范</a>, by DaoCloud<br><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf" target="_blank" rel="external">技术写作技巧在日汉翻译中的应用</a>, by 刘方<br><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf" target="_blank" rel="external">简体中文规范指南</a>，by lengoo<br><a href="https://open.leancloud.cn/copywriting-style-guide.html" target="_blank" rel="external">文档风格指南</a>, by LeanCloud<br><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit" target="_blank" rel="external">豌豆荚文案风格指南</a>, by 豌豆荚<br><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="external">中文文案排版指北</a>，by sparanoid<br><a href="http://w3c.github.io/clreq/" target="_blank" rel="external">中文排版需求</a>，by W3C  </p>
</blockquote>
<hr>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[别了，2016；你好，2017]]></title>
      <url>http://noparkinghere.win/2017/01/01/2017/2017-01-01-%E5%88%AB%E4%BA%86%EF%BC%8C2016%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C2017/</url>
      <content type="html"><![CDATA[<p>这篇文章写的晚了，本来是想年前写得，结果一耽搁已经是2017了，过去得一年有太多值得说得，新的一年也有太多值得期待的，这篇文章中只会写有关学习工作上面的得失，个人生活不做涉及。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-01-01-别了，2016；你好，2017/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="别了，2016"><a href="#别了，2016" class="headerlink" title="别了，2016"></a>别了，2016</h3><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>2016 对我来说也算是一个特殊的年份，但其实细想起来所有的得失也基本都集中在了下半年，其中最值得一提的可以分为如下几点：</p>
<ul>
<li>首先是加入了 github 这个家庭，虽然是 15 年就注册了 github 但一直没有研究和使用过，且那时对 git 也不够熟悉了解，有大半年的时间都没能开采这座金矿。</li>
<li>放弃了玩了多年的游戏（LOL），这中间也是是非曲中良多，朋友同学的互相指责，让单纯的游戏最后都不欢而散，之后转型玩了一段时间 dota2 ，网速不是太好，加上更新有问题，后来也就不玩了。也许已经不再是个孩子，再者本身从事电脑工作，是时候和电脑游戏说再见了。不玩游戏后也确实节省出了很多时间，也完成了接下来绝大多数的一些工作内容。</li>
<li>在 github 上搭建了个人博客，建立博客本身并不是难事，阅读教程按部就班就可以了，但最大的收获还是切实得整理总结了一些有内容的文章，对于高中语文一直不及格的我来说，能够写博客也是怪不可思议的。</li>
<li>基本掌握了 git 的使用，且也用于个人的一些项目上了。有关 git ，个人觉得还是比较复杂抽象的，也可能原因在于起初学习时，没看到什么较好的教程，现在学会了，却发现最近出来了不少通俗易懂的教程。</li>
<li>对 EFM32 的芯片有了一定的研究认识，虽然过程是十分艰难的，但目前而言，已经可以写一些常规的驱动了。</li>
<li>学了两次 Python，只能说基本掌握了 Python 的思想和语法。</li>
<li>尝试并体验了多家云服务器，买了国外一个分拆的 VPS 服务，体验来说良好，通过虚拟机和 VPS 也学习并且尝试了多个服务的搭建，简单的搭建并不困难，但要运营管理好，对现阶段的我来说还是有相当一段距离的。</li>
<li>使用 shanbay 学习了快两年了，阅读英文文档和网站已经基本可以胜任。</li>
</ul>
<h4 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h4><ul>
<li>学了两次 Python，说来还是比较失败的，两次都因为各种原因中断了，应该来说还是缺少一个项目历练或者学习全面的学习计划，两次都是学到某一阶段，后面不知道该做啥了，然后又因为某些原因中断了一段时间。</li>
<li>学习方法差，效率低，很多计划未能够完成，python 的书籍，还有 linux-c 的一本书籍都未能完成阅读</li>
<li>网络文档看多了或者其他原因，不能/未能静下心好好的看看书，学习一些东西，光靠互联网，走了不少歪路。</li>
<li>上半年浪费时间过多，收获不显著，早点不玩游戏，可能会收获更多。</li>
<li>shanbay 单词荒废过多，一整年都没能静下心来真正拼写背诵单词，虽有提高但不大，主要在于学习不够专注，对自己不够狠。</li>
<li>周末利用率不高，对于技术从业者来说，提高基本上靠业余时间，但一般也仅仅能够利用晚上，且效率比较低，总的来说还是不够专注。</li>
<li>linux 虽然用了也蛮久了，但还是需要重新系统的学习一次，命令的使用，思想的建立都不够完善。</li>
<li>blog 未能好好装修，计划的 H5 没能研究学习完。</li>
</ul>
<h3 id="你好，2017"><a href="#你好，2017" class="headerlink" title="你好，2017"></a>你好，2017</h3><p>2016 在学习工作上面不算成功，有不少欠缺之处，最主要还是表现两点：1.在工作学习不够专注，效率低。 2.业余时间尤其是周末利用率不高。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[MCU中的HardFault_Handler问题]]></title>
      <url>http://noparkinghere.win/2016/12/28/2016/2016-12-28-mcu%E4%B8%AD%E7%9A%84hardfault-handler%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用的工具 KDE-5.11 在调试目标芯片 EFM32 时出现问题，起初是调试铁电驱动，但在单步仿真时到某一步总会不再响应，或者结束仿真时 PC 跳转到了 HardFault_Handler 异常。为了解决这个问题，于是不断地缩减代码，之后发现程序从 startup 开始执行时，一进入 main 函数就会不响应或者跳转到 HardFault_Handler 中，一度怀疑自己的硬件 CMSIS 移植有问题。为了解决这个问题，尝试了多个办法，包括并不仅仅限于更换调试工具，断点调试，评估板代替测试，重新移植底层代码，查看 RAM 占用，修改静态区全局变量占用大小等等。下面总结一些遇到 HardFault_Handler 异常的解决方法。</p>
<a id="more"></a>
<h3 id="HardFault-Handler-分析"><a href="#HardFault-Handler-分析" class="headerlink" title="HardFault_Handler 分析"></a>HardFault_Handler 分析</h3><p>一般 HardFault_Handler 错误是指 PC 指向了一个无法访问的位置，主要可以分为两种：</p>
<ul>
<li>内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。</li>
<li>堆栈溢出。增加堆栈的大小。</li>
</ul>
<p>仿真时，有时会出现 HardFault_Handler 这种错误，这种错误往往会涉及到一些编译运行时的深层次原理，但基本可以肯定的是一般都是 SP,LR,PC 这三个寄存器出了问题，下面介绍这三个寄存器：</p>
<ul>
<li><p>堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。</p>
</li>
<li><p>连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">（1）保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：</div><div class="line">            MOV PC, LR </div><div class="line">            BX LR</div><div class="line"></div><div class="line">	通常子程序这样写，保证了子程序中还可以调用子程序。</div><div class="line">             stmfd sp!, &#123;lr&#125;</div><div class="line">             ……</div><div class="line">             ldmfd sp!, &#123;pc&#125;</div><div class="line"></div><div class="line">（2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。</div></pre></td></tr></table></figure>
<ul>
<li>程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。</li>
</ul>
<p>需要研究到底寄存器、函数是如何跳转调用的，我们需要使用 KDE 中的两个仿真工具： Register 和 Call Stack+Locals。Register 中主要观察 SP,LR,PC 三个寄存器的数据，PC永远指向 CPU 正在执行工作的位置，LR 会保存你调用子函数之前的跳转地址，也就是说当子函数完成返回时，会回到 LR 值对应的地址继续执行下面的程序。我这边实验时，能够看出每次执行错误后， PC 会跳转到一个很大的错误地址。</p>
<h3 id="指针跑飞"><a href="#指针跑飞" class="headerlink" title="指针跑飞"></a>指针跑飞</h3><p>在 HardFault_Handler 中的 while(1) 设置断点，然后运行，给它触发 HardFault_Handler 的条件，然后到断点处之后，查看 watch 窗口中的 Call Stack+Locals，也就是堆栈以及局部变量，程序执行到哪一句发生的错误，以及当时各个压栈的函数的各个局部变量的值一目了然。一般而言最常出现的就是<strong>指针跑飞，数组越界</strong>，这两种其实可以看做一个情况，都是指针访问了无权限访问的空间，通过 Call Stack+Locals 窗口往往能够定位到该函数，然后可以采用单步执行，看到具体在哪一步触发了异常。</p>
<h3 id="RAM溢出"><a href="#RAM溢出" class="headerlink" title="RAM溢出"></a>RAM溢出</h3><p>这种情况也是我排查的一种情况，编译完成之后，全局变量已经占用了相应大小 RAM 中的静态存储区域，如果你的 MCU 本身不够大，例如我的只有 8K RAM空间，而 COM 的缓冲数组占用了过多的全局变量，这边就存在一定的可能 RAM 不够分配而越界。</p>
<h3 id="底层-CMSIS-问题"><a href="#底层-CMSIS-问题" class="headerlink" title="底层 CMSIS 问题"></a>底层 CMSIS 问题</h3><p>因为我的项目是在进入 main 函数一开始就出错了，所以为了排除是不是之前的跳转就有问题，所以重新移植 startup.s 文件</p>
<h3 id="Jlink"><a href="#Jlink" class="headerlink" title="Jlink"></a>Jlink</h3><p>不排除调试器存在缺陷，所以更换了调试器，将自己的程序移植到评估板上面运行，进一步验证，直接使用官方自带例程，在评估板上面运行。</p>
<h3 id="inline函数无法捕捉"><a href="#inline函数无法捕捉" class="headerlink" title="inline函数无法捕捉"></a>inline函数无法捕捉</h3><p>EFM32 芯片采用 JLINK V9 多次测试多款不同型号的芯片都无法单步执行，单步只能在 while(1) 中执行，一般从 startup 到 main 函数中就会发生错误，开始怀疑是调试工具的问题，通过增加断点部分解决了这个问题，经过评估板测试，查看 RAM 占用，静态区全局变量等查看不断排查，之后发现是共同规律是每次 inline 函数调用某一个普通函数时，单步执行到 return 时，无法找到真实的返回地址。</p>
<p>这边是我主要出现错误的情况，一般较为少见，根本原因在于 inline 函数是类似于宏定义，直接本地展开的，如果使用断点是无法捕捉到的，这边我的 inline 函数中又调用了一个普通函数，因为 inline 函数是原地展开，LR 没有载入它的地址，而每次普通函数在返回时，无法获取到 inline 函数的返回地址，然后就跳转了异常，这本身并不能算是一个问题，在 MCU 正常运行时不会产生任何影响，影响的仅是你的调试过程。另外我个人在调试 SPI 驱动时，因为也调用了固件库自带的 inline 函数，所以导致也没法单步执行这段程序。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然这边查出我的问题出现在内联函数上面，但是，以上的集中方法都可以作为常用排查 HardFault_Handler 异常的方法，且一般而言出现指针跑飞的可能性最高。</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/zyboy2000/article/details/7668331" target="_blank" rel="external">http://blog.csdn.net/zyboy2000/article/details/7668331</a><br><a href="http://www.51hei.com/bbs/dpj-39846-1.html" target="_blank" rel="external">http://www.51hei.com/bbs/dpj-39846-1.html</a><br><a href="http://blog.csdn.net/jimmy2013_1_1/article/details/9723461" target="_blank" rel="external">http://blog.csdn.net/jimmy2013_1_1/article/details/9723461</a><br><a href="http://blog.chinaunix.net/uid-26967414-id-3823606.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26967414-id-3823606.html</a><br><a href="http://blog.csdn.net/zhou1232006/article/details/6149548" target="_blank" rel="external">http://blog.csdn.net/zhou1232006/article/details/6149548</a><br><a href="http://blog.csdn.net/pony_maggie/article/details/5270501" target="_blank" rel="external">http://blog.csdn.net/pony_maggie/article/details/5270501</a><br><a href="http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view" target="_blank" rel="external">http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh 使用详解]]></title>
      <url>http://noparkinghere.win/2016/12/27/2016/2016-12-27-ssh-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[针对百度网盘限速的解决方案]]></title>
      <url>http://noparkinghere.win/2016/12/26/2016/2016-12-26-%E9%92%88%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>虽然百度这家公司在道德水准上面没下限（卖假药，开赌场等），大多数产品做的也都比较烂（界面丑，体验差），但在搜索引擎和网盘这两个领域，因为国内种种众所周知的原因，还是只能用这家的产品。面对百度网盘下载速度越来越慢，收费越来越高，服务越来越差等特点，本文主要介绍一些方法，让我们能够更快地下载百度网盘中的资源。参考自<a href="http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D" target="_blank" rel="external">文章</a> 主要的方法可以分为两种，破解版的百度云管家和直链下载。</p>
<a id="more"></a>
<h3 id="破解版百度云管家"><a href="#破解版百度云管家" class="headerlink" title="破解版百度云管家"></a>破解版百度云管家</h3><p>经常使用百度云的用户，无疑客户端是最佳的选择，破解版本的百度云管家是可以让你<strong>无限时的免费试用百度云管家</strong>。可以去<a href="http://www.52pojie.cn/" target="_blank" rel="external">吾爱破解</a>等论坛下载最新破解版本的百度云，但这边不推荐这种方法，主要原因是客户端破解版很容易失效。</p>
<h3 id="云直链下载"><a href="#云直链下载" class="headerlink" title="云直链下载"></a>云直链下载</h3><h4 id="网页嵌入脚本下载"><a href="#网页嵌入脚本下载" class="headerlink" title="网页嵌入脚本下载"></a>网页嵌入脚本下载</h4><ul>
<li>Chrome需要安装拓展 <a href="http://tampermonkey.net/" target="_blank" rel="external">Tampermonkey</a>，其他Chrome壳浏览器安装 Tampermonkey，在应用市场可以找到并下载安装。</li>
<li>打开<a href="https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B" target="_blank" rel="external">脚本地址</a>，并安装。</li>
<li>每次打开百度云资源后，脚本就会自动获取相关信息，加载，并可以获取直链了。</li>
</ul>
<p>但注意：将直连放到迅雷等软件中，下载速度依然很慢，时断时连，原因暂未明了，不排除我这边网络的问题。</p>
<h4 id="应用数据获取直链"><a href="#应用数据获取直链" class="headerlink" title="应用数据获取直链"></a>应用数据获取直链</h4><p>提供这种方法的应用较多，例如：<a href="http://bdbea3.duapp.com/baidu_pcs/index.php" target="_blank" rel="external">百度网盘直链系统V2.0</a>，授权打开后，会在百度云盘根目录下的我的应用数据中新建文件夹，讲需要下载的文件，放到该新增的文件夹中，直接下载可以获取直链，个人实验速度要稍微比上面的直链快些，但也仅有 600-700k 的样子，且也不适用于几个G的大文件，依然不是很满意。</p>
<p>百度云直连系统：<a href="http://www.139.sh/" target="_blank" rel="external">免费云存储-免费百度网盘直链平台-永久外链-139直链网盘</a>，同样也是一个直链系统，方法依然是将需要下载的文件放入我的应用数据文件夹中，然后打开该服务网址，就可以看到外链已经被解析出来了，直接复制下载即可。就我个人的网络网盘来说这个速度最快，使用 aria2 可以得到数兆每秒的下载速度，且大文件也没有问题。</p>
<hr>
<p>To be continued …</p>
<blockquote>
<p>参考链接：<br><a href="http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D" target="_blank" rel="external">http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D</a><br><a href="https://www.zhihu.com/question/28333225" target="_blank" rel="external">https://www.zhihu.com/question/28333225</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux 系统瘦身]]></title>
      <url>http://noparkinghere.win/2016/12/20/2016/2016-12-20-linux-%E7%B3%BB%E7%BB%9F%E7%98%A6%E8%BA%AB/</url>
      <content type="html"><![CDATA[<p>目前 PC 市场中，硬盘内存等硬件设备越来越廉价不值钱，所以很多人不再考虑删减系统清除无用文件等来节省更多的空间。然而，很多不同的应用对存储空间运行空间等依然十分敏感，本文主要针对是在个人使用的 VPS 上，如何使用更少的资源运行更多的服务。</p>
<p>系统以 ubuntu/debian 为例，作为 VPS 普通服务器的操作系统来使用，进行优化，删除不会经常使用的工具，保留一些个人认为有用的功能。</p>
<h3 id="清理下载的缓存包"><a href="#清理下载的缓存包" class="headerlink" title="清理下载的缓存包"></a>清理下载的缓存包</h3><p>在 Ubuntu 中通过 sudo apt-get install 安装软件时，其下载的包都缓存在 /var/cache/apt/archives/ 目录中。如果要清理掉这些已下载的缓存包，那么可以执行命令：<br><code>sudo apt-get autoclean</code> 和 <code>sudo apt-get clean</code> 。</p>
<a id="more"></a>
<h3 id="清理不再需要的包"><a href="#清理不再需要的包" class="headerlink" title="清理不再需要的包"></a>清理不再需要的包</h3><p>在 Ubuntu 系统中安装软件时，该软件的依赖通常也会自动安装上。那么，在删除该软件后，其依赖可能需要我们手动删除之。可以运行 sudo apt-get autoremove 命令来解决这个问题。</p>
<h3 id="清除-update-库"><a href="#清除-update-库" class="headerlink" title="清除 update 库"></a>清除 update 库</h3><p>清除 apt-get update 过程中所下载的软件库列表： <code>rm -rf /var/lib/apt/lists/*</code> 。但注意每次执行 apt-get update 后还会重新更新这些文件，因此在仍然需要安装软件的 VPS 上这个用处不大，但是如果服务器已经配置成功了，可以接连使用  <code>rm -rf /var/lib/apt/lists/* &amp;&amp;  apt-get autoclean &amp;&amp; apt-get autoremove</code> 来清除空间。</p>
<h3 id="清理无用的语言文件"><a href="#清理无用的语言文件" class="headerlink" title="清理无用的语言文件"></a>清理无用的语言文件</h3><p>Ubuntu 与其他 Linux 发行版一样，是一个支持多语言界面的系统。其实，对使用自己母语的我们来说，通常保留中文即可，也可以保留自己所需要使用的语言，如英文。其他的语言文件则没有必要保留。为了清理这些无用的语言文件，需要在 Ubuntu 系统中安装一个名为 localepurge 的小工具，apt-get install localepurge。执行 localepurge，软件会提示你如何操作，服务器端建议只保留 en, en_US, en_US.UTF-8 。该软件分为两种界面，一种是直接按空格选择需要保留的包，另外一种是输入包序号选择保留包。</p>
<h3 id="清理-build-essential"><a href="#清理-build-essential" class="headerlink" title="清理 build-essential"></a>清理 build-essential</h3><p>查看该软件包的依赖关系，可以看到以下内容：<br>$ apt-cache depends build-essential</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">build-essential</div><div class="line">|依赖: libc6-dev</div><div class="line">依赖: &lt;libc-dev&gt;</div><div class="line">libc6-dev</div><div class="line">依赖: gcc</div><div class="line">依赖: g++</div><div class="line">依赖: make</div><div class="line">依赖: dpkg-dev</div></pre></td></tr></table></figure>
<p>也就是说，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，需要安装该软件包就可以了， build-essential 里面包含了最常用的编译工具，编译程序有了这个软件包<br>它才知道头文件在哪，也才知道库函数在哪，还会下载其他依赖的软件包，最后才组成一个开发环境。</p>
<p>对于不开发 c/c++ 用的服务器来说，如果只是用安装包安装，不用源码编译的话，则可以卸载这个软件包。</p>
<h3 id="清除部分文档帮助文件"><a href="#清除部分文档帮助文件" class="headerlink" title="清除部分文档帮助文件"></a>清除部分文档帮助文件</h3><p>清除其中的一些帮助说明文档： <code>rm -rf /usr/share/{doc,man}</code> 。</p>
<h3 id="编辑器安装和卸载"><a href="#编辑器安装和卸载" class="headerlink" title="编辑器安装和卸载"></a>编辑器安装和卸载</h3><p>安装 vim，个人习惯只用 vim ，但 vim 的套件也会占用 20M 以上的空间，这边如果对编辑器没有特殊要求的可以安装使用 nano （约 2M 大小）。</p>
<blockquote>
<p>参考链接：<br><a href="https://zhidao.baidu.com/question/2051702708087103867.html" target="_blank" rel="external">https://zhidao.baidu.com/question/2051702708087103867.html</a><br><a href="http://www.cnblogs.com/dolphi/p/3622570.html" target="_blank" rel="external">http://www.cnblogs.com/dolphi/p/3622570.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS 简介]]></title>
      <url>http://noparkinghere.win/2016/12/19/2016/2016-12-19-vps-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>起初对云服务很好奇，完全不知所云，无从下手的感觉，但经过一段时间的摸索研究，也基本能够搭建一些自己想要的服务了，这边根据一些网络资料和自己的学习研究，对这阶段进行一个总结，希望对那些刚刚开始尝试搭建云服务的网友有所帮助。</p>
<h3 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h3><p>利用虚拟话技术在一台物理服务器上面创建多个相互隔离的虚拟化私有主机(“Virtual Private Server – VPS”)，可以看出原理和 PC 上面用虚拟机自己虚拟出来的系统并没有什么本质区别，只不过 VPS 是虚拟化之后放到网络上面使用的而已。对用户和应用程序来说，每个 VPS 平台的运行和管理都与一台独立主机完全相同，每个 VPS 均可以独立进行重启并且拥有 root 访问权限，用户，IP地址，内存，进程，文件，应用程序，系统函数库以及配置文件等。</p>
<p>目前一般 VPS 结构是这样的：最底层为 Host Hardware 硬件， 然后是 Host Operating System 宿主机/真实系统，再然后是真实系统上面运行的虚拟化软件，最后是虚拟机软件内部运行的操作系统 Guest OS 访客系统（这边看上去和我们个人电脑 PC 上面跑的虚拟机中的虚拟操作系统并没啥区别）。</p>
<p>随着云技术的不断成熟，现在的 VPS 也有了很大的改进，例如国内的腾讯，阿里等都给自己的 VPS 起了新名字，什么弹性云服务，无虚拟机，云服务器等等，从用户角度来看和 VPS 没有区别，但技术层面一般现在都会将 Host Hardware 硬件通过集群技术搭建，几百上千台主机共建一个硬件平台，然后分配资源建立 VPS，这边一般可以看作是 cloud VPS，可以做到弹性扩展，无缝对接，无需在需要时再去更新硬件资源。</p>
<p>能够使用 linux VPS 完成的优先使用 linux。</p>
<p>这边如果对 VPS 服务器等还有疑惑可以参考本博客的另外一篇文章<strong>虚拟主机、VPS和云主机</strong>。</p>
<a id="more"></a>
<h4 id="桌面用户："><a href="#桌面用户：" class="headerlink" title="桌面用户："></a>桌面用户：</h4><p>vmware，virtualbox，virutalPC等，vmware，virtualbox都是支持多个操作系统的跨平台软件功能强大，用的也比较多。</p>
<h4 id="服务器用户："><a href="#服务器用户：" class="headerlink" title="服务器用户："></a>服务器用户：</h4><ul>
<li>Hyper-V：微软自带的虚拟化技术，只能在 windows 上运行，买 windows vps 很可能是 Hype-V 虚拟的</li>
<li>vmware：专业做虚拟话技术的公司，产品覆盖很广，个人企业都有，功能强大，可运行在各个平台，虚拟出各种操作系统。</li>
<li>OpenVZ：很老的一款软件，只能运行在 linux 上，也只能虚拟出 linux 操作系统，国内很多在拆分的时候没有很好的维护以及滥用超售，不能运行需要编译内核的应用。</li>
<li>Xen：版虚拟化技术，性能有一定损失，可以升级内核等</li>
<li>KVM：最近两年刚流行的，是一个开源系统虚拟化模块，KVM 目前已经成为学术界主流的虚拟机监控器之一，目前因为硬件虚拟化技术等都比较成熟，KVM 性能优势等相当明显。</li>
</ul>
<p>对于 VPS 的免费软件选择： KVM &gt; XEN &gt; OpenVZ。</p>
<h4 id="用途分析："><a href="#用途分析：" class="headerlink" title="用途分析："></a>用途分析：</h4><ul>
<li>搭建网站平台</li>
<li>不熟企业信息化系统，中小型企业不存在机房，使用 VPS 会节约成本。</li>
<li>挂 PT 数据传输分享</li>
<li>加密数据访问，科学上网</li>
<li>多人协作开发，代码托管</li>
<li>私有云存储空间</li>
<li>等等</li>
</ul>
<h4 id="VPS-选择"><a href="#VPS-选择" class="headerlink" title="VPS 选择"></a>VPS 选择</h4><ul>
<li>优先选择 linux VPS ，软件多，性能稳定，占用资源少，价格便宜等等。</li>
<li>选择国内 VPS （阿里云/腾讯云）：面向群体为国内用户，需要 ICP 备案，时间较长；另外支持备案的域名较少，使用国内 VPS 时，购买域名需要慎重。</li>
<li>选择国外 VPS （vultr，digitalocean, 搬瓦工）：客户是国外用户或者不用于商业用途，价格为国内一半以下，带宽充足。</li>
</ul>
<h4 id="选择虚拟技术"><a href="#选择虚拟技术" class="headerlink" title="选择虚拟技术"></a>选择虚拟技术</h4><p>优先选择 KVM， 其次 XEN 或 vmware，最后 OpenVZ。</p>
<h4 id="硬件资源选择"><a href="#硬件资源选择" class="headerlink" title="硬件资源选择"></a>硬件资源选择</h4><p>一般 VPS 会提供多种方案或者自由搭配组合，主要根据自己的实际需求选择硬件资源。</p>
<ul>
<li>应用要求高，则选择内存大的，CPU 强劲的方案，例如游戏服务器等</li>
<li>网络应用，主要分享文件视频等，选择流量大的</li>
<li>主要用于存储数据的，选择较大的硬盘空间。</li>
</ul>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=Hs-er4JwHc8" target="_blank" rel="external">https://www.youtube.com/watch?v=Hs-er4JwHc8</a><br><a href="http://www.chinaz.com/prime/2012/1021/279069.shtml" target="_blank" rel="external">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[TeamViewer 远程控制]]></title>
      <url>http://noparkinghere.win/2016/12/12/2016/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>TeamViewer 是一款最流行的远程桌面连接工具，特点：连接稳定，功能强大，跨平台，对网络稳定性要求低等等，几乎集成了市面上大多数远程工具的优点，实时性很强，且资源消耗低，这些都远不是 qq 等国内软件的远程服务可以比拟的。本篇文章就是 windows 远程连接 Ubuntu 桌面编辑完成的。</p>
<p>本文主要介绍如何在局域网内使用 TeamViewer 完成远程桌面的设置。</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>这边给出<a href="https://www.teamviewer.com/zhcn/download/linux/" target="_blank" rel="external">官方下载地址</a>，可以看到官方提供了目前主流移动端和 PC 端的各个版本的软件。这边根据你自己的平台下载需要的版本。因为平台需要这边我下载的是 windows 版本和 Ubuntu 版本。需要注意的是：下载版本为完整版，而不是缩减版（缩减版中需要联网登录，且不直接存在登录远程功能），图示如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="广域网连接"><a href="#广域网连接" class="headerlink" title="广域网连接"></a>广域网连接</h4><p>通过ID+密码连接，首先，输入对方的 ID 地址，然后选择下方的远程控制后点击连接到小伙伴，最后输入对方的密码即可完成远程控制。比较诡异的是远程链接到对方的 windows 后，背景图会变成黑色，但这无须担心，退出连接后，会恢复原来主题。另外如果实在看的不舒服，登录后点击“查看”，然后把“删除墙纸”勾掉就可以了。</p>
<h4 id="局域网连接"><a href="#局域网连接" class="headerlink" title="局域网连接"></a>局域网连接</h4><p>局域网下的 teamviewer 的使用，可以类似于 windows 下的远程登录，虽然原理不尽相同，但通 teamviewer 我们可以图形化的实现跨平台操作，也就是说 windows 下可以远程操作 linux 的图形化界面，实现功能类似于我之前的一篇文章 “putty-xming-远程使用-linux-gui” 。“putty-xming-远程使用-linux-gui” 采用的是 ssh 加密，转发，登录的是一个新的账号，对网络的要求特别高，刷新速度慢；而 teamviewer 对比 ssh 转发的效果更好，速度更快，网络要求也更低，刷新快，操作流畅，即便浏览网页问题也不大，但和 windows 远程桌面登录相比在体验上还是有差距的。</p>
<ul>
<li>使用局域网链接，需要先配置下本机设置，找开软件后，先要设置允许接入lan（或者叫允许局域网连接），那样的话，ID的地方就显示内网的IP了。如果你的 ID 不能显示自己的 IP 地址，重新启动软件即可。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/2.jpg" alt=""></p>
<ul>
<li>局域网内同样需要两边都先打开软件，然后使用 IP 代替伙伴ID输入，后续操作和上面类似，直接点远程控制，输入密码即可。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/3.jpg" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TeamViewer 的链接方式稳定，带宽占用资源小，高质量模式下，也仅有 200kb/s 的传输速度，操作也很及时，附带的录屏文件传输等功能强大。但 TeamViewer 并非完全免费的软件，一些附带功能和商业用途需要付费支持，另外 TeamViewer 只能用于远程图形化界面的使用的话，说白了就是只能一个人使用，不能类似于 ssh 可以多人使用登录。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.wuji8.com/meta/864411156.html" target="_blank" rel="external">http://www.wuji8.com/meta/864411156.html</a><br><a href="https://zhidao.baidu.com/question/497787316.html" target="_blank" rel="external">https://zhidao.baidu.com/question/497787316.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[LAMP 环境搭建]]></title>
      <url>http://noparkinghere.win/2016/12/09/2016/2016-12-09-lamp-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>之前写过一些服务器的配置文章，但当时都只是按部就班，对于相关服务的理解很欠缺。由于很多的博客系统，网站都依赖于：操作系统，服务器软件，数据库，后台编程语言等，本质上他们都存在很大的共性，细心品尝里面的门道其实不可谓不多，这边重新梳理 LAMP 环境的搭建，帮助学习和理解。</p>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[efm32开发板+FAQ]]></title>
      <url>http://noparkinghere.win/2016/12/08/2016/2016-12-08-efm32%E5%BC%80%E5%8F%91%E6%9D%BF+FAQ/</url>
      <content type="html"><![CDATA[<p>silabs 的 EFM 系列芯片历来以低能耗，可信的加密而文明，比较遗憾的是，国内用的较少，且基本上没有什么中文参考资料，刚刚开办没多久的官方中文论坛贴出来的资料也大都是英文版，且论坛在 GFW 下访问相当困难。因为项目需求，这边我入手了两个系列的 EFM 开发板，但都出了大大小小的问题。</p>
<p>个人总结：1.因为前期缺少相关指导，且官方指导手册仅告诉要如何做，却没指示相关工具的位置和使用。2.该芯片配备专有 IDE 且还分好几个版本，无疑增加了摸索的难度。3.个人经验不足，之前上手的都是开发板，没接触过这种官方自带的评估板。</p>
<p>其实上手这个评估板并不困难，困难的是没有一个详尽完整的指导手册，不知道如何用评估板去烧录上面的 MCU ，如何用评估板烧录自己产品的 MCU等。</p>
<p>相比国内的开发板学习板而言，EFM 开发板大都是官方的评估板，并且大都是英文原版说明文档。最主要的一点，在购买 EFM 开发板时，官方是不会将开发板资料打包给你的，取而代之的是让你安装官方的软件 simplicity studio ，软件中会将你芯片的相关文档程序等进行罗列。虽然看起来更加人性化了，然而问题也出在这边，simplicity studio offline 罗列出来的文档/程序不全，部分你芯片的资料已经被装在电脑中了，但 simplicity studio 却没有将呈现给你，一般你还得自己手动在电脑中检索，或者去官网搜索。</p>
<h3 id="评估板简介："><a href="#评估板简介：" class="headerlink" title="评估板简介："></a>评估板简介：</h3><p>EFM32 配套评估板 上 Jlink 是从Segger授权的, 功能上应该没有缩减。因此价格也较贵，原价 $69 现价 $29 ，一般网购的价格在 ￥200 左右，这个价位对于国内 STM32 满地跑，部分 STM32 开发板价格甚至在 100 左右来说的话，还是较贵的，最关键的是淘宝购买的厂家不承担售后服务之类的，出问题只能自己解决。</p>
<p>另外，EFM32 官方配套软件很强大，将编码，烧录，仿真，能耗监控，文档，样例等等都集成在了一起，很多资料都需要去这个 IDE 中查找，对英语不好或者不善于摸索的人来说也是一道门槛。</p>
<p>评估板的功能：</p>
<ul>
<li>根据你的版型，不同的板子有不同的功能，一般都会有显示器，按键，led等基本功能</li>
<li>能耗检测模块</li>
<li>板载 Jlink ：可以烧录板载 MCU，也可以烧录外置芯片。</li>
<li>可以使用外置 Jlink 来烧录板载的 MCU。</li>
<li>大多数引脚引出，且预留焊盘，另外还有 EXP 扩展口（注意 debug-out 是小灯，而不是指 EXP 扩展口）。</li>
</ul>
<a id="more"></a>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>评估板的 debug 主要分为 in,out,mcu,off 等选项，这几个选项至关重要，我们可以不使用 simplicity studio 这个 IDE，但如果需要使用这个评估板，就必须得弄清楚如何设置评估板的 debug 模式。</p>
<p>这边我使用 simplicity v3 版本，设置 debug 模式，需要通过一个 commander 的软件，该软件在 simplicity v3 安装包中可以检索到，如果需要在 simplicity studio 中打开，则安装时需要安装无线模块套件（如果不安装这个套件，软件中无法打开这个 commander 工具，因此建议新手安装完整版的 simplicity v3 而不是只安装你所需要的芯片组建），打开 simplicity IDE 然后在 file 中打开 simplicity commander。</p>
<p>每次使用评估板要进行相关操作时，都需要使用 commander 进行设置，详细配置说明：</p>
<ul>
<li>debug-in ： 烧录评估板上面的 jlink 固件，注意烧录的是 jlink 而不是评估板的 EFM芯片。</li>
<li>debug-out : 使用评估板作为 jlink 烧录其他板子上面的外置芯片。mcu 资料中可以读出外置芯片具体信息，另外评估板有个 debug-out 灯会亮起。</li>
<li>debug-mcu : 烧录评估板上面自带的 EFM 芯片。mcu 资料中可以读出板载芯片具体信息。</li>
</ul>
<p><strong>评估板作为 jlink 是官方正版授权的，烧录程序一般没有问题，但如果需要打多个断点进行仿真，则可能会仿真失败，应该是和 jink 采用的芯片有关系。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-08-efm32开发板+FAQ/1.png" alt=""></p>
<h3 id="固件烧录"><a href="#固件烧录" class="headerlink" title="固件烧录"></a>固件烧录</h3><p>普通升级，官方推荐使用 Kit Manager 打开后会自动判断固件是否需要升级，事实上 Kit Manager 和 simplicity commander 功能基本相同，但 Kit Manager 更显得傻瓜式，而且也会经常出现无法打开，无法连接芯片等问题，如果遇到了这些问题，建议还是使用 simplicity commander 进行所有操作。</p>
<p>如果无法找到 commander 工具，这边推荐给出两个该工具的下载地址：</p>
<p>固件烧录失败后，如何重新烧录固件，步骤差不多如下：</p>
<ul>
<li>将评估板的 bootloader 接地（bootloader 位置各个开发板不尽相同，可以参照原理图，或者查看下面给出的参考连接），接下来连接电脑，打开 simplicity commander ，如果 bootloader 接地成功则会显示 j-link device 信息，否则读取不到信息。</li>
<li>设置 debug mode:in 烧录 jlink 芯片，找到固件包，安装包（包为 .emz 格式，在 simplicity 安装目录中，可以电脑自行检索包路径）。</li>
</ul>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>这边附上一个中文版的问题总结，比较难得的一版中文资料， <a href="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-08-efm32开发板+FAQ/1.pdf" target="_blank" rel="external">EFM32 系列微控制器 FAQ</a></p>
<h4 id="根据-CMU-的时钟树，在使用其他低频时钟源操作-LEA-LEB-时无需配置-CMU-HFCORECLKEN0，但实际操作必须配置-CMU-HFCORECLKEN0-才可以正常工作。"><a href="#根据-CMU-的时钟树，在使用其他低频时钟源操作-LEA-LEB-时无需配置-CMU-HFCORECLKEN0，但实际操作必须配置-CMU-HFCORECLKEN0-才可以正常工作。" class="headerlink" title="根据 CMU 的时钟树，在使用其他低频时钟源操作 LEA/LEB 时无需配置 CMU_HFCORECLKEN0，但实际操作必须配置 CMU_HFCORECLKEN0 才可以正常工作。"></a>根据 CMU 的时钟树，在使用其他低频时钟源操作 LEA/LEB 时无需配置 CMU_HFCORECLKEN0，但实际操作必须配置 CMU_HFCORECLKEN0 才可以正常工作。</h4><p>查看 RTC/LEUART 可以看到 To use this module, the LE interface clock must be enabled in CMU_HFCORECLKEN0, in addition to the module clock. 时钟树没能将具体的成都呈现出来，实际工作时，查看相关外设的使用说明，会有使用方法。</p>
<blockquote>
<p>参考链接：<br><a href="http://m.blog.csdn.net/article/details?id=41648431" target="_blank" rel="external">http://m.blog.csdn.net/article/details?id=41648431</a><br><a href="http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142" target="_blank" rel="external">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142</a><br><a href="http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776" target="_blank" rel="external">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776</a><br><a href="http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view" target="_blank" rel="external">http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view</a><br><a href="http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227" target="_blank" rel="external">http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227</a><br><a href="http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx" target="_blank" rel="external">http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[PuTTY + Xming 远程使用 Linux GUI]]></title>
      <url>http://noparkinghere.win/2016/12/01/2016/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/</url>
      <content type="html"><![CDATA[<p>就目前而言，将 linux 作为个人电脑操作系统使用的人还比较少，而 linux 也一直以来因为其占用资源少，系统稳定，强大的 CLI 而闻名于世。因此显而易见，广大用户一般都是通过 ssh 等方式登录连接 linux ，然后使用 CLI 完成需要的操作，而使用 linux GUI 用户较少，甚至可以被忽略，但出于个人的需要，本人需要通过 windows 远程登录 linux 然后通过 chrome 等</p>
<h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3><ul>
<li>windows 7 x64 中文旗舰版</li>
<li>ubuntu 16.04 </li>
</ul>
<a id="more"></a>
<h3 id="软件配置："><a href="#软件配置：" class="headerlink" title="软件配置："></a>软件配置：</h3><h4 id="Xming-："><a href="#Xming-：" class="headerlink" title="Xming ："></a>Xming ：</h4><p>Xming是一个在 Microsoft Windows 操作系统上运行 X Window System 的自由软件。其主要功能是通过在Linux平台上通过交叉编译的方法，实现了跨越操作系统对X GUI的表现。</p>
<p>正常安装该软件：这边使用过的是： Xming-6-9-0-31-setup.exe 的版本，正常安装过，一般都没有问题，设置按照下图选择不安装 ssh client。 Display 设置按照个人习惯进行设置，如果仅是打开个别 GUI 窗口的话，建议采用 Multiple windows ，可以讲所有的 GUI 窗口作为一个个应用进行打开。接下来按照默认设置进行下一步即可，另外最后一步可以保存当前设置作为一个快捷方式，下次直接打开即可。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/1.png" alt=""></p>
<h4 id="putty"><a href="#putty" class="headerlink" title="putty :"></a>putty :</h4><p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。自带SSH Forwarding的功能，包括X11 Forwarding。</p>
<ul>
<li>输入需要拨号的地址（这边注意本机和目标机器在同一个网段）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/2.png" alt=""></p>
<ul>
<li>设置拨号的账户名，方便下次登录</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/3.png" alt=""></p>
<ul>
<li>一定要打开 X11 转发模式，可以让 ssh 图形化转发给 Xming 进行工作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/4.png" alt=""></p>
<h4 id="SecureCRT-方式（可以跳过）"><a href="#SecureCRT-方式（可以跳过）" class="headerlink" title="SecureCRT 方式（可以跳过）"></a>SecureCRT 方式（可以跳过）</h4><p>这边补充 SecureCRT 这个软件的方式，原理和 putty 类似，得益于 SecureCRT 在用户界面上面更加友好方便，常常用作远程管理使用，如果已经使用了 putty 的这边可以跳过，两种方式选其一即可。</p>
<p>SecureCRT 同 putty 类似，设置时，需要在 session options -&gt; connection -&gt; port forwarding -&gt; remote/x11 中勾选 x11 forwarding 下面的 forward x11 packets 和 enforce x11 authentication 。注意：不需要添加 remotely forwarded connections 中的内容。</p>
<h4 id="linux端设置"><a href="#linux端设置" class="headerlink" title="linux端设置"></a>linux端设置</h4><ul>
<li>要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行，<code>X11Forwrding yes</code> 至此配置完成。</li>
<li>保证 linux 端至少要有多个可以访问的用户。</li>
</ul>
<h4 id="工作运行"><a href="#工作运行" class="headerlink" title="工作运行"></a>工作运行</h4><ul>
<li>上述部分 putty 设置完成后，开始登录，注意使用不同于 linux 上已经登录图形界面的账户登录 putty 。</li>
<li>在 windows 上使用 PuTTY 连接到 linux ，输入 xclock &amp; ，可以看到一个图形化时钟出现了，说明图形化转发已经成功了。</li>
<li>输入 <code>google-chrome</code> 则可以在 xming 中打开 chrome 浏览器进行需要的操作了。</li>
<li>输入 <code>gnome-session</code> 则可以远程打开 GUI 交互环境。</li>
</ul>
<p><strong>这边要注意的是：如果 putty 和 linux GUI 登录了同一个账号，则输入相关命令可能会无法打开相关 GUI，检查发现事实上，你要打开的窗口在 linux 主机上面被打开了，因此最好的办法是登录一个新的账号，进行相关的图形化操作。</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过步骤可以发现，PuTTY + Xming 或 SecureCRT + Xming 的配置较为简单，但效率较低，即便传输速率达到 4mb/s 图像依然刷新较慢，体验效果很差。可能是 ssh 的直接访问方式，没有对视频等多媒体进行过优化，推荐可以采用其他方式进行远程桌面连接，这边可以参考博客中另外一篇文章 <em>TeamViewer 远程控制</em>。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html" target="_blank" rel="external">http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[vps-docker]]></title>
      <url>http://noparkinghere.win/2016/11/28/2016/2016-11-28-vps-docker/</url>
      <content type="html"><![CDATA[<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[检测VPS虚拟化技术]]></title>
      <url>http://noparkinghere.win/2016/11/26/2016/2016-11-26-%E6%A3%80%E6%B5%8BVPS%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>很多时候，我们需要知道自己的 VPS 是通过什么软件进行分配的，这是可以使用如下的几种方式：</p>
<h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>使用如下命令运行</p>
<p><code>wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/code/master/vm_check.sh &amp;&amp; bash vm_check.sh</code></p>
<p>代码运行结束就会在最后一行显示虚拟化技术：kvm还是openv或者是xen一目了然。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line">make[1]: Leaving directory `/root/virt-what-1.12<span class="string">'</span></div><div class="line">openvz</div><div class="line">kvm</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上述内容，看末尾显示如果是：openvz 和 kvm 表示经过了 openvz 和 kvm 两层虚拟化最后构建了你所用的 VPS 。</p>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>这种方法是后来看到的，方法更为简单:</p>
<ul>
<li>apt-get install virt-what</li>
<li>直接执行 virt-what 这个脚本，就会报告结果，例如：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@a118:~<span class="comment"># virt-what </span></div><div class="line">openvz</div><div class="line">kvm</div></pre></td></tr></table></figure>
<blockquote>
<p>参考地址：<br><a href="https://www.91yun.org/zh/archives/836" target="_blank" rel="external">https://www.91yun.org/zh/archives/836</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS : shadowsocks]]></title>
      <url>http://noparkinghere.win/2016/11/25/2016/2016-11-25-vps-shadowsocks/</url>
      <content type="html"><![CDATA[<p>日常生活中，由于GFW的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，本文章使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器，推荐 vultr 搬瓦工等廉价vpn。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>这边可以参考<a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="external">原文博客</a>，以下只是简单罗列一些原理：</strong></p>
<ul>
<li>早期互联网用户访问网站时，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户： </li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss1.png" alt=""></p>
<ul>
<li>GFW 出现后，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss2.png" alt=""></p>
<ul>
<li>为了绕过GFW的过滤（包含了各种HTTP代理服务、Socks服务、VPN服务等等），以 ssh tunnel 的方法为例：1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss3.png" alt=""></p>
<p><strong>由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题</strong></p>
<ul>
<li>shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似:1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss4.png" alt=""></p>
<ul>
<li>GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>
</ul>
<h3 id="软件简介："><a href="#软件简介：" class="headerlink" title="软件简介："></a>软件简介：</h3><h4 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks:"></a>shadowsocks:</h4><p><a href="https://shadowsocks.org/en/index.html" target="_blank" rel="external">shadowsocks：A secure socks5 proxy,designed to protect your Internet traffic.</a>。</p>
<p>Shadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。</p>
<p>Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。</p>
<ul>
<li>Shadowsocks使用自行设计的协议进行加密通信。[4]加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。</li>
<li>所有的流量都经过算法加密，允许自行选择算法，所以比较安全。</li>
<li>Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。</li>
<li>客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器（OpenWrt）等[5]。</li>
<li>专为移动设备和无线网络优化。</li>
</ul>
<h4 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor:"></a>supervisor:</h4><p>Linux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p>
<h3 id="VPS-安装及配置："><a href="#VPS-安装及配置：" class="headerlink" title="VPS 安装及配置："></a>VPS 安装及配置：</h3><h4 id="软件列表："><a href="#软件列表：" class="headerlink" title="软件列表："></a>软件列表：</h4><ul>
<li>vps（Debian GNU/Linux 7 ），这边采用 Debian 系列linux，ubuntu 应该步骤类似，如果使用 redhat 系列，部分指令需要自行更改，这边不做累述。</li>
<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>
<li>supervisor ： 用于Linux后台进程管理的利器</li>
</ul>
<a id="more"></a>
<h4 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul>
<li>安装软件，终端输入：<code>apt-get install python-pip &amp;&amp; pip install shadowsocks</code>。</li>
<li>写 shadowsocks 配置文件： vim /etc/shadowsocks.json ， 具体内容如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line">    <span class="string">"server_port"</span>:50003,</div><div class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="string">"local_port"</span>:1080,</div><div class="line">    <span class="string">"password"</span>:<span class="string">"123456"</span>,</div><div class="line">    <span class="string">"timeout"</span>:300,</div><div class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</div><div class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">说明： </div><div class="line">server 你vps的IP</div><div class="line">servier_port 服务端的端口</div><div class="line">local_port 本地端口，一般默认1080</div><div class="line">password 服务端设置的密码</div><div class="line">timeout 超时设置</div><div class="line">method 加密方法</div><div class="line"></div><div class="line">如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码:</div><div class="line">&#123;</div><div class="line">    <span class="string">"timeout"</span>: 600,</div><div class="line">    <span class="string">"method"</span>: <span class="string">"aes-256-cfb"</span>,</div><div class="line">    <span class="string">"port_password"</span>:</div><div class="line">    &#123;</div><div class="line">        <span class="string">"40001"</span>: <span class="string">"password1"</span>,</div><div class="line">        <span class="string">"40002"</span>: <span class="string">"password2"</span>,</div><div class="line">        <span class="string">"40003"</span>: <span class="string">"password3"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"_comment"</span>:</div><div class="line">    &#123;</div><div class="line">        <span class="string">"40001"</span>: <span class="string">"xiaoming"</span>,</div><div class="line">        <span class="string">"40002"</span>: <span class="string">"lilei"</span>,</div><div class="line">        <span class="string">"40003"</span>: <span class="string">"mike"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这边 server 的地址可以通过 ipconfig 获取本机地址，如果是一些多层虚拟出来的机器，如果无法获得本机IP，则输入0.0.0.0即可。</p>
<ul>
<li>安装 supervisor： apt-get install supervisor</li>
<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisord.conf 在末尾加入如下内容：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[program:shadowsocks]</div><div class="line"><span class="built_in">command</span>=ssserver -c /etc/shadowsocks.json</div><div class="line">autostart=<span class="literal">true</span></div><div class="line">autorestart=<span class="literal">true</span></div><div class="line">user=root</div><div class="line">log_stderr=<span class="literal">true</span></div><div class="line">logfile=/var/<span class="built_in">log</span>/shadowsocks.log</div></pre></td></tr></table></figure>
<ul>
<li>最后让 supervisor 开机自启动：在 <code>vim /etc/rc.local</code> 空白行加入 <code>service supervisor restart</code> (事实上这一步可以不用加，supervisor 本身就会开机自启动，在 <code>/etc/rc2.d/</code> 下 我们可以看到 <code>lrwxrwxrwx 1 root root  20 Nov 25 11:56 S01supervisor -&gt; ../init.d/supervisor</code> ，当然如果你的系统没能自动开启 supervisor 守护进程，则需要手动完成上述操作)，重启服务器查看是否配置成功。</li>
</ul>
<p><em>采用 supervisor 的原因很大程度上是：将 <code>sslocal -c /etc/shadowsocks.json</code> 放入/etc/rc.local中没法开启自启该服务，有待查找原因。</em></p>
<p><strong>以上内容均为个人总结转述，如果可以访问外网，请参考<a href="https://shadowsocks.org/en/download/servers.html" target="_blank" rel="external">官网</a>给出的更加详细的配置步骤。以下为客户端配置，注意只有在完成了服务器端配置或者你已经有一个可以使用的 shadowsocks 服务器，才能够在本地搭建以下服务。</strong></p>
<h3 id="本地-linux-下的安装配置"><a href="#本地-linux-下的安装配置" class="headerlink" title="本地 linux 下的安装配置"></a>本地 linux 下的安装配置</h3><h4 id="软件列表：-1"><a href="#软件列表：-1" class="headerlink" title="软件列表："></a>软件列表：</h4><ul>
<li>linux PC端： shadowsocks ， 本地操作系统 ubuntu 16.04 , 。</li>
<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>
<li>supervisor ： 用于Linux后台进程管理的利器</li>
<li>chrome 插件 SwitchyOmega ：</li>
</ul>
<h4 id="详细步骤：-1"><a href="#详细步骤：-1" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul>
<li>安装 shadowsocks （我们这边不采用 GUI 软件而直接使用 shadowsocks 命令工具连接 shadowsocks 服务器。）步骤如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install python-pip</div><div class="line">sudo apt-get install python-setuptools m2crypto</div><div class="line">pip install shadowsocks</div><div class="line"></div><div class="line">注意： 如果是 ubuntu 16.04 的版本执行完以上命令后可能仍然无法执行 sslocal 命令，需要手动执行 `sudo apt install shadowsocks` （ubuntu16.04 直接可以直接用apt 而不用 apt-get 这是一项改进）。</div></pre></td></tr></table></figure>
<ul>
<li>配置 Shadowsocks ：同服务器类似， 也是配置 shadowsocks.json 这个文件，可以在你想要指定的目录下新建这个文件如：~/.config/shadowsocks.json ， 编辑该文件：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"www.baidu.com"</span>,</div><div class="line">    <span class="string">"server_port"</span>:50003,</div><div class="line">    <span class="string">"local_port"</span>:1080,</div><div class="line">    <span class="string">"password"</span>:<span class="string">"123456"</span>,</div><div class="line">    <span class="string">"timeout"</span>:600,</div><div class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">说明：</div><div class="line">server 后面填写你需要链接的服务器地址</div><div class="line">server_port 后面填写你 Shadowsocks 服务器配置的 server_port 端口</div><div class="line">local_port 无需修改</div><div class="line">password 需要和 Shadowsocks 服务器保持一致</div></pre></td></tr></table></figure>
<ul>
<li>完成以下步骤后，你的浏览器仍然不能浏览网页，Shadowsocks 仅提供了转发服务，而你本地的端口发送的数据还无法和server_port进行链接，这时候，你可以采用全局代理的软件让所有数据帮转发，这边推荐chrome的 SwitchyOmega 插件。可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="external">SwitchyOmega</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。安装好之后下面开始设置代理，如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/3.png" alt=""></p>
<p>上图步骤中注意类型条件中勾选<strong>规则列表规则</strong>， 规则地址： <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 填入其中。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/4.png" alt=""></p>
<p>点击 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。</p>
<p>如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。</p>
<ul>
<li>安装 supervisor： sudo apt-get install supervisor</li>
<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisor.conf 在末尾加入如下内容，或者在 /etc/supervisor/conf.d 下新建新的文件增加如下内容（注意 shadowsocks.json 文件路径写对）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[program:shadowsocks]</div><div class="line"><span class="built_in">command</span>=sslocal -c /home/username/.config/shadowsocks.json</div><div class="line">autostart=<span class="literal">true</span></div><div class="line">autorestart=<span class="literal">true</span></div><div class="line">user=root</div><div class="line">log_stderr=<span class="literal">true</span></div><div class="line">logfile=/var/<span class="built_in">log</span>/shadowsocks.log</div></pre></td></tr></table></figure>
<ul>
<li>最后让 supervisor 开机自启动：在 <code>sudo vim /etc/rc.local</code> 空白行加入 <code>sudo service supervisor restart</code>。<em>不知出于什么原因这边 supervisor 必须手动写入 /etc/rc.local 中才会开机自启动</em> 查看是否配置成功可以重启电脑。</li>
</ul>
<p><em>如果需要让 linux 下其他软件也都可以使用 ss 服务，可以参考我的另外一篇文章：linux-shadowsocks全局代理。</em></p>
<h3 id="本地-windows-下安装配置"><a href="#本地-windows-下安装配置" class="headerlink" title="本地 windows 下安装配置"></a>本地 windows 下安装配置</h3><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.3.5/Shadowsocks-3.3.5.zip" target="_blank" rel="external">下载客户端</a>，作为一个开源软件 GUI 客户端分为多个版本，这边提供了 win 版本，需要安装 微软的库，打开后如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/5.png" alt=""></p>
<p>这边的服务器 IP 同上面 linux 的类似，填写你的域名或者 IP 即可，密码也要和服务器的 shadowsocks 服务保持一致。值得一提的是 windows 下面的客户端直接可以设置全局代理，右击任务栏的小图标可以设置相关选项。</p>
<h3 id="本地-安卓手机端-安装配置"><a href="#本地-安卓手机端-安装配置" class="headerlink" title="本地 安卓手机端 安装配置"></a>本地 安卓手机端 安装配置</h3><p>安卓用户这边推荐使用腾讯自家的应用宝，直接搜索 shadowsocks 会看到中文名“影梭”的这个软件(<em>注意应用宝中的软件版本较老，为 2.8.3 目前最新版本为 3.2.7。</em>)，设置基本和 windows 的类似，设置完毕后，点击右上角的开启按钮。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/6.png" alt=""></p>
<blockquote>
<p>参考链接：<br><a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="external">http://vc2tea.com/whats-shadowsocks/</a><br><a href="https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html" target="_blank" rel="external">https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html</a><br><a href="https://aitanlu.com/linux-ubuntu-install-shadowsocks.html" target="_blank" rel="external">https://aitanlu.com/linux-ubuntu-install-shadowsocks.html</a><br><a href="https://php-rmcr7.rhcloud.com/shadowsocks-server/" target="_blank" rel="external">https://php-rmcr7.rhcloud.com/shadowsocks-server/</a><br><a href="http://blog.chinaunix.net/uid-25530360-id-5595974.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-25530360-id-5595974.html</a><br><a href="http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000" target="_blank" rel="external">http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000</a><br><a href="https://zh.wikipedia.org/zh-hans/Shadowsocks" target="_blank" rel="external">https://zh.wikipedia.org/zh-hans/Shadowsocks</a><br><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks/tree/master</a><br><a href="http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[(转)虚拟主机、VPS和云主机]]></title>
      <url>http://noparkinghere.win/2016/11/23/2016/2016-11-23-%E8%BD%AC-%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E3%80%81vps%E5%92%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转载链接：<a href="http://www.chinaz.com/prime/2012/1021/279069.shtml" target="_blank" rel="external">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>
</blockquote>
<p>云计算时代，云主机其可扩展性、价格便宜、安全可靠的特性深受企业和开发者欢迎，但目前有些IDC企业，新瓶装旧酒，将虚拟主机、VPS进行包装推出所谓的云主机服务，为了帮助用户更好的辨别和挑选云主机，下文详细介绍虚拟主机、VPS和云主机产品的特点以及差异性。</p>
<h3 id="一、虚拟主机、VPS和云主机"><a href="#一、虚拟主机、VPS和云主机" class="headerlink" title="一、虚拟主机、VPS和云主机"></a>一、虚拟主机、VPS和云主机</h3><p>共享主机也称虚拟主机，从互联网诞生至今，大部分站长都是从”共享主机”(shared hosting)开始学习建站的。所谓”共享主机”，就是一台服务器上有许多网站，大家共享这台服务器的硬件和带宽。如果它发生故障，那么上面的所有网站都无法访问。</p>
<p>VPS主机(Virtual Private Server 虚拟专用服务器)，将一部服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。用户除了可以分配多个虚拟主机及无限企业邮箱外，更具有独立服务器功能，可自行安装程序，单独重启服务器。</p>
<p>”云主机”(Cloud hosting)可以看成是新一代的共享主机。</p>
<p>首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。</p>
<p>比如，假设你要把本机的文件备份到网上，你可以使用共享主机，把文件传到某一台服务器上;也可以使用云主机，通过某种形式的接口，把它们传到云里。也就是说，共享主机用户直接面对特定的服务器，而云主机用户直接面对网络接口，看不到服务器内部。</p>
<p>一个通俗的比喻是，你可以向银行租一个编号为”8888″的保险箱(共享主机)，也可以把贵重物品直接交给保管公司，听任他们保管。</p>
<p>诸如Gmail、FaceBook、Twitter、Flickr这样的产品，都可以看作是基于”云主机”的服务。</p>
<p>云主机能真正获得root权限，用户可以重装和升级操作系统，而VPS主机用户没有root权限，无法重装和升级操作系统。</p>
<a id="more"></a>
<h3 id="二、虚拟主机、VPS、云主机的区别"><a href="#二、虚拟主机、VPS、云主机的区别" class="headerlink" title="二、虚拟主机、VPS、云主机的区别"></a>二、虚拟主机、VPS、云主机的区别</h3><h4 id="供应和部署时间"><a href="#供应和部署时间" class="headerlink" title="供应和部署时间"></a>供应和部署时间</h4><p>虚拟主机——数天至数周</p>
<p>VPS———即时，无需安装操作系统</p>
<p>云主机——即时，几分钟即可完成，可一键部署、也可自主安装操作系统</p>
<h4 id="安全可靠性"><a href="#安全可靠性" class="headerlink" title="安全可靠性"></a>安全可靠性</h4><p>虚拟主机——一般：租用白牌服务器故障率高、基本无ARP、木马和DDOS防范能力、基本无备机和数据备份服务</p>
<p>VPS———差：同一台物理服务器上其他VPS上安装的程序缺陷、ARP欺骗、病毒、资源挤占等会严重影响到自身;基本无ARP、木马和DDOS防范能力</p>
<p>云主机——高：内置ARP防范，规模化提升DDOS防攻击能力;分享品牌企业级服务器和硬件虚拟化的性能和可靠性，内置HA;提供备机、快照、数据备份等多种快速恢复措施</p>
<h4 id="性能及保障"><a href="#性能及保障" class="headerlink" title="性能及保障"></a>性能及保障</h4><p>虚拟主机——好且有保障</p>
<p>VPS———差：性能一般，只适用于小规模并发访问;性能无保障，易遭受同一台物理服务器上其他VPS的挤压</p>
<p>云主机——好且有保障：同物理服务器</p>
<h4 id="弹性和扩展性"><a href="#弹性和扩展性" class="headerlink" title="弹性和扩展性"></a>弹性和扩展性</h4><p>虚拟主机——扩容需要重新租用新服务器、还需为原有租用资源付费</p>
<p>VPS———扩容快，受制于单台服务器配置</p>
<p>云主机——即时供应、按需扩展 ，无需为原有租用资源付费</p>
<h4 id="拥有成本"><a href="#拥有成本" class="headerlink" title="拥有成本"></a>拥有成本</h4><p>虚拟主机——季付年付成本高、需要为服务商转嫁CapEx支出支付押金;需要自己维护租用的服务器导致Opex较高</p>
<p>VPS———低配置的VPS租用价格最低;但低安全可靠性和无保障的性能导致服务质量无保障，运营成本难控制且偏高</p>
<p>云主机——综合成本最低：月付无押金、按需使用按需付费、基本零维护 ，还可分享规模化、绿色节能、最佳IT实践带来的成本优势</p>
<h4 id="易用、易管理性"><a href="#易用、易管理性" class="headerlink" title="易用、易管理性"></a>易用、易管理性</h4><p>虚拟主机——需要远程控制卡且只有租用品牌机才有可能，无法实现集中统一管理</p>
<p>VPS———提供单一的单机管理界面，无root或超级管理员操作系统权限，管理灵活性受制于管理界面</p>
<p>云主机——内置KVM、客户通过自服务系统可以集中统一管理分布在各地的云主机;完全拥有root或超级管理员操作系统权限</p>
<h3 id="三、云主机的优点"><a href="#三、云主机的优点" class="headerlink" title="三、云主机的优点"></a>三、云主机的优点</h3><p>云主机主要有三大优点。</p>
<ul>
<li><p>便宜:因为服务可以分散到多台服务器，因此能够充分利用资源，这样就降低了硬件、电力和维护成本。而且，云主机是根据使用量计费的，多用多付，少用少付，所以对小网站特别有利。</p>
</li>
<li><p>可靠:因为服务分布在多台服务器、甚至多个机房，所以不容易彻底宕机，抗灾容错能力强，可以保证长时间在线。</p>
</li>
<li><p>可扩展性好(scalability):云主机的基本特点就是分布式架构，所以可以轻而易举地增加服务器，成倍扩展服务能力。</p>
</li>
</ul>
<h3 id="四、云主机的缺点"><a href="#四、云主机的缺点" class="headerlink" title="四、云主机的缺点"></a>四、云主机的缺点</h3><p>一些客户担心云主机的安全问题，感到对服务缺乏控制。</p>
<p>因为云主机只是提供网络接口，所以客户的数据必然全部服从云服务公司的安排，完全在后者控制之下。数据是否安全保密，取决于后者的职业道德和保护能力。</p>
<p>但是，这其实是一个”伪问题”，因为绝大多数情况下，云服务公司会比客户更在乎、也更善于保护数据。Paul Graham在《黑客与画家》一书中，就谈过这一点：</p>
<p>”反对者往往觉得我们的产品不安全，如果员工可以很容易地登录，那么坏人也可以很容易地登录。一些大公司觉得不能把客户的信用卡资料交给我们，而是放在自己的服务器上更安全。……但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。</p>
<p>想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？……而且我们比他们更关心数据的安全。如果一家服装零售商的服务器被入侵，最多只影响到这家公司本身，这件事也很可能在公司内部被掩盖起来，最严重的情况下可能还会有一个员工被解雇。但是，如果我们的服务器被入侵，就有成千上万家公司可能受到影响，这件事也许还会被当作新闻，发表在业内网站上面，使得我们生意做不下去，不得不关门歇业。</p>
<p>如果你想把钱藏在安全的地方，请问你是选择家中床垫下面，还是选择银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理、备份等等，都是我们占优。”</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git submodule 详解]]></title>
      <url>http://noparkinghere.win/2016/11/23/2016/2016-11-23-git-submodule-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>使用 git 也有一段时间，但不得不说 git 的功能相当强大和复杂，需要你不断的去摸索学习。这边介绍一个 git 很强大的功能：git submodule 。起初发现这个文件是在我本人 fork 了一个 awesome 的配置文件，用了也蛮久，但最近由于总是出现连接错误，然后手动去更改了一些文件，但意外发现更改的文件无法提交， status 中竟然没有这些文件的信息，另外通过其他官方文档 gitignore 中的几个 ignore 中仔细查看，很确定项目中并没有忽略这些文件，通过排查最后才发现是 .gitmodules 这个文件捣的鬼。仔细研究发现git-submodule是一个十分强大的功能，值得去学习研究。</p>
<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="external">http://www.kafeitu.me/git/2012/03/27/git-submodule.html</a><br><a href="https://git-scm.com/docs/git-submodule" target="_blank" rel="external">https://git-scm.com/docs/git-submodule</a><br><a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">https://git-scm.com/docs/git-config</a><br><a href="https://git-scm.com/docs/gitignore" target="_blank" rel="external">https://git-scm.com/docs/gitignore</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CRC校验]]></title>
      <url>http://noparkinghere.win/2016/11/22/2016/2016-11-22-crc%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="原理规则"><a href="#原理规则" class="headerlink" title="原理规则"></a>原理规则</h3><a id="more"></a>
<h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK" target="_blank" rel="external">http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK</a><br><a href="http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS" target="_blank" rel="external">http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS</a><br><a href="http://blog.csdn.net/husion01/article/details/17440333" target="_blank" rel="external">http://blog.csdn.net/husion01/article/details/17440333</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[vim学习]]></title>
      <url>http://noparkinghere.win/2016/11/21/2016/2016-11-21-vim%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>vim 和 emacs 一个号称编辑器之神，一个被称为神的编辑器。打开 vim 执行命令：vimtutor 则可以查看官方说明教程，vimtutor是vim使用入门教程。老实说，自从接触vim到现在也有好多年了，但一直没有强迫自己使用，以及它的难定制性，让我至今都还无法像那些大神一样，完全脱离鼠标和IDE，本文对现阶段我学习 vim 进行一个总结，后续还会不断记录更新。</p>
<h3 id="最基本操作"><a href="#最基本操作" class="headerlink" title="最基本操作"></a>最基本操作</h3><ul>
<li>请按<esc>键(这是为了确保您处在正常模式)。</esc></li>
<li>h 的键位于左边，每次按下就会向左移动。</li>
<li>l 的键位于右边，每次按下就会向右移动。</li>
<li>j 键看起来很象一支尖端方向朝下的箭头。</li>
<li>k朝上移动。</li>
<li>:q! &lt;回车&gt;不保存退出。</li>
<li>:wq &lt;回车&gt;保存并退出。</li>
<li>gg 跳到首行</li>
<li>G 跳到末行</li>
<li>yy 复制</li>
<li>p 粘贴</li>
<li>dd 删除单行</li>
<li>u 撤销上次操作</li>
</ul>
<h4 id="复制："><a href="#复制：" class="headerlink" title="复制："></a>复制：</h4><p>vim有12个粘贴板，分别是 <code>0、1、2、...、9、a、&quot;、+</code> 用 :reg 命令可以查看各个粘贴板里的内容。下面讲一下vim的粘贴板的基础知识：</p>
<ul>
<li>+号粘贴板是系统粘贴板，用 “+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用 Ctrl＋C 或右键复制的内容复制到 vim 中，需要在正常模式下按 “+p 。</li>
<li>“ 号粘贴板（临时粘贴板）比较特殊，直接按 y 就复制到这个粘贴板中了，直接按 p 就粘贴这个粘贴板中的内容；</li>
<li>要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按”Np，其中N为粘贴板号，如上所述，可以按”5p将5号粘贴板里的内容粘贴进来，也可以按”+p将系统全局粘贴板里的内容粘贴进来。</li>
</ul>
<a id="more"></a>
<h3 id="常用命令操作"><a href="#常用命令操作" class="headerlink" title="常用命令操作"></a>常用命令操作</h3><h3 id="扩展使用"><a href="#扩展使用" class="headerlink" title="扩展使用"></a>扩展使用</h3><blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/nkguohao/article/details/8937695" target="_blank" rel="external">http://blog.csdn.net/nkguohao/article/details/8937695</a>  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[keil工程的代码优化]]></title>
      <url>http://noparkinghere.win/2016/11/16/2016/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="C项目的工程优化"><a href="#C项目的工程优化" class="headerlink" title="C项目的工程优化"></a>C项目的工程优化</h3><p>这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。</p>
<h3 id="keil"><a href="#keil" class="headerlink" title="keil"></a>keil</h3><p>keil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。</p>
<p>每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。</p>
<p><strong>Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM &gt; Code + RO Data + RW Data  ， 而 RAM &gt; RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png" alt=""></p>
<a id="more"></a>
<p>KDE 生成的 .map 文件分析：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">Product: MDK-ARM Standard 5.10</div><div class="line">Component: ARM Compiler 5.04 update 1 (build 49)</div><div class="line">Tool: armlink [5040049]</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Section Cross References</div><div class="line"></div><div class="line">    main.o(i.AdjustTask) refers to memseta.o(.text) <span class="keyword">for</span> __aeabi_memclr4</div><div class="line">    main.o(i.AdjustTask) refers to analogin.o(i.AnalogInConvert) <span class="keyword">for</span> AnalogInConvert</div><div class="line">	...</div><div class="line">	</div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Removing Unused input sections from the image.</div><div class="line"></div><div class="line">    Removing main.o(.data), (1 bytes).</div><div class="line">    Removing main.o(.data), (4 bytes).</div><div class="line">	...</div><div class="line"></div><div class="line">329 unused section(s) (total 12428 bytes) removed from the image.</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Image Symbol Table</div><div class="line"></div><div class="line">    Local Symbols</div><div class="line"></div><div class="line">    Symbol Name                              Value     Ov Type        Size  Object(Section)</div><div class="line"></div><div class="line">    ../clib/../cmprslib/zerorunl2.c          0x00000000   Number         0  __dczerorl2.o ABSOLUTE</div><div class="line">    ../clib/microlib/division.c              0x00000000   Number         0  uldiv.o ABSOLUTE</div><div class="line">	...</div><div class="line">	</div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Memory Map of the image</div><div class="line"></div><div class="line">  Image Entry point : 0x08000131</div><div class="line"></div><div class="line">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x0001c0c8, Max: 0x00080000, ABSOLUTE, COMPRESSED[0x0001bc94])</div><div class="line"></div><div class="line">    Execution Region ER_IROM1 (Base: 0x08000000, Size: 0x0001baa0, Max: 0x00080000, ABSOLUTE)</div><div class="line"></div><div class="line">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class="line"></div><div class="line">    0x08000000   0x00000130   Data   RO         4967    RESET               startup_stm32f10x_hd.o</div><div class="line">    0x08000130   0x00000000   Code   RO         5008  * .ARM.Collect$$$<span class="variable">$00000000</span>  mc_w.l(entry.o)</div><div class="line">    0x08000130   0x00000004   Code   RO         5086    .ARM.Collect$$$<span class="variable">$00000001</span>  mc_w.l(entry2.o)</div><div class="line">	...</div><div class="line">	</div><div class="line">    Execution Region RW_IRAM1 (Base: 0x20000000, Size: 0x0000f050, Max: 0x00010000, ABSOLUTE, COMPRESSED[0x000001f4])</div><div class="line"></div><div class="line">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class="line"></div><div class="line">    0x20000000   0x00000038   Data   RW           27    .data               main.o</div><div class="line">    0x20000038   0x00000005   Data   RW          422    .data               analogin.o</div><div class="line">	...</div><div class="line">	</div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Image component sizes</div><div class="line"></div><div class="line"></div><div class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</div><div class="line"></div><div class="line">      1252        138          0          5        200       3550   analogin.o</div><div class="line">       704         74         12         24          0       5534   analogout.o</div><div class="line">	...</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line"></div><div class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   </div><div class="line"></div><div class="line">     80732       6214      32580       1576      59944     659393   Grand Totals</div><div class="line">     80732       6214      32580        500      59944     659393   ELF Image Totals (compressed)</div><div class="line">     80732       6214      32580        500          0          0   ROM Totals</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line">    Total RO  Size (Code + RO Data)               113312 ( 110.66kB)</div><div class="line">    Total RW  Size (RW Data + ZI Data)             61520 (  60.08kB)</div><div class="line">    Total ROM Size (Code + RO Data + RW Data)     113812 ( 111.14kB)</div><div class="line"></div><div class="line">==============================================================================</div></pre></td></tr></table></figure>
<p>优化步骤如下：</p>
<ul>
<li>project &gt;&gt; Option for Target “**” 打开如图 2界面。选择“target”，勾选上“Use MicroLIB”再编译。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/2.png" alt=""></p>
<p><strong>分析：microLIB是缺省的C库，而且microLIB进行了高度优化。如果不勾选“Use MicroLIB”，keil会连接标准C库。所以勾选“Use MicroLIB”会减小code大小。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/3.png" alt=""></p>
<ul>
<li>project &gt;&gt; Option for Target “**” 打开如界面。选择“C/C++”，勾选上“One ELF Section per Functin”再编译。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/4.png" alt=""></p>
<p><strong>分析：“One ELF Section per Functin”就是将每个函数都生成一个ELF文件，最会将需要的函数链接成一个大的ELF文件。但是如果没有勾选“One ELF Section per Functin”。Keil将每个文件编译成一个ELF文件（即使文件中用未被使用的函数），最会链接成一个ELF文件。所以勾选“One ELF Section per Functin”会使code变小。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/5.png" alt=""></p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/abclixu123/article/details/46923725" target="_blank" rel="external">http://blog.csdn.net/abclixu123/article/details/46923725</a><br><a href="http://blog.csdn.net/gasbi/article/details/6186312" target="_blank" rel="external">http://blog.csdn.net/gasbi/article/details/6186312</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[notepad++和MinGW]]></title>
      <url>http://noparkinghere.win/2016/11/15/2016/2016-11-15-notepad-%E5%92%8Cmingw/</url>
      <content type="html"><![CDATA[<p>今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。</p>
<h3 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h3><p>Windows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><a href="https://pan.baidu.com/s/1slNDMtn" target="_blank" rel="external">notepad++</a>只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了<a href="https://pan.baidu.com/s/1bFK8TC" target="_blank" rel="external">MinGW-5.1.6</a>离线包，安装步骤很简单，这边不具体阐述。</p>
<a id="more"></a>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><h4 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h4><p>环境变量，简而言之就是在终端中直接输入名称，系统能够识别，且运行的一些可执行文件名称。在（我的电脑右击－－&gt;系统属性－－&gt;高级－－&gt;环境变量－－&gt;系统变量 中）（以下目录都根据自己的电脑MinGW所在位置不同而改变）在PATH的值中加入“D:\MinGW\bin”（如果没有就新建一个PATH）。如果PATH中还有其他内容，需要用英文状态下使用分号进行分割。这是寻找gcc编译器的路径。（这一步中PATH的值根据你的MinGW安装的路径设定，要能够访问的gcc编译器，也就是MInGW安装目录里面的bin文件夹）</p>
<p>下面两步作为可选步骤，如果有确切需求可以添加：新建LIBRARY_PATH变量，在其值中加入“D:\MinGW\lib”。这是标准库存放的路径。新建C_INCLUDE_PATH变量，在其值中加入“D:\MinGW\include”。这是Include查找头文件的路径。</p>
<p>设置结束之后，在cmd控制台窗口下面，输入gcc -v。若已经成功安装好，会显示gcc的版本信息。比如说我的：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-15-notepad-%E5%92%8Cmingw/2.png" alt=""></p>
<p>测试一下：<br>随便找个c文件，你也可以自己写个。使用命令提示符cd到c文件保存的目录，然后：输入<code>gcc -o test.exe (你的c文件名).c</code>如果有提示语法错误或者在当前目录生成了test.exe那说明gcc可用了，如果提示 ‘gcc’ 不是内部或外部命令，也不是可运行的程序或批处理文件。说明环境MinGW的环境变量未设置成功。</p>
<h4 id="notepad"><a href="#notepad" class="headerlink" title="notepad++"></a>notepad++</h4><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-15-notepad-%E5%92%8Cmingw/1.png" alt=""></p>
<p>如上图，选用自己喜欢的风格模式，对里面的一些背景参数适当的设置，将行号等常用的功能打开，可以隐藏一些不需要的工具栏，菜单中列出了可以执行的一些操作，适当借用于快捷键可以更快的编写代码。</p>
<p>由于这边主要是让notepad++可以一键编译c程序，所以为其加上编译，运行。</p>
<ul>
<li>编译：按F5输入<code>cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT</code> 点保存，设置快捷键为F9</li>
<li>运行：按F5输入<code>cmd /k &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F9</li>
</ul>
<p>上述两步，环境搭建完成，当你用N++编写程序时，先保存再按F9可编译，然后再按Ctrl+F9开看到运行结果。</p>
<p>熟练习惯后，可以将编译运行一起使用：<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; cmd /k &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>或者<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; pause &amp; &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F5。</p>
<p><strong>关键字说明：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">引号的使用是为了适用于文件名或者路径中带有空格的情况，一定不能省略。</div><div class="line">&amp; PAUSE 含义是命令运行后暂停等待键盘操作</div><div class="line">&amp; EXIT 含义是完成后退出运行窗口，回到notepad++</div><div class="line">$(NAME_PART) 代表当前正操作的文件的文件名，不含后缀；</div><div class="line">$(FULL_CURRENT_PATH) 代表当前正操作的文件的完整路径，包括盘符、路径、文件名、后缀；</div><div class="line">$(CURRENT_DIRECTORY) 代表当前文件所在的目录路径；</div><div class="line">通过以上三个环境变量可以很容易的理解上面一段指令的含义。</div><div class="line">至于gcc，-o参数就是将一个c文件编译成exe文件。gcc的bin目录已经之前在系统环境变量中进行过设定，否则需要补全gcc命令的绝对路径。(很简单，将<span class="string">"g++.exe"</span>换成<span class="string">"D:\MinGW\bin\g++.exe"</span>,还是要参照你安装的路径）</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html" target="_blank" rel="external">http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[美国总统诞生了]]></title>
      <url>http://noparkinghere.win/2016/11/10/2016/2016-11-10-%E7%BE%8E%E5%9B%BD%E6%80%BB%E7%BB%9F%E8%AF%9E%E7%94%9F%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。</p>
<p>就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。</p>
<p>其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。</p>
<p>其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。</p>
<p>当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。</p>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言工程组建]]></title>
      <url>http://noparkinghere.win/2016/11/10/2016/2016-11-10-c%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E7%BB%84%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。</p>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 编程技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待蓝绿大厂问鼎中国]]></title>
      <url>http://noparkinghere.win/2016/11/03/2016/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/</url>
      <content type="html"><![CDATA[<p>根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。</p>
<hr>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg" alt=""></p>
<h3 id="差强人意"><a href="#差强人意" class="headerlink" title="差强人意"></a>差强人意</h3><p>就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。</p>
<p>在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。</p>
<p>音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。</p>
<p>快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。</p>
<p>在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。</p>
<p>软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。</p>
<p>说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。</p>
<p>举个例子：OV两家的CPU &lt; 荣耀6的CPU，OV两家的CPU &lt; MI4的CPU；OV两家的GPU &gt; 荣耀6的GPU，OV两家的GPU &lt; MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。</p>
<p>因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。</p>
<p>对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。</p>
<p>综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg" alt=""></p>
<a id="more"></a>
<h3 id="信息轰炸"><a href="#信息轰炸" class="headerlink" title="信息轰炸"></a>信息轰炸</h3><p>这个时代是改革开放来最差的时代，因为经济增长缓慢，民营实业入不敷出，房价虚高，资本的寒冬；但这个时代缺失娱乐业最好的时代，各种综艺节目，电视电影，网剧直播等层出不穷，一个全民娱乐的时代。OV两家恰恰是这个时代最大的受益者之一，在娱乐圈，电视台，广告界磨辊打趴了这么多年，积累了深厚的资源和用户，动辄数亿的广告，但却往往能够找准最佳的商机，带来丰厚的回报。细数OV两家的广告可以遍布你身边的一切，从最初的湖南卫视到浙江卫视，从多个热门综艺节目到热门电视剧，从微博到微信。无论你是做哪一行的，逃到哪儿都可以看到这两家的广告。</p>
<p>绝大多数用户的心理都是从众的，OV两家前几年在小米混的风生水起的时候，只能通过电视广告来发展自己偏远地区的业务，那时候两家主要的购买群体一般是三四线城市或者农村，因为网络物流不发达，用户主要获取信息途径通过电视，所以来自这些地方的用户大都购买这两款手机。OV两家那时候属于闷声赚钱，相比于“中酷联”这三家，既不用面对激烈的竞争，也还能谋取较高的利润，但市场占有率不算高，算是小日子过得还不错。</p>
<p>仔细研究OV两家的进程，颇有点“农村包围城市”的韵味，OV两家最近的之所以能够逆袭，不是得益于自身手机的发展，恰恰是整个行业的不发展，苹果两年一大步今年都已经干脆不走了。早从13年的同质化开始，整个行业已经陷入了僵局，各个产品几乎不存在差异化，或者只是微差异化。OV两家只要跟着谷歌走，产品做的不是实在太烂，在有一定知名度的前提下，就可以掌握更多用户。如果说早期的OV两家是牢牢把控了小城市和农村，那现在就是“农村包围城市”，这两家很大成都就是说服了互联网，一二线城市中的原有苹果用户，老旧安卓机转型过来的用户以及追星的用户来购买他们的产品而实现销量增长的。老苹果用户在更新手机的时候想体验其他平台或者因为预算选择稍微便宜的手机，OV两家一般都会是他们的首选，原因有两点：1.广告效应，论知名度，两家无出其右，其他国产机都具备屌丝标签。2.OV两家刻意模仿苹果，用户体验各方面几乎可以和苹果无缝对接了，连图标都做的一致。老旧安卓机用户的原因可以分为两点：1.耳熟能详的知名度。2.更好的外观和体验。</p>
<p>综上可以看出，不断地信息轰炸，建立自己的品牌影响力，让观众普遍认为你手机还不错，这点很重要。在苹果和三星占有率再创新低时，OV两家的信息轰炸还是很有效果的。</p>
<h3 id="低调专注"><a href="#低调专注" class="headerlink" title="低调专注"></a>低调专注</h3><p><strong>低调专注算是一个褒义词，这边我们只就事论事</strong>，众所周知，做任何事情专注最为重要，OV两家的成功决不能排除专注这一点，当别人都在迫于小米荣耀等线上角逐的势头，而不得不做互联网营销时，这两家却反其道而行之，专注于线下（因为他们也知道自己的手机那时在智能机时代确实毫无竞争力可言），构建更加完善的线下渠道，在更多传统媒体上面布满广告，给予经销商高回报率等，这些都奠定了它成功的基础。我们来重新回顾思考这些事情，当初其实OV在做大规模营销和扩大线下建设时，其实大多数人都认为，这已经是个信息化社会了，线下终将被淘汰，减少中间商环节才是未来数码3C的大势所趋。但事实证明，大多数人的观点并不正确，中国的城市化进程，网络物流的推广覆盖远不是坐在高层写字楼办公的金领白领可以看清的，中国仍然有6亿的农村人口，即便他们可以使用网络但却没有物流，小型城市人口也仍然在中国占了很大的比重，他们虽然可以使用网络，但未必人人都会完全融入信息化社会。可以看出OV两家的“农村包围城市”的战略还是很明智的，这些地盘往往是被忽视了的金库。</p>
<p>各家在网络上面都会进行营销。锤子小米华为等，微博，贴吧上粉黑水军争吵不断。当提及OV两家，不得不说一个有趣的现象，几乎所有这些互联网品牌的手机用户的都看不上OV两家，谁和它比都不屑。这也导致，市面上几乎就找不到OV两家手机的测评，一些测评花了几分钟说了下外观和界面，然后说“这手机就这样也没什么好说的”，但这两家公司历来低调，对这些评论从来都不进行任何回复，也就是说直接无视你们，因为他们知道这些人不是他们的用户群，把事情闹大，万一大家都知道你手机不好，那咋办？另一个低调表现在对高通和谷歌的顺从，当其某厂家发声质疑高通的垄断时而期望获取更多话语权的时候，OV两家义无反顾地积极配合响应高通等公司，这主要取决于他们知道自身的定位，缺乏核心技术，软件研发调优能力弱，同时也不具备芯片等研发能力，所以业务重点更能定为清晰，只做产品的整装与宣传。可见<strong>在商言商</strong>，专注低调赚钱往往更能够成功！</p>
<h3 id="外观精良"><a href="#外观精良" class="headerlink" title="外观精良"></a>外观精良</h3><p>外观这边用不美这个词，还是很讲究的，在我看来精美这个词只能用于“在一定的时期，能够满足社会上8,9成数用户的审美标准，那才可以称得上是精美”，iphone 4刚出来的时候是可以算上精美的，而iphone 6的机身和背面惊人的白带，还是离精美差的较远的。精致的话，一般用在工业制造上面极为考究的产品，如小米的工业陶瓷机身，所以这边考虑到这两家做外观虽然都能看到很多苹果的影子，但还算是用料不错，品质有保证。</p>
<p>就OV的外观而言，国产手机中，也就只有魅族可以和它一起争夺女性用户了。</p>
<p>国内小米和华为在外观上面都有着浓厚的工科生或中年人审美情怀，OPPO，VIVO，魅族的外观类似苹果材质和颜色看起来也更加清新和明快，虽然不能如galaxy edge系类满足绝大多数人审美，但往往更讨年轻人和女性用户的喜欢。这一点尤为重要，上述提到过，当今社会，手机早已同质化严重，创新疲乏，所以试问普通用户除了外观还有啥可以追求？！换句话说，即便各家仍然有软件体验，应用等创新层出不穷，但毕竟这是个看脸的社会，有多少人会喜欢小米正面左上方的LOGO？举个例子：亲身经历，身边有50岁大妈，之前用手机只打电话，所以一直用的红米之类的千元机，现在周围人都用微信，所以入手一智能机，本来是去看华为的手机，结果转了一圈，都嫌太丑，最后买了VIVO的一款主打机型。连三星都将国行版正面LOGO给去掉了，可见对于国人来说，颜值是多么重要！</p>
<p>综上，OV虽然未必美观漂亮，但最起码有明星加持，有苹果的影子，用户不会觉得像其他国产机一样丑，智能手机已经快走过了10个年头，如果它寿命还没有结束的话，未来的竞争恐怕也只有外观的竞争了吧。</p>
<h3 id="高回报率"><a href="#高回报率" class="headerlink" title="高回报率"></a>高回报率</h3><p>再好的策略都离不开优秀的执行者，OV两家的成功离不开线下销售人员的三寸不烂之舌，如何让调用手机销售的积极性，让他们都来卖你的手机，而不是卖其他品牌的呢？大家如果有去电脑城战JS的经理的话，都会知道，JS推荐笔记本或者品牌机都是有选择性的，贵的他不一定推荐给你，便宜的也不一定推荐给你，他们会选择自己赚的最多的推荐给你，举例子说：他们会极力诱导你放弃购买6000的电脑（他只能赚800），而去买4200的电脑（因为他能赚1500）。OV两家同样是如此，在高提成高回报率的前提下，很多销售甚至会阻止你购买其他机型，而大力诱导你买这两家的手机。</p>
<h3 id="稳步求变"><a href="#稳步求变" class="headerlink" title="稳步求变"></a>稳步求变</h3><p>OV在广告领域可谓早有心得，但近期可以看到在微博微信流媒体视频都可以看到OV两家的身影，要想一直繁荣，就必须有增长，只是市场经济不变的法则。OV两家也是看到早已坐实了线下渠道，通过种种手段完成了资本的原始积累，所以从今年开始攻占线上渠道，也就是说等线上销售基本已经定型，各家玩不出什么花样的时候，他们直接拿过来照搬，再加上线下和主流媒体渠道实现全范围的对大家进行轰炸，最终这两个季度用户数量激增，拿下了市场冠亚军的宝座。</p>
<p>总结：虽然黑了OV两家这么多年，但也不得不承认他们确确实实有自身的可取之处。写了这么多，我们可以看出，OV两家成功的主要原因：自始至终大力投资广告，一点点增加自己的品牌影响和曝光度；早期依靠线下在智能机行业站稳脚跟，达到原始资本的积累；后期为了再增长，主打外观，将广告进一步做大，做广，最终在国内手机行业登顶。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>存在即为合理，我们不能否认最近两年来OV两家在市场拓展上面的成功，就如当年小米开创互联网营销模式一样，OV用同样利用全民娱乐，线上线下互补，手机制造门槛降低等打出了一手好牌。但如果一味的模仿抄袭，产品无特色体验差等，最终当消费者觉醒时，依然会被市场所抛弃。我们有理由相信好的产品真金不怕火炼，最终才会经得起消费者检验；但同时，手段和策略能更快地给我们带来更多的资金和市场也同样至关重要。一个公司要想能够持续性发展，势必需要将资金反馈到自己的产品中才行，否则<em>挂羊头卖狗肉</em>的事最终会被揭露出来。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[uart/spi/iic的比较]]></title>
      <url>http://noparkinghere.win/2016/10/30/2016/2016-10-30-uart-spi-iic%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[大端和小端]]></title>
      <url>http://noparkinghere.win/2016/10/30/2016/2016-10-30-%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/</url>
      <content type="html"><![CDATA[<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>
<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。</p>
<p><strong>端模式(Byte Endian)</strong> 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。</p>
<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>
<p>注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。</p>
<h3 id="端模式-Byte-Endian-简述"><a href="#端模式-Byte-Endian-简述" class="headerlink" title="端模式(Byte Endian)简述"></a>端模式(Byte Endian)简述</h3><ul>
<li><p>大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01-&gt;1000，0x23-&gt;1001，0x45-&gt;1002，0x67-&gt;1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。</p>
</li>
<li><p>小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67-&gt;1000，0x45-&gt;1001，0x23-&gt;1002，0x01-&gt;1003这种顺序存储。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。</p>
</li>
</ul>
<p>除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。</p>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。</p>
<p>描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：</p>
<ul>
<li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 同 0x789A6B 次序一致，这种更加符合人的阅读习惯。大端更加符合人的阅读习惯，自左往右的依次增高的阅读习惯。</li>
<li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 看起来并不容易阅读。小端比较符合人的一般思维逻辑（注意仅仅符合思维逻辑，并不符合阅读习惯）。</li>
</ul>
<p>这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实没有一个统一的标准，串口传输数据时一般都满足原则：<strong>先传输字符的低位，后传输字符的高位</strong>；然而在某些通信协议中却刚好相反，如 SPI 中，就是<strong>先传输字符的高位，后传输字符的低位</strong>的方式。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-30-大端和小端/1.png" alt=""></p>
<ul>
<li><em>以下内容引用自阮一峰老师的博客：</em>  </li>
</ul>
<blockquote>
<p>首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。<br>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
</blockquote>
<p>个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。</p>
<h3 id="记忆方法"><a href="#记忆方法" class="headerlink" title="记忆方法"></a>记忆方法</h3><blockquote>
<p>在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。</p>
</blockquote>
<p>这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。</p>
<h3 id="测试大小端参考代码："><a href="#测试大小端参考代码：" class="headerlink" title="测试大小端参考代码："></a>测试大小端参考代码：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">方法1：</div><div class="line">typedef unsigned char u8;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	unsigned long int a = 0x01020304;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (u8 i = 0; i &lt; 4; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, *((u8 *)&amp;a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果结果为：4321则为小端模式，而1234为大端模式。</div><div class="line"></div><div class="line">方法2：</div><div class="line"></div><div class="line">typedef union</div><div class="line">&#123;</div><div class="line">	unsigned short int a;</div><div class="line">	unsigned char b;</div><div class="line">&#125;Union;</div><div class="line"></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	Union u1;</div><div class="line">	u1.a = 0x0201;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (u1.b == 0x01)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (u1.b == 0x02)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/vvzaixian/article/details/7067221" target="_blank" rel="external">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href="http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml" target="_blank" rel="external">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href="https://my.oschina.net/chaenomeles/blog/673091" target="_blank" rel="external">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href="http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[字节对齐]]></title>
      <url>http://noparkinghere.win/2016/10/30/2016/2016-10-30-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
      <content type="html"><![CDATA[<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>
<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</p>
<h3 id="字节对齐（Byte-Alignment）"><a href="#字节对齐（Byte-Alignment）" class="headerlink" title="字节对齐（Byte Alignment）"></a>字节对齐（Byte Alignment）</h3><p>我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。</p>
<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 <em> 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。<strong>基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数</strong>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<em>*为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</em></em>。</p>
<p>举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>
<p>结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然<strong>结构体变量首地址必须是4字节对齐的</strong>，但是<strong>结构体的每个成员有各自默认的对齐方式</strong>，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且<strong>第一个成员的首地址等于整个结构体变量的首地址</strong>。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">char(1字节)，1字节对齐</div><div class="line">short(2字节)，2字节对齐</div><div class="line">int(4字节)，4字节对齐</div><div class="line"><span class="built_in">float</span>(4字节)，4字节对齐</div><div class="line">double(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。</div><div class="line">*不同CPU的对其规则可能不同, 请参考手册。*</div></pre></td></tr></table></figure>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>
<a id="more"></a>
<h3 id="对齐的算法："><a href="#对齐的算法：" class="headerlink" title="对齐的算法："></a>对齐的算法：</h3><p>由于各个平台和编译器的不同，现以 gcc 3.4.5 编译器（x64平台）为例，来讨论编译器对 struct 数据结构中的各成员如何进行对齐的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">测试程序如下：</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	long int a;</div><div class="line">	char b;</div><div class="line">	short c;</div><div class="line">&#125;STRU_A;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	long int a;</div><div class="line">	short c;</div><div class="line">&#125;STRU_B;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, sizeof (STRU_A), sizeof (STRU_B));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体 A 中包含了 4 字节长度的 int 1个，1 字节长度的 char 1个和 2 字节长度的 short 型数据1个。所以 A 用到的空间应该是 7 字节。但是因为编译器要对数据成员在空间上进行对齐。所以使用 sizeof(STRU_A)值为 8。现在把该结构体调整成员变量的顺序。这时候同样是总共 7 个字节的变量，但是 sizeof(STRU_B)的值却是 12。</p>
<p>程序编译器对结构存储的特殊处理确实提高了CPU的存储变量速度，但有时候也会带来一些麻烦，这边我们使用#pragma pack (value)来屏蔽掉变量默认的对齐方式。下面我们使用预编译指令#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">进一步我们修改代码：</div><div class="line"></div><div class="line"><span class="comment">#pragma pack (2) /*指定按 2 字节对齐*/</span></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	long int a;</div><div class="line">	short c;</div><div class="line">&#125;STRU1;</div><div class="line"><span class="comment">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span></div><div class="line"></div><div class="line"><span class="comment">#pragma pack (1) /*指定按 1 字节对齐*/</span></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	long int a;</div><div class="line">	short c;</div><div class="line">&#125;STRU2;</div><div class="line"><span class="comment">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, sizeof (STRU1), sizeof (STRU2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeof(STRU1)值为 7。对于 char 型数据，其自身对齐值为 1，对于 short 型为 2，对于 int,float,double类型，其自身对齐值为 4，单位字节。</p>
<p>这里面有四个概念值：</p>
<ul>
<li>数据类型自身的对齐值：就是上面交代的基本数据类型的自身对齐值。</li>
<li>指定对齐值：#pragma pack (value)时的指定对齐值 value。</li>
<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>
</ul>
<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值 N 是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在 N 上”，也就是说该数据的”存放起始地址%N=0”.而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">例子分析：</div><div class="line">分析例子 B；</div><div class="line">struct B</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	int a;</div><div class="line">	short c;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;同理,分析上面例子C：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pragma pack (2) /*指定按 2 字节对齐*/</span></div><div class="line">struct C</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	int a;</div><div class="line">	short c;</div><div class="line">&#125;;</div><div class="line"><span class="comment">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span></div></pre></td></tr></table></figure>
<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。</p>
<p>下面是一个有char，int，short三种类型，4个成员组成的结构体，该结构体在还未编译之前是大小占8个字节。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct AlignData</div><div class="line">&#123;</div><div class="line">	char a;</div><div class="line">	short b;</div><div class="line">	int c;</div><div class="line">	char d;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译之后，为了保持结构体中的每个成员都是按照各自的对齐，编译器会在一些成员之间插入一些padding，因此编译后得到如下的结构体：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct AlignData </div><div class="line">&#123;</div><div class="line">	char a;</div><div class="line">	char Padding0[1];</div><div class="line">	short b;</div><div class="line">	int c;</div><div class="line">	char d;</div><div class="line">	char Padding1[3];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译后该结构体的大小为12个字节，<strong>最后一个成员d后面填充的字节数要使该结构体的总大小是其成员类型中拥有最大字节数的倍数</strong>(int拥有最大字节数)，因此d后面要填充3个字节。</p>
<p>通过以上的详细分析，我们可以总结编译器在自动分配结构体类型对齐时，<strong>一般是以第一个数据为基准值，然后往后累加地址查找，最终确保将每个需要分配的数据分配到sizeof(data)整数倍的地址上面。至于那些在查找过程中不满足要求的存储空间就空出。</strong>一般主要满足以下规则：</p>
<ul>
<li>单个字节(char)能对齐到任意地址</li>
<li>2字节(short)以2字节边界对齐</li>
<li>4字节(int, long)以4字节边界对齐</li>
</ul>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/vvzaixian/article/details/7067221" target="_blank" rel="external">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href="http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml" target="_blank" rel="external">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href="https://my.oschina.net/chaenomeles/blog/673091" target="_blank" rel="external">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href="http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SPI通信详解]]></title>
      <url>http://noparkinghere.win/2016/10/29/2016/2016-10-29-spi%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>SPI 相比其他协议算是比较简单的，本来是去年要总结的一篇文章，但由于偷懒只把部分参考链接放出来了，隔了很长时间，才下定决心将内容整理出来，之前写过 uart 还有其他一些内容，要完整的表述出来，还是相当占用篇幅的。</em></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>SPI, Serial Perripheral Interface, 串行外围设备接口, 是 Motorola 公司推出的一种同步串行接口技术. SPI 总线在物理上是通过接在外围设备微控制器(PICmicro) 上面的微处理控制单元 (MCU) 上叫作同步串行端口(Synchronous Serial Port) 的模块(Module)来实现的, 它允许 MCU 以全双工的同步串行方式, 与各种外围设备进行高速数据通信.SPI最大的特点是由主设备时钟信号的出现与否来确定主／从设备间的通信。一旦检测到主设备的时钟信号，数据开始传输。SPI 是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为 PCB 的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如 AT91RM9200，stm32，efm32等等。</p>
<p>SPI 主要应用在 EEPROM, Flash, 实时时钟(RTC), 数模转换器(ADC), 数字信号处理器(DSP) 以及数字信号解码器之间. 它在芯片中只占用四根管脚 (Pin) 用来控制以及数据传输, 节约了芯片的 pin 数目, 同时为 PCB 在布局上节省了空间. 正是出于这种简单易用的特性, 现在越来越多的芯片上都集成了 SPI技术.</p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（单向传输时）。也是所有基于SPI的设备共有的，它们是SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）。</p>
<ul>
<li>SDO/MOSI：主设备数据输出，从设备数据输入</li>
<li>SDI/MISO：主设备数据输入，从设备数据输出</li>
<li>SCLK：时钟信号，由主设备产生（除非需要指定频率如： uart ，其他通讯一些一般都会配上一个时钟总线）</li>
<li>CS：从设备使能信号，由主设备控制，主设备可以通过 CS 来选择究竟读写哪个从设备</li>
</ul>
<p>CS: 其中CS是控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），对此芯片的操作才有效，这就允许在同一总线上连接多个SPI设备成为可能。</p>
<p>SDI/SDO/SCLK: 通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCK时钟线存在的原因，由SCK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。这样，在至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="采用主-从模式-Master-Slave-的控制方式"><a href="#采用主-从模式-Master-Slave-的控制方式" class="headerlink" title="采用主-从模式(Master-Slave) 的控制方式"></a>采用主-从模式(Master-Slave) 的控制方式</h4><p>SPI 规定了两个 SPI 设备之间通信必须由主设备 (Master) 来控制次设备 (Slave). 一个 Master 设备可以通过提供 Clock 以及对 Slave 设备进行片选 (Slave Select) 来控制多个 Slave 设备, SPI 协议还规定 Slave 设备的 Clock 由 Master 设备通过 SCK 管脚提供给 Slave 设备, Slave 设备本身不能产生或控制 Clock, 没有 Clock 则 Slave 设备不能正常工作。</p>
<h4 id="采用同步方式-Synchronous-传输数据"><a href="#采用同步方式-Synchronous-传输数据" class="headerlink" title="采用同步方式(Synchronous)传输数据"></a>采用同步方式(Synchronous)传输数据</h4><p>Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse), 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过时钟极性 (CPOL) 和 时钟相位 (CPHA) 控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的。</p>
<h4 id="数据交换-Data-Exchanges"><a href="#数据交换-Data-Exchanges" class="headerlink" title="数据交换(Data Exchanges)"></a>数据交换(Data Exchanges)</h4><p>SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个 “发送者(Transmitter)” 或者 “接收者(Receiver)”. 在每个 Clock 周期内, SPI 设备都会发送并接收一个 bit 大小的数据, 相当于该设备有一个 bit 大小的数据被交换了。</p>
<p>一个 Slave 设备要想能够接收到 Master 发过来的控制信号, 必须在此之前能够被 Master 设备进行访问 (Access)。 所以, Master 设备必须首先通过 SS/CS pin 对 Slave 设备进行片选, 把想要访问的 Slave 设备选上。</p>
<a id="more"></a>
<h3 id="模拟-SPI"><a href="#模拟-SPI" class="headerlink" title="模拟 SPI"></a>模拟 SPI</h3><p>SPI 并非芯片必须集成的功能，很多过去的芯片都没有集成该功能，但我们依然可以通过控制 IO 高低电平/输入输出，来模拟出芯片手册上面要求的信号，下面我以 FM25W256-G 为例做个简单说明。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 以下程序临时改写，未经过实验验证 */</span></div><div class="line"></div><div class="line"><span class="comment">/* SPI端口初始化 */</span>  </div><div class="line"><span class="keyword">void</span> spi_init()  </div><div class="line">&#123;  </div><div class="line">    set_gpio_direction(SS, OUTP);  </div><div class="line">    set_gpio_direction(SCLK, OUTP);  </div><div class="line">    set_gpio_direction(MOSI, OUTP);  </div><div class="line">    set_gpio_direction(MISO, INP);  </div><div class="line">    set_gpio_value(SCLK, <span class="number">0</span>);     <span class="comment">//CPOL=0  </span></div><div class="line">    set_gpio_value(MOSI, <span class="number">0</span>);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">从设备使能 enable：为1时，使能信号有效，SS低电平为0时，使能信号无效，SS高电平</div><div class="line">*/  </div><div class="line"><span class="keyword">void</span> ss_enable(<span class="keyword">int</span> enable)  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">if</span> (enable)  </div><div class="line">        set_gpio_value(SS, <span class="number">0</span>);     <span class="comment">//SS低电平，从设备使能有效  </span></div><div class="line">    <span class="built_in">else</span>  </div><div class="line">        set_gpio_value(SS, <span class="number">1</span>);     <span class="comment">//SS高电平，从设备使能无效  </span></div><div class="line">&#125;  </div><div class="line"> <span class="comment">/* SPI字节写 */</span>  </div><div class="line"><span class="keyword">void</span> spi_write_byte(<span class="keyword">unsigned</span> <span class="keyword">char</span> b)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="built_in">for</span> (i=<span class="number">7</span>; i&gt;=<span class="number">0</span>; i--) &#123;  </div><div class="line">        set_gpio_value(SCLK, <span class="number">0</span>);  </div><div class="line">        set_gpio_value(MOSI, b&amp;(<span class="number">1</span>&lt;&lt;i));   <span class="comment">//从高位7到低位0进行串行写入  </span></div><div class="line">        <span class="built_in">delay</span>();       <span class="comment">//延时  </span></div><div class="line">        set_gpio_value(SCLK, <span class="number">1</span>);    <span class="comment">// CPHA=1，在时钟的第一个跳变沿采样  </span></div><div class="line">        <span class="built_in">delay</span>();   </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/* SPI字节读 */</span>  </div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> spi_read_byte(<span class="keyword">void</span>)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r = <span class="number">0</span>;  </div><div class="line">    <span class="built_in">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;  </div><div class="line">        set_gpio_value(SCLK, <span class="number">0</span>);  </div><div class="line">        <span class="built_in">delay</span>();       <span class="comment">//延时  </span></div><div class="line">        set_gpio_value(SCLK, <span class="number">1</span>);    <span class="comment">// CPHA=1，在时钟的第一个跳变沿采样  </span></div><div class="line">        r = (r &lt;&lt;<span class="number">1</span>) | get_gpio_value(MISO);   <span class="comment">//从高位7到低位0进行串行读出  </span></div><div class="line">        <span class="built_in">delay</span>();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> SPI写操作  buf：写缓冲区  len：写入字节的长度 </div><div class="line">*/  </div><div class="line"><span class="keyword">void</span> spi_write (<span class="keyword">unsigned</span> <span class="keyword">int</span> add, <span class="keyword">unsigned</span> <span class="keyword">char</span> date)  </div><div class="line">&#123;  </div><div class="line">    spi_init();       <span class="comment">//初始化GPIO接口  </span></div><div class="line">    ss_enable(<span class="number">1</span>);       <span class="comment">//从设备使能有效，通信开始  </span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    spi_write_byte(<span class="number">0x06</span>);  	<span class="comment">// 写使能指令</span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    ss_enable(<span class="number">0</span>);       </div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">	</div><div class="line">    ss_enable(<span class="number">1</span>);       <span class="comment">//从设备使能有效，通信开始  </span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    spi_write_byte(<span class="number">0x02</span>);  	<span class="comment">// 写指令</span></div><div class="line">    spi_write_byte((add&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>);  	<span class="comment">// 写高地址</span></div><div class="line">    spi_write_byte(add&amp;<span class="number">0xff</span>);  	<span class="comment">// 写低地址</span></div><div class="line">    spi_write_byte(date);  <span class="comment">// 写数据</span></div><div class="line">    <span class="built_in">delay</span>();  </div><div class="line">    ss_enable(<span class="number">0</span>);       <span class="comment">//从设备使能无效，通信结束  </span></div><div class="line">&#125;  </div><div class="line"><span class="comment">/* </span></div><div class="line">SPI读操作 buf：读缓冲区 len：读入字节的长度 </div><div class="line">*/  </div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> spi_read(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len)  </div><div class="line">&#123;  </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> res;</div><div class="line">    spi_init();       <span class="comment">//初始化GPIO接口  </span></div><div class="line">    ss_enable(<span class="number">1</span>);       <span class="comment">//从设备使能有效，通信开始  </span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    spi_write_byte(<span class="number">0x03</span>);  	<span class="comment">// 写指令</span></div><div class="line">    spi_write_byte((add&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>);  	<span class="comment">// 写高地址</span></div><div class="line">    spi_write_byte(add&amp;<span class="number">0xff</span>);  	<span class="comment">// 写低地址</span></div><div class="line">    res = spi_read_byte();  <span class="comment">// 写数据</span></div><div class="line">    <span class="built_in">delay</span>();  </div><div class="line">    ss_enable(<span class="number">0</span>);       <span class="comment">//从设备使能无效，通信结束  </span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = <span class="number">0</span>;</div><div class="line">	spi_init();</div><div class="line">	spi_write_byte(<span class="number">0xaa</span>, <span class="number">0x22</span>);</div><div class="line">	tmp = spi_read_byte(<span class="number">0xaa</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上述代码我们不难发现，在使用模拟 SPI 时，可以方便我们移植，且不会增加特定寄存器的配置难度，但同时也以为着会增加代码量，且时钟要控制的比较精准才可以读取成功。</p>
<h3 id="寄存器操作-SPI"><a href="#寄存器操作-SPI" class="headerlink" title="寄存器操作 SPI"></a>寄存器操作 SPI</h3><p>使用寄存器配置 SPI，每个芯片厂家都不尽相同，会有自己的独家配置，这边为了文章的完整性，以 stm32 为例举个简答的例子。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>相比 IIC 等其他协议而言，SPI 操作比较简单，但会占用更多的资源。同任何其他协议一样，在使用 SPI 进行通信时，也需要仔细阅读芯片手册，以下介绍一些可以会引起读写失败，容易忽视的问题：</p>
<h4 id="时钟生效"><a href="#时钟生效" class="headerlink" title="时钟生效"></a>时钟生效</h4><p>在看芯片手册时，往往不同的 SPI 通讯设备，会存在不同的时钟周期，有效，如上面 FM25W256-G 就是在上升沿时有效，而少数芯片却可能会是下降沿有效，在使用 SPI 控制芯片时首先第一步就是该仔细看时钟周期，如果你在配置寄存器时，忽略了这点往往会读写失败。</p>
<h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>同样芯片手册会详细指定是 MSB 还是 LSB 这点也要仔细阅读，不然容易造成数据错误。</p>
<h4 id="指令操作顺序"><a href="#指令操作顺序" class="headerlink" title="指令操作顺序"></a>指令操作顺序</h4><p>操作指令的顺序很重要，FM25W256-G 这款芯片就仅指定了每次写时需要先使能，我们需要仔细阅读手册的时序图，查看使能时是否作为一个完整的执行周期。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>写作时间：20:30-22:30</p>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://baike.baidu.com/item/SPI" target="_blank" rel="external">http://baike.baidu.com/item/SPI</a><br><a href="https://my.oschina.net/freeblues/blog/67400" target="_blank" rel="external">https://my.oschina.net/freeblues/blog/67400</a><br><a href="http://www.cnblogs.com/hello2mhb/p/3518974.html" target="_blank" rel="external">http://www.cnblogs.com/hello2mhb/p/3518974.html</a><br><a href="http://www.cnblogs.com/aaronLinux/p/6219146.html" target="_blank" rel="external">http://www.cnblogs.com/aaronLinux/p/6219146.html</a><br><a href="http://blog.csdn.net/special_lin/article/details/12835863" target="_blank" rel="external">http://blog.csdn.net/special_lin/article/details/12835863</a><br><a href="http://blog.csdn.net/zyboy2000/article/details/11861329" target="_blank" rel="external">http://blog.csdn.net/zyboy2000/article/details/11861329</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[MSB 和 LSB]]></title>
      <url>http://noparkinghere.win/2016/10/29/2016/2016-10-29-msb-%E5%92%8C-lsb/</url>
      <content type="html"><![CDATA[<p>MSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：</p>
<ul>
<li>MSB ： Most Significant Bit，LSB ： Least Significant Bit</li>
<li>MSB ： Most Significant Byte，LSB ： Least Significant Byte</li>
</ul>
<p>但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。</p>
<h3 id="高低位"><a href="#高低位" class="headerlink" title="高低位"></a>高低位</h3><p>MSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。</p>
<p>一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是<strong>重要位（Most Significant Bit</strong>，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明<strong>Data is written MSB first</strong>。</p>
<p>但值得注意的是，uart 通讯中全部采用<strong>Data is written LSB first</strong>，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。</p>
<h3 id="高低字节"><a href="#高低字节" class="headerlink" title="高低字节"></a>高低字节</h3><p>MSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。</p>
<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>
<p>计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux分区问题]]></title>
      <url>http://noparkinghere.win/2016/10/28/2016/2016-10-28-linux%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>分区功能是个使用系统时候的必备功能，但却不特别常用，所以每次使用时难免会因为不记得指令或者错误使用指令而导致一些没必要的错误发生，建议如果不是经常分区，对步骤不是记得太清楚的话，在分区前还是搜索一下详细步骤，免得出了问题仍然不自知。笔者之所以写这篇文章就是潜意识中觉得分区步骤简单，然后出了问题，还不知道问题出在哪儿。</p>
<h3 id="简述分区步骤："><a href="#简述分区步骤：" class="headerlink" title="简述分区步骤："></a>简述分区步骤：</h3><ul>
<li>df:可以查看下当前系统<strong>挂载了的分区</strong>，如下图所示</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Filesystem     1K-blocks     Used Available Use% Mounted on</div><div class="line">udev             4044748        0   4044748   0% /dev</div><div class="line">tmpfs             812844     9744    803100   2% /run</div><div class="line">/dev/sda2       47930248 11323396  34149048  25% /</div><div class="line">tmpfs            4064220   349608   3714612   9% /dev/shm</div><div class="line">tmpfs               5120        4      5116   1% /run/lock</div><div class="line">tmpfs            4064220        0   4064220   0% /sys/fs/cgroup</div><div class="line">/dev/sda1         497696     3668    494028   1% /boot/efi</div><div class="line">/dev/sda3       95990540 70935460  20155908  78% /home</div><div class="line">tmpfs             812844       12    812832   1% /run/user/1000</div><div class="line">/dev/sda5      142794248 34011608 101506060  26% /home/demon/Space</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>也可以使用sudo fdisk -l 看当前系统存在的分区信息</li>
<li>下面开始分区，使用sudo fdisk /dev/sda，这边要对sda设备进行分区，主要看你要对哪块盘进行分区，如果有第二块盘，则是sdb。执行完这个指令后，会有帮助提示，跟着提示走，会很简单。</li>
<li>这边我们新建分区，输入：n，选择分区码，起始扇区，结尾扇区。最后输入w写入分区表。这边出现警告：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The partition table has been altered.</div><div class="line">Calling ioctl() to re-read partition table.</div><div class="line">Re-reading the partition table failed.: Device or resource busy</div><div class="line"></div><div class="line">The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).</div></pre></td></tr></table></figure>
<p>起初一直在纠结这个问题，后来通过网上查看发现仅仅是个警告，并非错误，而虽然完成但事实上这边没有格式化，值得注意的是，fdisk虽然选择了分区类型，但并没有格式化分区，而这边的分区类型仅仅是将分区类型的内容写入了MBR中，真正格式化还得手动执行。</p>
<ul>
<li>使用sudo fdisk -l 已经可以查看到分区列表了</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Device         Start        End    Sectors   Size Type</div><div class="line">/dev/sda1       2048     999423     997376   487M EFI System</div><div class="line">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class="line">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class="line">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class="line">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class="line">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>
<ul>
<li>下面真正格式化分区，格式化分区需要选择格式化类型，上面通过fdisk已经选定了分区为linux filesystem了，这边就要将其格式化为其对应的文件系统。sudo mkfs.ext4 /dev/sda6，再看分区sudo fdisk -l。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Device         Start        End    Sectors   Size Type</div><div class="line">/dev/sda1       2048     999423     997376   487M EFI System</div><div class="line">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class="line">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class="line">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class="line">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class="line">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>
<ul>
<li>最后一步就是挂载分区了，使用sudo mount /dev/sda6 ~/Extern 将sda6新分出来的分区挂载到当前用户目录下的Extern分区中即可。</li>
<li>df再次查看可以发现，分区已经被挂载成功了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Aria2详解]]></title>
      <url>http://noparkinghere.win/2016/10/27/2016/2016-10-27-aria2%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Aria2应该来说是最流行的免费下载工具之一，因为它的轻量级以及支持各种协议而被广为使用。</p>
<p><em>这个东西折腾了很长时间，终于配好了，老实说仅仅是配置使用的话应该是相当简单的，但由于一开始参考了mac下配置的那篇文章，虽然更改了路径等内容，但每次启动aria2的时候总是经常启动不起来，或者启动后自动被kill了，反复往返，看了很多教程官方文档说明等，一直查不出问题所在，最后没办法，直接自己写配置文件，终于可以使用了。</em></p>
<h3 id="aria2配置"><a href="#aria2配置" class="headerlink" title="aria2配置"></a>aria2配置</h3><p>根据man文档aria2的默认配置在$HOME/.aria2/aria2.conf中，你也可以在每次加载的过程中人为修改位置如：<code>aria2c --conf-path=/etc/.aria2/aria2.conf</code>。</p>
<p>配置如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#保存路径，注意这边必须写完整路径</span></div><div class="line">dir=/home/demon/Downloads</div><div class="line"><span class="comment">#允许rpc</span></div><div class="line"><span class="built_in">enable</span>-rpc=<span class="literal">true</span></div><div class="line"><span class="comment">#允许所有来源, web界面跨域权限需要</span></div><div class="line">rpc-allow-origin-all=<span class="literal">true</span></div><div class="line"><span class="comment">##允许非外部访问</span></div><div class="line">rpc-listen-all=<span class="literal">true</span></div><div class="line"><span class="comment">#RPC端口, 仅当默认端口被占用时修改</span></div><div class="line">rpc-listen-port=6800</div><div class="line"><span class="comment">#disable-ipv6=true</span></div><div class="line"><span class="comment">#最大同时下载数(任务数), 路由建议值: 3</span></div><div class="line">max-concurrent-downloads=10</div><div class="line"><span class="comment">#断点续传</span></div><div class="line"><span class="built_in">continue</span>=<span class="literal">true</span></div><div class="line"><span class="comment">#同服务器连接数</span></div><div class="line">max-connection-per-server=10</div><div class="line"><span class="comment">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span></div><div class="line">min-split-size=10M</div><div class="line"><span class="comment">#单文件最大线程数, 路由建议值: 5</span></div><div class="line">split=10</div><div class="line"><span class="comment">#下载速度限制</span></div><div class="line">max-overall-download-limit=0</div><div class="line"><span class="comment">#单文件速度限制</span></div><div class="line">max-download-limit=0</div><div class="line"><span class="comment">#上传速度限制</span></div><div class="line">max-overall-upload-limit=0</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="aria2c命令"><a href="#aria2c命令" class="headerlink" title="aria2c命令"></a>aria2c命令</h3><p>基本使用</p>
<ul>
<li>下载一个文件（Download a file）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aria2c http://host/image.iso</div><div class="line">说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。</div></pre></td></tr></table></figure>
<ul>
<li>用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aria2c -x2 http://host/image.iso</div><div class="line">说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。</div></pre></td></tr></table></figure>
<ul>
<li>同时使用两个连接下载同一文件（Download a file using 2 connections）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c <span class="_">-s</span>2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso</div><div class="line"></div><div class="line">说明：你可以指定URIs的数量多余 <span class="_">-s</span> 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。</div></pre></td></tr></table></figure>
<ul>
<li>同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aria2c http://host1/file.zip ftp://host2/file.zip</div></pre></td></tr></table></figure>
<ul>
<li>并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c -Z http://host/file1 file2.torrent file3.metalink</div><div class="line">说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。</div><div class="line">aria2c file1.torrent file2.torrent</div></pre></td></tr></table></figure>
<ul>
<li>并发下载一个文件中的URI（Download files listed in a file concurrently）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c -ifiles.txt -j5</div><div class="line">说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。</div><div class="line">说明：你可以指定一些 选项 在下载文件（input list file）中。</div></pre></td></tr></table></figure>
<ul>
<li>在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c -ifiles.txt --save-session=out.txt</div><div class="line">当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。</div><div class="line">aria2c -iout.txt</div></pre></td></tr></table></figure>
<h3 id="uget"><a href="#uget" class="headerlink" title="uget"></a>uget</h3><p>uget可以说相当于一个图形化界面的下载器，这个下载器的优点是可以调用curl和aria2等工具，在设置–插件中选择aria2即可，具体的使用类似迅雷等一些下载器类似。一单设置选择了aria2的话，uget就会自动运行aria2这个进程，其他程序就无法调用aria2的部分功能了。这个软件占用资源较小，如果使用的linux操作系统，简单易用，基本上不需要配置，重点推荐。</p>
<h3 id="web软件"><a href="#web软件" class="headerlink" title="web软件"></a>web软件</h3><p>aria2c有几个比较出名的web软件可以选择：<a href="http://ziahamza.github.io/webui-aria2/" target="_blank" rel="external">webui-aria2</a>，<a href="https://binux.github.io/yaaw/" target="_blank" rel="external">yaaw</a>。</p>
<p>注意在使用这些UI工具时，实际仍然是调用aria2s命令，因此需要实现开启aria2的守护进程：<code>aria2c -D</code>，然后在浏览器上面可以执行相关操作。</p>
<p>我个人在使用这两个工具时，研究了很久但一直不能使用，疑似无法读取本地的配置文件，极少情况能够加载成功，进行下载。<strong>待解决</strong></p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://aria2c.com/usage.html" target="_blank" rel="external">http://aria2c.com/usage.html</a><br><a href="https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay" target="_blank" rel="external">https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay</a><br><a href="http://yalv.me/aria2/" target="_blank" rel="external">http://yalv.me/aria2/</a><br><a href="https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk</a><br><a href="http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727" target="_blank" rel="external">http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727</a><br><a href="http://www.cnblogs.com/RhinoC/p/aria2.html" target="_blank" rel="external">http://www.cnblogs.com/RhinoC/p/aria2.html</a><br><a href="https://aria2.github.io/" target="_blank" rel="external">https://aria2.github.io/</a><br><a href="http://sydi.org/posts/linux/aria2c-usage-sample-cns.html" target="_blank" rel="external">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a><br><a href="http://chanjh.com/post/software/0012" target="_blank" rel="external">http://chanjh.com/post/software/0012</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux免密码命令]]></title>
      <url>http://noparkinghere.win/2016/10/24/2016/2016-10-24-linux%E5%85%8D%E5%AF%86%E7%A0%81%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>在使用ubuntu的过程中，部分命令必须要具备root权限才可以执行，然后root权限需要输入密码，很多常用的命令如:reboot等，甚至需要每次输入密码，部分用户也许会很不满意。另外当如果在写脚本时也会出现这种问题，脚本中可能会包含一些sudo指令，但用户不想每次都输入密码。这边介绍几种方法以供参考。</p>
<a id="more"></a>
<h3 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h3><p>将免密码文件写入到 /etc/sudoers 配置文件中，书写格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">假设你的用户名是user，host是host则可以将以下命令加入到 /etc/sudoers 中:</div><div class="line"></div><div class="line">user host = (root) NOPASSWD: /sbin/shutdown</div><div class="line">user host = (root) NOPASSWD: /sbin/reboot</div><div class="line">user host = (root) NOPASSWD: /home/user/program/startup.sh (注意：startup.up需要设定为可执行)</div><div class="line"></div><div class="line">可以看到通过以上方法写入到sudoers中可以让程序或者脚本中即便需要root权限，也可以免密码自动执行。</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password" target="_blank" rel="external">http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[IIC通信详解]]></title>
      <url>http://noparkinghere.win/2016/10/20/2016/2016-10-20-iic%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>我们在使用单片机的过程中，IIC通信可以说是最被广泛使用和采纳的一个协议，这边</p>
<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[usb转串口]]></title>
      <url>http://noparkinghere.win/2016/10/19/2016/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>使用单片机，对硬件编程的时候，可以说串口是最常用的交互方式，毕竟要安装一个显示器，显示屏等设备需要额外的开销，大量增加代码量，且很多场景并非必备外设。这篇文章将会详细的介绍单片机中最常使用的串口通信功能，这边通过<strong>多篇文章</strong>以51单片机和stm32为例，对串口（以ttl电平，232，485等）进行详细的论述。</p>
<p>在实验调试单片机时，串口相当重要以及常用，而现在电脑却一般仅有usb口（考虑到串口非专业人士不再使用）。因此我们在使用单片机读取串口数据时，往往需要<strong>将相应的串口转换为usb口</strong>。由于串口这边根据串口的不同，主要介绍常见的几种转接方式。</p>
<h3 id="串口ttl转usb"><a href="#串口ttl转usb" class="headerlink" title="串口ttl转usb"></a>串口ttl转usb</h3><p>常规调试过程中，我们可以将单片机ttl电平的串口信号TX和RX，通过转换芯片变成usb总线的信号。<strong>注意该过程既不是RS232也不是RS485，而是ttl的串口信号，该信号一般仅仅用来测试和下载，仅仅是方便使用而已。</strong></p>
<p>通常我们用来讲ttl串口信号转换为usb信号的芯片可以分为三种：FT232,CH340,PL2303，价位由高到低。这边我仅仅使用过CH340,PL2303这两款芯片的模块，对比后缺失PL2303误码率较高（当然不排除厂家因素）。一般情况我们使用CH340较多，相对稳定且价格便宜。实现的原理如下，其他集中芯片也大体一致：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/1.png" alt=""></p>
<p>建议大家使用CH340的模块，价格也很便宜，这边给出完整的电路原理图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/2.jpg" alt=""></p>
<a id="more"></a>
<h3 id="RS232串口转usb"><a href="#RS232串口转usb" class="headerlink" title="RS232串口转usb"></a>RS232串口转usb</h3><p>实际上是先将RS232转换为ttl电平，然后在通过上述方式转为usb通讯。下面详细介绍下RS232如何转换为ttl电平。</p>
<p>一般我们通过使用max232或者max3232将RS232电平（逻辑1(MARK)=-3V～-15V，逻辑0(SPACE)=+3～+15V）转换为ttl电平（5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列）。</p>
<ul>
<li>max232 供电电压5v，耗电5mA，外接4个1uF电容，传统5v供电单片机常用。</li>
<li>max3232 供电电压5v或3.3V，耗电0.3mA，外接4个0.1uF电容其他特性都一样，价格略有差别。现在更为常用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/3.png" alt=""></p>
<p>也就是说如果RS232串口想要和单片机链接通讯中间必须要有max232或者max3232这样的转换芯片，而如果RS232串口想要通过usb链接电脑，则必须先通过max232或者max3232转换成ttl信号，然后在通过CH340转换为usb通讯。</p>
<h3 id="RS485串口转usb"><a href="#RS485串口转usb" class="headerlink" title="RS485串口转usb"></a>RS485串口转usb</h3><p>RS485的转换就更为丰富了，包括以下几种：RS485&lt;-&gt;RS232，RS485&lt;-&gt;ttl，RS485&lt;-&gt;usb。网上基本也有各种转接头可以购买，这边仅做简要阐述。</p>
<ul>
<li>RS485&lt;-&gt;ttl：选用芯片MAX485(5V)或MAX3485(3.3V)类似上面提到的max232和max3232。</li>
<li>RS485&lt;-&gt;RS232：一般核心采用MAX232+MAX485共同设计电路，但设计细节差异较大，可以参加文末给出的链接</li>
<li>RS485&lt;-&gt;usb：分为两种方式：1.同RS232串口转usb类似，可以通过接MAX485转成ttl电平然后通过CH340转成usb通讯，2.将RS485转成RS232，然后再将RS232转成usb。</li>
</ul>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://tieba.baidu.com/p/3263424064" target="_blank" rel="external">http://tieba.baidu.com/p/3263424064</a><br><a href="http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO" target="_blank" rel="external">http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO</a><br><a href="http://www.elecfans.com/article/88/131/189/2015/20150929385089.html" target="_blank" rel="external">http://www.elecfans.com/article/88/131/189/2015/20150929385089.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[串口RS232通信详解]]></title>
      <url>http://noparkinghere.win/2016/10/19/2016/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>
<p>波特率：单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。（有单独文章详解）</p>
<p>数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。当然，一般8位为一个字节，通常都喜欢设置为8位数据位传输。</p>
<p>停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。</p>
<p>奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。</p>
<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>
<p>注意：<strong>串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。</strong></p>
<a id="more"></a>
<h3 id="串口通讯—全双工和半双工方式"><a href="#串口通讯—全双工和半双工方式" class="headerlink" title="串口通讯—全双工和半双工方式"></a>串口通讯—全双工和半双工方式</h3><h4 id="全双工方式-full-duplex-："><a href="#全双工方式-full-duplex-：" class="headerlink" title="全双工方式(full duplex)："></a>全双工方式(full duplex)：</h4><p>当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工制。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。(可能还需要控制线和状态线，以及地线)。比如，计算机主机用串行接口连接显示终端，而显示终端带有键盘。这样，一方面键盘上输入的字符送到主机内存;另一方面，主机内存的信息可以送到屏幕显示。通常，往键盘上打入1个字符以后，先不显示，计算机主机收到字符后，立即回送到终端，然后终端再把这个字符显示出来。这样，前一个字符的回送过程和后一个字符的输入过程是同时进行的，即工作于全双工方式。</p>
<h4 id="半双工方式-half-duplex"><a href="#半双工方式-half-duplex" class="headerlink" title="半双工方式(half duplex):"></a>半双工方式(half duplex):</h4><p>若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工制。采用半双工方式时，通信系统每一端的发送器和接收器，通过收/发开关转接到通信线上，进行方向的切换，因此，会产生时间延迟。收/发开关实际上是由软件控制的电子开关。当计算机主机用串行接口连接显示终端时，在半双工方式中，输入过程和输出过程使用同一通路。有些计算机和显示终端之间采用半双工方式工作，这时，从键盘打入的字符在发送到主机的同时就被送到终端上显示出来，而不是用回送的办法，所以避免了接收过程和发送过程同时进行的情况。</p>
<p>目前多数终端和串行接口都为半双工方式提供了换向能力，也为全双工方式提供了两条独立的引脚。在实际使用时，一般并不需要通信双方同时既发送又接收，像打印机这类的单向传送设备，半双工甚至单工就能胜任，也无需倒向。</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>首先需要明白两个概念，就是DTE和DCE。DTE是指数据终端设备，典型的DTE就是计算机和单片机。DCE是指数据通信设备，典型的DCE就是MODEM。RS232串口标准中的RXD和TXD都是站在DTE立场上的，而不是DCE。明白了这一点，再讲下面的接线方法，就很好理解了。</p>
<p>单片机与计算机进行串口通信时，单片机的RXD接计算机的TXD，单片机的TXD接计算机的RXD。主要是在使用串口时，TXD和RXD都是成对的，因此值得注意的是如果都是标准串口链接方式，往往不能直接连接，必须要错开链接，而这常常有两种方式，一种是让其中一个端口的RXD和TXD对调（故意错开），然后导线直通；另外一种是两个端口都采用标准端口，但导线部分RXD和TXD对调（交叉线）。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>
<p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>
<p>即便串口拥有同步功能，一般也是作为uart（通用异步收发传输器）使用，在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。事实上目前一般我们所说的串口通信就是指通用异步收发，极少采用同步通讯的方式。</p>
<h3 id="硬件接口以及连线"><a href="#硬件接口以及连线" class="headerlink" title="硬件接口以及连线"></a>硬件接口以及连线</h3><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口。</p>
<p>RXD接TXD，TXD接RXD，无论是单片机和单片机相连还是计算机和单片机相连都是如此，发射部分TXD永远同RXD链接配对。具体连接见下图：</p>
<ul>
<li>使用串口直通线。设计电路时，单片机的RXD连接电路板DB9的TXD，单片机的TXD连接电路板DB9的RXD，具体实现可在232电平转换芯片处反接。</li>
<li>使用串口交叉线。设计电路时，因为串口线已做交叉，单片机的RXD连接电路板DB9的RXD，单片机的TXD连接电路板DB9的TXD，均直连即可。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/5.jpg" alt=""></p>
<p>除非专门说明，否则所有引脚线序都是指串口外侧的线序，RS232串口的端口示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg" alt=""></p>
<p>如果是作为RS-232C接口，则各引脚定义如表所示。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg" alt=""></p>
<p>值得注意的是：<strong>公头和母头的RS232口在所有引脚的定义上面都是一致的，因此在购买选链接线的时候会分很多种：公对公23交叉，公对公直通，母对母直通，母对母23交叉，公对母23交叉，公对母直通。如果不能确定是什么线，万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。</strong></p>
<p>各引脚的电气特性为：在TxD和RxD上，逻辑“1”为-3V~-15V； 逻辑“0”为+3V~+15V。在RTS、CTS、DSR、DTR和DCD等控制线上，信号有效为+3V~+15V；信号无效为-3V~-15V。对于数据信号，逻辑“1”为低于-3V，逻辑“0”为高于+3V；对于控制信号，接通ON为低于-3V；断开OFF为高于+3V；-3V~+3V、低于-15V、高于+15V都表示电压无意义。</p>
<p><strong>串口异步传输在空闲状态时都必须是高电平。</strong></p>
<h3 id="特征简述"><a href="#特征简述" class="headerlink" title="特征简述"></a>特征简述</h3><ul>
<li>RS-232串口通信最远距离是50英尺，约为15m，可见232的距离传输并不是很远，由于正负逻辑电平的差量有限，232的抗干扰能力较弱。</li>
<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps（传统情况下232的传输速度有限一般就是在19200以下）</li>
<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （使用过程中尤其需要注意232的电平，不能直接将单片机同RS-232C口中RX，TX直连，中间需要有相应的转换芯片才可）</li>
</ul>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>既然要详细介绍RS232的使用和通讯，这边肯定要附上常见的硬件设计电路和原理图的。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/72.png" alt=""></p>
<h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><p>串口因为作为最常用的一个功能，有关串口的协议一般已经被迁入到了目前市面上几乎所有主流的芯片中了，目前绝大多数芯片本身自带串口相关功能，用户无需按照协议来模拟出高低电平和时间周期来发送码元，相关功能已经作为芯片自带功能嵌入到了相关寄存器中，用户仅仅需要根据参考文档，完成usart相关寄存器的配置和调用，即可实现串口的发送和接收了。</p>
<h4 id="IO口模拟uart实现"><a href="#IO口模拟uart实现" class="headerlink" title="IO口模拟uart实现"></a>IO口模拟uart实现</h4><p>IO口模拟uart能够帮助我们更加深入了理解uart的相关协议，知道整个uart通信过程中，是如何工作，对一切细节特性都可以了如指掌，对于我们深入的研究学习串口通信还是比较有帮助的，且IO模拟出来的通信协议一般都更具兼容性，可以很方便的进行不同芯片的移植，而无需关注芯片本身寄存器和底层结构。</p>
<p>众所周知数字电路实现的最主要功能就是输入输出，高低电平。所谓的协议虽然复杂但都是可以通过输入输出和高低电频给模拟出来的。下面主要以stm32芯片为例，使用IO口模拟出串口通讯，这边只附上主要程序片段，详细工程见链接。</p>
<p>首先，必须要知道串口通讯时数据是怎样传输的？这里以异步传输字符为例子，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/6.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>串口异步传输在空闲状态时都必须是高电平</li>
<li>起始位是低电平，发完后有一个等待时间</li>
<li>中间数据位个数以及是否有校验位需要和接收端保持一致，发完后有一个等待时间</li>
<li>停止位为高电平</li>
<li>每次发完后的等待时间由波特率所决定，停止位之后需要有一定的空闲时间，这个时间是超过等待时间的。</li>
</ul>
<p>以下为模拟串口接收发送的主要代码，<strong>仅仅是一个粗稿，实验使用，具体的工程项目存在较大的缺陷，还要进一步完善。</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">/* IO口设置，这边不详细写出，IO配置成LED灯的模式即可 */</div><div class="line"></div><div class="line">***以下为模拟uart的TX口发送数据***</div><div class="line"></div><div class="line">/*主要的打印字符串函数*/</div><div class="line">void my_printf(char * str, ...)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span> (*str != <span class="string">'\0'</span>)</div><div class="line">	&#123;</div><div class="line">		UART_SendData((u8)*str++);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*串口发送每个数据包*/</div><div class="line">void UART_SendData(u8 data)</div><div class="line">&#123;</div><div class="line">	TX_LOW();</div><div class="line">	UART_DELAY();</div><div class="line"></div><div class="line">	//传输字节的过程中是从字节的低位开始发送的。</div><div class="line">    <span class="keyword">for</span> (u8 i = 0; i &lt; 8; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (data &amp; 0x01)</div><div class="line">		&#123;</div><div class="line">			TX_HIGH();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> </div><div class="line">		&#123;</div><div class="line">			TX_LOW();</div><div class="line">		&#125;</div><div class="line">		data &gt;&gt;= 1;</div><div class="line">		</div><div class="line">		UART_DELAY();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	TX_HIGH();</div><div class="line">	</div><div class="line">	// 值得注意的是在发送完毕后</div><div class="line">	UART_DELAY();</div><div class="line">	UART_DELAY();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*使用systick定时器精准制定波特率115200*/</div><div class="line"><span class="comment">#define	UART_DELAY()	delay_com()</span></div><div class="line"></div><div class="line">void delay_com(void)</div><div class="line">&#123;		</div><div class="line">	u32 temp;	    	 </div><div class="line">	SysTick-&gt;LOAD =  SystemCoreClock / 8 / 115200; //时间加载	  		 </div><div class="line">	SysTick-&gt;VAL = 0x00;        //清空计数器</div><div class="line">	SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk ;          //开始倒数	 </div><div class="line">	<span class="keyword">do</span></div><div class="line">	&#123;</div><div class="line">		temp = SysTick-&gt;CTRL;</div><div class="line">	&#125;<span class="keyword">while</span>(temp &amp; 0x01 &amp;&amp; !(temp&amp;(1&lt;&lt;16)));//等待时间到达   </div><div class="line">	SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;       //关闭计数器</div><div class="line">	SysTick-&gt;VAL = 0X00;       //清空计数器	 </div><div class="line">&#125;</div><div class="line"></div><div class="line">***以下为模拟uart的RX接收数据***</div><div class="line"></div><div class="line">这边内容较多，不做详细的累述，仅大致提供下思路，详细内容可以参见代码。</div><div class="line"></div><div class="line"></div><div class="line">/* 串口完整接收一个字节的数据 */</div><div class="line">u8 UART_GetByte(void)</div><div class="line">&#123;</div><div class="line">	u8 Data = 0;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (u8 i = 0; i &lt; USART_DATA_LEN; i++)</div><div class="line">	&#123;</div><div class="line">		UART_DELAY();</div><div class="line">		Data |= RX1_READ()&lt;&lt;i;	</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span> Data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 终端捕捉信号 */</div><div class="line">void EXTI15_10_IRQHandler(void) /* bit &amp; add */</div><div class="line">&#123;</div><div class="line">	/* about key2 bit*/</div><div class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(RX1_EXTI_LINE) != RESET)</div><div class="line">    &#123;</div><div class="line">		/* 每次有数据接受时，开启定时器用来计量数据采集的时间 */</div><div class="line">		TIM3-&gt;CNT = 0;</div><div class="line">		TIM_Cmd(TIMER_NUM[TIMER3], ENABLE); //使能定时器3</div><div class="line"></div><div class="line">		TIM3_Init_Ctrl(ENABLE);</div><div class="line"></div><div class="line">		g_TimeOut = 0;</div><div class="line">		</div><div class="line">		g_byStore[point++] = UART_GetByte();</div><div class="line"></div><div class="line">        /* 清除中断挂起标志位，否则会被认为中断没有被处理而循环再次进入中断 */</div><div class="line">      	EXTI_ClearITPendingBit(RX1_EXTI_LINE);</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">**这边的难点在于如何判断数据发送完毕**</div><div class="line">- 设置RX口为外部终端触发，当接收到第一个下降沿时，进入中断函数</div><div class="line">- 中断函数逐一执行接收数据的采集和捕捉</div><div class="line">- 我们通过采用一个定时器来每次收到外部中断时，完成一次计时，当计时超过一次数据接收的时间，则认为接收完毕</div></pre></td></tr></table></figure>
<p> 一般字符传输都采用：1位起始位，8位数据位，1位停止位，没有校验位 的形式传输，其他形式的这里不讲。<strong>串口异步传输在空闲状态时都必须是高电平</strong>。第一位传输的是起始位，<strong>起始位会将原来空闲时的高电平拉成低电平</strong>，起始位用来来标识数据开始传输，提示接收方准备开始接收数据；当接收方第一次检测到一个下降沿时，就表示接收到了起始位。起始位后就是8位的数据位，接收方在接收每一位数据的时候会采集几十次，如果结果都是低电平，则接收到的数据位0，如果结果都是高电平，则接受到的数据位是1。1位停止位会将电平拉成高电平，为接收下一个数据做准备。</p>
<h4 id="芯片自带uart实现"><a href="#芯片自带uart实现" class="headerlink" title="芯片自带uart实现"></a>芯片自带uart实现</h4><p>既然IO口也能够模拟出uart通信功能，为何众多芯片厂商还要费尽心思的将uart做入芯片里面呢？就我个人理解而言，IO虽然可以模拟出通信协议，但毕竟是IO口的操作，在能耗，速度还有计算资源占用上面都会是一个很大的开销。尤其对功耗而言，将这些做入芯片内部，可以最完美的匹配这些协议，降低能耗，另外虽然牺牲了一定的移植性，但模拟这些通讯协议可以减少代码复杂度，降低程序员编写代码的门槛，无需彻底的理解弄清这些协议，即可完成相关功能，这现在也被大家广泛接受，毕竟如：IIC，SPI等通信协议书完全用IO模拟写起来并不是太简单。这边主要以stm32中自带的串口驱动为例，本事例不具备普遍应用性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/jason-lu/articles/3171870.html" target="_blank" rel="external">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href="http://book.51cto.com/art/201308/408900.htm" target="_blank" rel="external">http://book.51cto.com/art/201308/408900.htm</a><br><a href="http://blog.csdn.net/sdwuyulunbi/article/details/6632382" target="_blank" rel="external">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href="http://blog.csdn.net/skyflying2012/article/details/49274313" target="_blank" rel="external">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href="http://blog.csdn.net/gszhy/article/details/8594433" target="_blank" rel="external">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href="http://blog.csdn.net/bytxl/article/details/49147915" target="_blank" rel="external">http://blog.csdn.net/bytxl/article/details/49147915</a><br><a href="http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F</a><br><a href="http://ziye334.blog.163.com/blog/static/224306191201452833850647" target="_blank" rel="external">http://ziye334.blog.163.com/blog/static/224306191201452833850647</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[串口RS485通信详解]]></title>
      <url>http://noparkinghere.win/2016/10/19/2016/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>注意：串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。串口的一些内容不再逐一介绍说明，可以参加之前的usb转串口及RS232通信等文章</strong></p>
<h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><p>485（一般称作 RS485/EIA-485）是隶属于 OSI 模型物理层的电气特性规定为 2 线，半双工，多点通信的标准。它的电气特性和 RS-232 大不一样。用缆线两端的电压差值来表示传递信号。值得注意的是：RS485 仅仅规定了接受端和发送端的电气特性，它没有规定或推荐任何数据协议。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg" alt=""></p>
<p>RS485接口可以只使用两根线进行通讯（其他串口通讯至少需要三根线，一根为地线作为参考电平），通过差分电平（利用两个信号的差值来判断信息，使用差分信号来传输的，也就是一根线传同相信号，一根线传反相，这样差值最大，抗干扰能力强。）来确定信号是0还是1，也正因为这个原因，所以RS485每次有且仅有一根线能够传输数据，另外一根线作为比对信号，因此RS485是半双工的通讯方式。主要特点如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg" alt=""></p>
<ul>
<li>接口电平低，不易损坏芯片。 RS485 的电气特性：逻辑“ 1”以两线间的电压差为+(2~6)V<br>表示；逻辑“ 0”以两线间的电压差为-(2~6)V 表示。接口信号电平比 RS232 降低了，<br>不易损坏接口电路的芯片，且该电平与 TTL 电平兼容，可方便与 TTL 电路连接。</li>
<li>传输速率高。 10 米时， RS485 的数据最高传输速率可达 35Mbps，在 1200m 时，传输<br>速度可达 100Kbps。</li>
<li>抗干扰能力强。 RS485 接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力<br>增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485 总线最长可以传输 1200m<br>以上（速率≤100Kbps）</li>
<li>一般最大支持 32 个节点，如果使用特制的 485 芯片，可以达到 128 个或者 256 个节点，<br>最大的可以支持到 400 个节点。</li>
</ul>
<a id="more"></a>
<h3 id="类比RS232"><a href="#类比RS232" class="headerlink" title="类比RS232"></a>类比RS232</h3><p>实际上232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>
<p>因为都是采用串口通信协议，所以软件端几乎可以直接使用，且RS485具备耗材少，抗干扰强等特点，在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>
<ul>
<li>从接线上，RS232是三线制，RS485是两线制</li>
<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>
<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>
<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>
</ul>
<p>RS232的接线：<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/3.jpg" alt="">)</p>
<p>RS485的接线<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/4.jpg" alt=""></p>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/jason-lu/articles/3171870.html" target="_blank" rel="external">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href="http://book.51cto.com/art/201308/408900.htm" target="_blank" rel="external">http://book.51cto.com/art/201308/408900.htm</a><br><a href="http://blog.csdn.net/sdwuyulunbi/article/details/6632382" target="_blank" rel="external">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href="http://blog.csdn.net/skyflying2012/article/details/49274313" target="_blank" rel="external">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href="http://blog.csdn.net/gszhy/article/details/8594433" target="_blank" rel="external">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href="http://blog.csdn.net/bytxl/article/details/49147915" target="_blank" rel="external">http://blog.csdn.net/bytxl/article/details/49147915</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu关闭笔记本触摸板]]></title>
      <url>http://noparkinghere.win/2016/10/18/2016/2016-10-18-ubuntu%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%A7%A6%E6%91%B8%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p><em>ubuntu 16.04的版本中，试过多个笔记本都可以通过键盘的快捷按键关闭触摸板的使用，但仍然显得不够智能，因为缺乏相关的程序和驱动，无法做到自动选择触摸板和鼠标。另外虽然我用的是ubuntu的系统但因为没有使用它的WM所以触摸板无法直接禁用，必须通过手动的方式才可以实现。</em></p>
<p>本文搜集了一些比较通用的触摸板禁用方式，另外后续如果找到更好的方法，还会补充上来。以下在dell的超极本和msi的游戏本上面实现过，且实验环境是ubuntu 16.04，其他系统和笔记本不能确保一定可以实现。</p>
<h3 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><ul>
<li>sudo rmmod psmouse    这个是禁用触摸板</li>
<li>sudo modprobe psmouse 这个是启用触摸板</li>
</ul>
<p>方式简单快捷，但是会将触点和触板都禁用了，一般还是希望保持触点是启用的，且仅有启用和禁用的两个功能，每次需要指令才可以实现，无法做到智能识别鼠标自动启用禁用。</p>
<a id="more"></a>
<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>在软件中心中搜索”pointing-device”安装，图形化界面操作简单方便。</p>
<p>但新问题出现了：禁用之后，如果敲击键盘的话，那么触板又会启用。这个问题当时很头大啊。经测试发现，只要将系统自带的管理器中“敲击键盘时禁用触摸板”这一项的勾去掉。那么就不会出问题了。<br>小结：以上就是对在Ubuntu系统下关闭触摸板很有用的两种方法，这两种方法使得以后再出现这样的情况时就可以采用的哦！</p>
<p><em>该方法我并没有尝试过，因为较少使用ubuntu自带的软件中心，有兴趣的朋友可以尝试下。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.285868.com/a/xtjc/5798.html" target="_blank" rel="external">http://www.285868.com/a/xtjc/5798.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机中的通信简介]]></title>
      <url>http://noparkinghere.win/2016/10/18/2016/2016-10-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>计算机从最初发展到现在已经有半个多世纪的历史，众所周知其实计算机就是一堆电路的组成，传统最为通用的计算功能仅仅是控制高低电平，输入输出（0和1）。而计算机中的CPU和其他设备如内存，硬盘，主板的其他电路连接过程中，控制的过程就是通过相关的通信协议，让一堆的高低电平输入输出最终可以转化为我们我们工作需要的内容，而赋予这些0,1实际意义的就是通信协议。计算机中有着众多的通信协议，有些协议已经逐渐被淘汰，而另外一些经过这么多年的发展仍然在各行各业经久不衰，一些更新更稳定更满足这个时代需求的协议也正在被越来越多的智能设备移动设备所采纳。本文仅仅是简要的叙述计算机嵌入式中最常用的一些协议。</p>
<p>这边如果对码元，波特率等还不是恨清除的可以参考<strong>传输速率</strong>这篇文章。</p>
<p><em>在了解通信协议和传输前，得先弄明白：总线和协议，串行传输和并行传输，同步通信和异步通信，全双工和半双工等基本概念，至于具体的通信方式和协议，这边仅作简述，有单独文章进行具体阐述。</em></p>
<h3 id="总线和协议"><a href="#总线和协议" class="headerlink" title="总线和协议"></a>总线和协议</h3><p>在展开讲解之前，先来区分两个概念：总线和协议。</p>
<p><strong>总线</strong>是一组信号线的集合，它定义了各引线的信号、电机、机械特性，使计算机内部各组成部分之间以及不同的计算机之间建立信号联系，进行信息传送和通信，按照作用范围简单来分可以分为内部总线和外部总线。内部总线：就是计算机内部功能模板之间进行通信的总线，它是构成完整的计算机系统的内部信息枢纽，但按功能仍要分为数据总线DB，地址总线AB，控制总线CB，电源总线PB。外部总线是计算机与计算机之间或计算机与其他智能设备之间进行通信的连接。但随着嵌入式不断的发展，现在在两者的区分已经不是那么严格，USB的传输可以认作是外部串行传输方式，而传统所认为是内部穿行传输方式的IIC现在也被一些外接的传感器所使用，因此在嵌入式领域已经无需再纠结是内部总线还是外部总线，毕竟为了满足需求很多原有的协议已经进行的改进使得传输距离更远，抗干扰性更强了，也有更多曾经的内部总线被在外部所使用了。</p>
<p>通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保在通信过程中数据顺利地传送到确定的地方。</p>
<p><em>因为总线的种类实在太多，各种总线的衍生品层出不穷，这边就不详细列举，以下仅仅将目前嵌入式/微机上面最为常见的通信方式列举出来。</em></p>
<a id="more"></a>
<h3 id="串行总线和并行总线"><a href="#串行总线和并行总线" class="headerlink" title="串行总线和并行总线"></a>串行总线和并行总线</h3><p>采用串行传输方式的总线被成为串行总线，一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。</p>
<p>串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰（串扰），传输时速度就受到了限制，传输容易出错。串口没有互相干扰。并口同时发送的数据量大，但要比串口慢。串口硬盘就是这样被人们重视的。</p>
<p>采用并行传输方式的总线被成为并行总线，并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时也需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息（需要时钟信息，是为了确保一次发送的为一组相关数据，当始终跳转一次的时候，再发送下一租数据，如果缺少始终信息，而多组数据的传输有快有慢的话，则所有数据会串扰，通讯毫无意义。而串行通讯则没有这样的问题，一个个位发送，最终只需按照协议整合数据即可，当然也有部分穿行通信协议利用时钟来实现附加的操作），为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。</p>
<p>通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低，抗干扰能力强（可以用在长距离通讯），成本低；并行通讯比较复杂，但是相对速度高，成本高（需要更多的线），抗干扰能力弱（传输距离短）。</p>
<h3 id="同步通信和异步通信"><a href="#同步通信和异步通信" class="headerlink" title="同步通信和异步通信"></a>同步通信和异步通信</h3><p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>
<p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>
<p>除了时间频率的不同外，异步通信和同步通信之间的区别还是发送数据的表示形式，异步通信一般发送单位是字符，同步通信发送单位是比特流（数据帧），但是这不是绝对的，异步通信有时也使用帧来通信。同步通讯进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是自同步，后者是外同步。事实上目前大多是采用异步通讯，极少数是采用同步通讯的。</p>
<h3 id="单工，全双工和半双工"><a href="#单工，全双工和半双工" class="headerlink" title="单工，全双工和半双工"></a>单工，全双工和半双工</h3><ul>
<li>如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。</li>
<li>如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在（即不能同时传输）,称为半双工传输。</li>
<li>如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。</li>
</ul>
<h3 id="串口通信-（见详细文章）"><a href="#串口通信-（见详细文章）" class="headerlink" title="串口通信 （见详细文章）"></a>串口通信 （见详细文章）</h3><p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>
<p>在使用串口通信时最重要的参数：波特率，数据位，停止位，奇偶校验位。</p>
<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>
<h4 id="RS-232-C"><a href="#RS-232-C" class="headerlink" title="RS-232-C"></a>RS-232-C</h4><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口，</p>
<ul>
<li>RS-232串口通信最远距离是50英尺，约为15m</li>
<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps</li>
<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （）</li>
</ul>
<h4 id="RS-485"><a href="#RS-485" class="headerlink" title="RS-485"></a>RS-485</h4><p>232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>
<p>因为都是串口通信，所以本质两者是相差无几的，但耗材少，抗干扰强等特点让RS485在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>
<ul>
<li>从接线上，RS232是三线制，RS485是两线制</li>
<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>
<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>
<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>
</ul>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>SPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，<strong>全双工</strong>，<strong>同步</strong>的通信总线，并且在芯片的管脚上只占用<strong>四根线</strong>，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200，stm32f103等。<br>:</p>
<h3 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h3><p>IIC 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口，如今越来越多的芯片集成了这种通信协议，比如stm32f103，EFM32等。</p>
<p>### </p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/wind19/article/details/7433249" target="_blank" rel="external">http://blog.csdn.net/wind19/article/details/7433249</a><br><a href="http://baike.baidu.com/view/185322.htm" target="_blank" rel="external">http://baike.baidu.com/view/185322.htm</a><br><a href="http://www.cnblogs.com/mylinux/p/4078576.html" target="_blank" rel="external">http://www.cnblogs.com/mylinux/p/4078576.html</a><br><a href="http://baike.baidu.com/view/716175.htm" target="_blank" rel="external">http://baike.baidu.com/view/716175.htm</a><br><a href="https://www.zhihu.com/question/29033993" target="_blank" rel="external">https://www.zhihu.com/question/29033993</a><br><a href="http://www.cnblogs.com/general001/articles/2344079.html" target="_blank" rel="external">http://www.cnblogs.com/general001/articles/2344079.html</a><br><a href="http://blog.csdn.net/weiqifa0/article/details/8845281" target="_blank" rel="external">http://blog.csdn.net/weiqifa0/article/details/8845281</a><br><a href="http://www.cnblogs.com/jason-lu/articles/3171870.html" target="_blank" rel="external">http://www.cnblogs.com/jason-lu/articles/3171870.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[杂谈小纪]]></title>
      <url>http://noparkinghere.win/2016/10/17/2016/2016-10-17-%E6%9D%82%E8%B0%88%E5%B0%8F%E7%BA%AA/</url>
      <content type="html"><![CDATA[<p>2016转眼又快结束，这个月加上国庆休假一下子又过去了半个多月，直到今天才开始上班。今年除了工作上面的几个项目进一步完善外，这边为16年最后几个月制定一个小计划：</p>
<ul>
<li>按照自己的风格，为神州王开发板写一套完整的学习案例，并同步到github。</li>
<li>学习研究python，以视频文档和案例学习为主。</li>
<li>装修自己的blog</li>
</ul>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Note 7 的一些个人看法]]></title>
      <url>http://noparkinghere.win/2016/10/16/2016/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><em>本文是一篇杂谈笔记，一直比较关注科技圈多年，喜欢各种电子产品，且能够DIY或者修理一些小东西，虽然对三星这家公司一直缺乏好感，但还是吐槽一番。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/1.jpg" alt=""></p>
<p>最近闹的比较火的三星Note 7手榴弹事件，终于在这两天落下了帷幕，最终三星将中国市场和海外市场同等对待，停售并回收所有该款机型，无需退还相关赠送配件，允许用户退换或者置换手机，并作出一系列相关补偿。事情看起来似乎是皆大欢喜，恶势力最终向国人低头。</p>
<p>但换而言之，通过三星的一些列举动不得不说是：<strong>搬起石头砸自己的脚</strong>。首先三星和苹果一直是占据高端手机市场几乎所有份额的，三星早些时候在12年以前可以说是国内最最畅销的手机厂家。原因是：产品线广，覆盖低中高多个销售人群，品牌大众认可度高，国内缺乏有力的竞争对手，那时候小米，华为等也才刚刚起步没多久。三星的衰亡也恰恰因为这些原因，首先，13年以后，国内主打性价比性能的手机层出不穷，而三星天然的重广告轻研发的基因，也让它的中低端机型用户体验奇差无比。国内中低端市场逐渐被国产手机厂家占领，三星从此排名一落千丈，且这几年似乎已经从中国主流消费者眼中销声匿迹了。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/2.jpg" alt=""></p>
<p>三星的再次复兴应该是从galaxy S6开始的，虽然中低端市场挫败，但高端市场推出曲面屏，防水等一些列更加满足用户差别需求的产品，让三星在多个方面包括：拍照成像等都成为了市面上面最好的手机。而这次Note 7更加是来势汹汹的，wacom顶尖手绘笔技术，红魔识别，高成像画质等等众多功能，确实让三星这次绝对有秒杀市面一切手机的资本。但恰恰是这颗手榴弹毁了三星，手机本身是一个附加的用户产品，意义在于让用户更加方便的交流通信，没有手机我们一样可以完成很多事情，一样可以活，而手机本身仅仅是个工具为了方便交流，所以一切的附加属性再好的用户体验都离不开工具本身的属性，而如果这个工具需要大家冒着生命危险去使用，那又有哪个人不会望而却步呢？！有人说一个产品不能有任何的马虎，三星这次就是一个螺丝没上的好导致满盘皆输，事实上三星这次不仅仅是一个螺丝的问题，民用产品本身不会要求精益求精，苹果也有天线门，各家手机也会有各种问题等，三星这次是躺在了最不该出问题的事件上面，试想：一个手机被旅客禁止携带，简直是闻所未闻。</p>
<p>抛开国外市场，暂且不说，其实在国内尚且没有发生重大变故的前提下，三星最该去做好各种公关，积极响应用户号召，和国外市场一视同仁，直接退换机型，这样，虽然会有一定的经济损失，但一定可以建立一个更好的口碑市场。其实中国用户很好打发，尤其是国人有“伸手不打笑脸人”的思想，中国人一直有种奇怪的认知，不在乎你犯错，但你认错的态度一定要诚恳，很多时候甚至媒体艺人喜欢拿这些来炒作自己。三星如果这次一开始就积极认错，最终大多数国人会这样认为：不愧是三星，和别的国际厂家就是不一样，能够做到一视同仁，即便产品本身没有问题都可以为用户考虑，这样的大公司值得信赖。而反观这次，三星是被中国用户“逼着”去承认自己的错误，三星国行用的香港的电池可能确实是没有问题，但国内用户关注的早已不是电池的问题，而是区别对待的问题，只要有个别用户愿意，没有问题也可以把你整出问题，而这种调查出来的<em>真相</em>又有多少人愿意去相信？只会不断请权威机构证明，陷入死循环。而中国政府这个时候如果帮三星澄清无意是打自己的脸。三星如果还想在中国混，必然不得不向消费者低头，所有不得不说，在有这么多区别对待海内外市场公司的前科下，三星还范这种错误，无疑让人很难理解。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[多种电平的区分]]></title>
      <url>http://noparkinghere.win/2016/10/09/2016/2016-10-09-%E5%A4%9A%E7%A7%8D%E7%94%B5%E5%B9%B3%E7%9A%84%E5%8C%BA%E5%88%86/</url>
      <content type="html"><![CDATA[<p><strong>电平</strong>就是指电路中两点或几点在相同阻抗下电量的相对比值，即电量水平。常用逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。</p>
<h3 id="TTL电平"><a href="#TTL电平" class="headerlink" title="TTL电平"></a>TTL电平</h3><p>TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。</p>
<ul>
<li>5V TTL和5V CMOS逻辑电平是通用的逻辑电平。</li>
<li>3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。</li>
<li>低电压的逻辑电平还有2.5V和1.8V两种。</li>
</ul>
<a id="more"></a>
<h3 id="RS232电平"><a href="#RS232电平" class="headerlink" title="RS232电平"></a>RS232电平</h3><p>电脑的串口是标准RS232电平，最高电压 可达 +15V 或 -15V</p>
<h3 id="RS485电平"><a href="#RS485电平" class="headerlink" title="RS485电平"></a>RS485电平</h3><blockquote>
<p>参考链接：<br><a href="http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO" target="_blank" rel="external">http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[传输速率]]></title>
      <url>http://noparkinghere.win/2016/10/02/2016/2016-10-02-%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87/</url>
      <content type="html"><![CDATA[<p>数据传输过程中常常会涉及到传输速率，这边详细区分和介绍下波特率和比特率的区别。另一种说法是：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。码元，承载信息量的基本信号单位。</p>
<h3 id="码元："><a href="#码元：" class="headerlink" title="码元："></a>码元：</h3><p>书面解释：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。 而这个间隔被称为码元长度。值得注意的是当码元的离散状态有大于 2 个时（如M大于2个） 时，此时码元为M进制码元。</p>
<p>码元通俗的说就是信号，一个数字脉冲就是一个码元。但事实这种解释不够全面，同一个时间段，信号可以变化3次，也可以变化1次。实际上，正如码元的定义一样，码元是与时间相联系的。这边的时间并不是一个明确的时间，例如：串口通信时，双方约定波特率为 9600（9600bps），则代表一秒钟传输 9600 个位（bit），这时每个码元所在的时间片段就约为1/9600s。再例如：I2C 的传输速率最大为 400Kbps，而 I2C 的通信更加的自由，实际使用过程中，双方并不会事先指定好通信速度，而是采用一根单独的SCL总线来限定通信的速度即码元所间隔的时间，在SDA保持恒定的情况下，SCL总线每次变化电平时的这段时间间隔就作为一个码元所在的时间片段。</p>
<p>通过定义可以看出，通常来所说的码元就是表示二进制码元，当用一个码元传输一个多重含义的数据时，码元还是码元，但我们称其为 M 进制码元。但实际我们也可以设计一个M进制的码元，举个栗子：假如基带信号是 7536154210…..，直接发送，则每个码元作为（八进制）码元传输，这样一个码元相当于8个不同的待识别状态数据。（每个码元有 8 种状态，实际早期为何不使用 10 进制来定义计算机就是因为，一个数据包含的意义越多，越难解析识别，也越容易出错，会增加设计的复杂度，很显然，远距离通讯一般都还是采用二进制码元较多）。而大多数计算机都只能传输2进制数值，假如基带信号是 101011000110111010…..，如果直接发送，则每个码元携带一个比特的信息（每个码元只有 2 种状态），但是如果将信号中的三个比特编为一组，即 101，011，000，110，111，010……，三个比特同样可以表述 8 种不同的排列，我们可以用不同的调制方法来表示这种信，如 8 种不同的振幅，频率，相位等，如果采用相位调制，相位 ϕ0 表示 000，ϕ1 表示 001，以此类推，那么接收端如果收到相位是ϕ0的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号（每个码元有 8 种状态，每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难）。</p>
<p>根据上述内容总结：一个以 m 波特传送信号的线路，其传送二进制数据的速率不一定是 m 比特/秒，因为每个信号可以运载几个比特，例如，若使用 0、1、2、3、4、5、6、7 共 8 个电平级，则需要  ，即 3 个比特来表示一个信号值，因而这种条件下比特率将是波特率的3倍。某系统每秒钟传送 2400 个码元，则该系统的传码率为 2400 波特或 2400B。但要注意，码元传输速率仅仅表征单位时间内传送码元的数目，而没有限定这时的码元是何种进制，因统一系统的各点上可能采用不同的进制，故给出码元速率时必须说明码元的进制和该速率在系统中的位置。</p>
<p>常用进制（或键位数）的码元有： 8 进制（也称 8 键制）数字码元键盘，10 进制数字码元键盘，5 进制笔画数字码元键盘，还有 26 进制字母码元键盘，26进制部件字母码元键盘，还有韩文的 28 进制字母码元键盘，俄文的 33 进制字母码元键盘，以及中国维文的 30 进制字母码元键盘等。</p>
<a id="more"></a>
<h3 id="比特率："><a href="#比特率：" class="headerlink" title="比特率："></a>比特率：</h3><p>在电信行业，码率，比特率或数据传输速率指在一个数据传送系统中，单位时间内通过设备比特、字符、块等的平均量。通常使用比特每秒或字节每秒两单位的复合形式度量。比特率在数字信道中，比特率是数字信号的传输速率（需要注意的是比特率是一个传输速度的单位），比特率显然是以 bit 位作为最小传输量的，不要和 Byte 字节进行混淆。它用单位时间内传输的二进制代码的有效位(bit)数来表示，其单位为每秒比特数 bit/s(bps)、每秒千比特数(Kbps)或每秒兆比特数(Mbps)来表示(此处K和M分别为 1000 和 1000000，而不是涉及计算机存储器容量时的1024和1048576)，而为何这边换算不是以1024为单位，而是以1000为单位呢，值得一提的是，人类世界习惯于使用十进制来换算，一般除了计算机对存储单元采用 1024K=1000M 这种换算方式外，人类社会中的大多数的换算方法都是采用1000代表1K，最为常见的现象就是买回来的硬盘厂家生产会以 1000 作为一个单位级，而插上电脑后会以 1024 作为一个单位级，因此硬盘等设备插入电脑往往都会比说明上面小很多，传输速率比特率这个单位在使用k是从来都是代表 1000 的，不幸的是，人们常常错误地用 K 代替 Ki。</p>
<p>k 与 Ki 分别表示 kilo-（千） 与 kibi-（二进制千） 。作为前缀使用时， k 表示 1,000，Ki 表示1,024，因为“Ki”来源于它在计算机方面 210 = 1,024 的使用。不幸的是，人们常常错误地用 K 代替 Ki。此外，不知晓其中微妙差别的广大公众，常常不加区别地使用“Kbps”与“Kibps”，造成了混乱。总之，使用“Kibps”通常是正确的。</p>
<p>b 代表 bit（比特），B 代表 byte（字节），1 字节 即 8 比特。这会导致混淆。比如当“1M（1 Meg，1 兆）网络连接”字样出现在广告上时，它常常表示 1 Mib/s（mebibit per second，二进制兆比特每秒）或者 1.049 Mb/s（megabit per second，兆比特每秒），即可能达到的最大下载速度实际上仅为 128 KiB/s（kibibyte per second，二进制千字节每秒）或者 131 kB/s（kilobyte per second，千字节每秒）。</p>
<h3 id="波特率："><a href="#波特率：" class="headerlink" title="波特率："></a>波特率：</h3><p>指在电子通信领域，鲍（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1 鲍即指每秒传输 1 个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。“鲍”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“鲍”本身就已经是代表每秒的调制数，以“鲍每秒”（Baud per second）为单位是一种常见的错误。</p>
<p><strong>波特率有时候会同比特率混淆</strong>，实际上后者是对信息传输速率（传信率）的度量。波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。因此信息传输速率即比特率在数值上和波特率有这样的关系：I = S × log2 (N)  其中I为传信率，S为波特率，N为每个符号负载的信息量，而 log2 (N) 以比特为单位。</p>
<p>以 RS232 为例，典型的“鲍”是 300, 1200, 2400, 9600, 19200, 115200 等，假设目前“鲍”为 9600， 则此RS232的比特率计算为I = S × log2 (N) = 9600×log2 (2) = 9600bps。</p>
<p>电路传输信号是靠在一定的时间段内，波形的变化来识别每一位（英文单位bit）信息的，那么<br>这一位信息的波形就叫作码元。  当用一个码元传输多个比特位时，码元还是码元，但我们称其为M进制码元。</p>
<blockquote>
<p>参考链接：<br><a href="http://1992zhong.blog.51cto.com/3963309/1167100" target="_blank" rel="external">http://1992zhong.blog.51cto.com/3963309/1167100</a><br><a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下安装搜狗输入法]]></title>
      <url>http://noparkinghere.win/2016/10/01/2016/2016-10-01-ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>一个系统输入法很重要，尤其对于中文输入法来说，而国内目前而言，肯定是搜狗的输入法最本土化，制作的也最出众了，主要还是有网络词库的功能，除了无法实现账户登录同步外，其他基本和windows没有任何区别。</p>
<p>搜狗输入法的配置针对不同的系统有时还真有点小麻烦，本来是不打算写这篇文章的，因为之前的几次配置都是轻松的完成了，但这次就花了个吧小时都没搞定，主要原因还是对ubuntu图形界面一些设置位置无法找到，加上搜狗输入依赖诸如fcitx之类的软件并不能即装即用。错误往往出在某一部做的不够完善，下面列举出详细安装配置步骤。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ul>
<li>从<a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="external">官网</a>下载下来<a href="http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=C24ANiLdi7HwWFenlPkG-w&amp;e=1476682538&amp;fn=sogoupinyin_2.1.0.0082_amd64.deb" target="_blank" rel="external">sogou for linux</a></li>
<li>注意搜狗拼音依赖于fcitx框架，但这边使用的是ubuntu 16.04已经预装了fcitx，如果是更老的版本则需要手动安装fcitx，<a href="http://pinyin.sogou.com/linux/help.php" target="_blank" rel="external">安装方法</a>。</li>
<li>接下来需要选择默认的键盘输入系统，在ubuntu的所有设置（All Settings）中选择语言支持（Language Support）将Keyboard input method system：fcitx。</li>
<li>配置fcitx，可以通过ubuntu的软件直接打开，也可以终端输入运行fcitx-config-gtk3。使用左下角的添加按钮，手动添加sogou输入法，<em>注意：当前输入法如果不是中文，则需要手动将默认勾选的only show current language去掉，然后才可以找出搜狗拼音，同时需要保留一个默认的英文输入法</em>。</li>
<li>完成以上步骤后，基本完成了搜狗拼音的安装，已经可以简单的使用了。</li>
</ul>
<a id="more"></a>
<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><ul>
<li>隐藏状态栏</li>
<li>中英文切换使用ctrl键，切换时保留输入窗口字符上屏，个人<a href="http://noparkinghere.win/posts/Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2.html">将ctrl和caps lock进行互换</a>了，这样切换起来更加方便</li>
<li>候选词9个，模糊拼音等 </li>
</ul>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>每次开机重启后，第一次使用搜狗都会出现无法加载，只是一个小框显示正在输入，不载入搜狗的皮肤也不显示中文，然后等几秒钟状态栏会切换一次fcitx，再切换回搜狗拼音，就可以使用了。有没有什么解决问题的办法？系统是ubuntu16.04，WM用的是awesome。</p>
<p><em>如果有兴趣，也可以去搜狗拼音的论坛看一下，但有价值的帖子较少，论坛比较混杂。</em></p>
<p><strong>(2016-10-30)上述问题已经解决，具体方法：</strong></p>
<ul>
<li>查看fcitx帮助文档，得知该软件是个汉字管理软件，因此将fcitx -d加入开启自启动进程。</li>
<li>使用ps -aux | grep fcitx和ps -aux | grep sogou查看当前运行的进程。</li>
<li>在任意地方开始使用搜狗输入法一段时间，然后再次执行ps -aux | grep fcitx和ps -aux | grep sogou，将该指令和上次执行过的比对，发现上次执行缺少sogou-qimpanel，人为将该指令加入到awesome的rc.lua开机单次执行中去。</li>
</ul>
<p><strong>搜狗拼音输入法 v2.1.0.0082 存在 bug：</strong></p>
<ul>
<li>该版本存在较大的问题，主要是输入中文 jinjin 时，软件会自动崩溃，需要重启 fcitx 和 搜狗拼音</li>
</ul>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115" target="_blank" rel="external">http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GP22芯片详解]]></title>
      <url>http://noparkinghere.win/2016/09/30/2016/2016-09-30-GP22%E8%8A%AF%E7%89%87%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>GP22是一款工业计算时间的芯片，由于其精度高在几十ps级别，所以被广泛的应用在气表水表上面。本人由于工作上面的原因，有机会接触到这款芯片，但该芯片的研究学习并不简单，由于有多个寄存器，再加上寄存器的配置复用位数很多，所以注定这款芯片不简单，另外一些模拟数字电路，晶振校准能耗，采样精度等等各种功能很是繁杂，所以可以说这款芯片已经是类似于51单片机这种需要学习研究一下的芯片了。这篇文章将不断地总结记录，在使用这种芯片的重点，已经一些问题的总结。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>参考链接：</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）机器人工程师学习计划]]></title>
      <url>http://noparkinghere.win/2016/09/28/2016/2016-09-28-%EF%BC%88%E8%BD%AC%EF%BC%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p><em>本文是转载的一篇知乎专栏上的文章，写的相当好。可惜当年上学的时候无人指点，浪费了太多的光影。</em></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">作者：YY硕</div><div class="line">链接：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">22266788</span></div><div class="line">来源：知乎</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p>
<p>两年前，我在知乎回答如何定义「机器人」？ - YY硕的回答中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答我说到传感器是和物理世界交互的基础。后来，我又在知乎回答有哪些与控制、机器人等相关的 quotes？ - YY硕的回答中提到莫拉维克悖论（Moravec’s paradox），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p>
<p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p>
<p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（<a href="http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：" target="_blank" rel="external">http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：</a></p>
<p>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。<br>认知。人工智能、知识表达、规划、任务调度、机器学习等。<br>行为。运动学、动力学、控制、manipulation和locomotion等。<br>数学基础。最优估计、微分几何、计算几何、运筹学等。<br>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p>
<p>一些可能有争议性的观点：</p>
<ol>
<li><p>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</p>
</li>
<li><p>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</p>
</li>
<li><p>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</p>
</li>
</ol>
<p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p>
<p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p>
<p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p>
<p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p>
<a id="more"></a>
<h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p>
<p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p>
<p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p>
<p>网上有很多对于如何学好线性代数的讨论，比如知乎问题如何理解线性代数？ - 数学学习。Matrix67大神的文章随记：我们需要怎样的数学教育？也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href="https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done" target="_blank" rel="external">https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done</a> Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是麻省理工公开课：线性代数。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p>
<p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p>
<p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是麻省理工学院公开课：计算机科学及编程导论，比较好的Python开发学习环境是Anacoda (<a href="http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。" target="_blank" rel="external">http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</a></p>
<p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p>
<p>学习C我个人入门用的是清华大学出版的《C++语言程序设计》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。" target="_blank" rel="external">http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</a></p>
<p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（The leading OS for PC, tablet, phone and cloud）。原因是机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p>
<p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（Makefile详解（超级好）_mingw吧）这篇文章看。</p>
<p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="http://www.w3schools.com/，把网站左侧的“Learn" target="_blank" rel="external">http://www.w3schools.com/，把网站左侧的“Learn</a> HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上three.js / examples跪着看看热闹。</p>
<p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[转]MIT牛人解说数学体系，另一个是前Goolge研究员吴军博士写的《数学之美》（数学之美 (豆瓣)）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p>
<h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p>
<p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p>
<p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p>
<p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p>
<p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p>
<p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p>
<p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p>
<p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买Arduino STEM educational Robot kits Building Platform的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p>
<p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p>
<p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p>
<p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p>
<p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p>
<p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p>
<p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p>
<p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（Mathematica 到底有多厉害？ - Wolfram Mathematica），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control" target="_blank" rel="external">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control</a> of an Inverted Pendulum on a Cart）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p>
<p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p>
<h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p>
<p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p>
<p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（OpenCV | OpenCV）了。</p>
<p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 @Liu Top的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p>
<p>第一步：自己调一个小四轴飞起来<br>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 首页-第七实验室 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p>
<p>第二步：看硬件图、读代码<br>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p>
<p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p>
<p>第三步：小修小改加深理解<br>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p>
<p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p>
<p>第四步：理解核心的数学和控制知识<br>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。<br>姿态解算和控制解算涉及的知识有：</p>
<ol>
<li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。<br>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</li>
<li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li>
<li>线性估计基本原理。其实就是互补滤波：Reading a IMU Without Kalman: The Complementary Filter 。拿这个关键词百度各种搜就会了。<br>第五步：重头开始造轮子<br>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</li>
</ol>
<p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p>
<p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p>
<p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p>
<p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p>
<p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p>
<p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p>
<p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p>
<p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p>
<p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p>
<p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。" target="_blank" rel="external">http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</a></p>
<p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) = det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p>
<h3 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h3><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p>
<p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p>
<ol>
<li><p>概率机器人学，<a href="https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623" target="_blank" rel="external">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></p>
</li>
<li><p>凸优化，<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf" target="_blank" rel="external">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</a></p>
</li>
<li><p>线性系统理论，<a href="https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579" target="_blank" rel="external">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></p>
</li>
<li><p>Multiple View Geometry in Computer Vision，Multiple View Geometry in Computer Vision</p>
</li>
<li><p>线性估计，<a href="https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642" target="_blank" rel="external">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></p>
</li>
<li><p>《机器学习》，周志华老师的书。</p>
</li>
<li><p>An Invitation to 3-D Vision，<a href="https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf" target="_blank" rel="external">https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf</a></p>
</li>
<li><p>Modern Control Systems，<a href="https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580" target="_blank" rel="external">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></p>
</li>
<li><p>Rigid Body Dynamics，<a href="http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。" target="_blank" rel="external">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</a></p>
</li>
<li><p>Feedback Systems: An Introduction for Scientists and Engineers，FBSwiki</p>
</li>
</ol>
<p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p>
<p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p>
<p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p>
<p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p>
<p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p>
<p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐Draw Freely | Inkscape，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p>
<p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p>
<p>关于毕业设计的选题，我推荐这么几个：</p>
<ol>
<li><p>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</p>
</li>
<li><p>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</p>
</li>
<li><p>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</p>
</li>
<li><p>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</p>
</li>
<li><p>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</p>
</li>
</ol>
<p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p>
<p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p>
<h3 id="研究生一年级"><a href="#研究生一年级" class="headerlink" title="研究生一年级"></a>研究生一年级</h3><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p>
<p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p>
<p>如果做控制系统的研究，3、8、9、10一定要精读。</p>
<p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p>
<p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href="https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。" target="_blank" rel="external">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。</a></p>
<p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（Parallel Tracking and Mapping for Small AR Workspaces (PTAM)），ROS的标配VO（viso2_ros - ROS Wiki），SVO（GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry），LSD-SLAM（<a href="http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub" target="_blank" rel="external">http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub</a> - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：机器人 - 标签。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。" target="_blank" rel="external">https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。</a></p>
<p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p>
<p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答RoboMasters2015夏令营是怎样的？ - YY硕的回答里吹过一波M100，前面说过的今年夏令营的知乎回答参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新里也有人帮我吹了一波。</p>
<p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p>
<p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient" target="_blank" rel="external">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient</a> descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p>
<p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href="https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。" target="_blank" rel="external">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</a></p>
<p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包MoveIt! Motion Planning Framework，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（Denavit），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href="http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。" target="_blank" rel="external">http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。</a></p>
<p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p>
<p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href="http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。" target="_blank" rel="external">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</a></p>
<p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p>
<h3 id="研究生二年级"><a href="#研究生二年级" class="headerlink" title="研究生二年级"></a>研究生二年级</h3><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p>
<p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p>
<p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p>
<p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p>
<p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie" target="_blank" rel="external">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie</a> Shen的工作。</p>
<p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（New ‘deep learning’ technique enables robot mastery of skills via trial and error），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神@戴泓楷@周佳骥。</p>
<p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p>
<p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p>
<p>结束语</p>
<p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[关于手机的一些个人看法]]></title>
      <url>http://noparkinghere.win/2016/09/28/2016/2016-09-28-%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>个人一直很喜欢电子产品，且关于电子科技类新闻较多，近几年来可以说每日必看，曾经也经常混迹于各大论坛贴吧微博等。本文当然仅仅代表本人（一个非专业人事）对各个手机厂家品牌的一些看法，文章可能不会一次性写完，会随着我对手机了解成都的不断加深而更新本文。</p>
<a id="more"></a>
<p>To be continued…</p>
<hr>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过git管理一个工程]]></title>
      <url>http://noparkinghere.win/2016/09/28/2016/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>GIT虽然能够实现各种版本控制，且功能强大，可以做到随时切换版本，回退等各种功能，但过多的分支，无效的分支，杂乱的提交，无意义的命名等等问题，往往会让像我这样的初学者，异常头痛，网络上关于git的往往都是指导你各个命令如何去用，部分命令的使用场景等，但却缺少一个完整工程项目的管理步骤。部分大神的确总结出了自己的使用习惯，但却不是作为教程来陈述的，下面我会将自己的一些习惯进行总结，后续可能遇到更好的也还会不断的更改。</p>
<p>下面是一张团队协作示意图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/0.png" alt=""></p>
<p>通过这张图，我们可以初步了解git的工作流程，接下来将以这张图为基础，进行详细分析论述。</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>个人的GIT使用习惯，注意：不在master上面轻易进行提交，一般所有的工作步骤都放在develop分支上面进行，不做无意义的提交，所有提交最起码是能够通过编译的版本，有一定程度上的修改优化，且每次提交必须付上详细的commit说明。基于develop，如果平行进行多种不同类型版本的开发，则所有都建立相应的新分支dev_name，而基于dev_name，每个开发人员再次建立各自的分支，只有在完成相关开发后将各自分支合并到dev_name中。通过测试多个dev_name，选择最终确定的方案，将develop分支合并到某条dev_name上，继续开发，后续如果在遇到类似问题，继续重复上述步骤。默认的master分支只用来快速合并develop分支来确定发行版，对所有发行版都加入tag(release_name)。简单来说就是：GIT不断创建分支，master用来合并develop分支作为发行版发布；develop分支用来合并dev_name分支作为开发的主要分支；dev_name合并所有开发人员的各个提交的分支，在没有dev_name的情况下（即只有一个develop分支），develop分支用来合并所有开发人员的各个提交的分支。</p>
<p><strong>git控制版本的过程就是分支不断提交合并的过程。</strong></p>
<a id="more"></a>
<h3 id="版本控制步骤："><a href="#版本控制步骤：" class="headerlink" title="版本控制步骤："></a>版本控制步骤：</h3><ul>
<li>对项目初始化版本库（注意不能是裸库，裸库只能远程下载查看，无法本地查看，类似的github和git服务就是这种裸库）</li>
<li>编辑好相应的.gitignore文件，该文件用来忽略一些文件，不让提交，一般可以是非必要的工程文件，编译生成的文件等。（.git目录下也存在类似.gitignore的忽略文件，但该文件不能被提交和push，因此强烈建议使用.gitignore）</li>
<li>进行第一次空工程的提交，主要将.gitignore提交给master。</li>
<li>建立分支develop，将工作分支切换到develop上。</li>
<li>进行相应的程序编辑和编译，完成后，提交版本库。（因为上面已经checkout到了develop，所以默认的提交就是到develop，不进行分支切换的话，以后默认也都在这个分支上面进行。）</li>
<li>假如这时候需要建立多个版本进行分别开发，这时候需要建立多个dev_name分支（注意这边是建议对所有版本都建立新的分支，作为develop的分支进行开发测试，而develop只用于最后对他们做合并。），需要开发哪个版本就切换到哪条dev_name分支上面进行开发提交。</li>
<li>假设多个版本开发测试完毕，用户需要某个功能的测试版本，则给该分支的某个版本再建立新分支test_release，然后打上tag标记，可以简单发布。</li>
<li>然而项目仍然需要推进，最终你需要在所有测试版本中选择出最优的一个合并到develop分支上，做接下来的开发。</li>
<li>在develop分支上进一步进行开发，假设现在不再仅仅是你一个人接手这个项目，而是多个人的团队，则需要基于develop建立多个分支，让每个单独负责其中的一个分支。每个人所要进行的工作都各自在自己的分支上面进行。假如这时团队成员都各自任务完成了，所有人都提交版本，这时则由组长专门将所有分支再次逐个合并到develop分支上，当然这部分可能会有冲突，需要手动合并。</li>
<li>假如再次需要建立多个版本进行分别开发测试，这时同上述步骤一只，再次建立多个dev_name分支，然后基于每个dev_name，为每个组员生成多个dev_name的子分支，每个组员各负责一条子分支。组员完成工作后，各个分支的负责人再次将把所有分支合并到各自的dev_name上，当所有版本测试完毕后，组长再次将所有dev_name合并<br>develop上。</li>
<li>如此，开发过程中反复进行上述建立分支合并分支的操作。最终需要发布正式版本的时候，组长将develop的内容快速合并到master分支上，然后为这个节点打上tag（如：v1.0）。注意：master分支只用来快速合并和发布版本。</li>
</ul>
<p>上述步骤详细的导图：<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/master.png" alt=""></p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href="http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_" target="_blank" rel="external">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git的配置及相关插件]]></title>
      <url>http://noparkinghere.win/2016/09/28/2016/2016-09-28-git%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>一个好的工具，需要不断的打磨和熟悉使用技巧才可以把它用的炉火纯青，git同样如此，本文主要是推荐一些git常用的配置以及配套的一些工具。</p>
<h3 id="git的相关配置："><a href="#git的相关配置：" class="headerlink" title="git的相关配置："></a>git的相关配置：</h3><h4 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h4><a id="more"></a>
<h3 id="推荐的git插件："><a href="#推荐的git插件：" class="headerlink" title="推荐的git插件："></a>推荐的git插件：</h3><h4 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h4><p>首先推荐<a href="http://jonas.nitro.dk/tig/" target="_blank" rel="external">tig</a>（名字刚好和git相反），是一个专门针对git的小软件，官方这么介绍<em>text-mode interface for Git</em>。</p>
<p>推荐可以访问<a href="https://github.com/jonas/tig" target="_blank" rel="external">tig的github页面</a>,里面有相关的下载安装说明。</p>
<ul>
<li>软件能够恨清晰的看到你的版本目录结构</li>
</ul>
<h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><h4 id="小乌龟插件"><a href="#小乌龟插件" class="headerlink" title="小乌龟插件"></a>小乌龟插件</h4><h4 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h4>]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[windows7和虚拟机中的ubuntu实现文件共享]]></title>
      <url>http://noparkinghere.win/2016/09/26/2016/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>国内很多用户习惯于使用windows系类操作系统，然而其中部分人员需要使用ubuntu进行一些开发测试，但他们并不想完全脱离windows系统，这时候虚拟机满足了他们的需求，虚拟机以安装配置简单，镜像还原起来方便安全，而被广大学习爱好者所喜爱。但有些时候，需要将真实机中的一些文档或者数据传输到虚拟机中，而如何实现虚拟机同真实机的共享往往是一些初学者头痛的事情。下面我列举出几种方法，可以满足解决这些问题。</p>
<h3 id="通过网盘进行传输"><a href="#通过网盘进行传输" class="headerlink" title="通过网盘进行传输"></a>通过网盘进行传输</h3><p>首先可以参照我之前写的<em>桥接、nat、host-only上网方式的区别</em>里面介绍了如何配置虚拟机上网，一般虚拟机上方较为方便，如：vmware或者virtualbox之类的都可以一键安装系统，即便手动安装，通过虚拟机拓展工具也都可以补全网卡显示上网的。如果对你所使用的linux发行版不是太熟悉，且极少传输文件的话，可以使用这种方法。推荐使用百度云之类的网盘，先将本地数据文件上传，然后再通过linux中的浏览器将数据文件下载下来。这种方式的好处是无需学习，没有门槛，不需要了解任何linux的知识，只需要当做一个桌面系统使用即可，坏处显而易见：1.依赖外网，2.机密文件不方便上传，3.必须上传下载，大型文件速度慢。</p>
<a id="more"></a>
<h3 id="进行以下几种方法前建议先关闭linux和windows的防火墙"><a href="#进行以下几种方法前建议先关闭linux和windows的防火墙" class="headerlink" title="进行以下几种方法前建议先关闭linux和windows的防火墙"></a><strong>进行以下几种方法前建议先关闭linux和windows的防火墙</strong></h3><h3 id="通过虚拟机扩展直接拖动"><a href="#通过虚拟机扩展直接拖动" class="headerlink" title="通过虚拟机扩展直接拖动"></a>通过虚拟机扩展直接拖动</h3><p>一般虚拟机中的linux安装扩展插件就可以直接将windows下的文件托进linux去了，或者将linux的文件拖到windows下，但前提要求是：<strong>需要虚拟机和操作系统的内核版本兼容，各方面切合度高，能够完美支持的情况下，最好使用虚拟机要和两个操作系统都是同一时期发型的，推荐是使用新版windows，最新版虚拟机还有最新发行版的linux系统。</strong></p>
<h3 id="通过scp命令"><a href="#通过scp命令" class="headerlink" title="通过scp命令"></a>通过scp命令</h3><p>Linux与Linux之间传送文件，使用scp命令，这是一种基于ssh的方式，因此<strong>两个系统都必须要支持ssh协议</strong>，安装方式：</p>
<ul>
<li>ubuntu：<code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code>重启ssh服务，其他发行版该命令未必适用。查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的sshd和ssh-agent如果未打开则运行指令名字。</li>
<li>windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，比如WinSCP（开源），winsshd，使windows系统支持ssh协议才行。</li>
</ul>
<p>从linux系统复制文件到windows系统：<br><code>scp /tmp/a.txt administrator@192.168.3.181:/d:/</code></p>
<p>在linux环境下，将windows下的文件复制到linux系统中：<br><code>scp  administrator@192.168.3.181:/d:/test/config.ips  /tmp</code></p>
<p><em>。scp的方法于只安装了CLI的linux版本使用，所有操作无需图形界面，且能够在linux下完成。另外该方法也并非任何地方都能够完成，和虚拟机扩展类似，对系统环境有一定要求，尤其是一定要找到可用的windows下的ssh协议，往往是linux的ssh完美运行，但无法登陆windows。</em></p>
<h3 id="通过WinSCP软件"><a href="#通过WinSCP软件" class="headerlink" title="通过WinSCP软件"></a>通过WinSCP软件</h3><p>该软件主要就是实现同一网段内的windows和linux的数据互传，本质上应该和scp命令原理是相同的，好处是图形化界面操作简单，登陆后无需再输入指令。WinSCP 是一个支持SSH（Secure SHell）的SCP（Secure CoPy）文件传输软件。只要文件主机支持SSH协定，你就可以安心的下载、上传文件。他的操作界面是参考NC（Norton Commander）的双视窗排列方式，使用起来不会有太大的困难。在WinSCP中，一般的文件操作都没有问题，如：复制、移动、更名文件或文件夹等。</p>
<p>输入主机名，用户名，密码，点击保存。通过下图中的界面，实现登陆：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.jpg" alt=""></p>
<p><em>第一登陆的时候，会告诉你服务器的主秘钥不再缓存中，确认修改后，即可远程登陆，另外如果使用root用户的话，新安装的ubuntu系统需要设置root密码，以及修改ssh的配置文件：<code>sudo vi /etc/ssh/sshd-config</code>，将PermitRootLogin修改为yes。重启ssh服务：<code>sudo /etc/init.d/ssh restart</code></em></p>
<p>文件的上传与下载跟Windows的资源管理器差不多了，如果要编辑目录或文件，只要右键就会出相应的可选的项目。下图为登陆后的资源管理界面：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg" alt=""></p>
<h3 id="通过虚拟机共享文件夹的方式"><a href="#通过虚拟机共享文件夹的方式" class="headerlink" title="通过虚拟机共享文件夹的方式"></a>通过虚拟机共享文件夹的方式</h3><h4 id="安装VMware-tools或者virtualboxaddition等工具"><a href="#安装VMware-tools或者virtualboxaddition等工具" class="headerlink" title="安装VMware tools或者virtualboxaddition等工具"></a>安装VMware tools或者virtualboxaddition等工具</h4><ul>
<li>在VMware虚拟机界面，点VM-&gt;Install VMware Tools。之后，点击Ubuntu 窗口中主文件 按钮然后再左边会看见设备里有VMware tools文件夹，双击之，并且解压其中的压缩文件，把它拷贝到主文件夹</li>
<li>打开Terminal终端，进入解压的文件夹中，输入以下命令：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo tar zxf VMwareTools-xxx<span class="selector-class">.tar</span><span class="selector-class">.gz</span> (注：xxx为版本号)</div><div class="line">cd /vmware-tools-distrib</div><div class="line">sudo ./vmware-install<span class="selector-class">.pl</span></div><div class="line">安装过程中一直按enter即可，或者输入【】提示yes和no，直到安装完毕。</div></pre></td></tr></table></figure>
<ul>
<li>查看结果：lsmod | grep vmblock</li>
</ul>
<h4 id="设置共享文件夹的目录"><a href="#设置共享文件夹的目录" class="headerlink" title="设置共享文件夹的目录"></a>设置共享文件夹的目录</h4><ul>
<li>将Ubuntu关机（power off），否则不能添加共享文件夹</li>
<li>在VMware虚拟机窗口，选择VM-&gt;Settings-&gt;Options-&gt;Shared Folders</li>
<li>点右边的Add，点Next-&gt;选择Win7共享目录的路径，然后点Next-&gt;选中Enable this share-&gt;Finish</li>
<li>在VM-&gt;Settings-&gt;Options-&gt;Shared Folders窗口的右边，Folder sharing栏里选择Always enabled</li>
<li>点 OK 确定退出</li>
</ul>
<h4 id="在Ubuntu虚拟机下安装插件"><a href="#在Ubuntu虚拟机下安装插件" class="headerlink" title="在Ubuntu虚拟机下安装插件"></a>在Ubuntu虚拟机下安装插件</h4><ul>
<li>执行 sudo apt-get install open-vm-dkms (注：如果无法查到open-vm-dkms，则可能更名为：open-vm-tools-dkms)</li>
<li>执行 sudo mount -t vmhgfs .host:/ /mnt/hgfs </li>
<li>cd /mnt/hgfs</li>
</ul>
<p>注意：即便完成了这个方法的所有步骤也未必能够完成共享文件夹，同虚<em>拟机扩展直接拖动</em>类似，该方法对系统和虚拟机切合度要求较高，vmtools和ubuntu内核存在版本不兼容的问题，mount经常支持不够好。也就是说同样的方法，相同的步骤，有的人轻松就可以实现，有的需要不断的去修补linux的脚本头文件等，当然解决是一定可以解决，但往往较为麻烦，如果该方法不行，建议尝试其他方法。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><em>通过scp命令</em>和<em>通过虚拟机共享文件夹的方式</em>并不推荐，建议首先尝试安装虚拟机扩展工具，如果可以直接拖拽文件则问题已解决，无需参考文章中的方法，如果不行的话，推荐通过WinSCP软件来操作，适用的场景多且不容易出错，本人尝试过如centos 6.5，ubuntu 16.04等多个主流操作系统，均可以实现传输。</p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://huangfuff.blog.51cto.com/2632203/1604500" target="_blank" rel="external">http://huangfuff.blog.51cto.com/2632203/1604500</a><br><a href="https://my.oschina.net/u/811744/blog/179229" target="_blank" rel="external">https://my.oschina.net/u/811744/blog/179229</a><br><a href="https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/" target="_blank" rel="external">https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/</a><br><a href="http://blog.csdn.net/warringah1/article/details/8927437" target="_blank" rel="external">http://blog.csdn.net/warringah1/article/details/8927437</a><br><a href="http://fancyseeker.github.io/2013/12/31/ssh_connect/" target="_blank" rel="external">http://fancyseeker.github.io/2013/12/31/ssh_connect/</a><br><a href="http://blog.csdn.net/lulitianyu/article/details/50446015" target="_blank" rel="external">http://blog.csdn.net/lulitianyu/article/details/50446015</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[字符编码]]></title>
      <url>http://noparkinghere.win/2016/09/22/2016/2016-09-22-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>字符编码（英语：Character encoding）、字集码是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。计算机中的字符编码算是一个历史遗留性问题，因为各个国家种族对应着不同的问题，以及各个组织机构推出不同的标准，因此现在计算机中的字符编码格式繁多。</p>
<p>打开某网页，或者用记事本打开某文本文件时，我们可能会看到一堆的乱码如”бЇЯАзЪСЯ”、”�????????”，出现这种问题，往往是我们选用的字符编码不对。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。也就是说，我们在计算机中存储数据时，字母 ‘a’ 需要用什么二进制来表示，这便称为”编码”；反之，将存储在计算机中的二进制数解析显示出来，称为”解码”，如同密码学中的加密和解密。而如果在解码过程中我们使用了错误的规则，则会导致解码错误 ‘a’ 变成了 ‘0’。</p>
<p>字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>字符编码（Character Encoding）：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p>
<h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>常见字符编码为：ASCII,GB2312,UTF-8,Unicode,Big5等，下面我们对其中一些详细阐述。</p>
<h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p>ASCII（1963年）和EBCDIC（1964年）这样的字符集逐渐成为标准。最早的时候计算机ASCII码只能表示256个符号（含控制符号），这个字符集表示英文字母足够。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，我们通常成为扩展 ASCII 码，其使用 8位（bits）表示一个字符，共256字符。</p>
<p>一般标准 ASCII 码是每个学计算机的人必须知道和了解的，对常用的一些字符所表示的二进制能够非常熟悉，例如：(0-9)-&gt;(0x30-0x39) (A-Z)-&gt;(0x41-0x5A) (a-z)-&gt;(0x61-7A) NULL-&gt;(0x00) 等。</p>
<p>虽然 ASCII 的使用范围很广，但表示汉字、日语、韩语就不太够用了，汉字常用字有3000多个。这些字符集的局限很快就变得明显，于是人们开发了许多方法来扩展它们，于是就有了其他一些新兴字符集的出现。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-22-字符编码/1.png" alt=""></p>
<h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。但对于亚洲众多国家来说并不适用，当计算机传入我国后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。</p>
<p>于是国内指定了国标 GB2312（中国国家标准简体中文字符集），全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。</p>
<p>中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-22-字符编码/2.png" alt=""></p>
<p>GB2312 定义的规则如下：一个小于 127 的字符的意义与原来相同（即：兼容 ASCII 码标准），但两个大于 127 的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从 0xA1 用到 0xF7，后面一个字节（低字节）从 0xA1 到 0xFE，这样我们就可以组合出大约 7000 多个简体汉字了，GB2312 是对 ASCII 的中文扩展。</p>
<p>在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在 127 号以下的那些就叫”半角”字符了，也就不难看出为何我们平时选用全角输入数字字母时，会发现样式变宽了，占用了多个位置，这也是因为采用全角后，每个字符占用了两个字节，一般我应该要避免使用这种情况输入。</p>
<p>GB2312 后来发现还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-22-字符编码/3.jpg" alt=""></p>
<h4 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h4><p>Big5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13,060个汉字。Big5虽普及于台湾、香港与澳门等繁体中文通行区，但长期以来并非当地的国家标准，而只是业界标准。Big5码是一套双字节字符集，使用了双八码存储方法，以两个字节来安放一个字。第一个字节称为”高位字节”，第二个字节称为”低位字节”。”高位字节”使用了0x81-0xFE，”低位字节”使用了0x40-0x7E，及0xA1-0xFE。这边不再对该编码做过多的介绍。</p>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p>
<p>Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</p>
<p>从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的一个字符（并不是一个字节，而是两个字节）。在unicode中，一个字符就是两个字节，一个汉字不再类似于 GB2312 中当作两个字符来处理了。</p>
<p>unicode同样有着自身的问题，一个是，如何才能区别 unicode 和 ascii 。计算机如何知道三个字节表示一个符号，而不是分别表示三个符号呢？二是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于过去计算机来说存储空间极为珍贵，而这样做无疑造成了极大的浪费，文本文件的大小会因此大出两三倍，这是难以接受的。</p>
<p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了。UTF-8 就是每次8个位传输数据，而UTF-16就是每次16个位传输。UTF-8 就是在互联网上使用最广的一种 unicode 的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>
<p><strong>可以这样理解：Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。</strong></p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</p>
<p><strong>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</strong></p>
<p>UTF-8 的编码规则很简单：</p>
<ul>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 unicode 码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</li>
<li>对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li>
</ul>
<p>下面是对比 Unicode 和 UTF-8 的对比：</p>
<table>
<thead>
<tr>
<th>Unicode 符号范围</th>
<th>UTF-8 编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>(十六进制)</td>
<td>（二进制）</td>
</tr>
<tr>
<td>0000 0000-0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080-0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800-0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000-0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，”严”的 UTF-8 编码是 “11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>
<h3 id="BOM头"><a href="#BOM头" class="headerlink" title="BOM头"></a>BOM头</h3><p>UTF-8 本来是兼容性最好的编码，但 Windows 偏要加 BOM 于是经常出问题。</p>
<p>在 utf-8 编码文件中 BOM 在文件头部，占用三个字节，用来标识该文件属于 utf-8 编码，现在已经有很多软件识别 BOM 头，但还是有些不能识别 BOM 头，比如 PHP 就不能识别 BOM 头，这也就是用记事本编辑 utf-8 编码的 PHP 文件后，就会报错的原因。</p>
<p>在windows环境下，用记事本打开任何一个文本文件，另存为utf-8格式后，这样文件就自动被加上了BOM头信息。含BOM头的文件，在文件开头处多出三个字节 0xefbbbf。</p>
<p>windows 下一般不建议使用记事本打开文本文件，就如上面所提到的原因，记事本会加入 BOM 头，与此同时，记事本在处理其他平台传过来的文本时还有其他问题，因此计算机工作者，编辑文本时，推荐使用 notepad++ 或者 editplus。这些软件都可以兼容多个平台的文本文件，同时编辑能力强，打开速度快，能够直接各种格式的编码。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">https://www.zhihu.com/question/20650946</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</a><br><a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</a><br><a href="http://baike.baidu.com/link?url=HknfN5Mei0ekD1hoPPs-U1osSOA1tDDFYkfPfNa05SNX36LbaAh4ctHt_2XhefTVW03ZCRLaBw1dYpY6iG3-ea" target="_blank" rel="external">http://baike.baidu.com/link?url=HknfN5Mei0ekD1hoPPs-U1osSOA1tDDFYkfPfNa05SNX36LbaAh4ctHt_2XhefTVW03ZCRLaBw1dYpY6iG3-ea</a><br><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">https://www.zhihu.com/question/23374078</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a><br><a href="http://www.cnblogs.com/lfire/archive/2012/11/20/2778939.html" target="_blank" rel="external">http://www.cnblogs.com/lfire/archive/2012/11/20/2778939.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[windows 7个人使用环境配置]]></title>
      <url>http://noparkinghere.win/2016/09/20/2016/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>windows 7作为个人使用最久的一个系统，无论是稳定性美观程度等等都相当优秀，虽然windows是商业软件，源代码不开放定制性差，但通过一些日常的配置，配合常用的软件还是能够将它打造成一个个性化很强用起来恨顺畅的系统。本人因为工作需要经常会用到windows系统，另外周围也有不少朋友都用的这个系统，所以这边着重总结个人的一些常用配置，以及推荐一些非专业类软件。通过本文的文章和截图，后续重装系统，也能够轻松对照配置修改回来。</p>
<p><strong>假设你已经安装完了系统，这一个纯净版（非ghost版本，一般我都是安装这个版本）的windows 7，桌面仅有一个垃圾桶，没有其他软件。</strong></p>
<h3 id="windows-配置"><a href="#windows-配置" class="headerlink" title="windows 配置"></a>windows 配置</h3><h4 id="配置任务栏"><a href="#配置任务栏" class="headerlink" title="配置任务栏"></a>配置任务栏</h4><p>个人习惯采用小图标，窄任务栏，这样的好处是屏幕可以显示更多的内容。见下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png" alt=""></p>
<h4 id="修改窗体颜色"><a href="#修改窗体颜色" class="headerlink" title="修改窗体颜色"></a>修改窗体颜色</h4><p>一是为了美观，修改aero的透明窗体颜色，可以让窗体和任务栏，另外改变窗体颜色外观可以起到护眼的作用。见下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png" alt=""></p>
<h4 id="修改显示器颜色"><a href="#修改显示器颜色" class="headerlink" title="修改显示器颜色"></a>修改显示器颜色</h4><p>如果是台式机显示器，则显示器上面的配置按键可以进行手动修改，无需参照下面方式，下列方式主要适用于笔记本软件调节的方式，见下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png" alt=""></p>
<p><em>通过调整这些参数可以过滤部分蓝光效果，让颜色显暖色更易于护眼，当然这样做的坏处就是整体颜色失真，观看电影视频时候观感下降，另外如果设计图片视频时会对你有较大的影响，这边也可以使用第三方软件更加智能的调节，软件部分会推荐介绍该软件。</em></p>
<h4 id="电池管理"><a href="#电池管理" class="headerlink" title="电池管理"></a>电池管理</h4><p>这边针对笔记本在会待机，合上盖子会休眠等进行修改。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png" alt=""></p>
<h4 id="修改输入法的切换按键"><a href="#修改输入法的切换按键" class="headerlink" title="修改输入法的切换按键"></a>修改输入法的切换按键</h4><p><em>实现该功能的目的主要是切换中英文输入法，在使用ctrl或者shift切换时，很明显这两个键的位置远不如caps按起来方便，且shift往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而caps作为大小写时用起来相当罕见。大写完全可以用shift代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。<strong>这边将右ctrl和caps进行功能对调。</strong></em></p>
<p>打开注册表，在运行（win+R）中输入regedit，注册表位置：[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的Key，名叫：Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入如下的值：</div><div class="line">　　00,00,00,00</div><div class="line">　　00,00,00,00</div><div class="line">　　03,00,00,00</div><div class="line">　　3A,00,1D,E0</div><div class="line">　　1D,E0,3A,00</div><div class="line">　　00,00,00,00</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png" alt=""></p>
<p><strong>详细内容可以参见我的另外一篇专门介绍按键互换的文章。</strong></p>
<a id="more"></a>
<h3 id="常用基础软件"><a href="#常用基础软件" class="headerlink" title="常用基础软件"></a>常用基础软件</h3><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p><em>windows 自带的记事本，记事本的问题较多，例如：WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。所以windows下如果适用记事本会给跨平台编码带来巨大的麻烦，一旦出现很难发现和解决。另外记事本的编辑能力弱，可读性差等特点，也让大伙儿一致的决定抛弃这个软件。下面推荐两款比较好的文本编辑软件，无论是查看普通文本编辑，还是要少量的修改代码，这个两个软件都是不错的选择。</em></p>
<ul>
<li>editplus</li>
</ul>
<p>本人一般都用这个来编辑普通文件，如.txt,.md等需要阅读的文件，一般不需要怎么配置即可轻松上手使用，功能很强大，但个人主要用作查阅写说明文档等，一般不会对它单独定制。总之一点，这个软件配合上面我设置的窗口调色，用起来就是阅读舒服，写起来顺畅。但<strong>该软件是商业软件，需要付费使用。</strong></p>
<ul>
<li>notepad++</li>
</ul>
<p>windows下最喜欢的一款编辑器，功能强大，可定制性强，运行速度快，占用资源小，免费开源软件，可以说众多优点集一身。一般我只会对它进行简单的配置即可，主要用来修改文件代码。当然你也可以只用它即可，无需使用上面的editplus，因为个人将颜色调整为暗黑色，不易于阅读文本文字，所以同时安装了这两个软件。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png" alt=""></p>
<h4 id="输入法-有详细文章"><a href="#输入法-有详细文章" class="headerlink" title="输入法(有详细文章)"></a>输入法(有详细文章)</h4><p>选择<strong>搜狗或者qq拼音精简版</strong>，这两个都是不错的选择，百度占用资源较大，且，另外一些配置设置不够人性化，使用起来较麻烦，需要注意的是，拼音中开启两个功能：</p>
<ul>
<li>按ctrl按键切换中英文输入，上述设置了<em>键盘映射</em>，需要开启这个功能才可以。</li>
<li>安装截图插件，qq简版的截图功能较差，无法自动命名，可以选择搜狗拼音。</li>
</ul>
<p><em>主要强调的是windows下输入法的配置，因为完全使用第三方输入中的中英文，所以不再需要自带的输入法了，具体参见如下图片：</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png" alt=""></p>
<h4 id="检索软件"><a href="#检索软件" class="headerlink" title="检索软件"></a>检索软件</h4><p>也是个强烈推荐的一款可以快速检索的软件，软件特点如下：</p>
<ul>
<li>占用资源较大，长期占用一定的内存，且会影响开机时间，但现在内存都很大，这点可以接收，开机根据个人情况，一般无所谓，如果是固态硬盘，那就更没有什么影响了。</li>
<li>类似于linux下的locate命令吧，将所有文件信息生成一个数据库，然后每次搜索时能够快速定位，但当日修改的文件，信息更新的未必及时。</li>
</ul>
<p>国内软件中可以选用<em>稻田搜搜</em>,该软件界面好看，该有的功能也都有，但不支持通配符搜索，另外占用资源貌似也比较大。这边主要推荐使用 everything 这个老牌搜索软件，软件虽然小，但可定制性相当强，个人配置如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e1.png" alt=""><br>上图可见布局，右侧预览效果相当强大。</p>
<p>下面是一些我个人的定制，仅供参考：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e8.png" alt=""></p>
<h4 id="金山词霸"><a href="#金山词霸" class="headerlink" title="金山词霸"></a>金山词霸</h4><p>一款查单词较方便的软件，这边不推荐有道，是因为有道现在广告泛滥了，金山词霸还拥有离线版本，如果在公司不方便上网一样可以使用，之所以推荐客户端版本的字典，主要是他们都可以捕捉桌面词汇，不限于浏览器或者PDF文档等，我一般设置：</p>
<ul>
<li>双击alt将字典调出</li>
<li>选中单词双击ctrl调出解释</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">https://www.zhihu.com/question/20650946</a><br><a href="http://www.huangbowei.com/archives/92.html" target="_blank" rel="external">http://www.huangbowei.com/archives/92.html</a><br><a href="http://baike.baidu.com/subview/126558/5073180.htm" target="_blank" rel="external">http://baike.baidu.com/subview/126558/5073180.htm</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 配置推荐 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu搭建wordpress服务]]></title>
      <url>http://noparkinghere.win/2016/09/14/2016/2016-09-14-ubuntu%E6%90%AD%E5%BB%BAwordpress%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><em><a href="https://cn.wordpress.org/" target="_blank" rel="external">wordpress</a> 是目前比较流行的博客模板，精美的外观强可定制性收到了国内外很多bloger的亲睐，之前在虚拟机的ubuntu_server上面搭建过这个环境，个人所使用的blog是基于jekyll的静态页面，所以对wordpress不是特别了解，这边以腾讯云的ubuntu服务器为基础搭建自己的wordpress服务，当然现在很多云服务已经支持一键搭建wordpress的功能，但据说“访问速度和灵活性会受到很大影响”，这边有兴趣的朋友可以自己去尝试一下。</em></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul>
<li>需要搭建一个服务器，首先需要选定自己使用哪些服务套件，这边我选用LAMP套装，即linux(ubuntu), apache2.0, mysql, php(wordpress)。</li>
</ul>
<a id="more"></a>
<h3 id="详细安装步骤"><a href="#详细安装步骤" class="headerlink" title="详细安装步骤"></a>详细安装步骤</h3><h4 id="1-检查电脑是否安装了这些服务。"><a href="#1-检查电脑是否安装了这些服务。" class="headerlink" title="1.检查电脑是否安装了这些服务。"></a>1.检查电脑是否安装了这些服务。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dpkg <span class="_">-l</span> | grep apache</div><div class="line">dpkg <span class="_">-l</span> | grep php</div><div class="line">dpkg <span class="_">-l</span> | grep mysql</div></pre></td></tr></table></figure>
<h4 id="2-根据提示信息，如果没有安装则补安装。"><a href="#2-根据提示信息，如果没有安装则补安装。" class="headerlink" title="2.根据提示信息，如果没有安装则补安装。"></a>2.根据提示信息，如果没有安装则补安装。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install apache2 mysql-server php5 libapache2-mod-php5</div><div class="line">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>
<h4 id="3-让apache、php支持mysql"><a href="#3-让apache、php支持mysql" class="headerlink" title="3.让apache、php支持mysql"></a>3.让apache、php支持mysql</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libapache2-mod-auth-mysql php5-mysql</div><div class="line">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>
<h4 id="4-安装phpMyAdmin"><a href="#4-安装phpMyAdmin" class="headerlink" title="4.安装phpMyAdmin"></a>4.安装phpMyAdmin</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install phpmyadmin</div><div class="line">此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹。</div><div class="line">进入/var/www文件夹，在该目录下执行如下操作:</div><div class="line">sudo ln <span class="_">-s</span> /usr/share/phpmyadmin</div></pre></td></tr></table></figure>
<h4 id="5-为Wordpress新建mysql数据库"><a href="#5-为Wordpress新建mysql数据库" class="headerlink" title="5.为Wordpress新建mysql数据库"></a>5.<a href="https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E5.88.9B.E5.BB.BAWordPress.E6.95.B0.E6.8D.AE.E5.BA.93.E5.92.8C.E4.B8.80.E4.B8.AA.E7.94.A8.E6.88.B7" target="_blank" rel="external">为Wordpress新建mysql数据库</a></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mysql -u root -p	// 登陆管理数据库</div><div class="line">Enter password:</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 5340 to server version: 3.23.54</div><div class="line"> </div><div class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> help. Type <span class="string">'\c'</span> to clear the buffer.</div><div class="line"> </div><div class="line">mysql&gt; CREATE DATABASE blog;	// 创建数据库名称</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; GRANT ALL PRIVILEGES ON blog.* TO <span class="string">"demon"</span>@<span class="string">"hostname"</span> // 受理权限</div><div class="line">    -&gt; IDENTIFIED BY <span class="string">"password"</span>;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">  </div><div class="line">mysql&gt; FLUSH PRIVILEGES;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div><div class="line"></div><div class="line">mysql&gt; EXIT</div><div class="line">Bye</div><div class="line">$</div></pre></td></tr></table></figure>
<hr>
<p>to be continued…</p>
<blockquote>
<p>参考链接：<br><a href="https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php" target="_blank" rel="external">https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php</a><br><a href="http://www.jianshu.com/p/7e6566b613a7" target="_blank" rel="external">http://www.jianshu.com/p/7e6566b613a7</a><br><a href="http://www.jianshu.com/p/26d9e752994e" target="_blank" rel="external">http://www.jianshu.com/p/26d9e752994e</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[解决重启网卡后ip route add丢失]]></title>
      <url>http://noparkinghere.win/2016/09/12/2016/2016-09-12-%E8%A7%A3%E5%86%B3%E9%87%8D%E5%90%AF%E7%BD%91%E5%8D%A1%E5%90%8Eip-route-add%E4%B8%A2%E5%A4%B1/</url>
      <content type="html"><![CDATA[<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[网络监控工具wireshark]]></title>
      <url>http://noparkinghere.win/2016/09/12/2016/2016-09-12-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7wireshark/</url>
      <content type="html"><![CDATA[<h3 id="wireshark简介"><a href="#wireshark简介" class="headerlink" title="wireshark简介"></a>wireshark简介</h3><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。</p>
<a id="more"></a>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="linux下的安装"><a href="#linux下的安装" class="headerlink" title="linux下的安装"></a>linux下的安装</h4><p>首先，安装只要一个命令行(由于之前装过了，所以没有在安装什么了)：sudo apt-get install wireshark 。已经将wireshark安装完毕，接下来我没就可以通过：终端输入wireshark 用来启动它的图形界面。<br>然而，dumpcap需要root权限才能使用的,以普通用户打开Wireshark，Wireshark当然没有权限使用dumpcap进行截取封包。虽然可以用:sudo wireshark来完成。但是，以sudo的方式用root打开Wireshark显然是不安全的，也不是很方便，因为得到的封包数据也属于root用户。于是，我们提供下面的方法来完成普通用户下的操作。</p>
<ul>
<li>添加wireshark用户组<code>sudo groupadd  wireshark</code>，一般软件安装完成后，可能已经自动帮你生成了这个组。</li>
<li>将dumpcap程序更改为所属组为wireshark用户组<code>sudo chgrp wireshark /usr/bin/dumpcap</code></li>
<li>让wireshark用户组有root权限使用dumpcap即更改dumpcap的科执行权限，赋予所属组执行权限 <code>sudo chmod 4755 /usr/bin/dumpcap</code></li>
<li>将需要使用的普通用户名加入wireshark用户组，我的用户是“demon”（需要根据具体用户名修改！在#前面可以找到哟），则需要使用命令：<code>sudo gpasswd -a demon wireshark</code></li>
</ul>
<p>通过以上步骤就可以以普通用户登陆打开Wireshark，也会有权限进行抓包了。</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><blockquote>
<p>参考链接：<br><a href="http://fangxin.blog.51cto.com/1125131/735178" target="_blank" rel="external">http://fangxin.blog.51cto.com/1125131/735178</a><br><a href="http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html</a><br><a href="https://openmaniak.com/cn/wireshark_filters.php" target="_blank" rel="external">https://openmaniak.com/cn/wireshark_filters.php</a><br><a href="http://www.jianshu.com/p/400d4430a74a" target="_blank" rel="external">http://www.jianshu.com/p/400d4430a74a</a><br><a href="https://wiki.wireshark.org/CaptureSetup/CapturePrivileges" target="_blank" rel="external">https://wiki.wireshark.org/CaptureSetup/CapturePrivileges</a><br><a href="https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup" target="_blank" rel="external">https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup</a><br><a href="http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html" target="_blank" rel="external">http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh相关使用]]></title>
      <url>http://noparkinghere.win/2016/09/09/2016/2016-09-09-ssh%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><em>使用ssh已经很多次，但每次用到都得查看相关说明，一些操作也不是特别熟悉，本文将总结自己使用的ssh服务说明。</em></p>
<h3 id="本地SSH配置"><a href="#本地SSH配置" class="headerlink" title="本地SSH配置"></a>本地SSH配置</h3><ul>
<li>首先我们需要检查你电脑上现有的 ssh key：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh 检查本机的ssh密钥</div></pre></td></tr></table></figure>
<p>如果提示：No such file or directory 说明你是第一次使用 git。</p>
<ul>
<li>生成新的SSH Key：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></div></pre></td></tr></table></figure>
<p><em>此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」</em></p>
<ul>
<li>然后系统会要你输入密码：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):&lt;输入加密串&gt;</div><div class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</div></pre></td></tr></table></figure>
<p><em>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，相当于二次的加密，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人嫌麻烦一般不会再设定密码，本身ssh的访问就属于本地自动加密认真，就比较安全，除非你秘钥丢失，否则一般不会出问题，</em></p>
<ul>
<li><p>看到这样的界面，就成功设置了本地的 ssh key了：</p>
</li>
<li><p>~/.ssh/id_rsa.pub 就是需要使用的公钥，将该公钥加入到其他系统上面或者支持ssh服务的软件上面即可实现访问。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="将本地公钥上传到远程linux服务器"><a href="#将本地公钥上传到远程linux服务器" class="headerlink" title="将本地公钥上传到远程linux服务器"></a>将本地公钥上传到远程linux服务器</h3><blockquote>
<p>不同的 Linux 之间 copy 文件常用有3种方法：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">第一种就是 ftp，也就是其中一台 Linux 安装 ftp Server，这样可以另外一台使用 ftp 的 client 程序来进行文件的 copy。</div><div class="line"></div><div class="line">第二种方法就是采用 samba 服务，类似 Windows 文件 copy 的方式来操作，比较简洁方便。</div><div class="line"></div><div class="line">第三种就是利用 scp 命令来进行文件复制。</div></pre></td></tr></table></figure>
<p><strong>scp 是有Security的文件 copy，基于 ssh 登录。操作起来比较方便，比如要把当前一个文件 copy 到远程另外一台主机上，可以如下命令。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root</div></pre></td></tr></table></figure>
<p>然后会提示你输入另外那台 172.19.2.75 主机的 root 用户的登录密码，接着就开始 copy 了。如果想反过来操作，把文件从远程主机 copy 到当前系统，也很简单。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz</div></pre></td></tr></table></figure>
<ul>
<li>我们将原始机的公钥拷贝到目标服务器的 .ssh 目录下，且命名为 authorized_keys。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<p><em>注意，ubuntu_server 为 ip 对应的名称，这边可以改成 ip 地址，git 为用户名。修改实体机(本地机而不是服务器)的 ip 配置文件 <code>/ect/hosts</code>，加入如下行：<code>192.168.18.202 ubuntu_server</code>， ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server,可以修改 /etc/hostname 中的名称。</em></p>
<p><strong>注意：ssh在使用时无法通过VPN，需要人为手动做一些修改，这边主要是通过将需要ssh访问的ip地址直接经过网卡而不经过vpn。详细内容参见<em>linux 下 ssh 通过VPN推送失败</em>文章。</strong></p>
<blockquote>
<p><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a><br><a href="http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html" target="_blank" rel="external">http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html</a><br><a href="http://blog.csdn.net/hunanchenxingyu/article/details/40544513" target="_blank" rel="external">http://blog.csdn.net/hunanchenxingyu/article/details/40544513</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[个人云服务器选择]]></title>
      <url>http://noparkinghere.win/2016/09/09/2016/2016-09-09-%E4%B8%AA%E4%BA%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<p><em>首先声明，本人并非从事运维工作，玩服务器等也纯属业余爱好，个人作为一个web菜鸟，仅仅是能够安装系统，基本使用 linux 的一些操作，具体原理了解并不多。本文主要是针对那些和我一样的业余爱好者，想体验下云服务，且又不知道该如何选择的用户。</em></p>
<p>虽然个人博客搭建了也有一段时间了，但一直都是投机取巧占用了其他网站的服务器，没使用自己的服务器，经过半年的摸索，也体验过多家的云服务（这边仅是体验，并没有长期使用），下面写写个人的小结。</p>
<p>要使你的网站能够被访问，首先得申请个域名，当然不申请域名，你搭建的服务也可以通过 IP 地址直接访问的，但是一般都不这么做，固定 IP 地址的价格还是很昂贵的，不再本文讨论范畴之内，这边讨论下域名申请，一个可以 .site,.top,.xyz 结尾的一级域名一年也只要几块钱，但请注意，申请域名的时候目前支持备案的并不多（不备案的域名，使用国内服务器的话，就会强制你下线，不让访问），常用可以备案的域名为 .cn .com .org .edu 等。推荐购买域名国内的话可以去万网看看，定期会有打折，而国外也有一些网站，这边就不一一例举，免费的域名建议不要使用，因为每隔一两个月或者几天就可能被收回去。一个 .site 结尾的域名，可能价格才几元钱，所以如果只是想要买个玩玩的话，这些是不错的选择，但是如果你是商业用途，建议还是购买 .com .cn 结尾的域名，因为你需要国内的服务器让你的客户稳定访问，而要能够稳定访问，你的域名必须得备案。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>首先谈及下国内第一大，云服务提供商阿里云，阿里云收购了原来万网的一系列服务，目前在 VPS 领域可以说是提供服务最完善，用户群体最多，功能最强的网站了，当然，价格也最贵，不是一般的非商业用户所能够承受的，对于我这样的非专业人士来说，上云暂时也仅仅是体验服务，学习研究之类的，所有阿里云会选择按量购买，毕竟个人觉得按月购买每个月价格还是蛮高的，如果不是有特别需求，或者盈利性质的网站，你可以选择按量购买，也就是说按你用来购买，不用的时候就关闭服务。这类似于手机流量一样，用多少流量卖多少，不用的时候就将服务关闭掉。</p>
<p>阿里云的特点：</p>
<ul>
<li>稳定，毕竟国内最大的提供商</li>
<li>价格昂贵，选择高带宽需要额外收费</li>
<li>功能多，操作界面美观，商务范十足</li>
</ul>
<h3 id="腾讯云试用"><a href="#腾讯云试用" class="headerlink" title="腾讯云试用"></a>腾讯云试用</h3><p>腾讯云注册后有5-7天的免费使用时间，个人感觉这个对从来没接触过云服务，第一次试用的同学来说，还是很不错的，最起码可以自己尝试搭建一些小型的网站如：博客之类的还是很不错的，当然时间很宝贵，要试用的话，还是得抓紧时间。腾讯云的体验各种活动要比阿里云多不少，但操作略显简陋，只能说具备基本的功能。</p>
<p>腾讯云特点：</p>
<ul>
<li>还算稳定，也算是国内的大公司</li>
<li>同样，价格不便宜，比阿里云略低，选择不同的带宽需要额外付费</li>
<li>功能基本具备，界面体验等一般</li>
</ul>
<a id="more"></a>
<h3 id="搬瓦工（BandwagonHost-VPS）"><a href="#搬瓦工（BandwagonHost-VPS）" class="headerlink" title="搬瓦工（BandwagonHost VPS）"></a><a href="https://bwh1.net/" target="_blank" rel="external">搬瓦工</a>（BandwagonHost VPS）</h3><p>目前来说国外性价比较高的一个 VPS 服务商，过去有过一些精巧型的服务提供，一个 500M 的硬盘，可能年付费才几美金。最大的特点就是价格便宜：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span> GB SSD RAID<span class="number">-10</span> Disk Space</div><div class="line"><span class="number">256</span> MB RAM</div><div class="line"><span class="number">500</span> GB Transfer</div><div class="line">Gigabit port</div><div class="line">Multiple locations</div><div class="line"></div><div class="line">$<span class="number">2.99</span>/month</div></pre></td></tr></table></figure>
<p>如上所示，一个 VPS 价格才 $3/month 这意味着一年才 ￥200 多，国内的公司提供的同等服务，基本上都要 500-1000 元，且是限制带宽的，默认为 1M 带宽，而国外都是 100M/1000M 带宽。</p>
<h3 id="vultr"><a href="#vultr" class="headerlink" title="vultr"></a><a href="https://www.vultr.com/pricing/" target="_blank" rel="external">vultr</a></h3><p>这网站也是国外比较出名的一个高性价 VPS 服务商，价格与搬瓦工差不多，竞争关系，时高时低。最低套餐如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">20</span> GB SSD</div><div class="line"><span class="number">512</span> MB RAM</div><div class="line"><span class="number">500</span> GB Bandwidth</div><div class="line">$<span class="number">2.5</span>/month</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-09-个人云服务器选择/1.png" alt=""></p>
<p>可见以上这个套餐还是很划算的，每个月不到 20 块，就可以享受这种套餐，20 GB SSD 首先速度有保证，其次也基本上能够完成你的所有实验用途了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上内容只列举了目前为止，我所体验过得 VPS 服务，当然国内也有很多小型服务商，可能价格会略微便宜，但之前打听过，价格也不低，目前情况不得而知。优先建议的话是选择国外的 VPS 来体验（因为能看本文的绝不会是从事商业用途的），国外的 VPS 购买后可以用来做什么？这边不具体展开详细说明，只做一个简要的说明参考：</p>
<ul>
<li>购买国外的 VPS 可以用来搭建科学上网服务（也就是绕过 GFW）</li>
<li>搭建个人的博客，毕竟外国提供带宽很大，博客访问都是不错的，不用于商业用途应该没有影响</li>
<li>学习服务搭建，用虚拟机虽然也能学习服务搭建，但毕竟没有实际操作来的更爽，更加直观（虽然 VPS 也是个虚拟机），搭建服务后，你可以在互联网中实际访问，这是虚拟机无法带给你的成就感。</li>
</ul>
<hr>
<p>后续有新的体验和经验，仍然会更新…</p>
<p>To be continued…</p>
<p>写作时间：20:30-21:30</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux基本命令]]></title>
      <url>http://noparkinghere.win/2016/09/06/2016/2016-09-06-linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><em>本文主要学习总结，使用 linux CLI 的基本命令，这边不以任何发行版为例，介绍的是绝大多数 linux 发行版上面都会含有的 CLI 软件，需要注意的是，这边是以完整安装为基础的，部分命令可能在最小安装上面无法使用。目前 安装 linux CLI 后可以使用的命令超过上千个，但最常用的命令一般只有 80 个左右，由于篇幅有限，本文会选取 80 个中的几十个最基本必须掌握的命令进行罗列和简介，不会展开详解，详细内容还是需要查看 manual 或者借助搜索引擎。</em></p>
<p>shell 命令的一般格式为：command [option] [arguments]。具体如下：</p>
<ul>
<li>command 表示命令，command 事实上是一个可执行的软件，实上 linux 中所谓的命令绝大多数是预装的软件，因为地址被写入了全局，因此可以直接通过软件名来调用该软件。</li>
<li>option 表示选项，命令行中，选项是包含一个或者多个字母的字符串，一般在选项前有一个“-”用于区分参数，如：-l，-s等，这些都是设计程序时就已经被写在软件中的，用于方便用户选择软件执行的模式，选项这个词是并不是平白无故的，因为只有设计软件时被采用的一些字符才可以被称为选项，因此使用某个命令时，我们重点需要查看有哪些选项可以使用，以及使用后会有什么样的效果。</li>
<li>arguments 为参数，很多命令都可以接受参数，参数就是选项后紧跟的一个或多个字符串，这些字符串制定了命令的操作对象，如文件或者目录等。如：ls -al  /etc ，这边 /etc 就是一个参数，而 -al 则是一个选项。</li>
</ul>
<p><strong>因为 linux 中的每个软件都是不同开发者提供的，因此表示一种功能模式的参数却往往不尽相同，如：有的递归是 -r 而有的是 -R 等等。因此你如果需要使用某个软件时，需要以 manual 为准，而不是想当然的认为某个选项一定表示某个功能。</strong></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件管理主要包含了，复制，移动，更改路径等等</p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>显示指定工作目录下的内容，常用参数：</p>
<ul>
<li>-a 可以显示全部内容包含隐藏文件。</li>
<li>-l 用于列出文件的详细信息。</li>
</ul>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>打印当前工作目录（print working directory），使用该命令后，你所在工作目录的绝对路径将会被打印出来。</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>改变当前工作目录（change directory），后面可以用绝对路径或者相对路径。</p>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建新目录，一般为 <code>mkdir + 目录名</code>。</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>将文件从一个位置移到另一个位置，可以用绝对路径或者相对路径，如：mv source /tmp/source 表示将当前目录下的 source 文件移到根目录下的 tmp 文件夹中。值得注意的是，mv 可以用来重命名，linux 中往往是通过 mv 来更改文件名称的。</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp 命令的格式类似于 mv 命令，但相比而言会比 mv 多不少选项/模式，常用参数如： -r 用于递归复制文件夹中的内容。</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除命令，用于删除文件等，一般常用 -rf 用于强制递归删除文件夹等。</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>用于改变文件的时间戳（timestamp），注意该命令是改变文件时间的，并不是用来创建文件的，之所以我们用它来创建文件仅是因为在改变文件时间戳时，如果该文件不存在 touch 会新建一个空白的文件，所以创建文件是 touch 的一个附加功能。所以我们就不难理解在 touch 一个已经存在的文件时，原文件不会被改动，改动的是该文件的时间。</p>
<h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>ln 用来生成链接文件，提到链接，相信用过电脑的朋友对 windows 下的快捷方式都会有影响，在 linux 中我们将 windows 中的快捷方式称为软连接。</p>
<p>linux 下有两种链接：</p>
<ul>
<li>硬链接：文件 A 是文件 B 的硬链接，则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode 节点上的链接数增加一，每删除一个对应的文件名，inode 节点上的链接数减一，直到为 0，inode 节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A 删除的只是 A 这个文件名，而 A 对应的数据块（文件）只有在 inode 节点链接数减少为 0 的时候才会被系统回收。我们这边提到的是  inode 节点，而并非路径，注意这点和软链接的区别。</li>
<li>软链接：等同于 windows 的快捷方式，A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到B的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。注意：软链接的 A 和 B 是对应的不同 inode 的，而 A 存储的仅是 B 的路径（并不是 inode 的信息），因此我们如果删除 B 文件后，A 会找不到链接方向，而如果我们再创建 B 后，A 又会有了新的目标，而事实上，再次创建的 B 和原来不是同一个 inode，已经和原来的 B 没有任何联系了。</li>
</ul>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>直接使用该命令可以查看文件类型的详细信息，linux 中是不强制要求有后缀名的，但通过 file 我们可以看出文件类型。</p>
<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查找某指令名称/内置程序的完整路径。如：which updatedb –&gt; /usr/bin/updatedb。</p>
<h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>只能用于查找二进制文件，源文件以及用户手册文件。因此 whereis 搜索出来的内容要比 which 多些。</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>普通的查找命令，用于查找某个名称文件，后面可以跟多个选项，格式为 <code>find+路径+选项+文件名</code>，如 <code>find . -name a.c</code> 即查找当前目录下名称为 a.c 的文件，find 最大的特点就是速度慢，其次 find 查找如果不适用通配符的话默认为精确查找，这点注意和 locate 有很大的不同，因此查找以 ad 开头的文件需要执行：<code>find . -name ad*</code>。</p>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>find 每次会在目录下进行真正的搜索，一般这样做时间长，效率低。Linux 上更加优异的搜索命令，locate 会直接定位某个文件的位置，原理是 locate 寻找文件是通过  /var/lib/mlocate/ 数据库中的内容查找，不用去硬盘中检索，但往往新的变动对 locate 查找的数据库更新不及时，这是我们需要用 updatedb 命令手动更新（updatedb 需要 root 权限），locate 是默认为 <code>*name*</code> 的查找方式。如果需要精确查找，需要使用如下格式：<code>locate -b &#39;\NAME&#39;</code></p>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>passwd 用户修改用户密码，后面如果加用户名的话，可以直接修改该用户的登入密码，前提是你必须知道该原始登入密码。</p>
<h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>su 主要用于改变用户登入身份，即快速切换登入用户，普通用户切换需要输入登录用户的密码，root 可以任意切换别的用户。</p>
<h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>显示登录的所有用户的信息，whoami 只显示自己的登录信息，而 uname 表示的是打印系统信息和用户名等无关。</p>
<h4 id="w"><a href="#w" class="headerlink" title="w"></a>w</h4><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Linux中set,env和export这三个命令的区别</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>命令显示当前shell的变量，包括当前用户的变量;</p>
<h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>命令显示当前用户的变量;</p>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>命令显示当前导出成用户变量的shell变量。</p>
<p>每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，</p>
<p>但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p>
<a id="more"></a>
<h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><h4 id="zip、unzip"><a href="#zip、unzip" class="headerlink" title="zip、unzip"></a>zip、unzip</h4><p>zip 打包压缩文件，zip 是一种比较古老的压缩方式，各个个系统平台上面都基本支持，但压缩率较低。</p>
<h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>当你使用 gzip 迚行压缩时，在预设的状态下原本的档案会被压缩成为 .gz 结尾的文件， 源文件就不再存在了。gzip 要比 zip 压缩效率高的多，但使用 windows 时，gz 文件未必可以被解压。</p>
<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>bzip2 则比 gzip 更加先进，可以提供更高的压缩比，用法基本和 gzip 一致。</p>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>虽然 gzip 和 bzip2 也能够针对目录来进行压缩， 不过，这两个命令对目录的压缩指的是<strong>将目录内的所有档案 “分别” 迚行压缩</strong>，而一般我们其实是需要一个进行过打包和压缩过的文件。tar 可以将多个目录或者文件打包成一个大的文件，同时还可以调用 gzip/bzip 对打包文件进行压缩。</p>
<h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>该命令的功能是 转换并且复制一个文件。</p>
<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><h3 id="终端和文件查看"><a href="#终端和文件查看" class="headerlink" title="终端和文件查看"></a>终端和文件查看</h3><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><h3 id="系统信息查看："><a href="#系统信息查看：" class="headerlink" title="系统信息查看："></a>系统信息查看：</h3><p><em>注意：以下命令如果在ubuntu下可能都需要root权限才可以执行。</em></p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>lscpu : 查看的是cpu的统计信息.</li>
<li>cat /proc/cpuinfo : 可以知道每个cpu信息，如每个CPU的型号，主频等。</li>
</ul>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li>cat /proc/meminfo : 查看内存详细使用</li>
<li>free -m : 概要查看内存情况</li>
<li>grep MemTotal /proc/meminfo ： 查看内存总量 </li>
<li>grep MemFree /proc/meminfo ：  查看空闲内存量 </li>
</ul>
<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><ul>
<li>lsblk ： 查看硬盘和分区分布</li>
<li>fdisk -l ： 如果要看硬盘和分区的详细信息</li>
<li>df -h ： 查看各分区使用情况 </li>
<li>cat /proc/loadavg ： 查看系统负载磁盘和分区 </li>
</ul>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><ul>
<li>lspci | grep -i ‘eth’ ： 查看网卡硬件信息</li>
<li>ifconfig -a ： 查看系统的所有网络接口</li>
<li>route -n : 查看路由表 </li>
</ul>
<h4 id="其他硬件信息"><a href="#其他硬件信息" class="headerlink" title="其他硬件信息"></a>其他硬件信息</h4><ul>
<li>lspci ： 查看pci信息，即主板所有硬件槽信息。</li>
<li>dmidecode -t bios ： 查看bios信息</li>
<li>dmidecode -q : dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。</li>
<li>dmesg | grep IDE ： 查看启动时IDE设备检测状况网络 </li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>uname -a 或 cat /proc/version ： 查看内核/操作系统/CPU信息 </li>
<li>lsb_release -a 或 cat /etc/issue（此命令也适用于所有的Linux发行版)： 查看Linux系统版本</li>
<li>head -n 1 /etc/issue ： 查看操作系统版本 </li>
<li>lsmod ： 列出加载的内核模块 </li>
<li>hostname ： 查看计算机名 </li>
<li>free -m ： 查看内存使用量和交换区使用量 </li>
<li>uptime ： 查看系统运行时间、用户数、负载 </li>
<li>ps -ef ： 查看所有进程 </li>
<li>top ： 实时显示进程状态用户 </li>
<li>w ： 查看活动用户 </li>
<li>id &lt;用户名&gt; : 查看指定用户信息 </li>
<li>last : 查看用户登录日志 </li>
<li>cut -d: -f1 /etc/passwd : 查看系统所有用户 </li>
<li>cut -d: -f1 /etc/group : 查看系统所有组 </li>
<li>crontab -l : 查看当前用户的计划任务服务 </li>
<li>chkconfig –list : 列出所有系统服务 </li>
<li>chkconfig –list | grep on : 列出所有启动的系统服务程序 </li>
</ul>
<h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>显示或者修改系统时间和日期，只有超级用户可以用 date 设置时间，一般用户只可以显示时间。</p>
<h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><h4 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h4><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><h3 id="分屏功能"><a href="#分屏功能" class="headerlink" title="分屏功能"></a>分屏功能</h3><p>xrandr 命令，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享，图形界面的分屏控制大都是调用 xrandr 这个软件。</p>
<h3 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h3><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><h3 id="mount、unmount"><a href="#mount、unmount" class="headerlink" title="mount、unmount"></a>mount、unmount</h3><h3 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h3><h3 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h3><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://www.2cto.com/os/201306/223758.html" target="_blank" rel="external">http://www.2cto.com/os/201306/223758.html</a><br><a href="http://www.ha97.com/2987.html" target="_blank" rel="external">http://www.ha97.com/2987.html</a><br><a href="http://blog.csdn.net/lhf_tiger/article/details/7102753" target="_blank" rel="external">http://blog.csdn.net/lhf_tiger/article/details/7102753</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git问题总结FAQ]]></title>
      <url>http://noparkinghere.win/2016/08/28/2016/2016-08-28-git%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93FAQ/</url>
      <content type="html"><![CDATA[<p>git的使用过程真心不容易，尤其对于我这样的初学者且没有其他版本控制器的使用经验，另外也比较容易丢三落四的人来说。按照网上所给的步骤操作，但万一漏做了一些步骤，或者做错了一些步骤，所引起的问题也是致命的，虽然肯定有解决问题的办法，但往往会引起分支结构混乱，经常做了一次提交然后就回不去了，或者经常不知名的无法进行提交，无法进行回退，pull失败等等。</p>
<p><strong>可见要想真正让git成为你版本控制的工具，git的工作原理必定要相当清楚，版本控制的结构要特别清晰，一单出现问题立马就知道是哪一步做错了才行。</strong></p>
<h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><h4 id="git-checkout-–-filename"><a href="#git-checkout-–-filename" class="headerlink" title="git checkout – filename:"></a>git checkout – filename:</h4><p>在文件没有stage时可以通过这个命令将该文件撤销回来。一旦文件add后用该命令不再有效。这时需要使用 git reset HEAD – filename 意味着将文件unstage出库，还原到add之前，再使用git checkout – filename撤销文件。而如果你使用git checkout HEAD – filename 则直接会丢弃掉stage中的暂存内容，将文件还原。</p>
<a id="more"></a>
<h4 id="git-push-u-origin-master："><a href="#git-push-u-origin-master：" class="headerlink" title="git push -u origin master："></a>git push -u origin master：</h4><p>远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<em>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</em></p>
<h4 id="从github上面拉取库的方法："><a href="#从github上面拉取库的方法：" class="headerlink" title="从github上面拉取库的方法："></a>从github上面拉取库的方法：</h4><ul>
<li>方法1：使用git clone address：如果是其他人的库address必须是一个http地址，如果是自己的库，且本地配置好了ssh，则可以通过ssh协议拉取需要的文件。<strong>值得注意这种拉取是完整拉取，会建立一个库名的文件夹。</strong>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</li>
<li>方法2：本地已经存在git库的情况下，需要在本地库目录下使用git remote add origin address 将可以把一个已有的本地仓库与之关联。git push -u origin master把当前分支master推送到远程。我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后可以简化操作使用 git push origin master。</li>
</ul>
<p><em>推荐使用方法1，直接从远程库clone下来，需要工程时直接clone下来避免没必要的合并，每次使用前可以先pull一下远程库。</em></p>
<h4 id="github的协议："><a href="#github的协议：" class="headerlink" title="github的协议："></a>github的协议：</h4><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。默认的git://使用ssh，但也可以使用https等其他协议。clone他人或者自己的版本库的时候，都可以使用https或者ssh下载，但是配置好git的ssh的话，可以本地推送免密码，https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。</p>
<h4 id="git的分支和HEAD："><a href="#git的分支和HEAD：" class="headerlink" title="git的分支和HEAD："></a>git的分支和HEAD：</h4><p>贯穿git的整个结构的核心就是分支，每个分支都有一个名称，如主分支一般名称为master，master本身类似一个指针名，永远指向了该分支的最后一次提交的版本。而HEAD则是指向了这个指针。因此在创建分支branch test时，master和test指向同一个位置，这时候如果执行checkout test，则HEAD会从指向master变成指向test（因此git的切换高效事实是指针的操作高效），对这个test的分支相关操作会建立起新的分支结构，而master仍然停留在原处，这时如果checkout master对master进一步的操作提交，会发现版本中真正的形成了两条分支结构。</p>
<h4 id="git合并分支："><a href="#git合并分支：" class="headerlink" title="git合并分支："></a>git合并分支：</h4><p>git merge “branchname”：将两个分支进行合并</p>
<ul>
<li>Fast-forward：分支合并完成后出现Fast-forward，意味着快速合并，即合并分支时分支指针仅仅是直接更改了指向，而没有出现其他增删改查的文件。<em>这种情况一般是需要合并的分支仅仅是建立了一个节点，而没有将分支扩展出去，因此可以直接快速向前合并两个分支指针。</em><br>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</li>
<li>Automatic merge failed; fix conflicts and then commit the result：这种情况虽然合并失败了，但相关文件已经进行了一些变动修改，用户手动更改好，这些文件，然后add,commit 即可完成提交以及分支合并。</li>
</ul>
<h4 id="查看分支结构："><a href="#查看分支结构：" class="headerlink" title="查看分支结构："></a>查看分支结构：</h4><ul>
<li>git log –graph –pretty=oneline –abbrev-commit</li>
<li>使用插件tig，该插件在github上面有托管，可以下载源码安装编译，注意提示需要安装一些依赖库<em>托管，可以下载源码安装编译，注意提示需要安装一些依赖库。</em>。</li>
<li>如果使用了checkout的话，使用git log则看到内容有限，这时使用git log –all可以查看所有的提交结果。</li>
<li>值得注意的是使用了git reset之后，使用git log 就无法看到最近的一些提交了，因为reset属于版本回退，相当于整个时光倒流回去了，不会在看到未发生的内容，只能通过git reflog查看库里面的所有备份内容。</li>
</ul>
<h4 id="stash的用处："><a href="#stash的用处：" class="headerlink" title="stash的用处："></a>stash的用处：</h4><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<ul>
<li>git stash：在git add之后可以通过stash将文件修改暂存。</li>
<li>git stash list： 查看暂存的信息。<br>一些不需要的修改也可以存入stash中，相比而言stash不像commit那么严格，可以随便存入，随便删除。</li>
</ul>
<h4 id="远程库如何操作caozuo："><a href="#远程库如何操作caozuo：" class="headerlink" title="远程库如何操作caozuo："></a>远程库如何操作caozuo：</h4><p><em>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote，返回origin。可以看出远程库也是可以有多个的。</em></p>
<p><em>实际的远程建立库一般为–bare裸库是不存在实际工程文件的，相当于.git文件直接被展开了，实际使用的时候，需要clone下来才能够看到文件内容。</em></p>
<ul>
<li>git remote -v：显示更详细的信息,可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</li>
<li>push：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<code>git push origin master</code>，可以看到origin为远程库的名称，而master为本地需要推送的分支。在Git中，分支完全可以在本地自己，到底要不要推送则完全由你自己决定。</li>
<li>clone：从某一个位置将目录完整克隆下来，注意clone后面可以类似：<code>git clone git@github.com:hard/learngit.git</code>，也可以使用<code>git clone ~/home/gitname</code>但注意gitname必须得是个git的版本库，也就是说在里面执行过<code>git init</code>。</li>
<li>推送冲突失败：你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，则会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git会提示我们：<em>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</em>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接:<code>git branch --set-upstream dev origin/dev</code>，然后再pull。<strong>这边尤其需要每次输完指令后，看提示，有的未必会报错，但也没有执行相关操作，出现git command的时候，往往是你指令执行已经异常了。</strong></li>
</ul>
<h4 id="同步已有本地库到远程："><a href="#同步已有本地库到远程：" class="headerlink" title="同步已有本地库到远程："></a>同步已有本地库到远程：</h4><p><em>大多数时候，本地存在已有的库，而远程并没有，这个时候不能通过git clone来复制，需要通过以下的一些步骤</em></p>
<ul>
<li>删除本地的.git残留文件，如果本地已经有了git操作，但不明具体内容，则首先执行<code>rm -rf .git</code>清除掉无关内容，git的设置相当科学，几乎所有的记录信息全在.git目录下。</li>
<li>初始化这个库，<code>git init</code>这是必备步骤，建立一个空的默认库。</li>
<li>随意添加几个文件，例如：<code>echo &quot;hello world&quot; &gt;&gt; test.txt</code>，如果是实验的话可以操作本步骤，如果已有功能则跳过此步骤。</li>
<li>常规git操作，加入stage并提交，<code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code>，必备步骤，该步骤是相当于建立提交，放入到master中。</li>
<li>查看下本地库的状态：git status，一般提示，没有可提交的内容，则代表上面步骤成功了。</li>
<li>一切正常的话，将远程库与本地库建立关系：<code>git remote add origin git@ubuntu_server:/home/git/myRep.git</code>。这边的test为远程库的名称，默认一般为origin，但如果你一个项目中同时有多个库，则建议你将origin修改为其他名称。</li>
<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>
<li>推送远程分支很简单:git push origin local_branch_name:remote_branch_name,一般可以省略local分支名，则会自动推送当前分支。</li>
</ul>
<h4 id="tag和branch的区别："><a href="#tag和branch的区别：" class="headerlink" title="tag和branch的区别："></a>tag和branch的区别：</h4><p>我们可以认为tag是一个静态标签，tag一定设定后，它的位置就永远不会再改变了，tag就是哪个commit对应的一系列数字英文字符的别名。如正常情况下我们需要checkout某个提交的时候需要git log查看版本名称，然后可以使用类似git checkout a228来切换到这个版本上去。但给这个版本起了名字edition1，则这时，我们可以通过git checkout edition1直接切换这个版本，而无需再查看log。</p>
<p><strong>但一般我们不随便给任何提交打上tag，大多数情况只给某一次或几次特殊重要的提交打tag，比如发行版v1.0，测试版beta1.2等等。</strong></p>
<p>而branch则是分支，最为常见的就是master分支，注意分支实际是一个指针，分支的指向永远指向这条分支结构的最末尾端（及最后的一次提交），所以分支是会不断变动的，而tag是静态的，两者区别很明显。</p>
<h4 id="MDK工程管理出错："><a href="#MDK工程管理出错：" class="headerlink" title="MDK工程管理出错："></a>MDK工程管理出错：</h4><p>本人在工作中会使用到MDK来做一些MCU的编程开发，而MDK虽然配置简单，调试功能强大，但编辑扩展等其他功能都奇差无比。在使用git进行管理的过程中发现，MDK会对多个工程类文件进行不断修改，而这些文件，如果不进行提交的话，又会出现工程缺失文件，工程错误等现象，另外经常出现无法回退或者无法提交等现象。</p>
<p>经过查看和分析，最终发现：MDK只要打开的情况下，就会不断的对工程文件进行修改，即便你仅仅是查看没有做任何事情，因此下面推荐几种方法和技巧：</p>
<ul>
<li>gitignore中只排除MDK的编译文件。</li>
<li>每次要提交和回退的时候将MDK关闭再执行。</li>
<li>如果忘记关闭或者出现突然没法回退或者提交的情况下，git查看状态，如果仅仅是工程文件出现改动，而源文件和头文件不变的话，则直接丢弃这些修改或者将修改存入stash中，再继续要做的操作。</li>
</ul>
<h4 id="checkout和reset的区别："><a href="#checkout和reset的区别：" class="headerlink" title="checkout和reset的区别："></a>checkout和reset的区别：</h4><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对该版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>
<p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留，reset是一剂后悔药，只有在万不得已的情况下才会使用，但往往reset的滥用，也会让你的分支结构混乱。</p>
<p>综上所述，可以看出checkout是用来切换版本和分支的（分支其实是特殊的版本），而reset则是用来回退版本的。通常一般都是使用checkout来操作，只有发生重大错误，无法挽救时，才会使用reset。</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下的shell和终端使用]]></title>
      <url>http://noparkinghere.win/2016/08/26/2016/2016-08-26-linux%E4%B8%8B%E7%9A%84shell%E5%92%8C%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="ZSH使用"><a href="#ZSH使用" class="headerlink" title="ZSH使用"></a>ZSH使用</h3><p><em>bash为linux和OS X传统的默认shell，但使用起来比较麻烦，缺少一些人性化的特性，而现在流行的ZSH补足了bash的这些问题，且通过<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a>可以很方便的配置，因此已经广泛的被很多人使用。下面将会对网上的资料和自我使用经验做一个详细的总结。</em></p>
<p><em>本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最通用的bash下的快捷操作和相关技巧，当然bash本身也可以跨平台，在诸如OS X上面默认也使用bash，同样可以参考本文。</em></p>
<h3 id="Tmux使用"><a href="#Tmux使用" class="headerlink" title="Tmux使用"></a>Tmux使用</h3><a id="more"></a>
<blockquote>
<p>参考网址：<br><a href="http://blog.jobbole.com/87584/" target="_blank" rel="external">http://blog.jobbole.com/87584/</a><br><a href="http://xiaozhou.net/build-your-go-ide-2015-07-18.html" target="_blank" rel="external">http://xiaozhou.net/build-your-go-ide-2015-07-18.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）谈谈写程序与学英语]]></title>
      <url>http://noparkinghere.win/2016/08/25/2016/2016-08-25-%EF%BC%88%E8%BD%AC%EF%BC%89%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD/</url>
      <content type="html"><![CDATA[<p><em>注: 本文的作者是宋劲杉，<a href="http://songjinshan.com/blog/index.php/%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD%EF%BC%8D%EF%BC%8D%E8%87%B4%E4%BA%9A%E5%B5%8C%E5%B0%B1%E4%B8%9A%E7%8F%AD%E5%AD%A6%E5%91%98/" target="_blank" rel="external">原文链接</a>。转载自<a href="http://happypeter.github.io/on-english-and-prog.html" target="_blank" rel="external">网址</a></em></p>
<p>俗话说，没有金刚钻，就别揽瓷器活儿。套用到IT业，英语不行，就别做程序员。网上关于程序员学英语的文章不少，但我想谈谈我自己的看法。首先详细讨论一下为什么程序员离了英语不行，然后针对程序员应该怎么学英语说说我的体会。</p>
<p><strong>英语是计算机的母语，是程序的母语，所以必然是程序员的母语。</strong>程序中的变量名、函数名起得好不好是决定代码质量和可维护性的最关键因素。高质量的代码应该是这样的：代码基本上是自解释的（self-explanatory），不需要太多注释，不管代码的规模有多大，具有相关知识背景的读过文档的人都可以立刻上手、立刻参与维护和开发。要想使代码能够自解释，给变量和函数起个好名字很关键，很显然，只能用英文起名字，一是用汉语拼音起名字可读性很差，二是英文单词通常比汉语更expressive（看吧，如果用汉语来说，就得说“表达能力更强”、“更有表现力”这么罗嗦），由于程序的复杂性，变量和函数往往表示一些很抽象的概念，起个既准确又简洁的名字并不容易，可是很多时候，用汉语需要很多字才能说清楚的一件事，用英文一个单词再加点词形变化就能说清楚了。例如APUE上讲sleep函数的实现，其中有个变量表示“本来应该睡到某个时刻，但是提前被信号唤醒了，唤醒时与本来应该睡到的时刻相差的时间”，如果为了简洁而不求准确，这个变量名至少也得叫“未睡到”，而书中只用了一个单词unslept，非常准确、简洁地表达了这个意思。为了写程序而学英语需要学到什么水平？我认为能起出这种变量名就够水平了。很多在IT外企工作的中国人，说话写文章经常夹杂着英文单词（比我严重多了因为我不在外企），非常可以理解，确实是为了表达得更准确简洁的需要，而不是纯为了play zhuangbility。总之，要写程序必须学好英语，否则连变量名都起不好，这虽然是一个非技术问题，但却是个根本问题，比任何技术问题都重要。当然，现在很多编程语言也支持用Unicode字符给变量和函数起名，但是你见过有人用汉字写程序吗？根本不实用。有人会辩驳说一页英文翻译成中文往往只占半页，中文不是更简洁吗？但是你算算打一页英文和打半页中文哪个敲键盘次数多。另外，要读别人的代码也必须学好英语，如果你不知道unslept是由 sleep变形而来的，就体会不到其中的精妙，只有大量阅读高质量的代码，才能写出高质量的代码，创作都是从模仿开始的。</p>
<a id="more"></a>
<p><strong>说说英语对于看书学习的重要性。</strong>中文技术书和英文技术书的水平根本不在一个量级上，这是有很多原因的，不能全归结于中文书的作者水平差。最重要的是，出中文书的低回报率决定了作者不可能花太多心血在上面，你去amazon看看一本书卖多少美刀，再去chinapub看看一本书卖几块钱。老外写一本书，可以做到全书没有一个拼写错误（当然英文的拼写检查工具更完善也是部分原因），中文能找出一本没有错别字的书吗？Knuth可以悬赏让全世界读者来找磋，中文书作者有哪个敢这么做？不是因为老外态度有多认真治学有多严谨，而是因为他们赚到了，就应该拿出高质量的作品来，不然会被读者骂的。</p>
<p><strong>英文技术书的翻译质量通常很差。</strong>也不能归结于译者的水平差，我也翻译过书，也努力想译好，但真的很难译好。IT业的新名词层出不穷，像“内核”、“网络” 这种常见术语还好，稍微专一点的术语都没有统一的译名。我们在教学中发现，很多学员看书时搞不清这本书的名词A和那本书的名词B是什么区别，来问老师，才发现原来A和B就是一回事儿。这是一个单词对应多个译名的情况，还有一个译名对应多个单词的情况，比如field、domain、realm都译成 “域”，block、 bulk都译成“块”，argument、parameter都译成“参数”，attribute、property都译成“属性”，虽然这些词的意思本来就差不多，但是在一篇文章里，作者可以换着用，不同的单词表示不同的概念，翻译完了一看，都成一个概念了。英文书背后都有index，看到一半忘了某个名词是怎么定义的就可以翻index，而译文通常没有index，名词都已经乱七八糟了，没法做index。还有更发指的是，老外喜欢造词，现有的单词上加一点变化和组合（例如有人喜欢说automagically），看着心领神会，想译出来就很费劲。老外即使在技术书中也经常用一些生动的表达方式和俏皮话，而中文的书面语言非常死板，生动的表达方式只存在于口语中，如果写在书上就很不像话，这也是很难翻译的一个重要原因。看中文译本，不仅质量差，而且跟不上时代，通常一本英文书出来，至少要等一到两年才能看到中文译本。两年啊！等你看到这本书的中文译本时，这个版本都快淘汰了。</p>
<p><strong>然后说说英语在开发工作中的重要性。</strong>看书学习通常只起一个引导入门的作用，在工作中更有用的是手册、文档。学完了C语言开始写程序了，谁还会去查 K&amp;R附录中的库函数？查man page才是最有效率的。然而手册比入门书更少有中文译版，因为手册是随时变的，会随着软件版本更新，而且需要看这些开发手册的人通常不会有英文障碍，有英文障碍的人即使看了翻译的手册也写不出好程序来，所以当然没必要翻译了。<em>不管什么技术，官方的手册和技术标准才是最原始的第一手资料，看别的书都是以讹传讹，由于自然语言不可避免是有歧义的，文档中表达得不准确的地方就会被文档的读者也就是技术书的作者误解，技术书中再有表达不准确的地方又被译者误解。</em>我们小时候都玩过传话的游戏，几个人站一排，通过悄悄话传一句话，传到最后变成什么了？所以，学网络协议，就得看RFC，学ARM，就得看ARM公司的 Architecture Reference Manual，要学习C语言就得看C99，有歧义不要紧，自己去揣测原作者的意思，总比道听途说的可靠。</p>
<p>我们的学员出去面试经常被问到的一个问题就是：在开发工作中遇到问题，书和文档上都没有答案，网上搜一下也没有答案，怎么办？要我说，能看懂源代码的就去源代码中找答案，这称为hacking，不管是内核、libc还是各种framework，你调用的东西有问题都能从它的代码中找到原因。如果没有能力 hacking，或者时间紧不想去hacking，最好的办法就是去官方邮件列表和IRC问。如果英文不行就没办法了，只能去一些中文论坛：“各位大虾帮忙，小弟有一个问题求救！跪求！！在线等！！！”在线等了好几天也无人问津，或者答非所问。岂不知逛这些论坛的没有大虾，都是菜鸟，大虾们都在IRC上聊得正欢呢。我在做Qt开发时曾经有一个问题，当时在教育网，上国外网不方便，去各大中文论坛问了好几天也没人给出满意的回答，后来花钱连了国外网，去 trolltech官方新闻组提问，只等了几分钟就得到了满意的解决办法。这次经历给我留下了深刻印象，从此以后再也没有去中文论坛。</p>
<p>那么，如果现在英文水平很差，又想做程序员，应该怎么学英语呢？我下面说的方法有两个前提，一是你的英文至少达到高中毕业水平，也就是语法基本都学完了，即使用得不熟练也知道有那么回事儿，二是你希望尽快在工作中用上英语，写程序够用就行，而不是有考T考G这样的更高要求。</p>
<p>学习英语有听说读写四个方面的要求，做程序员至少需要读和写非常流畅，如果在外企工作还需要听和说的能力。技术英语和考T考G是不一样的，一是听和说不像读和写那么重要，不必担心自己是“聋哑英语”，没关系，丝毫不影响你成为编程高手，二是要求的词汇量要小得多。考T考G都要拿一本单词书背，很少有人会觉得背单词很有意思，至少我是觉得很痛苦，幸运的是看技术书不需要多少词汇量。技术书的描述对象都是局限于一个很窄的领域的，就那么几个单词翻来覆去地用，而且技术书是为了让人看懂的（不像诗是为了让人看不懂的），比较复杂的词在书中都有定义或解释。有些作者喜欢卖弄词汇量，用一些很生僻的单词，也有些作者卖弄一些典故，由于文化背景不同很难理解，不过这些通常都可以无视，不会影响阅读，还是因为技术书是为了让人看懂的。对于学习者来说，阅读能力是最重要的，等你完成了学习，成为一个合格的开发者时，需要写代码注释，需要写文档，需要通过邮件交流，写作的能力才开始重要了。所以应该首先从阅读开始练习英语。</p>
<p>现在就拿起一本英文原版书开始看吧。和学游泳一样，阅读的能力只能通过阅读本身来练习。我的经验是，不必先系统学习了单词和语法再看书，可以在看书时用到什么就补什么。我建议初学者看电子版，因为现在的词典软件都可以鼠标取词，边看边查很方便，很多勤快人喜欢把查过的单词都抄下来，我觉得没有必要，反正查字典很方便，下次再看到了就再查，多查几次总会记住的，抄下来就打断了看书的思路，而且不见得抄下来就能记住。也许是因为我这人比较懒，我用的都是懒办法。很多人不喜欢看电子书，理由是盯着屏幕看书太累，那么盯着屏幕写程序累不累？这种人显然不适合做程序员。语法不熟练怎么办？大多数情况下单词的意思都明白了就不影响阅读。技术书有时候喜欢用长句，其中可能包含各种从句，如果实在读不懂就去查语法书，同样也不需要把这种从句彻底弄明白，只要这一句能看过去就行了，以后多查几遍书，自然就掌握了。另外，技术书是说明文，通常不应该有过去时，看到过去时就需要注意了，很可能是虚拟语气，如果不注意这一点，看到的意思可能和真实的意思正好相反。</p>
<p>应该从哪本书开始看起呢？从你当前最需要学的技术书看起。看书是相当花时间的，如果能一边学英语一边学技术，这时间利用得就很有效率。比如，如果你的C语言已经学得相当好了，不要专门为了学英语去重看一遍原版的K&amp;R。市面上有一些专门的计算机英语教材，我的建议是不要看，浪费时间，nonsense。初学时最好选一本有中文译本的书，有看不懂的地方可以翻中文版来对照，但是不要相信中文的翻译，原因在前面讨论过了。如果你是初学编程，没有任何基础，我可以推荐一本英文很浅显技术也很浅显的书：<a href="http://interactivepython.org/runestone/static/thinkcspy/index.html" target="_blank" rel="external">How To Think Like a Computer Scientist</a>，有Python、Java和C++版本，可自由下载。</p>
<p>要逐渐养成良好的阅读习惯:</p>
<ul>
<li>不要每个生单词都去查，有些单词很生僻，查了也记不住，记住了也不会再见到它了，但是前面讲过，都是作者在卖弄词汇量，无视它丝毫不影响阅读，因此要学会猜测单词的意思，能不查就不查，继续贯彻“懒”的原则。</li>
<li>看书不要动口，不念出声也不行，就是不要动口，要努力在大脑中建立从词形到语义的直接映射，如果只能从词形到读音再到语义就太慢了，严重影响阅读速度。</li>
<li>努力做到每句话都从头到尾只看一遍，不许回头反复看，这一点比较难，必须注意力高度集中，经常在记忆中暂存前面半句的内容和句式才能做到，但是一旦神功练成就会成倍地提高阅读速度。</li>
<li>学会skim，就是略读，很多优秀的作者在组织材料时会给读者一些建议，比如这一段是扩展的高级话题，和主线的相关度较低，可以先skim到后面，注意不是让你skip到后面，这一段还是要读的，但是不必逐字句地读，而是抓主旨，大概讲了个什么概念（有一些下定义的句式），有哪些要点（有数字编号或bullet列表项），适用于哪些场合有哪些注意事项（有 caveat、gotcha、noteworthy这种字眼），后面可能还会碰到这个概念，虽然你没有仔细看这是个什么东西，但大体上也知道了，这样就能不影响后面的阅读，这不仅需要高度集中的注意力、熟练的语言能力，而且要有足够的背景知识去猜测性地理解。但是语言能力还是最重要的因素，我和几个同学交流过，他们也能熟练地看英文书，但是需要skim查一个东西时就觉得还是不如中文书查得快。skim的技能在查阅手册时尤其重要，没有人会像看入门书一样把上千页的手册从头到尾看一遍，都是用到哪儿就查哪儿。总之，锻炼各种阅读习惯就为了一个目的：如何在最短的时间内，在保证正确性的前提下，获取尽可能多的知识。程序员的学习时间都是非常宝贵的。</li>
</ul>
<p>以上本着“够用就好”的原则，多次提到用懒办法，但是学技术学英语这两件事不能懒，贵在坚持。要养成良好的阅读习惯也有很多东西需要坚持，其中<strong>最根本的是持续高度集中注意力，充分调动记忆能力、推理能力、猜测能力，就像考试做阅读题一样看每一段话。</strong>最根本也是最重要的，<strong>“有英文原版就不看中文版”这个原则一定要坚持。</strong>一开始看英文书可能会很慢，但只要一直坚持就会慢慢达到原来看中文书的速度，再坚持下去就会比中文书看得更有效率，因为避免了很多歧义和术语翻译的问题。有人会说，项目紧任务急，看英文资料太慢，这次就先用中文尽快解决工作中的问题吧，等以后有时间了再看英文书学习。可是什么时候才会有时间呢？工作总是一个接一个的，老板怎么会付了工资让你闲着呢？如果你有这样的困难，我的建议是干脆辞职，学好了英文再去工作。你只要想想，你的同行们在外企全英文的环境下工作，英文和技术每天都在突飞猛进，而你还在用效率极其低下的方式学习和工作，你和别人的差距不是越来越大了吗？另一方面，现在的在校学生从小学就开始抓英语，基础都很好，很多高校也逐渐重视引进原版教材，开设很多英文授课的专业课。你再不奋起直追，就不觉得以后的职业道路充满危机吗？</p>
<p>最后说说写作。刚开始练习时不要怕写错，能表达清楚自己的意思即可。我看过很多源代码和文档中的英文，一看就是中国人写的，谓语动词不分单复数，名词复数不加s，处处可见中国式英语，但是丝毫不影响我对这些编程大牛的景仰，因为其中的思想我看懂了，并且我认为很强大。我有一个朋友，中学毕业就出来混的，由于工作的性质总要跟老外打交道，他从来不惧和老外交流，虽然连一个囫囵的句子都说不出来，但总是能用中学学的那点单词让老外明白他的意思，这一点我就非常佩服。总之就是说，<em>*不要因为不知道怎么写是对的就不敢动笔写，只要敢交流，并且别人能懂你的意思，就是很有效的交流。而且随着阅读量的增加，自然能写出一手好英文，前面讲过了，创作总是从模仿开始的。不怕出错才能有一个好的开始，才能逐步练习提高，而练习的最终目的当然还是希望写好，不仅字句通顺无语法错误，还能适当修辞。</em></p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言中宏定义存在位置]]></title>
      <url>http://noparkinghere.win/2016/08/24/2016/2016-08-24-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%AD%98%E5%9C%A8%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><em>宏定义作为C语言的一个传统内容，如果使用新标准的话，一般也只用宏定义来结局编译的一些问题如：#ifndef，#if undefined()等。</em></p>
<p>宏定义究竟放在什么地方，在使用 C 语言老款编辑器情况下，一些程序大量使用宏定义，且很多程序都是将宏定义作为申明一样全部放在头文件中的，这个没有一个统一的说法，其中各有利弊，每个人风格不尽相同。</p>
<p>首先，宏定义的常量在编译的时候是作为内容直接替换的，因此这部分并不会因此占用你堆、栈等存储空间。所以这就导致无论你将宏定义放在头文件还是放在源文件中，资源消耗上面没有太大差别。差别就是在头文件和源文件中可以使用的作用域不同。</p>
<h3 id="1-放在头文件中："><a href="#1-放在头文件中：" class="headerlink" title="1. 放在头文件中："></a>1. 放在头文件中：</h3><ul>
<li>作用域更广，不仅仅对应源文件可以使用，且其他所有的源文件包含这个都可以使用，即便一些常量现在不会被使用，将来也可能会使用。</li>
<li>作用域太宽，可能会与其他文件中的某个宏定义命名冲突，需要定义较长的名字。</li>
<li>方便集中在一起进行管理，看起来代码更加显得整洁。</li>
</ul>
<a id="more"></a>
<h3 id="2-放在头文件中："><a href="#2-放在头文件中：" class="headerlink" title="2. 放在头文件中："></a>2. 放在头文件中：</h3><ul>
<li>没有统一管理，分部零散，查找较麻烦，将来一些需要引用的话，重新修改程序。</li>
<li>只作用需要使用到的范围，减少与其他文件的关联性，出错几率更低。</li>
<li>宏定义名称无所谓起多长，作用域有限，不会与其他文件冲突。</li>
<li>只将需要在其他文件中使用的宏定义放在头文件中，按需进行分配。</li>
</ul>
<p>个人建议：<br><strong>采用方法 2，将宏定义绝大多数放在 .c 文件中，只将极个别需要其他源文件引用的宏定义放在 .h 中，这可以有效控制一些源文件没必要的相关性，虽然较长的定义名也避免了出错，但为了减少耦合性，按照需求来进行分配算是一个良好的编程习惯，否则工程一旦复杂性增加难免会出现一些意想不到的问题。</strong></p>
]]></content>
      
        <categories>
            
            <category> 编程技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[头文件交叉引用]]></title>
      <url>http://noparkinghere.win/2016/08/24/2016/2016-08-24-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><strong>尽可能将所需要包含的头文件文件在.c文件中包含定义如：#inlcude “x.h”，除非头文件必须的部分申明出现在其他头文件中定义过的结构体或者宏定义类型，这时候没办法，只能在.h中包含.h。</strong></p>
<p>具体分析这样定义的原因：</p>
<h4 id="1-减少编译展开所需时间"><a href="#1-减少编译展开所需时间" class="headerlink" title="1. 减少编译展开所需时间"></a>1. 减少编译展开所需时间</h4><p>虽然头文件中都加入了<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ifndef __KEY_H</span></div><div class="line"><span class="comment">#define __KEY_H</span></div><div class="line">...</div><div class="line"><span class="comment">#endif</span></div></pre></td></tr></table></figure></p>
<p>一般编译不会再出现重定等错误，但是每次遇到#include的时候，都会将这段代码复制一边进行排查，而头文件多次被展开，会严重影响编译效率，且也没有什么好处。</p>
<a id="more"></a>
<h4 id="2-头文件的嵌套调用难免造成问题"><a href="#2-头文件的嵌套调用难免造成问题" class="headerlink" title="2. 头文件的嵌套调用难免造成问题"></a>2. 头文件的嵌套调用难免造成问题</h4><p>两个.c文件相互调用彼此的内容是常有的事情，这时候如果处理不善则往往会遇到未声明之类的报错，这种情况需要你小心的调整#include”x.h”文件在编译过程中第一次出现的顺序。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">举例：</div><div class="line">a.h中存在<span class="comment">#inlcude "b.h"</span></div><div class="line">b.h中存在<span class="comment">#inlcude "a.h"</span></div><div class="line">而这时候a.h依赖于 b.h,但b.h直接被先包含在了main.c文件中，这时候往往会提示编译错误，原因是a.h中的一些内容未被申明定义。</div><div class="line"></div><div class="line">具体解析：</div><div class="line">编译器在编译的过程中，如果先从main.c文件开始执行，main.c中包含有b.h，而b.h中包含有a.h则展开为：</div><div class="line"></div><div class="line">b.h(上部分极少数定义包含内容)</div><div class="line">a.h(全部内容，因为<span class="comment">#ifndef，所以b.h不会在a.h中再出现)</span></div><div class="line">b.h(绝大多数内容)</div><div class="line">因此，通过上述代码，在执行编译过程中，在编译a.h时则无法找到依赖b.h的一些相关定义。</div></pre></td></tr></table></figure></p>
<p><strong>直接将头文件文件相互写入到对方的头文件文件下这时候最容易出错。解决的办法一般是：1.将所有不需要写在头文件中的#inlcude写在#inlcude “.h”中。2.小心调整#inlcude “.h”的顺序，将需要依赖其他的那个调用放在后面，对于多次嵌套调用等情况，调整顺序时尤其需要注意顺序。</strong></p>
]]></content>
      
        <categories>
            
            <category> 编程技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu的基本使用]]></title>
      <url>http://noparkinghere.win/2016/08/15/2016/2016-08-15-ubuntu%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><em>本文专门针对ubuntu这个linux发行版而写的，对ubuntu特有一些操作进行介绍和总结。</em></p>
<h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><p>dpkg  是 Debian Packager 的简写，为 Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自 Debian 的 Linux 发行版都使用 dpkg，例如 Ubuntu Knoppix 深度linux 等。</p>
<p>dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件。</p>
<ul>
<li>安装本地软件：dpkg -i &lt;.deb file name&gt;</li>
<li>删除软件包（保留其配置信息）：dpkg -r <software></software></li>
</ul>
<p>其他一些详细操作这边就不罗列了，具体可查看 man 文件。</p>
<h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3><p>apt会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具。</p>
<p><em>用过ubuntu的人都知道apt-get的方便</em></p>
<ul>
<li>远程安装软件：sudo apt-get install xxx ，远程库一般会提供不少常见的软件，当然也可以手动添加源。</li>
<li>修复安装错误：sudo apt-get install -f 常用于手动安装软件后，出现错误，一般该指令可以解决大多数的依赖关系，一般这种错误来自于使用本地安装命令 dpkg 时出现的依赖错误。</li>
<li>删除已经安装的软件：sudo apt-get remove xxx 删除一个软件包。</li>
</ul>
<a id="more"></a>
<p>除了以上的安装操作外，apt-get 还有一些清理清理升级缓存以及无用包的命令：</p>
<ul>
<li>sudo apt-get autoclean ：清理旧版本的软件缓存</li>
<li>sudo apt-get clean：清理所有软件缓存</li>
<li>sudo apt-get autoremove：删除系统不再使用的孤立软件</li>
</ul>
<h3 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h3><p>在/etc/rc.local中可以加入ubuntu的开机自启内容。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考网址：<br><a href="http://my.oschina.net/zhangqingcai/blog/23994" target="_blank" rel="external">http://my.oschina.net/zhangqingcai/blog/23994</a><br><a href="http://blog.csdn.net/baixiaoshi/article/details/43529649" target="_blank" rel="external">http://blog.csdn.net/baixiaoshi/article/details/43529649</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C/C++编程规范]]></title>
      <url>http://noparkinghere.win/2016/08/11/2016/2016-08-11-C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p><em>文章阐述个人使用 C/C++ 的一些命名规范总结，当然现在很多编辑器强大，很多人不再注意这些规范，但由于本人记性较差，加上打字速度较快，所以这套规范虽然繁琐，但还是比较适合我自己的。</em></p>
<h3 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1. 命名规范"></a>1. 命名规范</h3><h4 id="1-1-宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。-当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。"><a href="#1-1-宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。-当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。" class="headerlink" title="1.1 宏定义的命名全部采用大写，中间间隔用隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。"></a>1.1 宏定义的命名全部采用大写，中间间隔用<em>隔开，要求常量名用大写，常量名用英文表达其意思。 当需要由多个单词表示时，单词与单词之间必须采用连字符”</em>“连接。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line"><span class="comment">#define CM_FILE_NOT_FOUND  CMMAKEHR(0X20B) 其中CM表示类别。</span></div></pre></td></tr></table></figure>
<h4 id="1-2-变量的命名规则要求用“匈牙利命名法”。-即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况"><a href="#1-2-变量的命名规则要求用“匈牙利命名法”。-即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况" class="headerlink" title="1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)"></a>1.2 变量的命名规则要求用“匈牙利命名法”。 (即便很冗余且很多时候并没有实际作用，但方便查看，记性差防止跳过去查了就忘的情况)</h4><p><em>这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来：</em></p>
<a id="more"></a>
<ul>
<li>属性部分：   </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g_ 全局变量	：如一个全局的长型变量定义为g_lFailCount。  </div><div class="line">m_ 　类，结构体成员变量</div><div class="line">s_ 　静态变量：如一个静态的指针变量定义为s_plPerv_Inst</div><div class="line">c_ 　常量： const 的变量 示例：const char* c_szFileName;</div></pre></td></tr></table></figure>
<ul>
<li>类型部分：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">bool 用b开头 b标志寄存器 </div><div class="line">int 用i  32位开头 iCount </div><div class="line">short  int  16位用n开头 nStepCount </div><div class="line">long  int 用l开头 lSum </div><div class="line">char  用c开头 cCount </div><div class="line"><span class="built_in">float</span> 用f开头 fAvg </div><div class="line">double 用d开头 dDeta </div><div class="line">unsigned  char / byte(字节) 用by开头 </div><div class="line">unsigned  int(WORD) 用w开头 wCount </div><div class="line">unsigned  long  int(DWORD) 用dw开头 dwBroad </div><div class="line">字符串 用s开头 sFileName </div><div class="line">用0结尾的字符串 用sz开头 szFileName </div><div class="line">指针数组跟着上面类型之前：</div><div class="line">数组 a：如一个short int型数组应该表示为anStat。</div><div class="line">指针 p：</div><div class="line">对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个<span class="built_in">float</span>*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。</div></pre></td></tr></table></figure>
<ul>
<li>描述部分：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">最大　Max		最小　M<span class="keyword">in</span>		初始化　Init		临时变量　T（或Temp）</div><div class="line">源对象　Src		目的对象　Dest</div></pre></td></tr></table></figure>
<h4 id="1-3-枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。"><a href="#1-3-枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。" class="headerlink" title="1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。"></a>1.3 枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">如： </div><div class="line">enum EMDays </div><div class="line">&#123; </div><div class="line">	EM_DAYS_MONDAY; </div><div class="line">	EM_DAYS_TUESDAY; </div><div class="line">	…… </div><div class="line">&#125;; </div><div class="line">EMDays  emToday;</div></pre></td></tr></table></figure>
<h4 id="1-4-结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上-stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加-m-不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）"><a href="#1-4-结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上-stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加-m-不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）" class="headerlink" title="1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）"></a>1.4 结构体、类、共用体的命名规则统一采用大驼峰式（帕斯克命名法），结构体类型定义时在前面需要加上 stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量统一加 m_ 不允许使用任何下划线。（函数与结构体变量方便区分，固都采用大驼峰式）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">typedef struct</div><div class="line">&#123; </div><div class="line">	char *m_pcNodeNext;</div><div class="line">char *m_pcNodePreview;</div><div class="line">&#125;struStudentNode; </div><div class="line">struStudentNode  StudentNode;</div></pre></td></tr></table></figure>
<h4 id="1-5-函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，init-I2C，delay-us-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）"><a href="#1-5-函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，init-I2C，delay-us-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）" class="headerlink" title="1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）"></a>1.5 函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如<code>NVIC_Configuration，init_I2C，delay_us 硬件设备相关的使用下划线</code>，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）</h4><p><strong>函数参数命名规范 :</strong></p>
<ul>
<li>参数名称的命名参照变量命名规范。</li>
<li>为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。</li>
<li>为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。 </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">int CmCopyString(const char * c_pcSource, char* pcDest) </div><div class="line">&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>普通函数与中断调用函数区别命名，普通函数如果需要设定控制终中断函数则命名以Set开头通过修改中断函数中的全局变量判定条件来控制中断执行，而中断功能函数只能被中断调用，不可直接被普通函数调用(包括主函数)，命名以 Run 开头。</li>
</ul>
<h4 id="1-6-硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写"><a href="#1-6-硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写" class="headerlink" title="1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写"></a>1.6 硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)</div><div class="line">&#123;</div><div class="line">	/* Check the parameters */</div><div class="line">	assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</div><div class="line"></div><div class="line">	/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */</div><div class="line">	SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-7-文件名-包括动态库、组件、控件、工程文件等-的命名规范-文件名的命名要求表达出文件的内容-要求文件名的长度不得少于5个字母，严禁使用象-file1-myfile-之类的文件名，多个具体含义的单词中用-隔开，一般都采用小写。"><a href="#1-7-文件名-包括动态库、组件、控件、工程文件等-的命名规范-文件名的命名要求表达出文件的内容-要求文件名的长度不得少于5个字母，严禁使用象-file1-myfile-之类的文件名，多个具体含义的单词中用-隔开，一般都采用小写。" class="headerlink" title="1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。"></a>1.7 文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容:要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名，多个具体含义的单词中用_隔开，一般都采用小写。</h4><h4 id="1-8-除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。"><a href="#1-8-除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。" class="headerlink" title="1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLETEST 之类以下划线开始和结尾的定义。"></a>1.8 除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLE<em>TEST</em> 之类以下划线开始和结尾的定义。</h4><h3 id="2-注释规范"><a href="#2-注释规范" class="headerlink" title="2 注释规范"></a>2 注释规范</h3><h4 id="2-1-文件注释：-使用-…-整体注释，不得采用-行注释"><a href="#2-1-文件注释：-使用-…-整体注释，不得采用-行注释" class="headerlink" title="2.1 文件注释：(使用/…/整体注释，不得采用//行注释)"></a>2.1 文件注释：(使用/<em>…</em>/整体注释，不得采用//行注释)</h4><p><em>格式：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/********************* Copyright(C)  20xx  company********************</div><div class="line">	File name: 	// 文件名</div><div class="line">	Author: 		// 作者、</div><div class="line">	Version:		// 版本</div><div class="line">	Date: 		// 完成日期</div><div class="line">	Description: 	// 用于详细说明此程序文件完成的主要功能，与其他模块</div><div class="line">				// 或函数的接口，输出值、取值范围、含义及参数间的控</div><div class="line">				// 制、顺序、独立或依赖等关系</div><div class="line">	Others: 		// 其它内容的说明</div><div class="line">	Function List: // 主要函数列表，每条记录应包括函数名及功能简要说明</div><div class="line">					1. ....</div><div class="line">	History: 	// 修改历史记录列表，每条修改记录应包括修改日期、修改</div><div class="line">				// 者及修改内容简述</div><div class="line">	&lt;author&gt; 		&lt;time&gt;	 	&lt;version &gt; 		&lt;desc&gt;</div><div class="line">	Name1			20xx.x.x		Vx.x		//修改的内容</div><div class="line"></div><div class="line">*************************************************/</div></pre></td></tr></table></figure>
<p><em>例：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/************************************ Copyright (C)  2015  HS ***********************************</div><div class="line">	File name：    	channel.c</div><div class="line">	Author: 		name</div><div class="line">	version:			V1.0</div><div class="line">	Description:		实现多个通道的脉冲发送</div><div class="line">	Others:</div><div class="line">	Function List:</div><div class="line">					void GetChanCtrl(void);</div><div class="line">					void SetNormalMode(void);</div><div class="line">					void SetImMode(void);</div><div class="line">					void CtrlPulse(u8 g_byComRev);</div><div class="line">					void SetTimeMode(void);</div><div class="line">					u16 ScanfValue(void);</div><div class="line">					u32 ScanfTime(void);</div><div class="line">					void CtrlChannel(void);</div><div class="line">					void InitChannel(void);</div><div class="line">					void RunNormal(void);</div><div class="line">					void RunPulse(void);</div><div class="line">					void RunMode(void);</div><div class="line">	History:</div><div class="line">	&lt;author&gt; 		&lt;time&gt;	 	&lt;version &gt; 		&lt;desc&gt;</div><div class="line">Name1			2015.6.1		V1.1		修复xx问题</div><div class="line">**************************************************************************************************/</div></pre></td></tr></table></figure>
<h4 id="2-2-函数注释：-使用-…-整体注释，不得采用-行注释"><a href="#2-2-函数注释：-使用-…-整体注释，不得采用-行注释" class="headerlink" title="2.2 函数注释：(使用/…/整体注释，不得采用//行注释)"></a>2.2 函数注释：(使用/<em>…</em>/整体注释，不得采用//行注释)</h4><p><em>格式：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**************************************************************************</div><div class="line">	Function: 		// 函数名称</div><div class="line">	Description: 		// 函数功能、性能等的描述</div><div class="line">	Calls: 			// 被本函数调用的函数清单</div><div class="line">	Called By:		 	// 调用本函数的函数清单</div><div class="line">	Table Accessed: 	// 被访问的表（此项仅对于牵扯到数据库操作的程序）</div><div class="line">	Table Updated: 	// 被修改的表（此项仅对于牵扯到数据库操作的程序）</div><div class="line">	Input: 			// 输入参数说明，包括每个参数的作</div><div class="line">					// 用、取值说明及参数间关系。</div><div class="line">	Output: 			// 对输出参数的说明。</div><div class="line">	Return: 			// 函数返回值的说明</div><div class="line">	Others: 			// 其它说明</div><div class="line">**************************************************************************/</div></pre></td></tr></table></figure>
<p><em>例：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**************************************************************************</div><div class="line">	Function: 		InitChannel</div><div class="line">	Description: 		启动初始化所有通道</div><div class="line">	Calls: 			TIM_DeInit</div><div class="line">					TIM3_Int_Init</div><div class="line">	Called By:			main()</div><div class="line">	Input: 			无</div><div class="line">	Output: 			让所有通道输出低电平</div><div class="line">	Return: 			无</div><div class="line">************************************************************************/</div></pre></td></tr></table></figure>
<h4 id="2-3-程序块注释："><a href="#2-3-程序块注释：" class="headerlink" title="2.3 程序块注释："></a>2.3 程序块注释：</h4><p><em>一般的程序块注释如 for，while 之类的注释在前面，程序排版整齐，并方便注释的阅读与理解，将注释与其上面的代码用空一行隔开，且该程序块与下面的代码也应该用空一行(使用/\</em>…*/整体注释，不得采用//行注释)*</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">例：</div><div class="line">void example_fun( void )</div><div class="line">&#123;</div><div class="line">	/* code one comments */</div><div class="line">	CodeBlock One</div><div class="line"></div><div class="line">	/* code two comments */</div><div class="line">	CodeBlock Two</div><div class="line"></div><div class="line">	/* code three comments */</div><div class="line">	CodeBlock Three</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-4-边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-在需要注释的变量以及函数调用后加注释使用-，无需空行。"><a href="#2-4-边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-在需要注释的变量以及函数调用后加注释使用-，无需空行。" class="headerlink" title="2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。"></a>2.4 边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),在需要注释的变量以及函数调用后加注释使用//，无需空行。</h4>]]></content>
      
        <categories>
            
            <category> 编程技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[模拟IIC通信时IO选用模式]]></title>
      <url>http://noparkinghere.win/2016/08/10/2016/2016-08-10-%E6%A8%A1%E6%8B%9FIIC%E9%80%9A%E4%BF%A1%E6%97%B6IO%E9%80%89%E7%94%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><em>现如今很多芯片都已经包含有 IIC 通信功能，为何仍然选择模拟 IIC 呢？</em> <strong>首先 IIC 通讯的版权掌握在飞利浦手中，部分厂家如：st 等，实现 IIC 通信较为繁琐，据说不是特别合理稳定；此外，芯片级的 IIC 不同的芯片就需要重新研究书写一次，而模拟 IIC 天生具有较好的移植性，可以做到一次书写，终身可移植。</strong></p>
<h3 id="IIC-通信原理"><a href="#IIC-通信原理" class="headerlink" title="IIC 通信原理"></a>IIC 通信原理</h3><h3 id="IIC-选用-IO-模式"><a href="#IIC-选用-IO-模式" class="headerlink" title="IIC 选用 IO 模式"></a>IIC 选用 IO 模式</h3><p>通过上面可以知道，IIC 在通信过程中，主设备SCL始终是保持发送状态，因此这边我们可以将 SCL 设置为推挽或者开漏输出。推挽的输出能力较强，开漏输出则需要加上拉电阻，而一般 IIC 的推荐电路就是需要人为增加了上拉电阻的，因此在考虑功耗等一些情况下，可能开漏输出更好。</p>
<p><strong>而问题的关键是 SDA 到底设置为什么模式？</strong></p>
<p>网上参考资料众说纷纭，这边以我自己做实验的亲身感受为例，我推荐在作为输出时将这个脚配置为开漏输出模式；在 MCU 需要接收信号的时候，如果 MCU 本身没有限制，或者不需要精简代码的话，则将其设置为输入模式。详解：</p>
<a id="more"></a>
<h4 id="将-SDA-直接设置为开漏模式："><a href="#将-SDA-直接设置为开漏模式：" class="headerlink" title="将 SDA 直接设置为开漏模式："></a>将 SDA 直接设置为开漏模式：</h4><p>这种方法一般用于之前程序的很多单片机中，开漏因为需要接上拉电阻才能改变电平，且具有线与的特性，通过读 IO 口的状态，即便是设置成了开漏输出，但仍然可以读取IO的数据状态，可以说一劳永逸，一种模式两种用途，虽然目前试过大多数MCU通过这种方式也都可以读取，但毕竟是输出模式，万一以后的设计更改了，无法读取了，则有潜在性的问题。</p>
<h4 id="将-SDA-设置位推挽输出模式进行输出，需要读取数据时转换成输入模式："><a href="#将-SDA-设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：" class="headerlink" title="将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式："></a>将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：</h4><p>最近在不少地方看到用这种方式来对 IIC 器件进行读取，感觉较为灵活，之前也将开漏转换成了这种模式。但最近实验过程中发现了不少问题，在 SDA 发送数据结束后，等待应答的这个过程中，使用推挽模式，有明显的短路风险。这段时间虽然时间很短，且接下来会立即将推挽切换为输入模式，但在单步执行测试的过程中,实际会出现很高的电流，疑似推挽的高电平输出引起了断路，用这种模式必须较为谨慎，注意各种延时时间，千万不能让器件断路烧坏。<em>在使用一个 IIC 通信的 AD 芯片过程中，一段时间后出现测量值不准，疑似可能是这种原因引起的。</em></p>
<h4 id="SCL-使用开漏输出模式，SDA-使用开漏输出-输入模式："><a href="#SCL-使用开漏输出模式，SDA-使用开漏输出-输入模式：" class="headerlink" title="SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式："></a>SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：</h4><p>通过上面的讨论，最终个人认为 IIC 通信过程中：SCL 使用开漏输出模式，SDA 使用开漏输出发送数据，使用输入模式读取数据，这种方法较为合理。值得注意：SDA 需要模式切换，IIC 的延迟时间无需过长，否则影响效率，这些根据手册中的标准执行。</p>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常规的通讯校验]]></title>
      <url>http://noparkinghere.win/2016/08/06/2016/2016-08-06-%E5%B8%B8%E8%A7%84%E7%9A%84%E9%80%9A%E8%AE%AF%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/liyuanbhu/article/details/7882789" target="_blank" rel="external">http://blog.csdn.net/liyuanbhu/article/details/7882789</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GPIO口详解]]></title>
      <url>http://noparkinghere.win/2016/08/03/2016/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>在做 MCU 编程开发的时候，GPIO 可以说是最基础也是最重要的部分，MCU 的学习研究无非就是三点：高低电频，输入输出，通讯协议。而GPIO可以说贯穿始终，在模拟一些通讯协议时，GPIO 所采用的模式，往往会引起各种意想不到的问题。</em></p>
<h3 id="GPIO-模式："><a href="#GPIO-模式：" class="headerlink" title="GPIO 模式："></a>GPIO 模式：</h3><h4 id="通用推挽输出（push-pull）："><a href="#通用推挽输出（push-pull）：" class="headerlink" title="通用推挽输出（push-pull）："></a>通用推挽输出（push-pull）：</h4><p>在功率放大器电路中大量采用推挽放大器电路，这种电路中用两只三极管构成一级放大器电路，两只三极管分别放大输入信号的正半周和负半周，即用一只三极管放大信号的正半周，用另一只三极管放大信号的负半周，两只三极管输出的半周信号在放大器负载上合并后得到一个完整周期的输出信号。原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg" alt=""></p>
<p>推挽放大器电路中，一只三极管工作在导通、放大状态时，另一只三极管处于截止状态，当输入信号变化到另一个半周后，原先导通、放大的三极管进入截止，而原先截止的三极管进入导通、放大状态，两只三极管在不断地交替导通放大和截止变化，所以称为<strong>推挽放大器</strong>。</p>
<p><em>这种电路主要用于低功耗情况下能输出较大功率的交流信号，通常用于低频放大电路设计中。可增强输出的负载能力。这种输出结构带负载能力较强，你驱动个LED灯什么的操作IO口可以用推挽输出。</em></p>
<a id="more"></a>
<h4 id="开漏输出（open-drain）"><a href="#开漏输出（open-drain）" class="headerlink" title="开漏输出（open drain）:"></a>开漏输出（open drain）:</h4><p>输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行。原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/DeepinScrot-2019.png" alt=""></p>
<p>开漏输出只有外部有上拉电阻时，才有可能输出高电平。当外部无上拉电阻时，该口不能输出高电平，处于悬空状态，或只可以输出低电平。开漏的主要用处：</p>
<ul>
<li>芯片的 Open drain 输出是设计用于”线或” (wire AND) 逻辑的，就是说当多个漏极开路器件的输出连在一起的时候，只要是其中一个导通，输出就为‘0’。这个特性被广泛用于串行总线电路。</li>
<li>可以用于如继电器之类只吸入电流的负载, 或驱动比你的芯片电源电压高的负载，吸电流能力较强，但是输出能力不如推挽输出较弱，（一般如果单一驱动的话，大都选用推挽输出。）</li>
<li>对于一些需要防止干扰的操作，如：不希望单片机的上拉电阻对外部电路（如ADC）产生任何影响。</li>
</ul>
<h4 id="开集输出（open-collector）："><a href="#开集输出（open-collector）：" class="headerlink" title="开集输出（open collector）："></a>开集输出（open collector）：</h4><h4 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h4><h3 id="通信协议："><a href="#通信协议：" class="headerlink" title="通信协议："></a>通信协议：</h3><blockquote>
<p>参考链接：<br><a href="http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9" target="_blank" rel="external">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href="http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9" target="_blank" rel="external">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href="http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html" target="_blank" rel="external">http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html</a><br><a href="http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3" target="_blank" rel="external">http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3</a><br><a href="http://blog.chinaunix.net/uid-23065002-id-3885199.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-23065002-id-3885199.html</a><br><a href="http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe" target="_blank" rel="external">http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe</a><br><a href="http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093" target="_blank" rel="external">http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[架设自己的git服务]]></title>
      <url>http://noparkinghere.win/2016/07/29/2016/2016-07-29-%E6%9E%B6%E8%AE%BE%E8%87%AA%E5%B7%B1%E7%9A%84git%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><em>本实验使用的是实体机 ubuntu 16.04 和虚拟机 virtualbox 搭建 ubuntu—server 16.04 系统进行连接，其中用 ubuntu-server 搭建 git，实体机 ubuntu desktop 连接 ubuntu-server，后续如果有其他环境也会逐一补充。</em></p>
<p><strong>这边暂时没有在实体机上面尝试，先列举出在虚拟机上面架设 git 服务器</strong></p>
<h3 id="使用-ssh-登陆-ubuntu-server"><a href="#使用-ssh-登陆-ubuntu-server" class="headerlink" title="使用 ssh 登陆 ubuntu-server"></a>使用 ssh 登陆 ubuntu-server</h3><h4 id="ping-通两个系统："><a href="#ping-通两个系统：" class="headerlink" title="ping 通两个系统："></a>ping 通两个系统：</h4><p>看是否可以 ping 通两个系统，首先查看 ip 地址，<code>ifconfig</code>， 例如主机是： 192.168.18.60 ，虚拟机是 192.168.18.202。则在主机中 ping 192.168.18.60 ，当然事情往往并不会一帆风顺，很多设置的时候，为了可以链接外网，虚拟机选用了 NAT 模式。<em>貌似该模式无法使用ssh服务，虚拟机可以 ping 通主机，但主机无法 ping 通虚拟机。</em>这时候可以使用几种方法：</p>
<ul>
<li>更改虚拟机模式为桥接模式，弃用原来的 NAT 模式。</li>
<li>使用实体机中的虚拟机网卡与虚拟机进行交互，但貌似 ubuntu 下面并无法找到这块虚拟网卡，解决办法可以手动建立一个虚拟网卡。</li>
<li>创建一个新的链接方式，通过这个桥接到实体机，然后通过 NAT 访问外网。<em>这边详细介绍这种方式</em></li>
</ul>
<p>详细步骤：</p>
<ul>
<li>使用 virtualbox 新建一个新的 adapter，选用 bridge adapter。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-2011.png" alt=""></p>
<ul>
<li>重启虚拟机系统，或者重启网络服务 <code>sudo /etc/init.d/networking restart</code> ，ifconfig -a 查看所有网卡，可以看到虚拟机中有一个网卡 enp0s8 并没有被使用，这个就是刚刚新建的那个桥接网卡。</li>
<li>设置该网卡，修改/etc/network/interfaces文件，如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4326.png" alt=""></p>
<ul>
<li><p>重启网络服务 <code>sudo /etc/init.d/networking restart</code>，ifconfig 查看网卡。如下图：<br>-<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4534.png" alt=""></p>
</li>
<li><p>接着基本就可以尝试 ping 通两个系统了，实体机中使用 ping 192.168.18.202，虚拟机中 ping 192.168.18.60 。如果仍然不行可以尝试关闭防火墙：<code>sudo ufw disable</code>。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="尝试ssh服务："><a href="#尝试ssh服务：" class="headerlink" title="尝试ssh服务："></a>尝试ssh服务：</h4><p><em>本步骤主要是建立链接，安装 ssh 服务，然后连接实体机可以登陆 ubuntu-server。因为这边 git 采用了 ssh 与服务器进行交互，所以 ssh 在这边是必须的。</em></p>
<ul>
<li>实体机和虚拟机，两个操作系统必须要同时安装 ssh 服务，如果只有实体机安装会出现链接失败。安装指令都是： <code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code> 重启 ssh 服务。</li>
<li>查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的 sshd 和 ssh-agent 如果未打开则运行指令名字。</li>
<li>修改实体机的 ip 配置文件 <code>/ect/hosts</code>，加入如下行： <code>192.168.18.202 ubuntu_server</code>，ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server ,可以修改 /etc/hostname 中的名称。</li>
<li>通过以上设置后，你的主机基本可以通过 ssh 访问虚拟机了，你可以在虚拟机新建一个用户 adduser git，然后实体机可以使用如下命令 <code>ssh git@ubuntu_server 或者 ssh git@192.168.18.202</code> 进行登陆，输入密码就可以进行相关操作了。</li>
</ul>
<p>补充：<em>如果 ssh 还不能登录上，就修改 sshd 的默认配置，例如： ssh 出现 permission denied (publickey) 问题:</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">修改 /etc/ssh/sshd-config 文件.</div><div class="line">将其中的 PermitRootLogin no 修改为 yes</div><div class="line">PubkeyAuthentication yes 修改为 no</div><div class="line">AuthorizedKeysFile .ssh/authorized_keys 前面加上<span class="comment">#屏蔽掉，</span></div><div class="line">PasswordAuthentication no 修改为 yes 就可以了。*</div></pre></td></tr></table></figure>
<h3 id="git虚拟服务器搭建："><a href="#git虚拟服务器搭建：" class="headerlink" title="git虚拟服务器搭建："></a>git虚拟服务器搭建：</h3><p><em>安装 git，可以使用命令 <code>sudo apt-get install git-core</code> 或者 `sudo apt-get install git</em>` 。</p>
<ul>
<li>在实体机上，我们使用命令： ssh-keygen –t rsa 生成密钥。秘钥在当前用户目录的 .ssh 目录下。</li>
<li>在虚拟机的 git 目录下新建一个 .ssh 目录</li>
<li>在 .ssh 目录下，我们可以看到 id_rsa 和 id_rsa.pub 文件，id_rsa.pub 为公钥，我们 通过命令 <code>scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</code>将实体机上生成的公钥拷贝到虚拟机的git账户目录下上。如果是要添加公钥可以使用使用命令 <code>cat /home/git/id_rsa.pub&gt;&gt;/home/git/.ssh/authorized_keys</code></li>
<li>使用命令 <code>git –-bare init /home/git/myRep.git</code> ,初始化化仓库。<strong>注意一定需要建立一个 –bare 的裸库。</strong></li>
</ul>
<h4 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h4><p><em>我们可以使用 <code>git clone git@gitServer:/home/git/myRep.git</code> 直接将库克隆下来，但一般推荐，在将本地库与远程库建立链接具体步骤如下：</em></p>
<ul>
<li>在实体机中新建一个文件夹， <code>mkdir test</code> ，进入该文件夹 <code>cd test</code></li>
<li>初始化这个库， <code>git init</code>。</li>
<li>随意添加几个文件，例如： <code>echo &quot;hello world&quot; &gt;&gt; test.txt</code></li>
<li>常规git操作，加入stage并提交， <code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code></li>
<li>查看下本地库的状态： git status</li>
<li>一切正常的话，将远程库与本地库建立关系： <code>git remote add test git@ubuntu_server:/home/git/myRep.git</code>。这边的 test 为远程库的名称，默认一般为 origin，但如果你一个项目中同时有多个库，则建议你修改 origin 名称。</li>
<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-1126.png" alt=""></p>
<ul>
<li>可以通过 <code>git push test master</code> 进行推送，注意这边远程库名为test而并不是默认的origin。也可以通过<code>git pull test master</code>对虚拟机中的远程库进行拉取。<em>注意因为不是默认名称，所以直接使用 git  push 或者 pull 会报错。</em></li>
</ul>
<p><strong>注意严格按照上面步骤执行，git 操作，一步错，可能就需要你删除 .git 以及 git remote remove test 等相关系列的操作，或者可以删除整个目录重新开始。值得注意的是， git 建立出来的每个库是相互独立的，除非全局设置，否则在添加远程库或者修改其他设置时，都不会对其他库有任何影响。</strong></p>
<p><strong>建立好库，并且也 push 等操作都成功了，但查看虚拟机中远程库的源文件却发现招不到任何一个文件，事实上， git 远程裸库仅仅保存修改记录和分支，并不是用来查看的，只有当你 clone 或者 pull 之后才可以查看某条分支的完整结构。</strong></p>
<blockquote>
<p>参考链接：<br><a href="http://developer.51cto.com/art/201507/483448.htm" target="_blank" rel="external">http://developer.51cto.com/art/201507/483448.htm</a><br><a href="http://blog.sina.com.cn/s/blog_6ab9984801011k81.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6ab9984801011k81.html</a><br><a href="http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n" target="_blank" rel="external">http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n</a><br><a href="http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html" target="_blank" rel="external">http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html</a><br><a href="http://blog.csdn.net/zht666/article/details/9340633" target="_blank" rel="external">http://blog.csdn.net/zht666/article/details/9340633</a><br><a href="http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html</a><br><a href="http://bbs.csdn.net/topics/390158779" target="_blank" rel="external">http://bbs.csdn.net/topics/390158779</a><br><a href="http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/" target="_blank" rel="external">http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[多个发行版linux使用体验]]></title>
      <url>http://noparkinghere.win/2016/07/27/2016/2016-07-27-%E5%A4%9A%E4%B8%AA%E5%8F%91%E8%A1%8C%E7%89%88linux%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p><em>本文主要记录自己使用多个linux的发行版的一些感受体验，会包括CLI和GUI的一些体验。本文具有一定的主观性，仅供参考。</em></p>
<p>发行版包括：ubuntu，debian，centOS，openSUSE等<br>窗口管理器包括：gnome，kde，awesome等</p>
<a id="more"></a>
<hr>
<p>To be continued…</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[桥接、NAT、Host-only上网方式的区别]]></title>
      <url>http://noparkinghere.win/2016/07/25/2016/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><em>经常使用虚拟机的小伙伴们都遇到过网络链接过程中的各种问题，仔细查看设置会发现有：桥接、NAT、Host-only 等设置，vmware 等虚拟机后还会自动生成vmnet1和vmnet8，初学者可能会一头雾水，为啥只有两个？不是三种模式吗？另外每个模式代表什么？他们又有什么区别？无论是 vmware 还是 vitualbox 这些内容都大同小异，而 vmware 中看起来可能会更加直观些，这边以windows下的安装使用为例，进行深入的详解。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/0.png" alt=""></p>
<p><strong>本文会尽可能详细地总结和罗列出三者的含义和区别，以及虚拟机中该如何配置他们更加合适。</strong></p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接:"></a>桥接:</h3><p>简而言之桥接就是指：<strong>就是通过一台设备（可能不止一个）把几个网络串起来形成的连接</strong>。这边主要介绍虚拟机所采用的桥接方式，虚拟出来的操作系统就像是局域网中的一独立的主机，它可以通过路由器网线访问网内任何一台机器。不过虚拟机需要占用你同一个网段的一个 IP 地址，当且仅当虚拟机和实体机在同一个网段，两者才可以进行通信，如：<em>虚拟机 IP：192.168.1.101，实体机 IP：192.168.1.100</em>。</p>
<p>在桥接模式下，例如在 windows 下使用 vmware 时，明显看到会生成多个虚拟网卡出来，但却没有一个网卡是属于桥接的，原因是虚拟机采用桥接方式时，是不需要虚拟网卡的，这时候<em>虚拟机操作系统和实体机操作系统同时使用真实网卡工作，然后真是网卡发送数据出去，而如果虚拟机发送数据给真实机，则数据流向是：<strong>虚拟机系统-&gt;真实网卡-&gt;路由器-&gt;真实网卡-&gt;实体机系统</strong>，不难看出同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em></p>
<p>通过上述内容发现，桥接必须经过真实网卡和路由器，因此当你的电脑没有链接有线网或者无线网的话，你的实体机是无法和虚拟机进行交互的，即便看起来两者很近也不行。<em>而选用桥接还是 NAT 等方式是在虚拟机软件中选定，进入虚拟的操作系统后，所有的设置和真实电脑没有本质区别，如果路由器允许自动分配 IP 地址，则操作系统设置为自动获取 IP 即可，如果不能自动分配，也可以在操作系统中手动分配 IP 地址。另外值得注意的是</em>某些公司路由器绑定了电脑 mac 地址和 IP 地址，这时候虚拟机中的桥接也相当于一个真实电脑，也需要完成相关的绑定才可以访问网络。*</p>
<p>可以看出：如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。下面举个栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而一般lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的 ip 是:</div><div class="line"></div><div class="line">A: 192.168.1.100/255.255.255.0,  B: 192.168.1.101/255.255.255.0,  C: 192.168.1.102/255.255.255.0,  D: 192.168.1.103/255.255.255.0</div><div class="line"></div><div class="line">那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99, 192.168.1.104-192.168.1.254 (网络地址 0 和 1 的除外，再除去 ABCD 四个人的 ip 地址)</div><div class="line"></div><div class="line">那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0,设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器 :8.8.8.8，到此，虚拟机就可以上网了。</div></pre></td></tr></table></figure>
<p>综上所述，<em>同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em>而虚拟机的桥接也只在其他电脑需要访问你电脑的虚拟机时，或者你虚拟机需要访问其他外部设备时才有相关需求*，一般情况还是建议配置成操作方便使用简单的 NAT 方式。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt=""></p>
<a id="more"></a>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT:"></a>NAT:</h3><p><em>NAT模式实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。虚拟机发送数据给实体机：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统</strong>（可以发现是不经过真实网卡的流程简单很多）；虚拟机访问外网：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统-&gt;真实网卡-&gt;路由器-&gt;外网</strong> 。</em></p>
<p>虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT 模式中，虚拟机的网卡和真实网卡的网络，不需要在同一个网络，虚拟机的网卡的网段可以理解：路由器所在网段之下的一个子网段。</p>
<p>采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。而缺点是： NAT 模式下，虚拟机仅仅可以同路由器下网段中的一台真实机通讯，而这台真实机就是安装虚拟机的这台电脑，之所以可以通讯是因为这台电脑本身充当了虚拟机的路由器，相当于路由器的 192.168.1.1 这个地址，而你在 vmware 下的网卡管理中是可以看到这个地址的。这边再补充一点：<em>采用NAT模式时，虚拟机和实体机交互并不是直接进行的，首先虚拟机操作系统访问虚拟网卡 VMnet8 （地址如： 192.188.1.33），然后这个虚拟网卡会再将数据提交给真实机操作系统VMware Network Adapter VMnet8（地址： 192.188.1.1）而地址（192.188.1.33 和 192.188.1.1）实际都是由虚拟机软件 vmware 提供的，具体的交互细节不作研究。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt=""></p>
<h3 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only:"></a>Host-only:</h3><p>在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet 。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。</p>
<p>Host-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/3.png" alt=""></p>
<h3 id="windows下的vmware："><a href="#windows下的vmware：" class="headerlink" title="windows下的vmware："></a>windows下的vmware：</h3><p>VMware 的几个虚拟设备：</p>
<ul>
<li>VMnet0：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；</li>
<li>VMnet1：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；</li>
<li>VMnet8：这是 VMware 用于虚拟NAT网络下的虚拟交换机；</li>
<li>VMware Network Adapter VMnet1：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；</li>
<li>VMware Network Adapter VMnet8：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/4.png" alt=""></p>
<p><em>事实上，根据上面对三种常见模式的详细，基本上应该已经有了清晰的认识，知道如何配置虚拟机网卡了。</em></p>
<h3 id="配置建议："><a href="#配置建议：" class="headerlink" title="配置建议："></a>配置建议：</h3><p>在普通常规虚拟机联网时，采用 NAT 的模式，一般 virtualbox 中默认就为该模式，也默认就帮设置好了网络，用户直接安装完虚拟机操作系统即可上网，如果不行通过安装相关扩展工具即可。如果不小心将如上图所示的Virtual Network Editor 中的内容或者第一张图所示中的网卡配置改乱了，则可以点击上图左下角的 Restore Default 恢复网络设置。</p>
<p>需要特殊使用情况，虚拟机需要连接其他实体设备时，采用桥接模式，需要注意的是：如果路由器无法自动分配IP地址，桥接需要配置 IP 地址，先查看网关地址，然后找一个无法 ping 通的 IP 地址，设置成静态 IP。</p>
<p>Host-only 模式暂时没有怎么用过，一般而言就是为了只让虚拟机和实体机链接使用，也为了屏蔽外部网络的干扰，创建一个纯净的内部实验环境，如果你需要在虚拟机中构建一台服务器，实验搭建服务环境的话，可以先设置成这种模式。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/bloghome/article/details/4487497" target="_blank" rel="external">http://blog.csdn.net/bloghome/article/details/4487497</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html</a><br><a href="http://os.51cto.com/art/201003/186914.htm" target="_blank" rel="external">http://os.51cto.com/art/201003/186914.htm</a><br><a href="http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html" target="_blank" rel="external">http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[githubpage+jekyll搭建博客]]></title>
      <url>http://noparkinghere.win/2016/07/21/2016/2016-07-21-githubpage-jekyll%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>使用 githubpage+jekyll 搭建博客也有半年时间了，这篇文章早该写好，但一致迟迟没有下笔。怎么说呢，githubpage+jekyll 搭建博客的静态博客，操作起来可视化成都较低，缺少 wordpress 等知名博客酷炫的管理后台，也很少能够找到炫酷的模板（文章下方链接给出了 jekyll 的一些模板），以上缺点也是显而易见，简而言之就是 jekyll 的界面丑陋用起来麻烦。但因为 githubpage 是 jekyll 提供的服务，所以好处就是 jekyll 文件无需每次本地编译，直接 push 到 github 上面，就可以生成页面，另外本地也会同时保存一份完整的源文件，书写时只需要按照 markdown 语法码字，更换平台博客搬家更是轻松。</p>
<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/" target="_blank" rel="external">http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/</a><br><a href="http://jekyll.com.cn/" target="_blank" rel="external">http://jekyll.com.cn/</a><br><a href="http://playingfingers.com/2016/03/26/build-a-blog/" target="_blank" rel="external">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href="https://github.com/jekyll/jekyll/wiki/sites" target="_blank" rel="external">https://github.com/jekyll/jekyll/wiki/sites</a><br><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html</a><br><a href="http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[windows7安装详解]]></title>
      <url>http://noparkinghere.win/2016/07/16/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>早在上学时,就安装过很多次win7,老是说,win7出了略微的比xp多占用了点资源外,确实好用。外观美观，性能也算不错。</em></p>
<h3 id="windows-7简介："><a href="#windows-7简介：" class="headerlink" title="windows 7简介："></a>windows 7简介：</h3><p>Windows 7 是由微软公司（Microsoft）开发的操作系统，版本有：入门版（Starter）、家庭普通版（Home Basic）、家庭高级版（Home Premium）、专业版（Professional）、企业版（Enterprise）（非零售）、旗舰版（Ultimate）。Windows 7 的设计主要围绕五个重点——针对笔记本电脑的特有设计；基于应用服务的设计；用户的个性化；视听娱乐的优化；用户易用性的新引擎。 跳跃列表，系统故障快速修复等，这些新功能令Windows 7成为比较美观易用的操作系统。</p>
<h3 id="必要的软件下载："><a href="#必要的软件下载：" class="headerlink" title="必要的软件下载："></a>必要的软件下载：</h3><ul>
<li>[windows 7 64位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</code></li>
<li>[windows 7 32位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/</code></li>
<li><a href="https://pan.baidu.com/s/1o8GRTb0" target="_blank" rel="external">大白菜windows PE</a></li>
<li><a href="https://pan.baidu.com/s/1micuzrE" target="_blank" rel="external">驱动精灵2015网卡版</a></li>
</ul>
<a id="more"></a>
<h3 id="windows-PE安装步骤："><a href="#windows-PE安装步骤：" class="headerlink" title="windows PE安装步骤："></a>windows PE安装步骤：</h3><ul>
<li>安装软件</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-53-18.png" alt="1"></p>
<ul>
<li><p>点击上图中的<em>请选择</em>，选中你的优盘，<strong>注意一定要是格式化的优盘，看大小和名称，千万不能选错，否则里面数据会全部丢失</strong>。</p>
</li>
<li><p>选中后直接点击一键制作usb启动盘，其他不需要修改，同图上即可。</p>
</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-54-24.png" alt="2"></p>
<ul>
<li>等待5分钟左右的时间，制作完成，弹出的提示信息点击否。</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_11-23-6.png" alt="3"></p>
<ul>
<li>到这边，优盘的PE制作则已经完成。</li>
</ul>
<h3 id="PC引导设置："><a href="#PC引导设置：" class="headerlink" title="PC引导设置："></a>PC引导设置：</h3><p>UEFI :这边不讨论 UEFI 下的安装，如果你的电脑设置为了 UEFI，则直接在改成传统设置。</p>
<p><strong>BIOS:传统设置，在主板中改成Legacy BIOS，则切换到这个模式。</strong></p>
<h4 id="BIOS下的设置步骤："><a href="#BIOS下的设置步骤：" class="headerlink" title="BIOS下的设置步骤："></a>BIOS下的设置步骤：</h4><ul>
<li>方法1：可以在 BIOS 中设置启动顺序，将优盘 HDD 或者你的优盘名称对应的那个选项移到最上方。</li>
<li>方法2：如果电脑开启了快速启动的选项，则可以一键选择引导的盘符，例如戴尔的一般是 F12 选项。</li>
</ul>
<h3 id="系统分区操作"><a href="#系统分区操作" class="headerlink" title="系统分区操作"></a>系统分区操作</h3><p><em>分区涉及到的学问很多，对于一个系统来说分区以及文件系统类型很重要。</em></p>
<p><em>这边以windows系统为例，大概简单介绍下：</em><br><strong>windows 系统现在主要使用的是 ntfs 和 fat32 两种格式，fat32 在大文件传输，以及分区容量多有限制，但是兼容性较好，所以我们优盘就格式化成了 fat32 格式。而 ntfs 格式现在 PC 上面普遍选用这种格式，我们的系统也会格式化成这种格式。</strong></p>
<h4 id="进入windowsPE系统"><a href="#进入windowsPE系统" class="headerlink" title="进入windowsPE系统"></a>进入windowsPE系统</h4><ul>
<li>安装时选择 12. 安装原版 win 系统</li>
<li>再选择 04. 进去后使用点击安装</li>
<li>进入 windows PE 系统</li>
</ul>
<h4 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h4><ul>
<li>前提是确保已经进入了 windows PE 系统之后。</li>
<li>打开桌面上的分区工具，可以使用推荐分区方式，建议所有软件都安装在 C 盘。</li>
<li>新建分区，点击<strong>快速分区</strong></li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111Z2E6.jpg" alt="新建分区"></p>
<ul>
<li>在弹出的窗口中选择“分区数目”，在高级设置中可以设置磁盘格式、大小、卷标以及主分区，修改完成后点击“确定”即可；如下图所示：（注意分区的大小，按照我上面提出的第一个是主分区至少40G，文件系统为NTFS，如果是总大小为120G的固态硬盘，可以只分两到三个区，对齐分区到此扇区的倍数选择4096。）</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411191b25.jpg" alt=""></p>
<ul>
<li>接着系统会弹出警告的提示窗口，我们确认无误后，单击“是”即可；如下图所示：</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411193B09.jpg" alt=""></p>
<ul>
<li>接下来系统会自动的进行格式化分区。</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111953b7.jpg" alt=""></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">安装在 C 盘的原因：如果重装系统的话，很多软件虽然仍然能用，但未必用起来稳定，加上软件默认的安装位置也是 C 盘，下次如果升级不注意可能会装重复，较少一部分软件是只能安装在C盘使用的，现在硬盘容量大，和系统装在一起不会有影响，另外重装系统的时候格 C 盘可以一次性清理干净,总而言之，个人认为装在C盘较好。（32 位 win7 的 C 盘分区在 40G 左右，64 位 win7 的 C 盘分区为 50-60G）。</div><div class="line"></div><div class="line">一般分区最多为 4 个分区，但后续的分区表中仍然能够存储其他分区，所以并不仅仅限于 4 个。windows 下的分区多半是一个主分区，和一个扩展分区，注意主分区就是 C 盘，用来安装操作系统的，扩展分区就是所有其他盘的总和，扩展分区是不可以直接使用的，因此分完扩展分区后，需要进一步将扩展分区分成多个逻辑分区，值得注意的是主分区可以有最多四个，但扩展分区有且只能有一个。</div><div class="line"></div><div class="line">格式化的时候扇区大小选择 4096，根据某些测评机构的数据，现在操作系统尤其是 windows 以及固态硬盘的情况下 4K 对齐能够有效的提升硬盘的各种性能。4K 对齐意味这大文件占用更少的扇区个数，数据在检索读取时往往会更快，但这无疑也是一种牺牲空间来换取时间的结果。</div></pre></td></tr></table></figure>
<h3 id="正式安装windows-7系统"><a href="#正式安装windows-7系统" class="headerlink" title="正式安装windows 7系统"></a>正式安装windows 7系统</h3><p><em>在 windowsPE 的环境下，且确定以上操作都没有错误的话，这一步反而是最简单的一步</em></p>
<ul>
<li>将下载好了的 windows 镜像文件复制到你刚刚分区完的电脑中，<strong>一定要复制过去，不能通过优盘加载读取，另外复制在除了 C 盘以外的任意盘上面。</strong></li>
<li>安装方法1：复制完成后，直接双击这个文件，windows PE 会自动加载，这时候回到根目录会看到多出了一个类似光盘的盘，点击进入，然后找到可执行文件双击打卡，按照步骤一步步安装即可。</li>
<li>安装方法2：使用大白菜 PE 装机工具，浏览到选择哪个 windows 镜像文件，选择 C 盘点击确定即可。</li>
<li>系统会重启两次，这个过程不用过分担忧。大约 10-20 分钟后，系统自动安装完成。</li>
</ul>
<p><em>如果以上操作不能完成，可以参考该<a href="http://www.dabaicai.tv/videos/2015/0424/941.html" target="_blank" rel="external">视频</a></em></p>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><p><em>对于一个系统而言，固然应用软件很重要，但它们都依赖于一个良好的驱动环境。</em>刚装完的windows，尤其我们安装的是纯净版，这时候缺少很多驱动程序，可能上不了网，也显示效果很差，下面我们一一来解决。</p>
<ul>
<li>安装我们上面提供的驱动精灵完整版，安装完后进行一次检查，它会帮你自动更新你的网卡驱动。（不排除特殊超极本仍然没法更新驱动，这时候使用能够联网的电脑，去官网搜索型号，下载最新网卡驱动。）</li>
<li>如果第一步能够解决上网问题，则进行这一步，使用驱动精灵联网更新驱动，必备的驱动是 intel 组件，网卡驱动以及显卡驱动，这边推荐再安装更新一个 usb 驱动，如果你的键盘比较特殊也可以更新键盘驱动，其他驱动看个人喜好而定。</li>
</ul>
<p><strong>至此整个的windows 7安装基本写完，如果不是很清晰的，后续可能会补充说明。</strong></p>
<hr>
<blockquote>
<p><a href="http://www.dabaicai.tv/" target="_blank" rel="external">http://www.dabaicai.tv/</a><br><a href="http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra" target="_blank" rel="external">http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra</a><br><a href="http://www.laomaotao.org/lmtjc/245.html" target="_blank" rel="external">http://www.laomaotao.org/lmtjc/245.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）github_markdown]]></title>
      <url>http://noparkinghere.win/2016/07/15/2016/2016-07-05-%EF%BC%88%E8%BD%AC%EF%BC%89github_markdown/</url>
      <content type="html"><![CDATA[<p><em>本内容主要例举了github适用的markdown语法，类似于基于基础markdown定制的语法特性，并非适用于所有的其他markdown编辑器，尤其是下述表情包基本上其他编辑器都不一定能够支持，本人使用的是atom外加一些github的插件，基本能够显示大多数内容，但仍由部分不能支持，另外本文的主要适用范围：<strong>在新建项目工程，书写readme时使用，其他如github page或者其他一些站点的markdown页面请勿参考本文。</strong></em></p>
<h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a><a href="https://github.com/guodongxiaren/README" target="_blank" rel="external">实现效果</a></h4><a id="more"></a>
<h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/guodongxiaren" target="_blank" rel="external">源码地址</a></h4><hr>
<blockquote>
<p>参考链接：<br><a href="https://github.com/guodongxiaren/README" target="_blank" rel="external">https://github.com/guodongxiaren/README</a> （正文原始地址）<br><a href="https://raw.githubusercontent.com/noparkinghere/README/master/README.md" target="_blank" rel="external">https://raw.githubusercontent.com/noparkinghere/README/master/README.md</a><br><a href="http://blog.csdn.net/wqvbjhc/article/details/27349209" target="_blank" rel="external">http://blog.csdn.net/wqvbjhc/article/details/27349209</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[atom使用总结]]></title>
      <url>http://noparkinghere.win/2016/07/15/2016/2016-07-15-atom%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Atom 是 Github 出的一款免费跨平台的 IDE，软件 15 年发布，至今时间较短，国内有一些文章或者帖子介绍该软件，但为数不多。笔者最初写也只是为了写文章而想在 linux 下找一款友好的 markdown 编辑器，翻阅了很多都不尽如人意，最后无意中发现了这款软件。Atom 的特点简而言之就是功能强大，但启动速度慢，如果你是 ssd 的话，这基本上没什么影响。<em>文章最下方的参考链接都写的比较详细，值得拿来参考阅读。</em></p>
<h3 id="Atom简介："><a href="#Atom简介：" class="headerlink" title="Atom简介："></a>Atom简介：</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-15-atom使用总结/1.png" alt=""></p>
<p>Atom 是 github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持 CSS，HTML，JavaScript 等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。继承了 SublimeText 和 vim 的众多优点（除了占用资源，和开启速度慢，当然现在内存越来越不值钱，以及固态硬盘速度奇快，这些都会是问题），很大程度上不仅如此。据称，在目前 IDE 如此之多的情况下，开发这个软件是为了替代 vim（当然这么宣传也可能只是噱头，但 atom 确实扩展性强且容易配置），让更新更优秀的功能能够被体验，因此事实上 Atom 这款软件中是包含了 vim 模式的，当然用惯了 vim 的大神未必服。另外 Atom 在 web 前端相当出名，基本来说具备 SublimeText 的大多数功能，且更加现代化无广告，你无限将其配置成任何你需要的环境（如：C/C++ 开发环境，python 开发环境，markdown 写作软件等等），可见，现在学习使用这款软件无论是功能性能还是面向将来都是值得的。</p>
<p>这边给出几个最主要的链接：<a href="https://atom.io/" target="_blank" rel="external">atom官网</a>，<a href="https://atom.io/packages" target="_blank" rel="external">atom插件中心</a>，<a href="http://flight-manual.atom.io/" target="_blank" rel="external">atom官方手册英文版</a>，<a href="https://atom-china.org/" target="_blank" rel="external">atom中文社区</a>，<a href="https://github.com/atom/atom" target="_blank" rel="external">atom源码</a>。</p>
<h3 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用:"></a>快捷键的使用:</h3><p>atom 的很多操作方式都和 chrome 等软件类似，如果习惯使用这些软件的人会觉得很得心应手，例如：ctrl+w 关闭标签页，ctrl+shift+t 重新打开之前关闭的标签等等。</p>
<p>ctrl+.  :  调用按键查看器<br>ctrl+\  :  文件目录结构管理<br>ctrl+,  :  setting设置<br>ctrl-shift-M : Markdown预览</p>
<a id="more"></a>
<h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>使用快捷键 ctrl+, 打开 setting 设置，左侧的最下方可以看到 Open Config Folder，在这里如果你对 atom 有比较深入的理解，完全可以修改所有的配置参数。如： packages 中一般存放了你自己安装插件的全大多数文件，而像 keymap.scon 中则可以设置自己需要的快捷键。</p>
<p>可以说极少有 IDE 能够像 atom 直接开放出这么多的定制功能，但能够使用他们的前提是你对它足够的了解，所以最好的途径还是去仔细阅读官方手册。</p>
<h3 id="插件指南："><a href="#插件指南：" class="headerlink" title="插件指南："></a>插件指南：</h3><p>有关 atom 的插件，可以使用 settings 中的自带搜索安装，也可以使用 apm install “packages” 安装插件，使用 apm remove “packages” 删除插件，所有的 package 一般都会有很详细的安装说明，注意仔细研读，一般推荐使用 apm install “packages” 方式安装插件，同时我们可以使用 apm update 进行插件的升级。</p>
<p>考虑到伟大的 GFW，部分通过上面两种方法还是无法安装的小伙伴，可以访问<a href="https://atom.io/packages" target="_blank" rel="external">atom插件中心</a>，需要找到插件在git上的下载地址（如果 atom 插件中心也无法访问，则直接去 github 上搜索）。将项目下载下来，解压后，文件夹移动到 <code>yourpath/.atom/packages/</code> 下，打开到该插件文件夹目录下，在该目录下执行 <code>apm install</code> ，之后你就可以在插件管理中看到新的插件出现了。</p>
<p>值得注意的是，各个插件虽然功能强大，但是也都会对 atom 进行一些定制，一些插件可能同事占用了某个快捷键，本身有冲突，所以在使用插件时，需要看一下里面的配置以及官方的说明，<strong>难能可贵的是：所有插件安装后都可以点击插件名打开相关网页，上面附带有详细的帮助和使用说明，另外你也可以直接在<a href="https://atom.io/packages" target="_blank" rel="external">官方网址</a>搜索自己想要的插件。</strong></p>
<ul>
<li><a href="https://atom.io/packages/sync-settings" target="_blank" rel="external">Sync-setttings</a> (插件-备份神器),可以将你配置的atom环境备份到github上面，换电脑时，可以方便移植。自带的说明写的相当详细，注意<em> new personal access token 中激活 Gist -&gt; create gists，但最好其他选项都不要打开，可能会引起插件无法读取加载。具体原因不明，如果你知道请在下面留言，或者发邮件给博主。</em></li>
<li><a href="https://atom.io/packages/activate-power-mode" target="_blank" rel="external">activate-power-mode</a> 貌似真没有什么实际作用，但的的确确是个装逼必备的神器，效果酷炫。</li>
<li><a href="https://atom.io/packages/vim-mode" target="_blank" rel="external">vim-mode</a>，顾名思义是在 atom 下使用 vim 一些操作。由于本人不是很精通 vim，只会一些正常的按键操作，所以作为日常编辑时，感觉还行。但这个插件用的应该不是太多，毕竟是 atom 官方的插件，但却要手动安装下载。</li>
<li>autocomplete-paths:文件路径自动提示。</li>
<li>gpp-compiler:C/C++ 的编译器，可以通过快捷键直接调用这些功能，让atom成为一款真正的 C 开发环境。</li>
<li>markdown-writer：书写 markdown 的强化工具</li>
<li>markdown-scroll-sync：目前最佳的 markdown 预览工具</li>
<li>python-tools：python 辅助开发工具</li>
</ul>
<p><strong>注意：同样的插件可能在 windows 和 linux 下的支持是不一样的，部分插件只支持 windows ，部分插件在 linux 中可能功能会更多，具体要参见开发者写的插件说明。</strong></p>
<h3 id="windows下的安装"><a href="#windows下的安装" class="headerlink" title="windows下的安装"></a>windows下的安装</h3><p>atom 的强大就在于跨平台的使用，可以让你在不同的平台有着几乎一样的编程体验。windows 下的安装大致可以分为两个版本，一个是 .exe/.msi 安装方式，需要.net工具包才能顺利安装，另外也可以下载解压包，可以免安装直接使用。</p>
<p>在dos 下通过cmd命令安装插件：</p>
<ul>
<li>打开 dos 窗口 window 可用快捷键 win+r  再输入cmd</li>
<li>输入 apm install “packages” 如果 apm 不能识别请用 npm install “packages”。</li>
</ul>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="failed-to-activate-the-package-cannot-find-module-“loe-random”"><a href="#failed-to-activate-the-package-cannot-find-module-“loe-random”" class="headerlink" title="failed to activate the package : cannot find module “loe.random”"></a>failed to activate the package : cannot find module “loe.random”</h4><p>执行 npm install loe.random（你缺失哪一个 module，你就用那个 module 替代代码中的位置）</p>
<h4 id="一行内容书写过多，阅读不方便，无法自动缩转到下一行。"><a href="#一行内容书写过多，阅读不方便，无法自动缩转到下一行。" class="headerlink" title="一行内容书写过多，阅读不方便，无法自动缩转到下一行。"></a>一行内容书写过多，阅读不方便，无法自动缩转到下一行。</h4><p>插件 language text 中的 soft wrap 等相关选项。</p>
<hr>
<p><em>补充：目前我主要使用 atom 写一些 markdown 文章，其他的一些操作都是偶尔使用，程序调试等还是会借助其他专门的 IDE，atom 的一些功能特性还没有全部摸清，后续有新的发现还会再补充。</em></p>
<p>To be continued…</p>
<blockquote>
<p>参考链接（建议查看，很多内容文章没复述）：<br><a href="http://www.07net01.com/2015/08/893825.html" target="_blank" rel="external">http://www.07net01.com/2015/08/893825.html</a><br><a href="http://www.jianshu.com/p/dd97cbb3c22d" target="_blank" rel="external">http://www.jianshu.com/p/dd97cbb3c22d</a><br><a href="http://www.jianshu.com/p/508d540ca9c3" target="_blank" rel="external">http://www.jianshu.com/p/508d540ca9c3</a><br><a href="http://www.hackbase.com/article-206939-1.html" target="_blank" rel="external">http://www.hackbase.com/article-206939-1.html</a><br><a href="http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;" target="_blank" rel="external">http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;</a><br><a href="http://www.jianshu.com/p/55d6cbc175a9" target="_blank" rel="external">http://www.jianshu.com/p/55d6cbc175a9</a><br><a href="https://www.zhihu.com/question/22867204" target="_blank" rel="external">https://www.zhihu.com/question/22867204</a><br><a href="http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html" target="_blank" rel="external">http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html</a><br><a href="http://www.cnblogs.com/20145221GQ/p/5334762.html" target="_blank" rel="external">http://www.cnblogs.com/20145221GQ/p/5334762.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Caps_Lock与右Ctrl互换]]></title>
      <url>http://noparkinghere.win/2016/07/14/2016/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p><em>实现该功能的目的主要是切换中英文输入法，在使用 ctrl 或者 shift 切换时，很明显这两个键的位置远不如caps按起来方便，且 shift 往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而 caps 作为大小写时用起来相当罕见，作为中文输入来说更可以说完全是鸡肋的功能。大写完全可以用 shift 代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。下面将会总结一个既保留 Caps_Lock 键功能，又可以充分利用这个最好位置的按键映射方法。</em></p>
<h3 id="linux系统下的实现"><a href="#linux系统下的实现" class="headerlink" title="linux系统下的实现"></a>linux系统下的实现</h3><h4 id="按键值查询"><a href="#按键值查询" class="headerlink" title="按键值查询"></a>按键值查询</h4><p>linux 下可以通过命令小程序对绝大多数按键值进行查找，要想修改键值映射, 先要知道按键的键值. 用如下命令查看: <code>xev | grep keycode</code>。</p>
<p>同时我们可以查看需要映射的按键的映射名称：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">例如, 执行命令查看 Menu 键相关的按键名:</div><div class="line"></div><div class="line">xmodmap -pke | grep menu -i</div><div class="line">显示结果为:</div><div class="line"></div><div class="line">keycode 135 = Menu NoSymbol Menu</div><div class="line">keycode 147 = XF86MenuKB NoSymbol XF86MenuKB</div></pre></td></tr></table></figure>
<p>比如想把键盘的右边的 Alt 改为 Menu : <code>xmodmap -e &quot;keycode 108=Menu&quot;</code>，简而言之 xmodmap 程序就是用来控制系统按键的，需要详细了解这个软件的操作，可以查看帮助文档。</p>
<a id="more"></a>
<h4 id="将Caps-Lock和键盘右边的Ctrl调换"><a href="#将Caps-Lock和键盘右边的Ctrl调换" class="headerlink" title="将Caps_Lock和键盘右边的Ctrl调换"></a>将Caps_Lock和键盘右边的Ctrl调换</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">remove Lock = Caps_Lock</div><div class="line">remove Control = Control_R</div><div class="line">keysym Control_R = Caps_Lock</div><div class="line">keysym Caps_Lock = Control_R</div><div class="line">add Lock = Caps_Lock</div><div class="line">add Control = Control_R</div></pre></td></tr></table></figure>
<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效。实际上，每次开机启动后，系统会通过 xmodmap 程序自动加载 .Xmodmap 程序，也就是一次创建更改 .Xmodmap 文件，终身配置有效。</p>
<p><strong>注意:完成上述步骤即可，以下步骤为最初设置时,出现的问题,可以忽略不看。</strong></p>
<h4 id="加入开机自启"><a href="#加入开机自启" class="headerlink" title="加入开机自启"></a>加入开机自启</h4><p>同大多数开机自启并没有太大区别，将<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>写入到 /etc/rc.local 中即可。该方法经常失效，不是太灵验，因此我设置了快捷键 ctrl+space ，每次按下这个快捷键时，会自动执行<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>。</p>
<p>解决:由于上面命名错误, .Xmodmap 文件的首字母是大写，因此加载总是出错，另外使用 <code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code> 命令后，每次无需再加入启动项了，一次配置成功即可。</p>
<h3 id="windows下的更换按键"><a href="#windows下的更换按键" class="headerlink" title="windows下的更换按键"></a>windows下的更换按键</h3><p>打开注册表，在运行（win+R）中输入 regedit ，注册表位置：[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的 Key，名叫： Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入如下的值：</div><div class="line">　　00,00,00,00</div><div class="line">　　00,00,00,00</div><div class="line">　　03,00,00,00</div><div class="line">　　3A,00,1D,E0</div><div class="line">　　1D,E0,3A,00</div><div class="line">　　00,00,00,00</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/BaiduShurufa_2016-8-10_14-5-24.png" alt=""></p>
<h4 id="windows-各个键位值的参考："><a href="#windows-各个键位值的参考：" class="headerlink" title="windows 各个键位值的参考："></a>windows 各个键位值的参考：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">　　Escape 01 00</div><div class="line">　　Tab 0F 00</div><div class="line">　　Caps Lock 3A 00</div><div class="line">　　Left Alt 38 00</div><div class="line">　　Left Ctrl 1D 00</div><div class="line">　　Left Shift 2A 00</div><div class="line">　　Left Windows 5B E0</div><div class="line">　　Right Alt 38 E0</div><div class="line">　　Right Ctrl 1D E0</div><div class="line">　　Right Shift 36 00</div><div class="line">　　Right Windows 5C E0</div><div class="line">　　Backspace 0E 00</div><div class="line">　　Delete 53 E0</div><div class="line">　　Enter 1C 00</div><div class="line">　　Space 39 00</div><div class="line">　　Insert 52 E0</div><div class="line">　　HOME 47 E0</div><div class="line">　　End 4F E0</div><div class="line">　　Num Lock 45 00</div><div class="line">　　Page Down 51 E0</div><div class="line">　　Page Up 49 E0</div><div class="line">　　Scroll Lock 46 00</div></pre></td></tr></table></figure>
<p>以上 windows 的按键更改仅在 windows 7 下实验过，其他系统有待验证。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/xiaobaibuhei/p/3629133.html" target="_blank" rel="external">http://www.cnblogs.com/xiaobaibuhei/p/3629133.html</a><br><a href="http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/" target="_blank" rel="external">http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/</a><br><a href="http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html" target="_blank" rel="external">http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html</a><br><a href="http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html" target="_blank" rel="external">http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html</a><br><a href="http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html" target="_blank" rel="external">http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html</a><br><a href="http://xahlee.info/kbd/linux_make_capslock_esc_key.html" target="_blank" rel="external">http://xahlee.info/kbd/linux_make_capslock_esc_key.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 配置推荐 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[jlink相关问题汇总]]></title>
      <url>http://noparkinghere.win/2016/07/12/2016/2016-07-12-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h3 id="jlink简介"><a href="#jlink简介" class="headerlink" title="jlink简介"></a>jlink简介</h3><h3 id="MDK如何让jlink不跳出升级"><a href="#MDK如何让jlink不跳出升级" class="headerlink" title="MDK如何让jlink不跳出升级"></a>MDK如何让jlink不跳出升级</h3><p>有三种方法(注意盗版的 jlink 谨慎升级),推荐方法3。</p>
<ol>
<li>升级 Keil 自带的 J-link 程序,新版本 jlink 的一般盗版的 v8 都没法直接升级。</li>
<li>使用之前版本 keil 自带的 J-link 驱动替换掉现在的,也就是将 ..\Keil\ARM\Segger 文件夹替换为老版本的,这样里面的 J-Link 驱动也是老版本的,就不会提示 J-Link 更新了,这种需要有之前的 keil 才可以,如果是直接安装新版的 keil 5 默认自带为 4.8 的版本。</li>
<li>卸载 segger，下载了比较新的驱动重新安装，并将 segger/jlinkarm_v440 目录下的 jlinkarm。dll 拷贝到 keil/arm/segger 的目录下。再次使用 MDK，提示升级，确定升级，但这次升级后，jlink 确实可以识别。这个版本需要注意的是 jlink 的版本必须在 4.4 以后(如 4.1x 的复制 jlinkarm.dll 软件会出错),另外复制前做好 jlinkarm.dll 的备份。</li>
</ol>
<a id="more"></a>
<h3 id="JLINK刷固件步骤"><a href="#JLINK刷固件步骤" class="headerlink" title="JLINK刷固件步骤"></a>JLINK刷固件步骤</h3><p><em>如果通过上面的方法,结果盗版jlink变板砖了,可以使用下面方法重新烧录固件。</em></p>
<h4 id="清除原有固件-烧录新固件"><a href="#清除原有固件-烧录新固件" class="headerlink" title="清除原有固件,烧录新固件"></a>清除原有固件,烧录新固件</h4><ul>
<li>下载安装提供的相关软件: jlink, Install AT91-ISP v1.13, 以及固件。</li>
<li>按照说明文档一步步操作,烧录固件,<strong>步骤先后顺序一定要完全一致,如果失败则重复多次</strong>。<a href="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-13-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/JLinkV8%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95%E6%8C%87%E5%AF%BC.pdf" title="JLinkV8固件烧录指导" target="_blank" rel="external">JLinkV8固件烧录指导</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### 升级方法:</span></div><div class="line">- 使用XP的环境, win7 大多都不行。</div><div class="line">- 打开 jLink <span class="built_in">command</span> 软件,注意不要升级固件。</div><div class="line">- 在命令行下输入: Exec SetSN=XXXXXXXX  回车。**注：XXXXXXXX 为你自己想要的 SN,SN 必须是8个数字。**</div><div class="line">- 关闭 jLink <span class="built_in">command</span> 软件再从新打开。即可生效。</div><div class="line">*注意:只能设置一次 SN,设置前请想好你的SN。*</div><div class="line"></div><div class="line">然后就可以正常升级了。</div></pre></td></tr></table></figure>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><h4 id="MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！"><a href="#MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！" class="headerlink" title="MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！"></a>MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！</h4><ul>
<li>如果 jlink 链接没有问题,且能够找到芯片的话,一般为 flash programming algorithm 丢失。<br><a href="http://www.openedv.com/posts/list/50048.htm" target="_blank" rel="external">参考网址 </a></li>
</ul>
<blockquote>
<p>参考链接:<br><a href="http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu" target="_blank" rel="external">http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu</a><br><a href="http://www.openedv.com/posts/list/50048.htm" target="_blank" rel="external">http://www.openedv.com/posts/list/50048.htm</a></p>
</blockquote>
<hr>
<p>TO be continued…</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下vpn配置]]></title>
      <url>http://noparkinghere.win/2016/07/12/2016/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>这篇文章的初稿是在一年前写的，今天简书通知我之前上传的一篇有关 ss 的文章竟然被强制下架了，让我突然想起以前写过这样一篇文章，ss 在国内查封的十分严重，百度几乎找不到任何有关的内容，而 VPN 在市面上算是广为流传，今天（2017-03-20）再次把文章拿出来总结下。</p>
<p>由于众所周知的原因，国内用户被强大的 GFW 保（lan）护（jie）而无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook，需要去国外厂家查找某方面的资料等，就一定需要学会翻墙上网，该方面的能力甚至已经算是软件从业/科研人员的基本素养，因此一般也将翻墙称作科学上网。本文主要介绍使用付费 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。</p>
<h3 id="推荐-VPN"><a href="#推荐-VPN" class="headerlink" title="推荐 VPN"></a>推荐 VPN</h3><p>如果你偶然需要访问下国外的网站，一般可以到网上试用免费的 VPN，几乎所有的 VPN 提供商都免费提供了试用 IP 地址，试用的账号大多是 1h 更换一次密码，速度仅能够访问网页。</p>
<p>购买付费 VPN 的时候，一定需要谨慎，由于众所周知的法律盲区或者说是非法的原因，VPN 一般都缺少市场规范和管控，简而言之就是本身就不合法，因此很多网站出售 VPN 可能存在诈骗或被查封的可能性。本文推荐的是一个老牌 VPN，经营多年，信誉各方面都有的保障，具备速度快，链接稳定，站点多，软件跨平台，支持市面上各种操作系统等有点。</p>
<p>这边首推国内最出名的 <a href="http://gjsq.me/web" target="_blank" rel="external">Green VPN</a>，域名经常会被查封，以上给出的这个网址一般会自动跳转，大多数情况不会变化。Green VPN 的费用一般在 ￥150/year 左右，可以两个客户端同时使用，特点是使用起来方便，速度稳定，一般带宽在 4M 以上，但不能长期链接，每天可能会断线一次。Green VPN 算是一家老牌的 VPN 了，价格虽然不算最便宜，但稳定性服务等都比较有保证，市面上面冒充 Green VPN 诈骗的也比较多，购买时需要当心注意。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/1.png" alt=""></p>
<p><a href="http://gjsq.me/web" target="_blank" rel="external">Green VPN</a> 官方给出了最详细的指导教程，使用前可以先观看图文教程，步骤详细，而且都配置简单。</p>
<p>VPN 的加密效果一般，还是有很大几率被监控到的，因此使用时，需要谨慎，切勿发表一些激动言论，谨防家中水表。</p>
<a id="more"></a>
<h3 id="linux-下的-VPN-配置"><a href="#linux-下的-VPN-配置" class="headerlink" title="linux 下的 VPN 配置"></a>linux 下的 VPN 配置</h3><p>Green VPN 上面的参考文档很多，其实已经给出了详细步骤，一般采用<a href="https://www.getgreenjsq.co/shiyong/67.html" target="_blank" rel="external">Ubuntu 设置方法 (PPTP)配置</a>，该步骤也适用于其他地方购买的 VPN，下面列出详细设置：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/4.png" alt=""></p>
<p>网关填写服务器地址，该地址是 VPN 网站提供给你的连接地址，用户名密码填写在 VPN 网站注册的信息，验证通过即可登录，但有时连接未必稳定，需要尝试多次才可以连接成功。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-linux%E4%B8%8Bvpn%E9%85%8D%E7%BD%AE/7.png" alt=""></p>
<h3 id="VPN-和-ssh-兼容"><a href="#VPN-和-ssh-兼容" class="headerlink" title="VPN 和 ssh 兼容"></a>VPN 和 ssh 兼容</h3><p>VPN 的所用的协议和 SSH 协议是互不兼容的，也就是说，如果你登陆了 VPN ，这时使用 SSH 命令想完成一些操作的话，会出现不响应的状况。如果遇到这种问题可以参考本博客的<strong>linux下ssh通过VPN推送失败</strong>文章。</p>
<h3 id="VPN-的开机自启动"><a href="#VPN-的开机自启动" class="headerlink" title="VPN 的开机自启动"></a>VPN 的开机自启动</h3><p>linux 下 VPN 的开机自启还没有找到，windows 等其他平台都有客户端可以很容易设置开机自启。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>VPN 相比 ss 而言，更加容易使用，无需具备太多的电脑知识，但 VPN 加密不如 ss，更容易被监控到。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="https://www.getgreenjsq.co/shiyong/67.html" target="_blank" rel="external">https://www.getgreenjsq.co/shiyong/67.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 配置推荐 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux正常学习办公]]></title>
      <url>http://noparkinghere.win/2016/07/11/2016/2016-07-11-linux%E6%AD%A3%E5%B8%B8%E5%AD%A6%E4%B9%A0%E5%8A%9E%E5%85%AC/</url>
      <content type="html"><![CDATA[<p>本文章在于总结自己如何使用 linux 完成正常的办公学习。linux 向来以它的可定制性强，稳定性高而出名，但 linux 常用领域大多也只限制在个别的一些如服务器领域，而民用领域即便是安卓系统也是 linux 经过层层封装之后的产物，早已逝去了该系统的原汁原味。linux 从发展至今也已经有了20多年的历史，但桌面版本一致被大家诟病，非专业人事不能使用，自从 ubuntu 这个发行版出来后，确实可以说是降低了新人使用的门槛，但是这个发行版的 GUI 定制性差，不够稳定等一系列的问题也让用户体验直线下降。这边我是以 ubuntu 的系统为基础采用 awesome 这儿 WM 进行图形化管理，目前已经使用了一年的时间，整体体验还算是良好。</p>
<blockquote>
<h2 id="系统选择："><a href="#系统选择：" class="headerlink" title="系统选择："></a>系统选择：</h2></blockquote>
<h3 id="为何选择ubuntu？"><a href="#为何选择ubuntu？" class="headerlink" title="为何选择ubuntu？"></a>为何选择ubuntu？</h3><p><em>现如今linux发行版很多，但真如ubuntu一样的美观，稳定又方便的真不多。说一下我用过的各个系统的体验吧：</em></p>
<ul>
<li>centOS 系统不够美观，本身使命就是等同 REDHAT 用于服务器的，虽然可以预装的软件比较多，但大都是用于开发及运维的。</li>
<li>arch 更像是一个 geek 玩的玩具，更新频率过快，该版本接触不是过多，但用于正常工作生活的系统，没有人愿意一天折腾几次吧？用不上一年就非得重装的吧？</li>
<li>deepin 这个是一个国产 linux，也只用过很短的一段时间，就界面各方面而言，感觉还是满美观，满人性化的，但用户太少，社区看起来也不是太活跃，虽然好像也是基于debian的衍生产品，但还是再观望一段时间再说吧。</li>
<li>ubuntu 出来时间也比较久了，本身一直专注于做桌面系统，gnome 的一整套组建目前来看也比较完善，各种自带软件，用户体验都还不错，有些甚至比 MS 的更好用。当然作为一个正常办公学习使用的人来说，最满意的还是 apt-get 可以直接管理获取各种资源了。也就是说，如果你是需要用 linux 来办公学习，写写程序的话，ubuntu 应该来说会是首选。</li>
</ul>
<a id="more"></a>
<h3 id="为何选择-awesome？"><a href="#为何选择-awesome？" class="headerlink" title="为何选择 awesome？"></a>为何选择 awesome？</h3><ul>
<li><p>gnome 的不稳定<em>ubuntu 下的 gnome 如果作为日常使用的话，很难满足要求，虽然经过这么多年的发展，但仍然会经常出现不响应。</em>试问，如果一个 GUI 连基本的稳定都没法保障，即便功能再完善，外观再美，用户长久用下来，最终会抛弃她。使用 gnome 两周，尽管尝试着去更改设置了不少东西，但度过了最开始的新奇感后，永无止境的不响应，从错误中恢复等等，最终让我还是选择更换一个新的图形化用户界面。</p>
</li>
<li><p>awesome 的轻便小巧，且可定制话极强（当然其他 linux 也都可以定制，只不过，其他的起点过高，对于普通用户而言，上手不易），awesome 即便是新手，在 github 上找个模板，稍加摸索也可以定制出自己满意的 GUI。</p>
</li>
</ul>
<blockquote>
<h2 id="linux-软件："><a href="#linux-软件：" class="headerlink" title="linux 软件："></a>linux 软件：</h2></blockquote>
<p>虽然 linux 上面的软件没有 windows 的丰富，在娱乐上面可能有所欠缺，但办公学习上面的并不少且功能大都很强大，下面我们介绍一些 linux 上最常用的软件，基本可以让你的 PC 不再需要安装 windows。</p>
<h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><h4 id="chrome"><a href="#chrome" class="headerlink" title="chrome:"></a>chrome:</h4><p>这个不做过多解释，简而言之就是好用，chrome 支持多个平台，而且用户体验都相近，关键 linux 下的 chrome 还相当稳定，远胜过 ubuntu 下自带的 firefox 等浏览器，使用体验可能更甚于 windows 下的 chrome。插件扩展等功能应有尽有。chrome 的使用和技巧内容很多，关于 chrome 可以参考本博客中专门的文章。</p>
<h4 id="thunar"><a href="#thunar" class="headerlink" title="thunar"></a>thunar</h4><p>一款占用资源少，功能强大的文件管理器，支持文件批量命名等等操作。</p>
<h4 id="virtualbox"><a href="#virtualbox" class="headerlink" title="virtualbox:"></a>virtualbox:</h4><p>算是使用 windows 软件的必备工具了，虽然说 wine 等也可以使用 windows 软件但不稳定也存在配置麻烦，这边还是推荐如果有需要用 windows 软件的时候可以使用虚拟机 virtualbox，目前电脑配置都极好，如果你是 i3 标压 CPU 和 8G 及以上的内存，在 virtualbox 下使用 windows 7 运行 Photoshop，下载文件，浏览网站，编辑文档，观看视频等都是没有问题的。当然这边并不提倡都在虚拟机中操作，否则我们安装 linux 就没有意义了，目前个人而言，除了需要迅雷，百度云下载大文件，以及 Photoshop 作图，其他基本上都可以在 linux 下解决。</p>
<h4 id="deepin-scrot截图："><a href="#deepin-scrot截图：" class="headerlink" title="deepin-scrot截图："></a>deepin-scrot截图：</h4><p>效果虽然可以达到 windows 下的截图工具大部分功能，但不够稳定。速度慢，虽然截图功能不是什么大的应用，但奈何之前在 win 平台下的截图都太好用了，暂时还没有在 linux 平台下面找到能够完全满意的截图软件。</p>
<h4 id="gthumb"><a href="#gthumb" class="headerlink" title="gthumb:"></a>gthumb:</h4><p>一款轻巧好用的图片查看编辑工具，基本具备大多数常用功能，但仍然不能算是满足日常工作需要，最起码标记涂鸦功能都没有。</p>
<h4 id="分屏功能"><a href="#分屏功能" class="headerlink" title="分屏功能"></a>分屏功能</h4><p>xrandr命令，这是一个命令行软件，并非图形界面软件，但很实用，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享。</p>
<ul>
<li>输出当前可用设备：xrandr</li>
<li>选用你需要使用的设备：xrandr –output HDMI1 –auto ,这边 HDMI1 就是上一条之前命令列出来的设备名称，模式选用自动，一般不会要在配置。</li>
</ul>
<h4 id="uget"><a href="#uget" class="headerlink" title="uget"></a>uget</h4><p>uget 工具类似于 windows 下的迅雷，但它调用其他的工具来下载，uget 仅是提供了一个图形界面，这边推荐使用 uget+aria2c 可以让你的速度飞起，比迅雷还要快很多。</p>
<h4 id="搜狗拼音"><a href="#搜狗拼音" class="headerlink" title="搜狗拼音"></a>搜狗拼音</h4><p>国内最出名的输入法，虽然之前用 windows 时，一直没用过他家的产品，发现只有这家提供了 linux 的版本，除了不支持账号登录外，其他该有的功能基本上都有。</p>
<h3 id="办公学习"><a href="#办公学习" class="headerlink" title="办公学习"></a>办公学习</h3><h4 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h4><p>linux 上面可以安装 openoffice，而 openoffice 类似于 Microsoft office 该有的功能也都有，但就是界面丑了点，这边我推荐国产的 WPS，让人惊喜的是这款软件目前除了账户同步功能没有，其他基本上和 windows 版本的没有太多区别。</p>
<h4 id="福昕阅读器"><a href="#福昕阅读器" class="headerlink" title="福昕阅读器"></a>福昕阅读器</h4><p>同样是一款国产的办公软件，这款软件特点是速度快，界面简洁，UI 风格和 windows 上区别还蛮大，目前只发现了英文版的。</p>
<h4 id="xmind"><a href="#xmind" class="headerlink" title="xmind:"></a>xmind:</h4><p>一款和 freemind 类似的思维导图软件，该软件是国产的一款开源商业软件，linux 上面体验和 windows 上略有差别，但该有的功能基本都有。</p>
<h4 id="teamview"><a href="#teamview" class="headerlink" title="teamview"></a>teamview</h4><p>跨平台的远程协助软件，功能性能相当强大，甩开 qq 远程桌面好几条街。</p>
<h4 id="录屏软件recordmydesktop"><a href="#录屏软件recordmydesktop" class="headerlink" title="录屏软件recordmydesktop"></a><a href="http://jingyan.baidu.com/article/7908e85c91f834af491ad241.html" target="_blank" rel="external">录屏软件recordmydesktop</a></h4><p>这边主要是本人用不到这个，不做详细介绍。</p>
<h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><h4 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h4><p>网易算是国内比较良心的厂家，网易云音乐可以说是国产众多软件中体验效果最好的，支持账号登录等所有功能，和 windows 版本以及 Android 版本没有发现差别。</p>
<h4 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h4><p>steam 这个游戏平台还是很出名，自从 steam 可以在 linux 上使用后，基本解决了 linux 没有娱乐的问题，当然注意，并不是每个 steam 平台的游戏都支持 linux，值得庆幸的是 dota2 是支持 linux 的，我的电脑是 2 代 i5 CPU + gt450 显卡 + 普通机械硬盘，运行 dota2 画质中等以下体验没有问题。</p>
<h3 id="开发套件："><a href="#开发套件：" class="headerlink" title="开发套件："></a>开发套件：</h3><h4 id="atom"><a href="#atom" class="headerlink" title="atom:"></a>atom:</h4><p>github 出品，算是现代 IDE 中的一个精品吧，结合了 vim 和 sublimeTEXT 一些特征特点，优缺点可谓见仁见智，反正在我看来vim能够实现的它也都可以实现，长期使用 vim mod 插件，且各种第三方插件应有尽有。</p>
<h4 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h4><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><h4 id="Qt-creator"><a href="#Qt-creator" class="headerlink" title="Qt creator"></a>Qt creator</h4><p><em>linux 可以说天生就适合程序元做开发的，各种比 windows 更加清晰，且基本上主流的 IDE 都可以找到对应的版本，这边就不详细介绍了。</em></p>
<blockquote>
<h2 id="私人定制："><a href="#私人定制：" class="headerlink" title="私人定制："></a>私人定制：</h2></blockquote>
<p>私人订制主要是基于以上的系统和 GUI，为了完成更好的体验效果和方便操作，所以个人增加了一些小功能。</p>
<h4 id="输入法，Caps-Lock-与右-Ctrl-互换（有相关详细文章）"><a href="#输入法，Caps-Lock-与右-Ctrl-互换（有相关详细文章）" class="headerlink" title="输入法，Caps_Lock 与右 Ctrl 互换（有相关详细文章）"></a>输入法，Caps_Lock 与右 Ctrl 互换（有相关详细文章）</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">remove Lock = Caps_Lock</div><div class="line">remove Control = Control_R</div><div class="line">keysym Control_R = Caps_Lock</div><div class="line">keysym Caps_Lock = Control_R</div><div class="line">add Lock = Caps_Lock</div><div class="line">add Control = Control_R</div></pre></td></tr></table></figure>
<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效，每次开机启动系统会自动加载.Xmodmap，无需相关设置。</p>
<h4 id="github-网站可以同时使用-ssh-和-VPN（有相关详细文章）"><a href="#github-网站可以同时使用-ssh-和-VPN（有相关详细文章）" class="headerlink" title="github 网站可以同时使用 ssh 和 VPN（有相关详细文章）"></a>github 网站可以同时使用 ssh 和 VPN（有相关详细文章）</h4><p><code>sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1</code> 命令作用主要是过滤部分IP地址，让他们直接从路由器网关发送，而不从 VPN 上面走，通过上面 ifconfig 可以看到本机被路由器分配的ip地址为 192.168.18.60，而 eno1 为计算机在访问外网中的实体网卡。通过谷歌搜索网站查看到 github 实际推送的ip地址为： 192.30.252.0/22</p>
<h4 id="关闭笔记本中的触摸板（有相关详细文章）"><a href="#关闭笔记本中的触摸板（有相关详细文章）" class="headerlink" title="关闭笔记本中的触摸板（有相关详细文章）"></a>关闭笔记本中的触摸板（有相关详细文章）</h4><ul>
<li>sudo rmmod psmouse    这个是禁用触摸板</li>
<li>sudo modprobe psmouse 这个是启用触摸板</li>
</ul>
<h4 id="gnome-下调网络管理小控件"><a href="#gnome-下调网络管理小控件" class="headerlink" title="gnome 下调网络管理小控件"></a>gnome 下调网络管理小控件</h4><p>ubuntu 的 GUI 在状态栏提供了一个网络管理的小工具，这边如果使用 awesome 可使用 nm-applet 命令将该工具打开，可以每次开机时自动启动该命令。</p>
<hr>
<p><em>国外的不少软件基本上都有 linux 版本的，如 skype，teamview 等等，这边国内人毕竟不常用就不详细介绍了。linux下向来不缺少优秀的办公学习开发类软件，很多软件都是开源项目，需要大家共同去维护，只要你需要，想得到的功能，基本都可以在网上找到。这边推荐可以阅读很多年前的一篇文章<a href="http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html" target="_blank" rel="external">完全用Linux工作-王垠</a>。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html" target="_blank" rel="external">http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html</a><br><a href="https://awesome.naquadah.org" target="_blank" rel="external">https://awesome.naquadah.org</a><br><a href="http://www.hahack.com/tools/awesome/" target="_blank" rel="external">http://www.hahack.com/tools/awesome/</a><br><a href="https://www.gitbook.com/book/voluong/awesome-linux-software/details" target="_blank" rel="external">https://www.gitbook.com/book/voluong/awesome-linux-software/details</a><br><a href="https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/" target="_blank" rel="external">https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/</a></p>
</blockquote>
<hr>
<p>To be continued…</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用指令详解]]></title>
      <url>http://noparkinghere.win/2016/07/11/2016/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>用git这个版本控制器也有一段时间了，但奈何一直停留在初浅的使用阶段，对诸如：分支，远程库，log，reflog，pull，clone等命令一直无法清晰的认识，仅仅是简单的add，commit，push，出了问题再查找。<br>始终无法串接成自有的知识体系，git 作为当下最流行的版本控制器，不得不说我对她真是既爱又恨，喜欢她的小巧高效功能强大；恨上手困难，虽然也有了一些简单易懂的教程，但在在实际使用时，始终不能形成自己的知识体系，原因可能还是项目中实际用的过少，这篇文章，会花一段时间，详细的介绍git的大概工作过程，对一些常用命令精简的介绍，然后从我个人的角度来认识git，总结自己的经验。*</p>
<a id="more"></a>
<p><strong>这篇文章的过程意在记录自己使用git的学习经历，并不断的总结推荐一些良好的配置以及相关软件。</strong></p>
<h3 id="GIT介绍："><a href="#GIT介绍：" class="headerlink" title="GIT介绍："></a>GIT介绍：</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<h4 id="版本控制器介绍："><a href="#版本控制器介绍：" class="headerlink" title="版本控制器介绍："></a>版本控制器介绍：</h4><p>版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。这种方法是工程图（engineering drawings）维护（maintenance）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推等等。</p>
<h4 id="GIT特点："><a href="#GIT特点：" class="headerlink" title="GIT特点："></a>GIT特点：</h4><p><em>GIT采用分支的结构形式来记录所有文本的修改，可以看出分支和指针是git的核心，git因为指针的高速切换而高效。所有的分支名都是指针，且该指针无条件的指向这条分支的最末端，例如：master指针永远指向master这条分支的最后一个节点，而HEAD指针则指向的是当前位置，即用户目前所在的工作位置。在git的工作过程中最主要使用的是：add,commit,log,checkout这几个命令，而诸如reflog，reset等其实用的并不算多，如果有远程库的话还需要注意pull,push,remote。</em></p>
<h3 id="常用GIT指令："><a href="#常用GIT指令：" class="headerlink" title="常用GIT指令："></a>常用GIT指令：</h3><ul>
<li><p>git add filename:将相关文件加入到暂存区stage中，注意有新文件的话，add步骤不能少。如果是一个人做的项目，一般如果整个项目加入可以使用git add . 或者git add * 。</p>
</li>
<li><p>git commit -m “commment”：git的版本提交，执行完这步骤，你就完成了版本的创建提交了，也是最常用的步骤。<em>建议：使用git commit -m 即可，去配置文件中修改editor，这样可以调用如vim之类的编辑器，否则备注写起来麻烦，且字数有限制。</em></p>
</li>
<li><p>git branch：查看分支结构，git的颇有c语言和数据结构的风格，整个git的版本控制，类似于一颗数，可以不断创建新的分支，然后分支名称类似于一个tag指针，始终指向分支的末尾处，而head这个指针指向的地方就是当前你所能看到的处在的版本位置，<strong>严格的来说并不是指向当前，而是上一个提交了的版本的位置，当前如果做了一些修改，而没去提交，则使用reset会回到上一个提交的版本，修改的内容会丢失</strong>。</p>
</li>
<li><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对改版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>
</li>
<li><p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留。</p>
</li>
<li><p>git merge “branchname”：将两个分支进行合并，也是比较常用的操作，如果没有文件冲突，一般git会快速自动合并，如果有冲突，会需要你进行比较手动修改冲突，合并的过程是当前HEAD指向的分支名，会跳转到branchname的位置。</p>
</li>
<li><p>git branch -d dev：合并分支后，可以将被合并了的分支号删除。</p>
</li>
<li><p>git tag ：这个也是个比较有用的方法，毕竟版本号是一大串随机数字，即便只要输入前4个，你也很难记得，对某个特别的版本加入tag标签名，之后可以直接使用git checkout tagname来指向该版本。</p>
</li>
<li>git diff : 将当前所有状态同指令后面对应的版本状态进行比较。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/265643011.jpg" alt=""></p>
<h4 id="简述分支策略："><a href="#简述分支策略：" class="headerlink" title="简述分支策略："></a>简述分支策略：</h4><p><strong>在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ul>
<li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>
<li>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</li>
<li>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>
</ul>
<p><strong>团队合作示意图：</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png" alt=""></p>
<blockquote>
<p>参考链接：<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href="http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_" target="_blank" rel="external">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）回车、换行、和文件末尾空行]]></title>
      <url>http://noparkinghere.win/2016/07/11/2016/2016-07-11-%EF%BC%88%E8%BD%AC%EF%BC%89%E5%9B%9E%E8%BD%A6%E3%80%81%E6%8D%A2%E8%A1%8C%E3%80%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE%E7%A9%BA%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h2 id="回车和换行"><a href="#回车和换行" class="headerlink" title="回车和换行"></a>回车和换行</h2><p>回车 (Carriage Return) 和换行 (Line Feed) 的区别，<a href="http://stackoverflow.com/questions/1761051/difference-between-n-and-r" target="_blank" rel="external">这里</a>有一个历史原因可参考：</p>
<blockquote>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。</p>
</blockquote>
<p>发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：</p>
<ul>
<li>Unix 系统里，每行结尾只有”&lt;换行&gt;”，即 “\n”</li>
<li>Windows 系统里面，每行结尾是”&lt;回车&gt;&lt;换行&gt;”，即 “\r\n”</li>
<li>在老的 Mac 系统里，每行结尾是”&lt;回车&gt;”，即 “\r”</li>
</ul>
<p>我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：</p>
<pre><code>//源文件内容
hello
hello2

//二进制内容
0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2
</code></pre><p>同样在 Mac 下用 Vim 新建一个：</p>
<pre><code>//源文件内容
hello
hello2

//二进制内容
0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.
</code></pre><p><code>0a</code>是 LF 的 ASCII 编码, <code>0d</code>是 CR 的 ASCII 编码。区别很明显了</p>
<ul>
<li>Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识 <code>\r\n</code>，也就是 <code>0d0a</code></li>
<li>Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 <code>^M</code>，(不是两个字符组成的)</li>
</ul>
<a id="more"></a>
<h2 id="文件末尾空行"><a href="#文件末尾空行" class="headerlink" title="文件末尾空行"></a>文件末尾空行</h2><p><a href="https://zh.wikipedia.org/zh-sg/POSIX" target="_blank" rel="external">POSIX</a>对行的<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206" target="_blank" rel="external">定义</a>如下：</p>
<blockquote>
<p>3.206 Line</p>
<p>A sequence of zero or more non- <newline\> characters plus a terminating <newline\> character.</newline\></newline\></p>
<p>行是由0个或者多个非 “换行” 符的字符组成，并且以 “换行” 符结尾。</p>
</blockquote>
<p>这样做有什么好处呢，举个例子：</p>
<pre><code>//hello.c
#include head.h
print(&apos;hello&apos;)

//world.c
#include tail.h
print(&apos;hello&apos;)
</code></pre><p>如果这两个文件都按 POSIX 规范来写， 在<code>cat *.c</code>之后，是没有问题的：</p>
<pre><code>//cat.c

#include head.h
print(&apos;hello&apos;)
#include tail.h
print(&apos;hello&apos;)
</code></pre><p>如果缺少最后一行的换行符（如 Windows 文件那样的定义），<code>cat</code>之后，就有问题了：</p>
<pre><code>//error.c

#include head.h
print(&apos;hello&apos;)#include tail.h
print(&apos;hello&apos;)
</code></pre><p>所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。</p>
<p>不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把<code>\n</code>的当做了行之间的分隔符，于是文件最后一行的<code>\n</code>就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。</p>
<h2 id="No-new-line-at-end-of-file"><a href="#No-new-line-at-end-of-file" class="headerlink" title="\ No new line at end of file"></a>\ No new line at end of file</h2><p>基于上面的原因，再去看 git diff 的<code>\ No new line at end of file</code>信息，就很好解释了。</p>
<p>各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的<code>0a</code>，那么对于 diff 程序来说，这当然是不可忽略的，但因为<code>0a</code>是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：</p>
<p><code>\ No new line at end of file</code></p>
<p>各编辑器也有相应的办法去解决这个问题，比如 Sublime，在<code>Default/Preferences.sublime-settings</code>中设置：</p>
<pre><code>// Set to true to ensure the last line of the file ends in a newline
// character when saving
&quot;ensure_newline_at_eof_on_save&quot;: true,
</code></pre><p>所以，请遵守规范。</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stm32F439案例汇总]]></title>
      <url>http://noparkinghere.win/2016/07/11/2016/2016-07-11-%E7%A5%9E%E5%B7%9Estm32%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><em>使用神州开发板，stm32F439芯片，但由于某种原因，配备资料(尤其是案例)并不齐全，且2014年之后相关网站也暂停了访问<br>本工程目的，只要是深入学习研究这块芯片，通过参考其他M4内核的历程，将这块开发板的相关案例完善，同时去除原历程中<br>模糊，难懂冗余的案例，尽量做到代码规范，案例可取，便于进一步的学习研究。</em></p>
<blockquote>
<p>www.armjishu.com(无法访问)</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用芯片为stm32F439IG，市面基于这块M4内核的st芯片比较少，一般多为407</li>
<li>烧录工具位jlink或ulink，正常情况下为jlink</li>
<li>开发板的原理图可见根目录，该开发板可以在某宝找到。</li>
</ul>
<a id="more"></a>
<h3 id="案例列表"><a href="#案例列表" class="headerlink" title="案例列表"></a>案例列表</h3><ul>
<li>实验0 Template工程模板</li>
<li>实验1 跑马灯</li>
<li>实验2 蜂鸣器</li>
<li>实验3 按键和外部中断</li>
<li>实验4 看门狗（独立和窗口）</li>
<li>实验5 待机唤醒</li>
<li>实验6 串口通讯（232和485）</li>
<li>实验7 定时器中断（含有RTC，SYSTICK，TIM）</li>
<li>实验8 PWM输出和输入捕获</li>
</ul>
<h3 id="注意说明"><a href="#注意说明" class="headerlink" title="注意说明"></a>注意说明</h3><h3 id="详细地址"><a href="#详细地址" class="headerlink" title="详细地址"></a>详细地址</h3><blockquote>
<p><a href="https://github.com/noparkinghere/stm32_test" target="_blank" rel="external">https://github.com/noparkinghere/stm32_test</a></p>
</blockquote>
<hr>
<p><em>未完待续</em></p>
]]></content>
      
        <categories>
            
            <category> 嵌入式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MCU </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MDK5安装及配置]]></title>
      <url>http://noparkinghere.win/2016/07/11/2016/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="MDK简介"><a href="#MDK简介" class="headerlink" title="MDK简介"></a>MDK简介</h3><blockquote>
<p>Keil MDK，也称MDK-ARM，Realview MDK、I-MDK、uVision4 等。Keil C51 是美国 Keil Software 公司出品的 51 系列兼容单片机 C 语言软件开发系统，被 ARM（英国）公司收购，作为在 51 单片机时代相当流行的一个软件。</p>
</blockquote>
<p><em>而如果你是一个嵌入式工作者，尤其是主要使用ST或者飞思卡尔等工业产品为主的芯片，在国内的话可以说你的选择要么是keil要么就是IAR。keil作为一个IDE来说编辑功能缺失恨薄弱，但是硬件调试能力还是毋容置疑的，而keil配置简单容易上手，该有的功能操作也都具备，本文主要讲述作者的一些keil配置及习惯。</em></p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>界面友好，上手简单</li>
<li>被ARM公司收购，编辑ARM相对友好，仿真功能十分强大</li>
<li>官方提供各种芯片的启动代码，仿真库</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>自带编辑功能薄弱</li>
<li>不支持/极少支持第三方插件</li>
</ul>
<a id="more"></a>
<h3 id="KEIL-5配置"><a href="#KEIL-5配置" class="headerlink" title="KEIL 5配置"></a>KEIL 5配置</h3><h4 id="界面配置"><a href="#界面配置" class="headerlink" title="界面配置"></a>界面配置</h4><ul>
<li>Keil 5及之后的版本缺少相关的原件类库，需要额外安装。可以从官网下载芯片库</li>
<li><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture1.png" alt=""></p>
</li>
<li><p>Keil 4.6及之后的版本对中文字体支持依旧很差，通过修改成GB2312的简体中文编码，可以让注释的中文字体不会拆分，但默认的Courier New - 10不能够良好的显示所有字体，直接通过修改GB2312会形成字体锯齿化，缺少虚化的过渡。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture2.png" alt=""></p>
<ul>
<li>通过尝试多种字体以及添加fonts文件，发现要么中文字体显示不错，英文不行，要么英文显示不错，中文不行，很多情况代码字体偏大或者偏小，最终个人觉得较好的配置界面如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture5.png" alt=""></p>
<ul>
<li>如果需要修改背景颜色，需要对c/c++ Editor files 下的text，number等所有的background进行修改。配置如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture7.png" alt=""></p>
<ul>
<li>光标指向向的颜色修改如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture8.png" alt=""></p>
<ul>
<li>菜单栏view下面的所有工具栏颜色是跟随系统变化的，可以采用如果腾讯软件管家之类的工具开启护眼模式。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture9.png" alt=""></p>
<h4 id="KEIL建立单片机工程文件注意事项：："><a href="#KEIL建立单片机工程文件注意事项：：" class="headerlink" title="KEIL建立单片机工程文件注意事项：："></a>KEIL建立单片机工程文件注意事项：：</h4><ul>
<li>注意KEIL的配置详细可以参考“Keil 5配置”文档。</li>
<li>工程文件建立目录结构需清晰可参考下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture10.png" alt=""></p>
<p>该工具条中主要存放的是项目中需要使用到的C文件（注意并不包含任何头文件），只有加入这个工具中得.c文件才会进行项目的编译。<br>下面仅作参考，根据个人的习惯而定制，相关存放内容说明：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">CORE</span>：存放<span class="selector-tag">SOC</span>相关代码，包含<span class="selector-class">.s</span>启动文件，<span class="selector-tag">CMSIS</span>的部分<span class="selector-class">.c</span>文件以及<span class="selector-tag">CPU</span>相关的底层核心文件</div><div class="line"><span class="selector-tag">FWLIB</span>：固件库，厂方提供的标准固件库，用于调用外设的函数。</div><div class="line"><span class="selector-tag">BSP</span>：操作系统与芯片的中间层</div><div class="line"><span class="selector-tag">USER</span>：用户自己写的函数文件，包括<span class="selector-tag">main</span>和用户定制的功能函数</div><div class="line"><span class="selector-tag">OS</span>：具体名称为操作系统名称，可以是<span class="selector-tag">UCOS</span>，<span class="selector-tag">uclinux</span>等等嵌入式操作系统</div><div class="line"><span class="selector-tag">README</span>：整个工程的相关项目说明</div></pre></td></tr></table></figure></p>
<ul>
<li>新建工程重点配置Define和Include Paths，如下图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture12.png" alt=""></p>
<p><em>需强调的是 Define 中的选项不能少，这些选项一般都是如：stm32f10x.h（芯片寄存器定义文件） 或者内核中的宏定义，可以用来进行芯片选型等操作，可以用查找工具全局查找，会发现相关的 #ifdef 语句。本质上面来说，Define 加入的内容就相当于在 c 文件中手动的写入 #define xxx 语句。<br>Include Paths 中定义的都是头文件所在的路径，注意是头文件的路经，这边 ..\CMSIS 等都是使用 windows 下相对路径的格式，如果头文件不在 Include Paths 下的路经中，则编译器无法找到相关头文件，会编译失败。</em></p>
<p><strong>其他注意点：</strong><br>C99Mode如果不勾选，默认可能会使用C89的编译器，一些如 bool 类型或者定义申明可能会无法编译，C89对老版本兼容性更好，但C99加入的许多新特性让编程更“合理”。具体根据自己项目需求而定。</p>
<ul>
<li>Debug 中进行相关模拟仿真下载器设置。一定要记得仿真设置 Reset and Run</li>
</ul>
<p>有仿真器的话，使用右边的仿真器选项，没有的话，则使用模拟。仿真器种类繁多，最常用的比如 JLINK，和 keil ulink 之类的，一些公司也会推出自己的仿真器，如silabs uda等</p>
<p><em>最好勾选setting-&gt;flash download下的Reset and Run，这样可以无需重新上电即可运行程序。</em></p>
<p>JLink 在连接 STM32F439 时，在勾选或者不勾选 Verify Code Download 时可能会出现下载错误，可能会是板子设计缺陷或者JLink版本过高。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture11.png" alt=""></p>
<ul>
<li><p>Utilities：将Use Debug Driver勾选或者手动设置成相同的调试器。</p>
</li>
<li><p>移植程序注意重点：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Project 的 USER 中一定要把 .c 源文件添加进去 </div><div class="line">FWLIB一定要记得添加 stm32f10x_xxx 相关的外设库文件</div><div class="line">Stm32xxx_conf.h 中需取消相关注释</div><div class="line">用户定义的.h头文件需加入 <span class="comment">#include "stm32f10x.h"，且不需要加入 Stm32xxx_conf.h 因为该头文件已经在 #include "stm32f10x.h" 中包含了。</span></div><div class="line">添加用户自定义 .c 文件时，记得把其头文件写入到 main 函数所在文件中</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://www.jb51.net/os/windows/211837.html" target="_blank" rel="external">http://www.jb51.net/os/windows/211837.html</a><br><a href="http://comm.chinaaet.com/adi/blogdetail/32471.html" target="_blank" rel="external">http://comm.chinaaet.com/adi/blogdetail/32471.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 配置推荐 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub_Page页面无法更新]]></title>
      <url>http://noparkinghere.win/2016/07/11/2016/2016-07-11-github-page%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<h3 id="详细问题："><a href="#详细问题：" class="headerlink" title="详细问题："></a>详细问题：</h3><ul>
<li>文章会在github的工程目录中出现，但github page中首页和存档都无法显示。</li>
<li>仔细查看过套用的html等模板，未能发现有问题。</li>
<li>连续多次都是某一次推送下，突然问题就解决了。</li>
<li>通过github page提供的jekyll服务进行更新文章时，经常会出现文章已经上传到了github的远程库中，但github page却无法显示内容出来，这样的问题出现了很多差，但不断的上传或者某一次传输一个文章，突然就成功了。</li>
</ul>
<a id="more"></a>
<h3 id="具体原因："><a href="#具体原因：" class="headerlink" title="具体原因："></a>具体原因：</h3><p>GitHub_Page 使用的是jekyll服务生成page页面的。由于jekyll 3（github目前的jekyll版本）默认对于认定为”未来”的post，是不生成的，详情可以参考<a href="http://jekyllrb.com/docs/upgrading/2-to-3/#future-posts" target="_blank" rel="external">Future posts - Jekyll</a>。这极有可能与github服务在美国有关,本人使用的是VPN在美国，不知道是否对此也有影响。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul>
<li>网上说可以修改feed.xml文件，具体看参考链接。（本人没有实验成功）</li>
<li>我使用的方法改写时间：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">layout: <span class="string">"post"</span></div><div class="line">title: <span class="string">"GitHub_Page页面无法更新"</span></div><div class="line">tags: <span class="string">"问题总结"</span></div><div class="line">category: <span class="string">"read"</span></div><div class="line">date: <span class="string">"2016-07-11 18:00"</span></div><div class="line">---</div><div class="line">将date中的时间改写，可以将18:00改为1:00，这样也能够有效解决问题。</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="https://segmentfault.com/q/1010000004584816" target="_blank" rel="external">https://segmentfault.com/q/1010000004584816</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chrome使用技巧]]></title>
      <url>http://noparkinghere.win/2016/07/10/2016/2016-07-10-chrome%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p><em>使用chrome虽然有好些年了，但其中的技巧种种，真的明白的并不多，本文着重总结chrome在日常使用中的一些快捷键，插件以及各种小技巧。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-10-chrome使用技巧/1.jpg" alt=""></p>
<p>Chrome其实有很多版本：</p>
<ul>
<li>Stable Channel（稳定版／正式版）： 这个版本是大部分人安装的普通版，为追求稳定的普通用户使用。</li>
<li>Beta Channel（测试版）： 正式版发布前的公开测试所用，版本上的新功能不会作太多修改，主要为安全上的测试，可能会存在不稳定情况，适合喜欢较稳定又可尝鲜的朋友下载使用。本版本安装后会覆盖稳定版。<br>其他版本：Dev Channel（开发版），Canary Build（构造版）这边不做详细说明。</li>
</ul>
<p>Chromium 是 Google 为发展自家的浏览器 Google Chrome 而做的开源项目，所以 Chromium 相当于 Google Chrome 的工程版或称实验版（尽管Google Chrome自身也有β版阶段），新功能会率先在 Chromium 上实现，待验证后才会应用在 Google Chrome 上。这边可以认为 Chromium 类似于谷歌发型的公版安卓系统，各家厂商，可以将 Chromium 修改定制，然后放入到自家的浏览器中。目前国内的主流浏览器大都是基于 Chromium 开发，同时兼容 IE 内核，如：360极速，遨游，猎豹，世界之窗极速版等等。</p>
<a id="more"></a>
<h3 id="基本快捷键："><a href="#基本快捷键：" class="headerlink" title="基本快捷键："></a>基本快捷键：</h3><ul>
<li>Ctrl+N 打开新窗口</li>
<li>Ctrl+T 打开新标签页</li>
<li>Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件</li>
<li><strong>Ctrl+Shift+N 在隐身模式下打开新窗口</strong></li>
<li><strong>Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</strong></li>
<li>Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口</li>
<li>Ctrl+H 查看”历史记录”页</li>
<li>Ctrl+J 查看”下载”页</li>
<li><strong>Shift+Escape 查看任务管理器</strong></li>
<li>F5 重新加载当前页</li>
<li>Ctrl+F 打开”在网页上查找”框</li>
<li>Ctrl+U 查看源代码</li>
<li>Ctrl+D 将当前网页加入书签</li>
<li><strong>Ctrl+0 将网页上的所有内容都恢复到正常大小</strong></li>
<li>ctrl+shift+T：这个快捷键组合可以打开你上次关闭的 tab 或者上次关闭窗口里面所有的 tab。</li>
</ul>
<p><strong><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="external">更加详细的快捷键参考地址</a></strong></p>
<h3 id="扩展插件："><a href="#扩展插件：" class="headerlink" title="扩展插件："></a>扩展插件：</h3><p>chrome 的强大之处就在于它丰富的插件，本人 chrome 常用的插件有大概 50 多个，每次更换电脑时，chrome 都会自动帮你同步插件，但注意很多插件有隐藏功能会可能修改你的一些默认配置。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-10-chrome使用技巧/2.png" alt=""></p>
<h4 id="必备插件："><a href="#必备插件：" class="headerlink" title="必备插件："></a>必备插件：</h4><ul>
<li>广告拦截：adblock plus 和 adblock pro，可以手动添加拦截，可以自动拦截，两个插件基本可以拦截腾讯视频的广告，但很多其他网站上的广告拦截不了。小黄瓜视频广告拦截，这个貌似可以拦截绝大多数的国内视频广告，但也存在一些副作用。</li>
<li>infinity new tab： 相当好用的一款tab插件，提供了不少针对chrome的扩展功能，重新规划了书签，扩展入口，历史记录等功能。Momentum：同infinity new tab类似，界面美观，但功能不够强大。</li>
<li>crxMouse Chrome Gestures：一款必备的定制手势的插件</li>
<li>Google Translate：一个小插件，用户体验不够好，提供了太多语言的选项，往往常用不是特别好，没有语言直接切换功能。翰林英汉双解词典：功能强大较多，但手动查找叫繁琐。</li>
<li>惠惠购物助手：国内可以直观的购物比价的一个插件</li>
<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>
<li>Checker Plus for Gmail：很优秀的一款gmail邮箱插件，可以只支持gmail，其他邮箱并没有一款如此优秀的插件。</li>
<li>有道云笔记网页剪报：快速将内容转入有道云笔记中。</li>
<li>Google Docs，sheet，slides：谷歌的office套件，基于web开发的，无须本地下载，功能齐全，线上可以实行多人同时阅览修改。</li>
<li>wechat： 可以登陆微信的一个app，版本太多，但只有个别几个比较好用。</li>
<li>internet-download-manager： 嫌弃 chrome 默认下载器功能太少，占用地方的话，可以使用这个插件。</li>
</ul>
<h4 id="Github插件"><a href="#Github插件" class="headerlink" title="Github插件"></a>Github插件</h4><ul>
<li>GitHub Mate 这个插件使得单文件下载更加轻松，并且还提供了一些其他功能。</li>
<li>Isometric Contributions 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换。</li>
<li>Sourcegraph Chrome 扩展允许你像使用一个很好的 IDE 那样浏览源代码。它为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接。 </li>
<li>ZenHub 是一个 Github 的本地项目管理工具，可以无缝的集成。</li>
<li>GitHub Linker 是一个可以链接到 NPM、bower、Composer &amp; Duo 依赖等项目主页的 Chrome 插件。</li>
<li>Github.Expandinizr 满屏显示项目</li>
<li>Avatars for Github 自动的为 GitHub 新闻和 Feed 页面添加显示用户头像。</li>
<li>Octotree 会为 Github 页面添加侧边栏，在浏览器中显示项目的目录结构，对于那些经常需要在 GitHub 阅读源代码的人非常有用。</li>
</ul>
<h4 id="图像插件"><a href="#图像插件" class="headerlink" title="图像插件"></a>图像插件</h4><ul>
<li>Fatkun图片批量下载：可以将一个或多个页面中的所有图片打包批量下载。对于</li>
<li>capture page，Capture, Explain and Send Screenshots：多功能的网页截图软件，所要的网页截图功能，这两款插件基本上全覆盖。</li>
<li>Pixlr Editor：在线版的photoshop，不解释。</li>
<li>ColorZilla：页面取色插件，速度快，功能强大。</li>
<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>IP-Address：可以显示IP地址的小插件。</li>
<li>Proxy SwitchyOmega：科学上网必备插件，可以同 shadowsocks 相互配合使用（可以参考我另外关于 shadowsocks 的文章）。</li>
<li>Marxico：书写markdown的一款chrome工具，可以本地使用，但不是免费，虽然界面美观，但大都基于web。</li>
</ul>
<h4 id="chrome-插件推荐网站"><a href="#chrome-插件推荐网站" class="headerlink" title="chrome 插件推荐网站"></a>chrome 插件推荐网站</h4><blockquote>
<p><a href="http://www.cnplugins.com/" target="_blank" rel="external">http://www.cnplugins.com/</a><br><a href="http://chromecj.com/" target="_blank" rel="external">http://chromecj.com/</a></p>
</blockquote>
<h3 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a>小技巧：</h3><ul>
<li>在网页标签处，单击鼠标中间键即可关闭网页，国内用户大都喜欢双击关闭页面，但大多数浏览器都支持中击关闭页面</li>
<li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容,  Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容，但一般<strong>按住 ctrl 键转动鼠标滚轮实现页面缩放</strong>, <strong>Ctrl+0  将网页上的所有内容都恢复到正常大小</strong>。</li>
<li>地址栏输入错误内容后，每次提示错误内容很麻烦，可以如下操作，地址栏中选中你要删除的网址，按 shift+delete 就可以删除 chrome 浏览器地址栏输入过的记录，以免每次都自动补全错误地址。</li>
<li>Ctrl+Shift+N 在隐身模式下打开新窗口，隐身模式，是不会保存任何历史等记录的，默认也不会加载任何插件，但可以通过扩展插件手动设置某些插件在隐身下工作。</li>
<li>chrome批量删除书签:1.网址栏输入：<code>chrome://bookmarks</code> 2.<code>ctrl + A Delete</code>，但是注意这种方法仅仅删除了本地的书签，服务器的书签仍然存在，一单登陆账户仍然会同步过来。</li>
<li>多台电脑数据重复冗余时，可以删除chrome的远程同步内容，打开设置，高级同步中点击了解更多，会出来chrome帮助网址，仔细阅读可以发现<a href="https://support.google.com/chrome/answer/1181035?hl=en&amp;ref_topic=3421437" target="_blank" rel="external">网址</a>，可以清空云端设置，然后整理好本地内容，登陆账户重新上传本地同步。</li>
<li>地址栏就是个计算器，输入你需要计算的公式（无需回车），下方直接出结果，非常方便，常用，输入方式<strong>参考一般编程的公式输入方式</strong>。</li>
<li>F12 按下后 ，刷新按钮可以右键或长按来选择刷新方式，普通刷新、硬性刷新和清空缓存硬性刷新。</li>
<li>地址栏输入某网址，按 tab 键，对于像 baidu zhihu 这种自带检索能力的网址，直接可以完成站内检索，同样支持这样做的网址还有，taobao，优酷，土豆，stackoverflow，github等，似乎有搜索功能的知名网站都可以。</li>
<li>删除某网站保留的账户名和密码：打开设置-&gt;显示更多设置-&gt;管理密码，在以保存密码中搜索你需要删除的网站，最后将保存信息删除。</li>
</ul>
<h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><p>chrome 的强大毋容置疑，与其说它是一个浏览网页的小工具，我们倒不如说它自己本身就是一个操作系统（只不过暂时依赖下层操作系统），事实上 Google 也确实基于网络应用开发了 chrome OS （一个完全独立的操作系统）。chrome 自己建立了完整的生态体系，各种强大的设置应用商城等等层出不穷，我们可以看做是一个网络操作系统，那么到底 chrome 隐藏了多少小秘密?打开( chrome://chrome-urls/ )查看chrome内部页面吧。</p>
<p>地址栏输入：chrome://chrome-urls/ 即可显示 Chrome URLs 列表，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">List of Chrome URLs</div><div class="line"></div><div class="line">chrome://accessibility</div><div class="line">chrome://appcache-internals</div><div class="line">chrome://apps</div><div class="line">chrome://blob-internals</div><div class="line">chrome://bookmarks</div><div class="line">chrome://cache</div><div class="line">chrome://chrome</div><div class="line">chrome://chrome-urls</div><div class="line">chrome://components</div><div class="line">chrome://crashes</div><div class="line">chrome://credits</div><div class="line">chrome://devices</div><div class="line">chrome://dns</div><div class="line">chrome://downloads</div><div class="line">chrome://extensions</div><div class="line">chrome://flags</div><div class="line">chrome://flash</div><div class="line">chrome://gcm-internals</div><div class="line">chrome://gpu</div><div class="line">chrome://<span class="built_in">help</span></div><div class="line">chrome://histograms</div><div class="line">chrome://<span class="built_in">history</span></div><div class="line">chrome://indexeddb-internals</div><div class="line">chrome://inspect</div><div class="line">chrome://invalidations</div><div class="line">chrome://ipc</div><div class="line">chrome://media-internals</div><div class="line">chrome://memory</div><div class="line">chrome://memory-internals</div><div class="line">chrome://nacl</div><div class="line">chrome://net-internals</div><div class="line">chrome://newtab</div><div class="line">chrome://omnibox</div><div class="line">chrome://plugins</div><div class="line">chrome://policy</div><div class="line">chrome://predictors</div><div class="line">chrome://<span class="built_in">print</span></div><div class="line">chrome://profiler</div><div class="line">chrome://quota-internals</div><div class="line">chrome://serviceworker-internals</div><div class="line">chrome://settings</div><div class="line">chrome://signin-internals</div><div class="line">chrome://stats</div><div class="line">chrome://sync-internals</div><div class="line">chrome://system</div><div class="line">chrome://terms</div><div class="line">chrome://tracing</div><div class="line">chrome://translate-internals</div><div class="line">chrome://user-actions</div><div class="line">chrome://version</div><div class="line">chrome://view-http-cache</div><div class="line">chrome://webrtc-internals</div><div class="line">chrome://webrtc-logs</div><div class="line">For Debug</div><div class="line"></div><div class="line">The following pages are <span class="keyword">for</span> debugging purposes only. Because they crash or hang the renderer, they are not linked directly; you can <span class="built_in">type</span> them into the address bar <span class="keyword">if</span> you need them.</div><div class="line"></div><div class="line">chrome://crash</div><div class="line">chrome://<span class="built_in">kill</span></div><div class="line">chrome://hang</div><div class="line">chrome://shorthang</div><div class="line">chrome://gpuclean</div><div class="line">chrome://gpucrash</div><div class="line">chrome://gpuhang</div><div class="line">chrome://ppapiflashcrash</div><div class="line">chrome://ppapiflashhang</div><div class="line">chrome://quit/</div><div class="line">chrome://restart/</div></pre></td></tr></table></figure>
<ul>
<li>chrome://flags/#overlay-scrollbars 重叠式滚动条，开启后滚动条会自动缩放带有动画效果。</li>
<li>保存网页本地阅读： 输入 <code>chrome://flags/</code> 然后开启 Save Page as MHTML 按照提示重启 chrome 之后右击网页保存即可。</li>
</ul>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html" target="_blank" rel="external">http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html</a><br><a href="http://zhidao.baidu.com/question/502291145.html" target="_blank" rel="external">http://zhidao.baidu.com/question/502291145.html</a><br><a href="http://www.igooda.cn/jzjl/201604061075.html" target="_blank" rel="external">http://www.igooda.cn/jzjl/201604061075.html</a><br><a href="http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html" target="_blank" rel="external">http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html</a><br><a href="https://www.zhihu.com/question/28531079?sort=created&amp;page=2" target="_blank" rel="external">https://www.zhihu.com/question/28531079?sort=created&amp;page=2</a><br><a href="https://www.zhihu.com/question/34682699" target="_blank" rel="external">https://www.zhihu.com/question/34682699</a><br><a href="http://www.cnblogs.com/constantince/p/4565261.html" target="_blank" rel="external">http://www.cnblogs.com/constantince/p/4565261.html</a><br><a href="https://www.zhihu.com/question/28531079" target="_blank" rel="external">https://www.zhihu.com/question/28531079</a><br><a href="http://www.ghacks.net/2012/09/04/list-of-chrome-urls-and-their-purpose/" target="_blank" rel="external">http://www.ghacks.net/2012/09/04/list-of-chrome-urls-and-their-purpose/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下的virtualbox安装配置]]></title>
      <url>http://noparkinghere.win/2016/07/07/2016/2016-07-07-linux%E4%B8%8B%E7%9A%84virtualbox%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h3><p>随着计算机技术的发展，硬件配置越来越高，跨平台软件，手机以及浏览器越来越强大，目前可以说<br>linux下除了大型游戏意外，其他的办公学习娱乐基本都可以解决，比如：</p>
<a id="more"></a>
<ul>
<li>购物可以电脑浏览，手机支付（很多win用户，估计也不怎么用u盾了）。</li>
<li>音乐可以使用百度，qq在线音乐。</li>
<li>至于编程等开发工具更是齐全。</li>
</ul>
<p>但仍然难免会有一些windows程序需要用户操心，个人主要需用使用的windows产品有：<br><em>迅雷，百度云，photoshop，illustrator，U盘系统制作工具等</em></p>
<p>解决办法主要有：</p>
<ul>
<li>wine提供windows的类库，是软件windows软件直接可以在linux上面运行</li>
<li>使用虚拟机，在linux上面虚拟一个windows xp出来，提供一定的硬件资源，运行需要使用的软件</li>
</ul>
<p><strong>这边我们选择虚拟机virtualbox，主要该软件开源小巧，且现在硬件强大，对资源的开销可以接收，外加wine向来不是太稳定，出现问题的几率高。</strong></p>
<h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><ul>
<li>ubuntu 16.04 终端输入： lsb_release -a</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>步骤如下：</p>
<ol>
<li>需要安装Oracle Virtualbox</li>
</ol>
<p>可以使用sudo apt-get install virutalbox 安装</p>
<p>也可以通过官网下载地址：<code>https://www.virtualbox.org/wiki/Downloads</code></p>
<p>安装增强包的方法介绍：<code>http://gaoke0820.blog.163.com/blog/static/21664965201332802833510/</code></p>
<ol>
<li>安装完之后，U盘识别</li>
</ol>
<p><em>如果如VirtualBox客户机挂载U盘中设置后，linux中还不能挂载u盘，而使用sudo启动virtualbox后里面的客户机可以挂载U盘，原因为 普通用户没有使用USB设备权限。</em></p>
<p>2.1 方法1：</p>
<p>让GUEST识别USB设备</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo gedit   /etc/fstab</div><div class="line"></div><div class="line">在末尾加上</div><div class="line"><span class="comment"># the USB group</span></div><div class="line"><span class="comment"># 对所有用户开放USB设备的读写权限</span></div><div class="line">none /proc/bus/usb usbfs devmode=666 0 0</div><div class="line">然后就可以使用的USB设备了。</div></pre></td></tr></table></figure>
<p><em>但是把USB设备的读写权限开放给所有用户的方式在一些情况下不太安全</em></p>
<p>2.2 方法2：</p>
<p>将用户名添加到vboxusers组,重启或注销后即可解决.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo adduser usrname vboxusers</div><div class="line"></div><div class="line">然后再输入：cat /etc/group |grep vboxusers</div><div class="line">这时可以看到显示：</div><div class="line">vboxusers:x:129:demon,hello</div></pre></td></tr></table></figure>
<p><em>该方法使用后，基本能够使用，但使用之前每次需要手动添加设备</em></p>
<p>2.3 方法3：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">增加用户组usbfs</div><div class="line"><span class="variable">$sudo</span> groupadd usbfs</div><div class="line"></div><div class="line">查看usbfs用户组的gid</div><div class="line">$ cat /etc/group | grep usbfs</div><div class="line">usbfs:x:1002:</div><div class="line"></div><div class="line">把当前用户增加到usbfs组</div><div class="line">sudo adduser demon usbfs</div></pre></td></tr></table></figure>
<p>为USB设备重新设置权限,编辑/etc/fstab文件，添加下面两行，注意你的gid可能不是1002</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> $   sudo gedit /etc/fstab</div><div class="line">在末尾加上</div><div class="line"><span class="comment"># 1002 is the USB group IDI</span></div><div class="line">none /proc/bus/usb usbfs devgid=1002,devmode=774 0 0</div></pre></td></tr></table></figure>
<p>重新启动后，应该就可以在客户机中使用USB设备了。</p>
<p>方法：插入一个USB设备后，如U盘、鼠标，右键点击虚拟机里右下脚的USB图标，选择已经识别的U盘，就可以正常使用了。<br>注意： 在客户机里使用USB设备前要先在主机里卸载。</p>
<p>﻿</p>
<ol>
<li>在virtualbox里启动USB控制器</li>
</ol>
<ol>
<li>打开虚拟机，这时在虚拟机的设备-分配USB设备中就可以看到USB设备了</li>
</ol>
<blockquote>
<p>相关参考：<br><a href="http://blog.csdn.net/rongyongfeikai2/article/details/21795741" target="_blank" rel="external">http://blog.csdn.net/rongyongfeikai2/article/details/21795741</a><br><a href="http://www.linuxidc.com/Linux/2012-01/52502.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-01/52502.htm</a><br><a href="http://xuantan.iteye.com/blog/1130808" target="_blank" rel="external">http://xuantan.iteye.com/blog/1130808</a><br><a href="http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php" target="_blank" rel="external">http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[github本地推送]]></title>
      <url>http://noparkinghere.win/2016/07/05/2016/2016-07-05-github%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/</url>
      <content type="html"><![CDATA[<h3 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h3><ul>
<li>ubuntu 16.04 终端输入： lsb_release -a</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>git 和 ssh</li>
</ul>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p><strong>github一般支持http和ssh两种传输协议（可能还有其他的，作为菜鸟暂时不作研究），而使用clone的时候，可以选择两者之一，生成地址，直接选用http的话，<br>不需要输入密码和验证，如果采用ssh则需要将上传到github上面的公钥和本地的私钥进行匹配，验证成功后才能进行相关一系列的操作。</strong></p>
<ul>
<li><p>安装git 和 ssh <code>sudo apt-get install git ssh</code></p>
</li>
<li><p>为了和Github的远程仓库进行传输，需要进行SSH加密设置。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"&#123;name@site.com&#125;"</span>    // 用你的邮箱替换&#123;name@site.com&#125;</div><div class="line">可以不输入其他信息，一直敲回车直到命令完成。</div><div class="line">这时你的用户目录下会出现名为.ssh 的文件夹（默认隐藏），点进去能看到 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa 是私钥，不能让怪人拿走， id_rsa.pub 是公钥，无需保密</div></pre></td></tr></table></figure>
<ul>
<li><p>登录Github，点击右上角头像下的Settings -&gt; SSH and GPG keys -&gt; New SSH key ,在title中输入名称，Key中输入公钥（id_rsa.pub中的所有内容）</p>
</li>
<li><p>终端下面设置git</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"&#123;name&#125;"</span>    // 用你的名字代替&#123;name&#125;</div><div class="line">git config --global user.email <span class="string">"&#123;name@site.com&#125;"</span>    // 用你的邮箱替换&#123;name@site.com&#125;</div></pre></td></tr></table></figure>
<ul>
<li>打开你需要下载目录，使用ssh协议远程下载你的项目</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> Documents</div><div class="line">git <span class="built_in">clone</span> git@github.com:xxx/yyy.git</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://playingfingers.com/2016/03/26/build-a-blog/#ssh" target="_blank" rel="external">http://playingfingers.com/2016/03/26/build-a-blog/#ssh</a><br><a href="http://www.yiibai.com/git/git_environment.html" target="_blank" rel="external">http://www.yiibai.com/git/git_environment.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下文件查找]]></title>
      <url>http://noparkinghere.win/2016/07/01/2016/2016-07-01-linux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>linux 使用 CLI 的情况下，如果要查找文件还是很方便的，本身提供了多个搜索查找工具，这边主要列出一般随系统自带的工具：”find”；”locate”；”whereis”；”which”；”type”，这几个工具，一般绝大多数 linux 发行版都会自带；linux 是一个小而美的系统，基于 linux 内核之上，肯定还有一些发行版或者个人会提供一些更加强大的检索工具，这边不做详细介绍。</p>
<h3 id="1-find"><a href="#1-find" class="headerlink" title="1. find"></a>1. find</h3><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。<br>find的使用格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class="line">&lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class="line">&lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class="line">&lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">find的使用实例：</div><div class="line">$ find . -name <span class="string">'my*'</span></div><div class="line">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class="line">$ find / -name <span class="string">'my*'</span> -ls</div><div class="line">搜索根目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class="line">$ find . -type f -mmin -10</div><div class="line">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure>
<p>注意：find 每次会遍历你索要搜索的路径，然后查找文件名，另外 find 后面如果直接跟文件名如： find . -name myfile 则只会查找文件名为 myfile 的文件，如果需要搜索 myfile1 等文件，则需要加入 * 通配符。</p>
<h3 id="2-locate"><a href="#2-locate" class="headerlink" title="2. locate"></a>2. locate</h3><p>locate 命令其实是 “find -name” 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<strong>先使用 updatedb 命令</strong>，手动更新数据库，ubuntu 下需要使用 sudo 才可以更新该数据库。</p>
<p>locate 相当于快速检索的 <code>find -name &quot;*name*&quot;</code> 写法，默认就带入模糊查找的功能，如果需要精准查找需要 <code>locate -b &#39;\NAME&#39;</code> man 文档中有详细描述。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">locate命令的使用实例：</div><div class="line">$ locate /etc/sh</div><div class="line">搜索etc目录下所有以sh开头的文件。</div><div class="line">$ locate ~/m</div><div class="line">搜索用户主目录下，所有以m开头的文件。</div><div class="line">$ locate -i ~/m</div><div class="line">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure>
<h3 id="3-whereis"><a href="#3-whereis" class="headerlink" title="3. whereis"></a>3. whereis</h3><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">whereis命令的使用实例：</div><div class="line">$ whereis grep</div></pre></td></tr></table></figure>
<h3 id="4-which"><a href="#4-which" class="headerlink" title="4. which"></a>4. which</h3><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">which</span>命令的使用实例：</div><div class="line">$ <span class="built_in">which</span> grep</div></pre></td></tr></table></figure>
<h3 id="5-type"><a href="#5-type" class="headerlink" title="5. type"></a>5. type</h3><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。<br>type命令的使用实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">type</span> <span class="built_in">cd</span></div><div class="line">系统会提示，<span class="built_in">cd</span>是shell的自带命令（build-in）。</div><div class="line">$ <span class="built_in">type</span> grep</div><div class="line">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class="line">$ <span class="built_in">type</span> -p grep</div><div class="line">加上-p参数后，就相当于<span class="built_in">which</span>命令。</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html</a><br><a href="http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm" target="_blank" rel="external">http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[u盘安装XP系统]]></title>
      <url>http://noparkinghere.win/2016/06/30/2016/2016-06-30-windowsXP%E7%BA%AF%E5%87%80%E7%89%88%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>如果仅需要优盘安装XP可以直接查看Windows XP安装部分</strong></p>
</blockquote>
<h3 id="1-Why-XP"><a href="#1-Why-XP" class="headerlink" title="1.Why XP?"></a>1.Why XP?</h3><p>windows XP 这个系统微软早已停止服务了，一般现在也不再会有人会想着安装这个系统了。作为已经安装过各种系统多次的人而言，老实说我也只有最初不太懂电脑的中学时候用过XP，自从09年win7出来后，就开始转战 win7 了，个人写这篇文章主要出于以下几种原因：</p>
<ul>
<li>这个系统相当稳定，占用资源很少，可以作为老旧机器的不二选择。</li>
<li>个人工作学习完全使用 Ubuntu 系统了，时不时会用 windows 平台下面的软件如：迅雷，百度云，photoshop 等，现在机器性能强劲，virtualbox 下的 xp 运行这些中小型软件完全没任何问题。</li>
<li>XP 安装与其他软件比较为特殊，通过文章的总结，下次便于参考。</li>
</ul>
<a id="more"></a>
<h4 id="windows-XP简介："><a href="#windows-XP简介：" class="headerlink" title="windows XP简介："></a>windows XP简介：</h4><p>Windows XP，是微软公司（Microsoft）推出的供个人电脑使用的操作系统，包括商用及家用的台式电脑等。Windows XP率先使用双列菜单，为之后的Windows 版本的开始菜单提供了基础。其名字 “XP” 的意思是英文中的 “体验（Experience）”，现已退役，如果你在结束支持后继续使用 Windows XP，那么你的电脑仍可工作，但它可能更容易受到安全风险与病毒的攻击。</p>
<p><em>我们这边以纯净版的sp3中文专业版为例。</em></p>
<h3 id="2-常规系统安装方法"><a href="#2-常规系统安装方法" class="headerlink" title="2.常规系统安装方法"></a>2.常规系统安装方法</h3><h4 id="2-1光驱安装"><a href="#2-1光驱安装" class="headerlink" title="2.1光驱安装"></a>2.1光驱安装</h4><p>以往的系统安装大多使用光驱安装，而电脑的 BIOS 引导项也都有光驱引导，但随着上网本，超极本等的流行，越来越多的电脑为了节省空间将光驱给去掉了。</p>
<p>事实也是如此，光驱读取速度慢，且网络如此发达，现在很多厂家现在也都不再提供光盘，而是通过官方网站自行获取相关软件及驱动程序，或者直接提供优盘（优盘越来越廉价）。</p>
<p><em>光盘安装简单，但不作为本文的重点，以下将不会再涉及。</em></p>
<h4 id="2-2优盘安装"><a href="#2-2优盘安装" class="headerlink" title="2.2优盘安装"></a>2.2优盘安装</h4><h5 id="2-2-1windows下的PE安装方式"><a href="#2-2-1windows下的PE安装方式" class="headerlink" title="2.2.1windows下的PE安装方式"></a>2.2.1windows下的PE安装方式</h5><p>大多数 windows 的产品都可以将优盘制作成一个 PE 启动盘，然后通过这个启动程序，引导需要安装的 ISO 文件，最终完成安装。</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>通过 pe，在安装系统之前，可以执行相关备份，分区等操作。</li>
<li>一次 pe 制作，下次可以重复反复使用，pe 一般通过软件制作在优盘中，很多都形成单独分区，不会影响优盘的正常使用。</li>
<li>通过 pe 可以执行一些辅助的操作，可以将 pe 作为一个系统软件，即便不需要安装系统，可以通过 pe 做一些事情。</li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>不同的 windows 系统，对应的 pe 不一样！！！没错确确实实不一样，例如： xp 的 pe 就基本上不可能帮你安装 win7 ，同样 win7 的 pe 也不可能让你安装的上 win10 或者 winXP 。</li>
<li>现在 pe 越做越复杂，对于只需要安装系统的新手来说，弄清楚里面 ghost 安装，原版安装，优盘一键安装这都很费力。</li>
</ul>
<h6 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h6><ul>
<li>pe 安装虽然可以解决大多数问题，但毕竟太过冗余，而且不同的系统安装还需要不同的PE，另外对于linux等其他系统也完全没办法解决。</li>
</ul>
<h5 id="2-2-2ultraISO制作u盘安装盘"><a href="#2-2-2ultraISO制作u盘安装盘" class="headerlink" title="2.2.2ultraISO制作u盘安装盘"></a>2.2.2ultraISO制作u盘安装盘</h5><p>注意 ultraISO 并非一个免费的软件，且免费版本的功能极为有限，这边提供ultraISO大容量版安装程序：<code>http://pan.baidu.com/s/1hrXbQ7q</code></p>
<h3 id="3-Windows-XP安装"><a href="#3-Windows-XP安装" class="headerlink" title="3.Windows XP安装"></a>3.Windows XP安装</h3><p>xp的安装同以上安装略有不同，原因根据查找可能是xp本身系统是不完全支持优盘引导的，所以在制作优盘XP引导时，如果仅仅使用ultraISO是很可能无法成功的。如下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/1.jpg" alt=""></p>
<p>为了解决这个问题，我们通过另外一个软件 WinSetupFromUSB 来制作 XP 优盘引导。</p>
<p>使用 WinSetupFromUSB 只需要下载一个 6.5MB 的绿色软件就可以制作好 windowsXP 的安装U盘，方便简捷。WinSetupFromUSB 不仅支持 WindowsXP 的，还支持 Win7/Vista 安装U盘的制作。</p>
<h4 id="3-1准备工具："><a href="#3-1准备工具：" class="headerlink" title="3.1准备工具："></a>3.1准备工具：</h4><ul>
<li>1G 以上 U 盘一枚，XP安装程序约为700M</li>
<li>WinSetupFromUSB 1.0 beta7：<br><code>http://pan.baidu.com/s/1geXdWyR</code><br><code>http://download.csdn.net/detail/littlefang/3664196</code></li>
<li>下载 Windows XP 安装光盘或镜像：<br><code>http://pan.baidu.com/s/1bNeMp4</code></li>
</ul>
<h4 id="3-2制作步骤："><a href="#3-2制作步骤：" class="headerlink" title="3.2制作步骤："></a>3.2制作步骤：</h4><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/2.gif" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/3.gif" alt=""></p>
<ul>
<li>在 3 BootOption 栏目中选择 XP/BartPE bootable[NTLDR]，在 4 FILESYSTEM and OVERRIDES中选择 NTFS和BOOT as HDD，然后点击 6 Prepare Drive</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/4.gif" alt=""></p>
<ul>
<li>开始写入引导文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/5.gif" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/6.gif" alt=""></p>
<ul>
<li>待窗口关闭后返回 RMPrepUSB 界面，点击 exit 退出</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/7.gif" alt=""></p>
<ul>
<li>指定安装文件路径回到 WinSetupFromUSB 主界面，选中 Windows 2000/XP/2003 Setup，指定安装盘所在盘符（I386文件夹的父目录），我使用虚拟光驱把xp的镜像加载到E盘。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/8.gif" alt=""></p>
<ul>
<li>等待启动 U 盘制作完毕，这个过程极为漫长，参考资料说 10 分钟，但实际用了 40 分钟左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/9.gif" alt=""></p>
<ul>
<li>完毕就绪</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/10.gif" alt=""></p>
<h4 id="3-3安装步骤："><a href="#3-3安装步骤：" class="headerlink" title="3.3安装步骤："></a>3.3安装步骤：</h4><ul>
<li><p>开始安装系统，相关 bios 设置这边不详细列出，电脑的厂家不一样，设置也不相同，快速设置功能未必打开，全功能的 bios 设置一般台式机为 delete 按键，笔记本可能是 F2,F10,F12 等根据主板型号而定，修改 bios 主要是为了修改引导方式，电脑一般加载系统会从硬盘进行引导，如果你想从优盘或者光盘引导系统的话，就需要在 boot 中将优盘或者光盘放在最高的优先级（第一位）。这边我们因为使用优盘安装，所以将优盘放在最上面即可。注意：如果你电脑打开了快速设置，一般可以直接选择优盘进行引导，而如果你的电脑是 Lenovo 等在主板中启用了安全功能，则需要讲该功能关闭才可以修改 bios 的引导方式，另外 UEFI 模式这边也需要改成 BIOS/legacy 模式。</p>
</li>
<li><p>XP安装界面，如果是全新硬盘，需要分区等操作，先使用 winPE 等工具，安装位置选择 C 盘（主分区）默认选项安装即可。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/11.gif" alt=""></p>
<ul>
<li>现在 CPU 和硬盘普遍读取速度快，XP 可能显示需要安装 30 分钟以上，但实际一个固态硬盘 +intel i5 以上的处理体只需要5分钟左右即可安装完毕。</li>
</ul>
<h4 id="3-4后续补充："><a href="#3-4后续补充：" class="headerlink" title="3.4后续补充："></a>3.4后续补充：</h4><ul>
<li>因为安装的是纯净版的 XP，因此极有可能会缺少相关驱动程序，尤其是网卡驱动，因此建议系统安装完毕后，使用驱动精灵（网卡版）将网卡驱动补全，进一步将所有需要的驱动下载安装，如果比较冷门的旧机器建议可以去官网下载驱动，主要需要安装的是网卡，intel 相关和显卡驱动，其他驱动程序不会有太大的影响。</li>
</ul>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/littlefang/article/details/6851864" target="_blank" rel="external">http://blog.csdn.net/littlefang/article/details/6851864</a><br><a href="http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html" target="_blank" rel="external">http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html</a><br><a href="http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux的下载工具]]></title>
      <url>http://noparkinghere.win/2016/06/29/2016/2016-06-29-linux%E4%B8%8B%E7%9A%84%E4%B8%8B%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>linux命令行下载外网文件或内网进行大文件传输，经常使用的文本下载工具wget、curl，今天给大家推荐支持Linux命令行多线程、断点续传下载工具axel和myget。</p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><h4 id="Linux系统如何查看版本信息"><a href="#Linux系统如何查看版本信息" class="headerlink" title="Linux系统如何查看版本信息"></a>Linux系统如何查看版本信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">输入<span class="string">"uname -a "</span>,可显示电脑以及操作系统的相关信息。</div><div class="line">Linux系统如何查看版本信息</div><div class="line">输入<span class="string">"cat /proc/version"</span>,说明正在运行的内核版本。</div><div class="line">Linux系统如何查看版本信息</div><div class="line">输入<span class="string">"cat /etc/issue"</span>, 显示的是发行版本信息</div><div class="line">Linux系统如何查看版本信息</div><div class="line">lsb_release <span class="_">-a</span> (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</div><div class="line">Linux系统如何查看版本信息</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="查看本机的信息"><a href="#查看本机的信息" class="headerlink" title="查看本机的信息"></a>查看本机的信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># lsb_release -a(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</span></div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<h3 id="下载工具安装、使用方法介绍"><a href="#下载工具安装、使用方法介绍" class="headerlink" title="下载工具安装、使用方法介绍"></a>下载工具安装、使用方法介绍</h3><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><ul>
<li>ubuntu安装请运行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sudo apt-get install wget</span></div><div class="line">wget版本信息</div><div class="line"><span class="comment"># wget -V</span></div><div class="line">GNU Wget 1.17.1 built on linux-gnu.</div></pre></td></tr></table></figure>
<ul>
<li>此工具比较常用，使用方法、参数略</li>
</ul>
<h4 id="Axel-下载-安装"><a href="#Axel-下载-安装" class="headerlink" title="Axel 下载 安装"></a>Axel 下载 安装</h4><ul>
<li>官方站点<a href="http://axel.alioth.debian.org/" target="_blank" rel="external">http://axel.alioth.debian.org/</a></li>
<li>安装axel</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sudo apt-get install axel</span></div><div class="line">axel版本</div><div class="line"><span class="comment"># axel -V</span></div><div class="line">Axel version 2.5 (Linux)</div><div class="line"></div><div class="line">Copyright 2001-2007 Wilmer van der Gaast,</div><div class="line">          2015      Joao Eriberto Mota Filho,</div><div class="line">                    and others.</div><div class="line">Please, see the CREDITS file.</div></pre></td></tr></table></figure>
<ul>
<li>axel命令使用方法：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">axel [选项参数] url1 [url2] [url……]</div><div class="line">axel 参数：</div><div class="line">--max-speed=x    <span class="comment">#限速值最高速度</span></div><div class="line"> <span class="_">-s</span> x</div><div class="line">Specify maximum speed (bytes per second)</div><div class="line"> --num-connections=x</div><div class="line"> -n x <span class="comment">#连接数</span></div><div class="line">Specify maximum number of connections</div><div class="line"> --output=f <span class="comment">#下载为本地文件</span></div><div class="line"> -o f</div><div class="line">Specify <span class="built_in">local</span> output file</div><div class="line"> --search[=x] <span class="comment">#搜索镜像</span></div><div class="line"> -S [x]</div><div class="line">Search <span class="keyword">for</span> mirrors and download from x servers</div><div class="line"> --header=x  </div><div class="line"> -H x     <span class="comment">#添加头文件字符串</span></div><div class="line">Add header string</div><div class="line"> --user-agent=x <span class="comment">#设置UA</span></div><div class="line"> -U x  </div><div class="line">Set user agent</div><div class="line"> --no-proxy     <span class="comment">#不使用代理服务器</span></div><div class="line"> -N  </div><div class="line">Just don<span class="string">'t use any proxy server --quiet  </span></div><div class="line"> --quiet, -q  </div><div class="line">No output to stdout. #静默模式，不输出到标准输出  </div><div class="line">--verbose  </div><div class="line"> -v  </div><div class="line">More status information #更多状态信息  </div><div class="line"> --alternate  </div><div class="line"> --help #帮助  </div><div class="line"> -h  </div><div class="line">--version #版本  </div><div class="line"> -V</div></pre></td></tr></table></figure>
<h4 id="myget-下载、安装"><a href="#myget-下载、安装" class="headerlink" title="myget 下载、安装"></a>myget 下载、安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget http://myget.sourceforge.net/release/myget-0.1.2.tar.gz</div><div class="line">tar -zxvf myget-0.1.2.tar.gz</div><div class="line"><span class="built_in">cd</span> myget-0.1.2</div><div class="line"><span class="comment"># ./configure &amp;&amp; make &amp;&amp; make install</span></div><div class="line">mytget版本，注意myget命令为mytget</div><div class="line"><span class="comment"># mytget -v</span></div><div class="line">myget 0.1.1</div></pre></td></tr></table></figure>
<ul>
<li>命令mytget用法</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mytget [选项] [url]</div><div class="line">参数</div><div class="line"> -b, --debug          Show the debug message <span class="comment">#看调试信息</span></div><div class="line"> -c, --count=num      Set the retry count to [num], no <span class="built_in">limit</span> when <span class="string">"0"</span>, the default is <span class="string">"99"</span> <span class="comment">#设置重试次数，0为无限，默认是99次。</span></div><div class="line"> <span class="_">-d</span>, --directory=dir Set the <span class="built_in">local</span> direcotry to [dir], the default is <span class="string">"."</span> <span class="comment">#指定下载本地目录，默认是当前目录</span></div><div class="line"> <span class="_">-f</span>, --file=file      Rename the file to [file] <span class="comment">#重命名下载到本地的文件名</span></div><div class="line"> -h, --help           A brief summary of all the options <span class="comment">#简短的帮助摘要</span></div><div class="line"> -i, --interval=num   Set the ftp retry interval to [num] seconds, the default is <span class="string">"5"</span> <span class="comment">#设置ftp重试间隔，单位s，默认5秒</span></div><div class="line"> -n, --number=num     Use [num] connections instead of the default (4) <span class="comment">#指定连接数，默认4</span></div><div class="line"> -r, --referer=URL    Include `Referer: [URL]<span class="string">' header in HTTP request. #包含请求头 Referer</span></div><div class="line"> -t, --timeout=num    Set the connection timeout to [num] seconds, the default is "30" #设置连接超时时间，默认30秒</div><div class="line"> -v, --version        Show the version of the myget and exit #查看版本信息</div><div class="line"> -x, --proxy=URL      Set the proxy [URL]  #设置代理</div></pre></td></tr></table></figure>
<h3 id="wget、axel、myget测试下载速度对比"><a href="#wget、axel、myget测试下载速度对比" class="headerlink" title="wget、axel、myget测试下载速度对比"></a>wget、axel、myget测试下载速度对比</h3><h4 id="下载速度对比"><a href="#下载速度对比" class="headerlink" title="下载速度对比"></a>下载速度对比</h4><p>说明：同一台机器下载同一个数据源链接</p>
<ul>
<li>wget下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 09:29:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div></pre></td></tr></table></figure>
<ul>
<li>axel下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso.0</div><div class="line">Starting download</div><div class="line"></div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 382.3KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 610.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 826.5KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1003.1KB/s]</div><div class="line">略</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2055.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2074.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2093.6KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2111.0KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... ...</div><div class="line">Downloaded 2693.8 kilobytes <span class="keyword">in</span> 1 second. (2113.05 KB/s)</div><div class="line"><span class="comment"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</span></div></pre></td></tr></table></figure>
<ul>
<li>axel  使用10个线程下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Starting download</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 440.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 707.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 935.1KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1138.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1310.5KB/s]</div><div class="line">略</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2180.3KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2196.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2189.7KB/s]</div><div class="line">[ 0%] .......... .......... .........</div><div class="line">Downloaded 4139.5 kilobytes <span class="keyword">in</span> 1 second. (2176.65 KB/s)</div></pre></td></tr></table></figure>
<h4 id="myget下载"><a href="#myget下载" class="headerlink" title="myget下载"></a>myget下载</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Filesize: 4.1G</div><div class="line"> 0% [                       &gt;                       &gt;                       &gt;                         ] [ 27M] [2.5M/s] [ETA:26:58]</div></pre></td></tr></table></figure>
<ul>
<li>myget指定10个线程下载</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># mytget -n <span class="number">10</span> http://url/iso/Centos/x86_64/CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso</span></div><div class="line"><span class="keyword">Begin </span>to download: CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso</span></div><div class="line"><span class="symbol">Filesize</span>: <span class="number">4</span>.<span class="number">1</span>G</div><div class="line"> <span class="number">0</span>% [        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;          ] [ <span class="number">39</span>M] [<span class="number">2</span>.<span class="number">6</span>M/s] [ETA:<span class="number">26</span>:<span class="number">27</span>]</div><div class="line"># ll CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso.mg\!</span></div><div class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">4353378404</span> <span class="keyword">Mar </span><span class="number">11</span> <span class="number">12</span>:<span class="number">53</span> CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso.mg!</span></div><div class="line">下载速度对比结论：axel、myget支持多线程，且速度较快都在<span class="number">2</span>M。</div></pre></td></tr></table></figure>
<h3 id="断点续传对比测试"><a href="#断点续传对比测试" class="headerlink" title="断点续传对比测试"></a>断点续传对比测试</h3><h4 id="axel"><a href="#axel" class="headerlink" title="axel"></a>axel</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Starting download</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 491.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 748.4KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1007.5KB/s]</div><div class="line">略</div><div class="line">[ 1%] .......... ........... .......... .......... .......... [2509.3KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [2509.5KB/s]</div><div class="line">[ 1%] .......... .......... .......... ....</div><div class="line">Downloaded 45.3 megabytes <span class="keyword">in</span> 18 seconds. (2510.95 KB/s)</div><div class="line">中止下载，进度已经到1%，下载了45.3mb</div></pre></td></tr></table></figure>
<ul>
<li>再次运行下载命令，继续从1%断点续传</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">State file found: 47549233 bytes downloaded, 4305829071 to go.</div><div class="line">Starting download</div><div class="line">        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,...... .......... [ 314.4KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [ 603.0KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [ 839.7KB/s]</div><div class="line">               略</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [1547.1KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [1548.8KB/s]</div><div class="line"><span class="comment"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</span></div></pre></td></tr></table></figure>
<h4 id="wget-1"><a href="#wget-1" class="headerlink" title="wget"></a>wget</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 09:51:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div><div class="line"> 1% [                                                                               ] 47,760,647 1.49M/s eta 47m 42s</div></pre></td></tr></table></figure>
<ul>
<li>wget在进度1%中止已经下载47,760,647，再次运行命令，重新开始下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 09:53:24-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso.1<span class="string">'</span></div><div class="line"> 0% [                                                                               ] 1,032,445   1.21M/s</div></pre></td></tr></table></figure>
<ul>
<li>wget直接运行不支持断点续传</li>
</ul>
<p><code># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</code></p>
<ul>
<li>wget重新测试使其支持断点续传</li>
</ul>
<p><code># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">--2013-03-11 12:40:15-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div><div class="line"> 1% [&gt;                                                                                          ] 52,620,206  1.57M/s eta 44m 58s</div><div class="line">在进度1%，已经下载52,620,206处停止</div></pre></td></tr></table></figure>
<ul>
<li>wget 加-c再次下载，支持断点续传</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 12:40:56-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 206 Partial Content</div><div class="line">Length: 4353378304 (4.1G), 4300661972 (4.0G) remaining [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div><div class="line"> 1% [+                                                                                          ] 59,663,080 1.59M/s eta 44m 14s</div><div class="line"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso.mg\!</div></pre></td></tr></table></figure>
<p>4.3 myget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Filesize: 4.1G</div><div class="line"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 45M] [2.1M/s] [ETA:33:06]</div><div class="line">下载进度到1% 文件大小45M</div><div class="line"><span class="comment"># ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\!</span></div><div class="line">-rw-r--r-- 1 root root 4353378404 Mar 11 12:54 CentOS-6.4-x86_64-bin-DVD1.iso.mg!</div><div class="line">再次执行命令，直接从进度1%开始下载</div><div class="line"><span class="comment"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Filesize: 4.1G</div><div class="line"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 51M] [2.9M/s] [ETA:23:57]</div></pre></td></tr></table></figure>
<p><strong>断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。<br>综上对比推荐大家工作中使用axel或myget提高效率，个人比较喜欢axel。<br>注意内网传输根据隧道带宽进行限速，别影响线上生产服务数据传输。</strong></p>
<h3 id="aria2c-The-ultra-fast-download-utility"><a href="#aria2c-The-ultra-fast-download-utility" class="headerlink" title="aria2c (The ultra fast download utility)"></a>aria2c (The ultra fast download utility)</h3><p>强烈推荐这个下载工具，可以说是 linux 下的下载神器，速度比 windows 下的迅雷还要快不少。aria2c 并不仅是一个简单的下载工具，里面配置选项相当多，另外也有不少 GUI 工具支持 aria2c 这边不做详细的介绍，具体可以参考本博客中的 Aria2 详解这篇文章。</p>
<p><em>未完待续</em></p>
<blockquote>
<p>相关链接：<br><a href="http://dreamway.blog.51cto.com/1281816/1151886" target="_blank" rel="external">http://dreamway.blog.51cto.com/1281816/1151886</a> (centos版本)<br><a href="http://sydi.org/posts/linux/aria2c-usage-sample-cns.html" target="_blank" rel="external">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下ssh通过VPN推送失败]]></title>
      <url>http://noparkinghere.win/2016/06/28/2016/2016-06-28-linux%E4%B8%8Bssh%E9%80%9A%E8%BF%87VPN%E6%8E%A8%E9%80%81%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<p>本文主要用于解决 VPN 和 SSH 两者冲突不兼容的问题。</p>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p>
<p>VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p>
<p>VPN的协议分类主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。windows 通过安装 putty等软件可以帮助安装 ssh 协议。</p>
<a id="more"></a>
<h3 id="在VPN下使用SSH服务"><a href="#在VPN下使用SSH服务" class="headerlink" title="在VPN下使用SSH服务"></a>在VPN下使用SSH服务</h3><h4 id="github使用ssh协议："><a href="#github使用ssh协议：" class="headerlink" title="github使用ssh协议："></a>github使用ssh协议：</h4><ul>
<li><p>我们可以本地推送而免输入账户名密码，这里不作为本文重点，相关网址教程如下：</p>
<blockquote>
<p><a href="http://playingfingers.com/2016/03/26/build-a-blog/" target="_blank" rel="external">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href="http://beiyuu.com/github-pages" target="_blank" rel="external">http://beiyuu.com/github-pages</a><br><a href="http://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="external">http://www.cnblogs.com/ayseeing/p/3572582.html</a><br><a href="http://blog.csdn.net/renfufei/article/details/37725057/" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/37725057/</a></p>
</blockquote>
</li>
</ul>
<h4 id="SSH无法推送"><a href="#SSH无法推送" class="headerlink" title="SSH无法推送:"></a>SSH无法推送:</h4><ul>
<li><p>当一切操作就绪后，会偶然出现无法通过SSH推送：</p>
<blockquote>
<p>等待很长时间后，显示超时！</p>
</blockquote>
</li>
</ul>
<h4 id="原理及方案："><a href="#原理及方案：" class="headerlink" title="原理及方案："></a>原理及方案：</h4><ul>
<li><strong>通过排查发现主要是由于链接的VPN引起的，SSH协议和VPN本身存在不兼容，要想解决可以通过底层设置让需要使用SSH协议的IP地址不经过VPN服务器，由电脑主机网卡直接访问。</strong></li>
</ul>
<h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ul>
<li>查看网卡情况</li>
</ul>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入指令：ifconfig</div><div class="line">下面出现的ppp0就是虚拟出来的VPN网卡。</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-28-linux下ssh通过VPN推送失败/2016-06-23-remarkable-install.png" alt=""></p>
<ul>
<li>查看ip列表,查看有哪些设置过了的IP地址</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route <span class="built_in">list</span></div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-28-linux下ssh通过VPN推送失败/DeepinScrot-3457.png" alt=""></p>
<ul>
<li>获取目标网站IP地址</li>
</ul>
<p><em>最简单的可以通过ping命令如下</em></p>
<p>ping www.github.com 终端返回：64 bytes from github.com (192.30.252.131): icmp_seq=1 ttl=54 time=210 ms，一般来说192.30.252.131 则为我们目标IP地址。但可能push的地址不一定是同一个地址。即便通过<code>nslookup + 详细网址</code>也未必能够获取真正推送的ip地址。最终通过谷歌搜索<a href="https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/" target="_blank" rel="external">网站</a>查看到github实际推送过程中ip地址为：192.30.252.0/22，（这边另外推荐可以使用wireshark进行抓包查看网络服务）</p>
<ul>
<li>将目标域名的IP地址加入到主机网卡中， 192.168.18.1为路由器网关的地址，通过上面ifconfig可以看到本机被路由器分配的ip地址为192.168.18.60，而eno1为计算机在访问外网中的实体网卡。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ip route add <span class="number">192.30</span><span class="number">.252</span><span class="number">.0</span>/<span class="number">22</span> via <span class="number">192.168</span><span class="number">.18</span><span class="number">.1</span> dev eno1</div></pre></td></tr></table></figure>
<ul>
<li>再次查看ip列表,查看有哪些设置过了的IP地址</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route <span class="built_in">list</span></div></pre></td></tr></table></figure>
<ul>
<li>最终完成推送<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-28-linux下ssh通过VPN推送失败/DeepinScrot-3044.png" alt=""></li>
</ul>
<hr>
<blockquote>
<p>参考网址：<br><a href="https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/" target="_blank" rel="external">https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[关于英国的独立日]]></title>
      <url>http://noparkinghere.win/2016/06/27/2016/2016-06-27-%E5%85%B3%E4%BA%8E%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%97%A5/</url>
      <content type="html"><![CDATA[<blockquote>
<p>6.24日英国通过公投，最终确认脱离欧盟。</p>
<p><a href="http://money.sohu.com/20160620/n455207391.shtml" target="_blank" rel="external">http://money.sohu.com/20160620/n455207391.shtml</a></p>
</blockquote>
<h3 id="英国和欧盟多年的友谊最终到了尽头"><a href="#英国和欧盟多年的友谊最终到了尽头" class="headerlink" title="英国和欧盟多年的友谊最终到了尽头"></a>英国和欧盟多年的友谊最终到了尽头</h3><p>不得不让人唏嘘，数十年的结盟，说散就散了，也许很多人英国人自己都难以相信这以现实。而如果要说英国与欧盟的矛盾，主要也是：</p>
<ul>
<li>英国自身条件优越，几个有钱的大哥后面跟了一群要钱的小弟，试想谁都不愿意。</li>
<li>欧盟这些年变得越来越大，不仅变得臃肿了，而且想要扩张自己的权利，很可能是想真正建立集权。</li>
<li>无非是难民问题，某些地区经过美国的打击，以及欧盟的被忽悠跟在后面起哄，最终越来越动荡，也使得难民潮不绝。</li>
</ul>
<p>虽说如此，另一方面英国通过欧盟也实实在在获得了很多好处，有些东西，一旦拥有了，就再也无法摆脱，英国大概也是如此，因为欧盟，伦敦成了世界的经济中心，也因为欧盟，英国有将近一半的公司来自于欧洲各国。英国的繁荣昌盛很大一部分程度是来自于其他各国对它的输入的，其实这和中国的上海并没有多大的区别，一个底子好地理位置好的地方可以成为经济贸易的中心，但这种荣耀并非属于你一个人的。英国认为要不断的去救济其他国家，拖累了自己，这看起来多么滑稽可笑，试想如果没有其他国家的支持，又怎么会有你今天的繁华呢？！就经济发展而言，英国离开欧盟可以相当于自断臂膀，相信未来很长一段时间，英国经济发展都在难有起色。与欧盟相比，所谓的英联邦，从过去到现在又真的有给英国经济带来过什么吗？</p>
<p>事实上欧洲也有很多国家发展的不错，也没有加入欧盟。很多人认为脱欧并代表不了什么。这就好比，如果你从来没有拥有过，你就也不会在乎你失去了什么。中国现在改革开放了，但如果说现在再次闭关锁国，在回到改革开放前，老百姓会受得了吗？！</p>
<blockquote>
<p><a href="http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj" target="_blank" rel="external">http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj</a></p>
</blockquote>
<a id="more"></a>
<h3 id="英国人请愿二次公投"><a href="#英国人请愿二次公投" class="headerlink" title="英国人请愿二次公投"></a>英国人请愿二次公投</h3><p>英国数百位万人请愿二次公投，很多人觉得是一个滑稽可笑的事情，但却细思极恐。公投象征了什么？无意象征了人民群众掌权，权力来自于人民的象征，人民决定国家命运的象征。一直以来，很多中国人也都羡慕美国投票选总统，但事实真的如此吗？英国作为金百年最发达的国家，人民群众的文化教育生活水平，不所谓不高吧？但仍然很多人将投票作为儿戏，很多人投票结束后采取谷歌搜索什么是欧盟？脱欧意味着什么？不得不说，卡梅隆真是相信自己的人民，而事实上历来都是：真理掌握在少数人手中，只有10%的人去统治90%的人的命运。将命运作为儿戏，权力不知道利用的人哪儿都用，中外也并没有区别。民众的倾向，一般也只会考虑到自己，什么对自己不好，往往最让他们印象深刻，所以看到难民影响他们生活了，就会有许多人投票要脱欧，却没有去想过，脱欧后谁来给他们供给廉价又可口的早餐，谁来为一些受理给欧盟的专利版权买单？</p>
<p>试想，如果中国人也拥有了公投，自己决定国家命运的权力！那会是什么样的乱象？！</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下安装remarkable]]></title>
      <url>http://noparkinghere.win/2016/06/23/2016/2016-06-23-remarkable-install/</url>
      <content type="html"><![CDATA[<h3 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-23-remarkable-install/remarkable.png" alt=""></p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>安装环境位ubuntu 16.04(64位)，markdown的网站无法正确的下载软件。</p>
<a id="more"></a>
<blockquote>
<p>附上其他下载地址：<a href="http://download.csdn.net/detail/ruanxingzhi/9402933" target="_blank" rel="external">http://download.csdn.net/detail/ruanxingzhi/9402933</a></p>
</blockquote>
<ol>
<li><p>下载的deb文件</p>
</li>
<li><p>使用dpkg -i remarkable**.deb 命令安装</p>
</li>
<li><p>安装过程出现缺失错误，使用sudo apt-get install -f 修复依赖关系，最终软件能够正确安装</p>
</li>
<li><p>如果出现了步骤3的情况，则重新执行步骤2</p>
</li>
<li><p>新版ubuntu系统出现错误：<br><code>GLib.Error: gtk-builder-error-quark: /usr/share/remarkable/ui/RemarkableWindow.ui:835:58 Object with ID  not found (13)</code></p>
</li>
</ol>
<ul>
<li>编辑 /usr/share/remarkable/ui/RemarkableWindow.ui将834~842之间的代码注释掉即可以解决问题：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!--</div><div class="line">                &lt;child&gt;</div><div class="line">                  &lt;object class=<span class="string">"GtkMenuItem"</span> id=<span class="string">"mnu_about"</span>&gt;</div><div class="line">                    &lt;property name=<span class="string">"related_action"</span>/&gt;</div><div class="line">                    &lt;property name=<span class="string">"visible"</span>&gt;True&lt;/property&gt;</div><div class="line">                    &lt;property name=<span class="string">"can_focus"</span>&gt;False&lt;/property&gt;</div><div class="line">                    &lt;property name=<span class="string">"label"</span> translatable=<span class="string">"yes"</span>&gt;About&lt;/property&gt;</div><div class="line">                    &lt;property name=<span class="string">"use_underline"</span>&gt;True&lt;/property&gt;</div><div class="line">                  &lt;/object&gt;</div><div class="line">                &lt;/child&gt;</div><div class="line">--&gt;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>安装软件显得较为简单，主要是出错之后的解决方法，因为软件较为小众，国内只能搜到两篇外文译稿，出错后也只能通过谷歌去一个个尝试解决办法。</li>
<li>该软件虽然较为轻巧，启动速度快，基本功能有，但个人仍然选择了atom（github提供的一款软件）作为markdown的常用书写环境，另外linux下也推荐可以使用chrome下的马克飞象插件或者直接使用<code>https://maxiang.io/</code>在线编辑。当然如果是vim高手，这些软件都没有必要。</li>
</ul>
<hr>
<blockquote>
<h4 id="参考网址："><a href="#参考网址：" class="headerlink" title="参考网址："></a>参考网址：</h4><p><a href="https://github.com/remarkableapp/Remarkable-Linux/issues/14" target="_blank" rel="external">https://github.com/remarkableapp/Remarkable-Linux/issues/14</a><br><a href="https://linux.cn/article-3741-1.html#comment" target="_blank" rel="external">https://linux.cn/article-3741-1.html#comment</a>  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
