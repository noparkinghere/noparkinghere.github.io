<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[(转)你是怎样将词汇量提升到2万以上的？]]></title>
      <url>http://noparkinghere.top/2018/12/24/2018/2018-12-24-%E8%BD%AC-%E4%BD%A0%E6%98%AF%E6%80%8E%E6%A0%B7%E5%B0%86%E8%AF%8D%E6%B1%87%E9%87%8F%E6%8F%90%E5%8D%87%E5%88%B02%E4%B8%87%E4%BB%A5%E4%B8%8A%E7%9A%84%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在知乎上看到了这个一样问题：“你是如何将词汇量提升到 2 万，甚至 3 万的？”觉得这个问题非常有意思，写了一篇答案，分享给大家。</p>
<p>在写这篇文章之前我特地跑到www.testyourvocab.com 上面测了测词汇量，结果大约是：</p>
<p>在某国产应用上测得的结果是：</p>
<p>词汇量应该算是有两万以上，说一说我是怎么做的。</p>
<p>在继续写下去之前，我们先来确定一件事情：我们究竟需要多大的词汇量？</p>
<p>不是六七千，不是八九千，也不是一两万，而是：越大越好。是的，两三万算凑合，四五万也不嫌多。著名的词汇量测试网站 www.testyourvocab.com 对此做了一个统计：</p>
<p>Native speaker随年龄增长词汇量的变化统计值</p>
<p>Non-native Vocabulary level</p>
<p>从统计图中可以发现，以英语为母语的成年人词汇量普遍在2W以上，且词汇量会随着受教育水平的上升而不断提高。柯林斯词典曾经对基于2.5亿词的语料库做了一个统计，标记出了最常用的14600词，也就是著名的柯林斯五星词频：</p>
<p>柯林斯词典有一个高达2.5亿的语料库，从语料库中筛选出了最常用的14600词用五星标注。其中五级（最常用词，以下逐级次之）680词，四级1040词（累计1720词），三级1580词（累计3300词），二级3200词（累计6500词），一级8100词（累计14600词）。根据语料库的统计结果，掌握五级四级的前1720詞，就可以读通英語资料的75%，掌握五、四、三、二級的6500詞，就可以读通英語资料的90%，掌握这14600詞，就可以读懂任何英語资料的95%，即从理论上说，任何一篇100词的文章里大概只有5个词不认识。</p>
<p>如果你想要比较顺畅地读懂外刊以及大部分原版书的话，你的词汇量至少要达到14600以上。词汇量太低造成的一个直接后果是，阅读时大部分时间都会花在纠结生词的意思上，而不是用在理解文本意思乃至欣赏文章的语言美上。我个人感受是，词汇量超过20000后平时在阅读过程中碰到的生词会越来越少，对文章的理解也会越来越准确。 但是，作为非英语母语学习者，要完全消灭生词基本上是不可能完成的任务，碰到生词这种事情在这辈子是躲不掉的。上次碰到一个50多岁的美国大叔，谈到词汇量这个话题时他表示即使到了这个年龄，他每天仍然可以学到新的单词。母语人士尚且如此，作为英语学习者的我们更加不必说。词汇量提升是一件活到老学到老的事情。</p>
<p>我总结了一下，目前关于如何提高词汇量主要有两种方法：<br>1.背单词：背单词书，背词频表，使用各种各样的背单词应用辅助背单词（比如百词斩，扇贝，不背单词等）<br>2.阅读：通过大量阅读来记单词，在阅读中自然积累生词</p>
<p>先说背单词。这种方法有用吗？有。因为我也试过背单词，而且通过背单词的方式完成了第一批词汇的原始积累。但是在衡量一种方法靠不靠谱的时候，我们不仅仅要看它是否有效果，还要综合考虑它的时间成本，执行效率，可行性等问题。通过背单词来提高词汇量这种方法存在的最大的问题是：它是一种非常低效的方法。</p>
<p>为什么？</p>
<p>因为通过这种方式得到的单词只能算是消极词汇，你大概在阅读时能够认出它们，运气好一点时能够把它们听出来。当时距离会说，会用，还有很长一段距离要走。我知道目前市面上有各种各样的背单词软件，每种都在宣称自己的生词库语音库有多么完善丰富，复习算法有多么科学严谨。但你真的是在学单词吗？还是只是生硬地将单词的中文释义塞到脑子里，知其然而不知其所以然？</p>
<p>举个例子，在背单词时，大部分的单词书或者背单词软件可能是这样的：</p>
<p>比如说对于”keen”这个单词，你看了一眼，知道了它差不多有”激烈的，热血的，渴望的，锋利敏捷的”这些意思，并且看了看例句。好了，好像记得七七八八了。但是对于”fervent,avid,enthusiastic,zealous”这些词，它们同样可以有“热心的”意思，你知道它们和”keen”之间的区别吗？ 下次阅读时碰到一个句子”They sell reliable products at very keen prices”，你能反应过来keen在句子中的意思吗？你能用这个单词造几个句子灵活应用到写作中吗？</p>
<p>通过背单词的方法其实是把单词和语境生生割裂开来了。换句话说，通过这种方式记住的只是消极词汇。单词来得快，走得也快。</p>
<p>所以我一直都不提倡通过背单词的方式来提高词汇量。</p>
<p>那么应该用什么方法？</p>
<p>阅读。更加具体的回答是：精读与泛读结合，配合英英词典，结合语境进行记忆。</p>
<p>你大概听说过通过阅读来记单词是记忆效果最好的方法，但是这种方法可能有个缺点：整理生词很不方便，积累单词的速度太慢。</p>
<p>有没有什么好的解决方案呢？</p>
<p>技术改变生活，同样也能改变英语学习。作为一名资深工具党，我一直在尝试寻找能够提高英文学习效率的工具。比如说下面要用到的Mdict，kindle以及英英词典。</p>
<p>我采取的策略是：精读与泛读结合，配合英英词典，结合语境进行记忆。</p>
<p>先说一说精读<br>我们做精读最重要的原则是，吃透掌握在精读过程中碰到的每一个生词。因此，在做精读的过程中有下面两点需要注意：1.选择合适难度的阅读材料 2.利用英英词典，软件等工具对阅读中碰到的单词进行查询以及整理</p>
<p>解释一下这两个点。<br>1.选择合适难度的阅读材料：假设你的英文水平为i，则选取的阅读材料难度要满足i+1（或i+2）的原则，这样可以保证你在做精读的过程中能碰到足够数量的生词。最理想的精读材料选择为外刊，因为上面的文章往往短小精悍，信息量大，可读性强。首推《经济学人》，如果你觉得经济学人的难度太高，《时代周刊》也可以。<br>2.对在阅读过程中遇到的生词，使用Mdict，深蓝等软件加载多本英英词典进行查询，并将查询结果整理成笔记。</p>
<p>我平时的精读材料是《经济学人》，我举个例子说明一下精读的步骤：<br>这是经济学人2015年1月的一篇文章节选，出自经济学人总编John Micklethwait之手：</p>
<p>THIS newspaper churlishly deprives its editors of the egocentric adornments of our trade.Tragically, these pages include no weekly “editor’s letter” to readers, underneath a beaming, air-brushed picture. Online, there is a weekly e-mail, but that comes from your “desk”, not you. As editor, you spend your time in deplorable obscurity, consoled merely by the fact you have the nicest job in journalism. But there are two indulgent exceptions: a brief mention when you are appointed; and this valedictory leader, which attempts to sum up the world that has hurtled across your desk.</p>
<p>It starts on the first day, and never lets up. There are elections, coups, wars, bankruptcies and tsunamis. Science throws up discoveries and ideas. A pantomime of Putinesque villains and Berlusconi-style clowns force themselves onto the cover. But for the things this newspaper cares about, the past nine years have been a battle, one that has left me in a state of paranoid optimism. Paranoia because so much remains under threat; optimism because, for the most part, the creed this newspaper lives by is strong enough to survive.</p>
<p>是不是觉得生词巨多？<br>我把段落中可能需要注意的单词以及短语标记一下：</p>
<p>THIS newspaper churlishly deprives its editors of the egocentric adornments of our trade.Tragically, these pages include no weekly “editor’s letter” to readers, underneath a beaming,air-brushed picture. Online, there is a weekly e-mail, but that comes from your “desk”, not you. As editor, you spend your time in deplorable obscurity, consoled merely by the fact you have the nicest job in journalism. But there are two indulgent exceptions: a brief mention when you are appointed; and this valedictory leader, which attempts to sum up the world that has hurtled acrossyour desk.</p>
<p>It starts on the first day, and never lets up. There are elections, coups, wars, bankruptcies and tsunamis. Science throws up discoveries and ideas. A pantomime of Putinesque villains and Berlusconi-style clowns force themselves onto the cover. But for the things this newspaper cares about, the past nine years have been a battle, one that has left me in a state of paranoid optimism. Paranoia because so much remains under threat; optimism because, for the most part, the creed this newspaper lives by is strong enough to survive.</p>
<p>整理一下：<br>生词：churlishly ，egocentric ，adornments，trade（一词多义），air-brushed，deplorable，consoled ，indulgent ，valedictory，tsunamis.，pantomime ，Putinesque，Berlusconi-style ，paranoid， creed<br>短语：hurtle across，let up<br>值得注意的句子：Science throws up discoveries and ideas.<br>节选的这两段文字只有187个词，结果我们整理出了这么多东西。</p>
<p>接下来要动用我们的大杀器了：英英词典以及词典软件。我电脑上装的是Mdict，上面一共加载了朗文英英五，剑桥高阶，韦氏大学，柯林斯，麦克米伦，美国传统词典等十几本词典。关于英英词典的详细介绍与选择可以参考这一篇文章：干货 | 怎样选择适合你的英文学习词典</p>
<p>比如对于文中的paranoid，我们查询之后可以得到这些结果：</p>
<p>归纳一下，paranoid有这些含义：<br>1.extremely suspicious and afraid of other people<br>2.suffering from the mental illness paranoia<br>3.someone who suffers from paranoia<br>此外，我们还可以发现 paranoid about 这个搭配</p>
<p>将原文，单词释义，以及词典上的优秀例句整理到word文档上</p>
<p>最后一条是我随手编的一个句子。</p>
<p>将每个生词按这个流程操作，整理出自己的生词本。通过这样整理之后，我们才可以说自己真正吃透了原文。你可以把这个生词本放到手机上，或者同步到印象笔记上，或者打印出来，不断对其进行复习，直到掌握每一个单词为止。记住，这是属于你的独一无二的生词本，通过这样的方式来记住生词效果也非常好，因为在查询整理的过程中你已经把单词的语境，释义，用法，搭配等都过了一遍，这样是真正在学单词，而不是在背单词。</p>
<p>有人可能会问这样操作会不会很繁琐导致速度太慢? 并不会，以上所有操作都是在电脑上完成的，单词的查询，例句的复制粘贴与整理的过程其实非常快。我测试了一下，两个小时可以整理40到50个单词，按一天两个小时，每个月积累1000个生词的速度来计算的话，半年就是6000个，一年就是12000个。You do the math.</p>
<p>这是我之前整理的生词本，你们感受一下：</p>
<p>再来说说泛读。</p>
<p>泛读是对精读的补充与拓展，在大量泛读中你将会不断重现精读过程中积累的词汇，对词汇的理解也会更上一层楼。泛读的材料可以适当选取小说类，比如Dan Brown 的Inferno，故事情节紧张刺激同时又有一定的词汇量。泛读过程中碰到的生词就不需要像精读时那样每词必究了，可以只查询出现频率高或者你觉得感兴趣的，有意思的词。</p>
<p>我使用的方法是kindle + kindle Mate 组合的方式。kindle Paperwhite 及之后的系列都有一个非常棒的功能，叫生词本。你在阅读过程中碰到生词时可以一键查询，而且查询到的生词都会被自动添加到生词本里面，非常方便，这个功能的出现彻底解决了看书看到一半需要停下来翻词典的问题。（kindle Paperwhite内置的是正版的New Oxford American Dictionary, Second Edition,非常棒的词典）</p>
<p>豆瓣上有个小组开发了一款叫 Kindle Mate的PC端软件，这款软件有多牛呢？连接kindle后它可以导出所有的生词本，笔记，注释，而且可以根据书籍、作者对标注笔记和生词本进行自动整理分类。这是我电脑上的kindle Mate截图：</p>
<p>从截图中可以看到，我在最近几个月的时间里一共在kindle上标记了3243个生词，整理了2196条笔记。它还可以对每本书标记的生词进行统计，比如我当时花了三周左右的时间将Inferno读完，在这个过程中一共标记了318个生词。同样地，你可以将这些生词用使用Mdict上的英英词典进行查询，整理成生词本。</p>
<p>通过以上精读加泛读的方法，可以在半年至一年的时间内实现词汇量的大幅度上涨，在这个过程中你的遣词造句的能力，阅读能力以及口语听力水平也会实现一个不小飞跃。欢迎在下面评论区参与讨论。</p>
<p>祝周末愉快！</p>
<blockquote>
<p>参考链接：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTY0NTYwMA==&amp;mid=205537213&amp;idx=1&amp;sn=949c3189569e1c69cedc74ad9abdf882&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzA4MTY0NTYwMA==&amp;mid=205537213&amp;idx=1&amp;sn=949c3189569e1c69cedc74ad9abdf882&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈考试和实际掌握程度]]></title>
      <url>http://noparkinghere.top/2018/12/24/2018/2018-12-24-%E8%B0%88%E8%B0%88%E8%80%83%E8%AF%95%E5%92%8C%E5%AE%9E%E9%99%85%E6%8E%8C%E6%8F%A1%E7%A8%8B%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>还在上学时我认为，考试是检验你对一个知识或实际技能掌握程度的最有效方式之一，当初我天真的以为你数学学的好，或者英语学的好，（这边好的意思就是说平时数学题目都会做，英语阅读量大应用的多等），考试就只是小菜一碟，轻松可以拿到一个满意的分数。</p>
<p>然而随着这两年对考试和学习知识的了解，我更加清晰的认识到，考试只是考试，学习知识是学习知识，两者有一定的共性，但却可以认为是分别独立的存在，有时候，甚至你知识掌握的越好反而考的越差，下面举些例子具体阐述我的观点，以下这些例子大都是我真实所见发生在我周围。</p>
<p>前年我认识一个孩子刚参加高考，我本来以为他会取得一个很高的分数的，毕竟就我所知，他初中就去国外参加过英语夏令营，高中看的不少书本都是国外的一些教材，他对化学很感兴趣，看了不少外文期刊，后来他对计算机比较痴迷，也翻译了一些国外的文档，但就是这样一个学生，高考英语并没有得到高分，分数在 120 多，据称发挥略微失常，但一度模考也只比这个多几分。</p>
<p>这些事情，让我不得不重新审视，考试和学习这两件事，与其说考试是检验学习成果的有效工具，不如说，考试本身也是一门技术，你学的再好考试未必能够拿到高分，你学的不好，考试未必就一定差。拿中学考试打个比方，a 学的很一般，但考试掌握了一些技巧，每次考试知道哪些部分是基础题目，他把 70% 容易得分基础的地方先做，做完后再复查确保能够不丢分，然后做 20% 中级部分，这部分内容能够会的已经完成了，最后看看高级部分，连猜带蒙尽量拿点分数，最后 100 分卷子，他拿了 85 分。而 b 平时基础很好学的不错，考试时，按照顺序一点点做，碰到难题卡主了，花了不少时间解决了，最后时间不够，一道 10 分大题没来得及写，由于粗心大意前面有几题算错了，最终只拿了 80 分。</p>
<p>拿某英语考试来说，你词汇量高达到 10000，考试大纲只要求 6000，很多学生甚至只有 4000 词汇量，考试时，你全凭正常人的思维常识来做题，虽然文章看明白了，但选择题做的满纠结，不少题目拿不定主意。而另一个同学用学来的偏方在做题，平时题目练多了，虽然单词不太认识文章也似懂非懂，但知道出题人的想法和思路就够了，最后的考试结果可能你们俩分数差不多。有个从小双语学习的人，据称他英语要略好于中文，去美国留学甚至被误认为是本土华裔，但参加托福考试成绩是听力阅读30，写作29，口语21，这个分数甚至被一些人嘲讽，觉得他英语也就很一般。</p>
<p>再拿计算机来说，你平时代码敲的贼六，多种数据结构都可以婉婉到来，自己对电脑相当了解，组装过机器写过汇编，甚至自己还实现过一个小型操作系统内核，而实际去考试时，你突然蒙了，这个数据结构不去查资料一时不知道怎么设计更好，那道题目虽然做出来了但也忙了半天，计算机考试竟然不需要写代码？结果最后你考试没过，而旁边一个两年来几乎没碰过电脑打字都困难，但啃了几个月全书真题卷子的同学竟然考过了。</p>
<p>上面的例子可能有时候过于极端，但却是真实存在的，知识点掌握的好，可能对考试唯一的帮助只是你学习的比别人快些。其实自我感觉不必太良好，你的快可能只是略微，你自学的固有思维或者你盲目的感觉良好都可能阻碍你拿分。考试并非和学习完全对立，考试对于知识学的好的人来说也是一个机会，通过准备考试，你可以更好地梳理自己的知识结构，虽然那些靠投机取巧的人可能会拿到一个还算可以的分数，但对他们而言只是为了拿证或者仅仅是一段回忆不起来的经历。</p>
<p>对于知识基础良好的人，我说下自己的建议吧，一些知识量比较大，难度系数高的考试，在考试前三个月大约 100 天的样子，一定要收紧自己怠慢松散的心，开始以一种初学者的状态去为考试做准备，花三个月时间抛弃自己原来有的思维习惯和解题方法，全心全意地跟某个老师或者教程的方法来，以 100 天为例：</p>
<ol>
<li>首先构建出一个完整的知识体系，了解这个考试有哪些知识点，哪些考点，有哪些题型等，这些东西要时刻在脑中，<strong>注意无论多忙每天花 10 分钟重新在纸上画一下，到后面要可以随时能够像思维导图一样罗列出来。</strong>（1-2 天）</li>
<li>然后重新完整地跟着复习指导书或者课程走一轮，每次学完后，扩充自己的思维导图，在题型和知识点后面再罗列出解题思路和方法。（25 天）</li>
<li>接下来查漏补缺，针对不同的知识点题型做专项练习，每题都要常识不同的方法，完整地解答出题目，同时更进一步的去查漏补缺这张导图，另外准备一个错题集，如果时间不充裕，错题本可以只列错题来自哪本书的哪个位置。每两周完整翻阅一下错题，对掌握不牢的题目前面打星，累计打 5 星的题目之后有空的话，每天看一下，3,4 星题目一周翻阅一次。（15 天）</li>
<li>接下来做批量练习，不会的题目也记录到错题集中，该段又分为几个小阶段，首先，每个题目不再是凭感觉一拿到手就做，而是看题后立马可以定位到导图中的知识点位置，就该道题考点是哪些，针对这几个考点，分别有哪些常用解题方法，每道题尝试不同的方法解答出结果，部分太熟悉的题目可以只写出大题步骤（25 天）；然后，题目开始有选择性的做，解题不再是解出答案，而是列出方法 1,2,3…，（10 天）；接着，做了这么多题目你应该很清楚地了解出题人思路和风格，如果你是出题人可能会如何出题，数学一道大题下，你还可能出题 （4），一篇阅读理解下，你可能会安排其他什么问题或选项（10 天）；看下是否还有时间，如果没有时间完善以上步骤即可，如果时间很充裕，则重新整理导图，思维和出题人同步，对导图中每个知识点进行回忆和重新出题。整个考试的准备过程应该有一半都在这个大阶段。（50 天）</li>
<li>做真题阶段，真题阶段分为三部，第一次做真题是在步骤 2 完成后，做一份真题，知道自己的差距，不用纠结答案和结果，只看打分不用看正确答案，甚至可以不用查看分数，只是做题的过程中了解自己会了多少，差距有多大；第二次做真题，是步骤 3 完成后，仍然做那份真题，对照答案错题整理，仔细研读为何出错。最后一阶段是步骤 4 完成后，正式做真题，十天时间，一天完成一套真题，做真题时间和分析真题时间控制在 1:1，十天的时间，主要目的是进一步提高解题速度，可找到考试状态，做题时间能够和考试同步更好，中途不可以休息和上厕所。(9 天)</li>
<li>翻阅一下真题和错题集，再次拿出考纲来仔细阅读一遍，于细微处见真知，任何一句话都可能透露了一些信息，重新整理下最近一段时间来学的知识点，再次完整地绘画一下知识结构图，将所有能够想到的内容过一遍，调整好心态准备去考场。</li>
</ol>
<p>因为以上是针对参加过考试，或者知识掌握良好的情况下的准备步骤，所以基础学习只会占用很少的一段时间，大部分的时间都用来针对梳理结构、刷题、考试技巧和出题思路上。而如果知识掌握不好的情况，可能会需要半年甚至几年的时间来完整的学习构建完整的知识基础，再进行以上步骤。这些步骤不仅仅是用来应付考试，只为了过线等，而更多的用来拿到一个理想的分数，不辜负自己所学。</p>
<p>重新审视下考试这件操作，考试考察的是什么？我大概归纳了下有这几点：知识点、解题速度、解题的准确率、考试状态、考试心态、同试卷思路的同步程度。知识点是其中考察的一部分内容并非全部，而即便经过专门的培训我们也很难面面俱到。有含金量的考试，从来都是千军万马过独木桥，当你觉得自己学的不错时，别人可能基础比你更好，我们没有任何理由觉得自己这个领域很优秀，就怠慢这些考试，毕竟理论未必符合实际，考试的内容可能会更窄，更深，或者更宽，更全面，你的知识结构在没有针对考试特训之前，不可能刚好完全契合。其实，某些领域的专家在这些考试中临场发挥也不见得能够得出好的结果，我也见过科教频道一些专家临场发挥时给出了错误结论，很可能是他们审题不清，也可能是太久没接触给忘了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[我眼中未来一年的房价]]></title>
      <url>http://noparkinghere.top/2018/12/19/2018/2018-12-19-%E6%88%91%E7%9C%BC%E4%B8%AD%E6%9C%AA%E6%9D%A5%E4%B8%80%E5%B9%B4%E7%9A%84%E6%88%BF%E4%BB%B7/</url>
      <content type="html"><![CDATA[<p>如果政府不大范围发放货币，不让人民币大规模的贬值，不刺激房价的话，未来一两年房价下跌应该是常态了很有可能会迎来最长一段时间的下跌，并不是房价想跌，而是现在没有交易量，这对炒房和想脱手的人来说都是很不利的，没有交易量房价就不肯上涨，不涨价他们赚什么？</p>
<p>说房价只会涨不会跌的，该好好查查，不能别轻易蛊惑带节奏，长期来看不可否认只要人类没绝种那么房价应该会迂回上升，总体肯定是上涨的，就房改这么多年来看，并不像任大炮说的房价只涨不跌，杭州跌过超三成，常州闹过鬼城，一些地方差点被腰斩，很多地区 5,6 年内房价没跑过物价等等，这些都是有数据可以查到的。</p>
<p>对大城市来说，没有交易量并不是没有刚需，也不是因为限购，而是很多人首付都交不起，一线城市正常地段正常居住面积没有 100w 基本上付不了首付，而另外一点，大城市的人存款不见得就比小城市的人多，换言之大城市的房价如果跌小城市的房价还有什么保障？</p>
<p>还有一点，房价的涨跌不是控制在刚需无贷款的人身上的，这些人压根不进行交易，不进行交易的人怎么可能对房价有影响？房价的涨跌还是由这些人决定，这些人是：巨额带宽刚需已购房者，持币观望者，投资炒房待出售者。</p>
<p>18 年下半年公认的房价下挫，除个别二线城市的部分地区外，其他地方或多或少多出现下跌，浦东近一年跌了一成，针对三个交易人群，我各有理由可以支持房价下跌。</p>
<p>炒房者肯定是要以赚钱为目的的，投资房子如果短期来不了钱，很多投资者就会抛售了，并不是所有投资者都会抛售，以房养房的应该可以排除；另外用固定工资低价入手投资一两套房的人也不会抛售，毕竟房价仍在可承受范围之内。</p>
<p>随着中美贸易战的开打，还有这两年投资热消退，互联网红利渐散，今年的创业和投资比去年少了一半，实体经济不景气增长乏力甚至破产，如：金立破产倒闭，格力增长乏力，全国个人众多实体老板借高利贷输血公司最终跳楼等等；虚拟经济泡沫破裂，OFO 破产，锤子找人接盘，京东、爱奇艺、美团未能扭亏为宜进一步亏损等等，用网上的段子来说，你上午还在调试程序，下午就被辞退了。就国外的统计来说（真实可靠性仅供参考），中国本来应该是世界经济的引导者，但这两年中国人的房贷负债超过了可支配收入，高于法国，日本和美国，也造成中国人消费和购买力的下降。我们只看到双十一的交易额，但阿里巴巴却没有把退货率告诉大家。经济萧条，员工下岗，这些贷款买房者的房贷如何偿还呢？最终还不是银行收回止损，同时追究你的债务，香港 97 年房价动荡曾有多人连续跳楼事件。</p>
<p>股市有买涨不买跌的说法，房市现在很多人看来都如股市，房价跌的时候，更多人是选择观望，而如果经济再不景气的话，除非部分刚需可以一次性付清的人，又有几个人会再投资房子吧？</p>
<p>还有一点是土地和人口，土地价格在我看来从来不是决定房价的因素，土地是随着房价而水涨船高的，而不是房价因为土地而涨价，因果关系就有问题。房价的暴涨应该归根于经济发展迅速收入增加货币贬值了，大量外来人口和适婚年龄者的刚需，以及资本的投机和炒作。随着老龄化的加剧，人口年龄结构确实失调，00 后等购房刚需会减少，但 90 后甚至 80 后很多刚需还没有得到解决，短期来看刚需只会增加，至少未来 10 年内都会如此，但墙倒众人推，社会舆论像多米诺骨牌一样，未来一两年内，人口老龄化很有可能会成为压垮房价的最后一根稻草。</p>
<p>17 年年底，我估计过今年的房价不会再涨了，基本上正确，理由也是大家手中没钱了，首付都未必能借到，只能靠众筹买房了。当然以上只是我的个人设想，这些假设都建立在政府不会大规模的刺激房价上涨之上，到目前为止，政府对房价都只是调控，主要还是市场为主导，即便政府不希望房价跌，也都没放到明面上来。而如果明年政府大量增发货币，提高工资收入，放开限购和贷款政策，挪用其他资金救房市的话，以上我提出的预测则全都不成立。</p>
<hr>
<p>以上仅代表个人观点，大家求同存异。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[示波器使用介绍]]></title>
      <url>http://noparkinghere.top/2018/11/14/2018/2018-11-14-%E7%A4%BA%E6%B3%A2%E5%99%A8%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>做电子电路开发调试时，示波器可以说是必备工具，有了示波器我们在观测模拟电路信号，直观查看通信协议都可以事半功倍。市面上的示波器品种繁多，前几年示波器普遍被国外的大公司泰克(Tektronix) 、安捷伦(Agilent)等垄断，但随着技术的不断进步，国内一些厂家生成的示波器也已经可以满足普通用户的需求，而价格都普遍在千元左右。</p>
<p>对数字应用而言，示波器带宽至少应比被测设计的最快时钟速率快5倍。但在需要精确测量信号的边沿速度时，则要根据信号的最大实际频率成分来决定示波器带宽。对模拟应用而言，示波器带宽至少应比被测设计中的模拟信号最高频率高3倍，但这一经验准则只适用于那些在低频段上频响相对平坦的示波器。</p>
<blockquote>
<p>参考链接：<br><a href="https://blog.csdn.net/u011391629/article/details/51779056" target="_blank" rel="external">https://blog.csdn.net/u011391629/article/details/51779056</a><br><a href="https://www.zhihu.com/question/270973559/answer/358053629" target="_blank" rel="external">https://www.zhihu.com/question/270973559/answer/358053629</a><br><a href="https://baike.baidu.com/item/%E7%A4%BA%E6%B3%A2%E5%99%A8%E5%B8%A6%E5%AE%BD" target="_blank" rel="external">https://baike.baidu.com/item/%E7%A4%BA%E6%B3%A2%E5%99%A8%E5%B8%A6%E5%AE%BD</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[有关人工智能的一些看法]]></title>
      <url>http://noparkinghere.top/2018/09/21/2018/2018-09-21-%E6%9C%89%E5%85%B3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><em>以下观点仅是我个人的看法。</em></p>
<p>个人始终认为中国这两年过份地高估了人工智能，各大报纸周刊什么政府大力助推人工智能发展、各个公司大力研究人工智能、无人车各地上路等等。实际上看一下这两年的发展，我们可以发现人工智能并没有似我们当初所设想的那样发展迅猛（早先设想的人工智能应该是成指数级成长的），现在所谓的人工智能充其量也就是人工智障，它们所能够解决的也无非是单一领域的重复劳动，距离真正的智能还完全不沾边。</p>
<p>欧美国家对新的技术向来都是市场主导，中国和日本却往往都是政府牵头公司大力跟进。上个世纪 8、9 十年代，正是日本如日中天的时候，仿佛离超越美国只有一步之遥，当年以终结者等机器人题材为主导的科幻片也一度认为 2000 年机器人就要代替人类，日本也同样高估了机器人，大力发展机器人，从而错过了很多真正可以带来翻盘的技术。虽然今天，日本的机器人技术仍然领先全球，但这个投入和回报是完全不成正比的。而反观美国，利用芯片和互联网再次制霸全球，实现了经济的多次增长。而现在的中国在人工智能上的大跃进似乎如昨日重现，一样地想要超越欧美，一样地想要靠科技弯道超车。幸运的是，除了政府和一些风投以外，不少国内公司仍算比较理智，抛开百度孤注一掷投入无人驾驶外，其他像阿里和腾讯虽然也在布局人工智能，但更多的精力还是放在云计算和大技术上。</p>
<p>发展任何技术都不是空中楼阁，底层的基础没有完备不可能凭空出现高大上的东西，至少有三点可能支持我的观点，1. 现阶段采用晶体管工艺的微处理器早已到达了瓶颈，核心处理能力跟不上人工智能的发展。2. 网络速度慢时延大，基础服务没法满足人工智能实时应对的需求。3. 大数据云计算等尚且处于起步阶段，而这两个是人工智能的基础。其他的还有很多原因，综上，现在可以先考虑布局人工智能，但如果花大力气大代价上去明显是不太明智的，而一些专门做人工智能的公司被资本过高评估了。</p>
<p>另外完全没必要担心你的工作问题，翻开历史可以发现任何科技革命都有一群人觉得自己失业了，而结果往往都是解放了人类创造了更多就业机会。工业革命解放了人类的双手，信息革命解放了人类的双脚，智能革命也许会解放人类的大脑，但未来仍然有其他的可能，现阶段人工智能都还没着落的前体现，就去考虑这些无疑是杞人忧天了，但无论你是靠体力还是靠脑力劳作，<strong>活到老学到老</strong>在任何时候都是不变的。</p>
<p>此外现在的人工智能多半长期内都会处于人工辅助阶段，也就是帮助我们更好地生活工作，但不不会放开让它去主导事情的处理，未来很长一段时间，我们会像看电视一样习惯人工辅助的生活。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql 安装配置]]></title>
      <url>http://noparkinghere.top/2018/03/29/2018/2018-03-29-mysql-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><em>mysql 的安装配置并不难，但一步错误可能会纠结很久，本文描述了 windows 下的 mysql 安装和配置。</em></p>
<p>MySQL 是一个小巧玲珑但功能强大的数据库，目前十分流行。但是官网给出的安装包有两种格式，一个是 msi 格式，一个是 zip 格式的。本人一开始使用的是 msi 格式，安装了一半，各种配置失效没能完成，这边建议还是使用传统的 zip 包手动安装。具体安装步骤如下：</p>
<h2 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h2><p>我的电脑-&gt;属性-&gt;高级-&gt;环境变量选择 PATH,在其后面添加: 你的mysql bin文件夹的路径 (如:C:\Program Files\MySQL\MySQL Server 5.6\bin ) <code>PATH=.......;C:\Program Files\MySQL\MySQL Server 5.6\bin</code> (注意是追加,不是覆盖)。</p>
<h2 id="配置默认文件"><a href="#配置默认文件" class="headerlink" title="配置默认文件"></a>配置默认文件</h2><p>在mysql-x.x.xx-winx64（小编的是5.6.17根据自己的版本来定）目录下，新建个my.ini。复制下面的代码保存就ok了。my.ini 会替换掉下面的 my-default.ini 文件。.ini 文件是 window 里面的配置文件。保存里面各种默认的数据。（把里面 <code>D:\mysql\mysql-5.6.17-winx64</code> 改成你自己的软件路径，保存。my.ini 必须得是 ASSIC 格式的文件，最好新建 txt 文件更改后缀，通过其他方式得到的 ini 文件可能会失效）。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="section">[mysql]</span></div><div class="line"></div><div class="line"><span class="comment"># 设置mysql客户端默认字符集</span></div><div class="line"></div><div class="line"><span class="attr">default-character-set</span>=utf8 </div><div class="line"><span class="section"></span></div><div class="line">[mysqld]</div><div class="line"></div><div class="line"><span class="comment">#设置3306端口</span></div><div class="line"></div><div class="line"><span class="attr">port</span> = <span class="number">3306</span> </div><div class="line"></div><div class="line"><span class="comment"># 设置mysql的安装目录</span></div><div class="line"></div><div class="line"><span class="attr">basedir</span>=D:\mysql\mysql-<span class="number">5.6</span>.<span class="number">17</span>-winx64</div><div class="line"></div><div class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></div><div class="line"></div><div class="line"><span class="attr">datadir</span>=D:\mysql\mysql-<span class="number">5.6</span>.<span class="number">17</span>-winx64\data</div><div class="line"></div><div class="line"><span class="comment"># 允许最大连接数</span></div><div class="line"></div><div class="line"><span class="attr">max_connections</span>=<span class="number">200</span></div><div class="line"></div><div class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></div><div class="line"></div><div class="line"><span class="attr">character-set-server</span>=utf8</div><div class="line"></div><div class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></div><div class="line"></div><div class="line"><span class="attr">default-storage-engine</span>=INNODB</div></pre></td></tr></table></figure>
<h2 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h2><p>你可能发现你的目录中没有data目录，这是因为mysql从5.7.6开始，zip archive中不再包含 data 目录，怎么办？</p>
<p>这恰恰是最关键的一步，很多教程偏老，没有提到 data 目录，一些用户自己手动创建该目录都可能造成后续错误，建议使用 initialize 来完成相关初始化。</p>
<p>在面的搜索栏里面输入cmd，上面会出来一个cmd.exe，要右键这个cmd.exe选择一管理员的身份运行这个选项。否则可能会出现一个身份不够的错误码。以管理员身份打开cmd窗口后，将目录切换到你解压文件的bin目录，具体命令如：</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="name">D</span>:</div><div class="line">CD <span class="name">D</span>:\mysql\mysql<span class="number">-5.6</span><span class="number">.17</span>-winx64\bin</div><div class="line">mysqld <span class="comment">--initialize</span></div></pre></td></tr></table></figure>
<h2 id="安装mysql服务"><a href="#安装mysql服务" class="headerlink" title="安装mysql服务"></a>安装mysql服务</h2><p>在 cmd 窗口下，继续下面内容，再输入 <code>mysqld install</code> 回车运行就行了（注意是mysqld，不是mysql），如果出现服务已经存在，可以使用 <code>mysqld remove</code> 进行删除，再用 <code>mysqld install</code> 重新安装。</p>
<p>输入 <code>net start mysql</code> 启动服务，如果出现<code>系统错误2</code>，则是<code>系统找不到指定的文件，因为安装服务路径不对</code>，查看 my.ini 文件中路径是否正确，再执行 <code>mysqld remove</code> ，在mysql目录下安装服务重新执行上述安装步骤。</p>
<p>输入 <code>net start mysql</code> 启动服务，如果需要关闭服务可以使用 <code>net stop mysql</code> 命令。</p>
<h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>此时 mysql 没有密码，需要进行设置密码，输入：<code>mysqladmin -u root password</code> 设置密码，再输入 <code>mysql -u root -p</code> 即可登录。</p>
<p>目前出现问题：<code>mysqladmin -u root password</code> 后显示 <code>connect to server at localhost failed</code>，但使用多个方法都无法修改密码。</p>
<blockquote>
<p>参考链接：<br><a href="https://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html" target="_blank" rel="external">https://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html</a><br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/6009153.html" target="_blank" rel="external">https://www.cnblogs.com/fnlingnzb-learner/p/6009153.html</a><br><a href="https://blog.csdn.net/liyangyang0528/article/details/54233632" target="_blank" rel="external">https://blog.csdn.net/liyangyang0528/article/details/54233632</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/data-directory-initialization-mysqld.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/data-directory-initialization-mysqld.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）汇编语言--ARM汇编]]></title>
      <url>http://noparkinghere.top/2018/03/22/2018/2018-03-22-%EF%BC%88%E8%BD%AC%EF%BC%89%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-arm%E6%B1%87%E7%BC%96/</url>
      <content type="html"><![CDATA[<p><em>本文为转载文章，简单易懂的介绍了 ARM 汇编指令，点击标题见原文链接</em></p>
<h1 id="ARM-关键几个寄存器"><a href="#ARM-关键几个寄存器" class="headerlink" title="ARM 关键几个寄存器"></a>ARM 关键几个寄存器</h1><p>ARM处理器共有37个寄存器。其中包括：31个通用寄存器，包括程序计数器(PC)在内。这些寄存器都是32位寄存器。以及6个32位状态寄存器。但目前只使用了其中12位。ARM处理器共有7种不同的处理器模式，在每一种处理器模式中有一组相应的寄存器组。任意时刻(也就是任意的处理器模式下)，可见的寄存器包括15个通用寄存器(R0～R14)、一个或两个状态寄存器及程序计数器(PC)。在所有的寄存器中，有些是各模式共用的同一个物理寄存器；有一些寄存器是各模式自己拥有的独立的物理寄存器。</p>
<p><img src="http://img.blog.csdn.net/20150618144520226" alt=""></p>
<p>图中缩写如下：</p>
<p>R：Register；寄存器<br>PC：Program Counter；程序计数器<br>CPSR：Current Program Status Register；当前程序状态寄存器<br>SPSR：Saved Program Status Register；保存的程序状态寄存器<br>SP：Stack Pointer；数据栈指针<br>LR：Link Register；连接寄存器<br>SB：静态基址寄存器<br>SL：数据栈限制指针<br>FP：帧指针<br>IP：Intra-Procedure-call Scratch Register；内部程序调用暂存寄存器</p>
<h2 id="PC-程序计数器-windows-中-EIP-程序计数器-R15"><a href="#PC-程序计数器-windows-中-EIP-程序计数器-R15" class="headerlink" title="PC(程序计数器) = windows 中 EIP (程序计数器 R15)"></a>PC(程序计数器) = windows 中 EIP (程序计数器 R15)</h2><p>处理器要执行的程序（指令序列）都是以二进制代码序列方式预存储在计算机的存储器中，处理器将这些代码逐条地取到处理器中再译码、执行，以完成整个程序的执行。为了保证程序能够连续地执行下去，CPU必须具<br>有某些手段来确定下一条取指指令的地址。程序计数器（PC)正是起到这种作用，所以通常又称之为‘指令计数器’。CPU 总是按照 PC 的指向对指令序列进行取指、译码和执行，也就是说，最终是PC 决定了程序运行流向。故而，程 序计数器（PC ）属于特别功能寄存器范畴，不能自由地用于存储其他运算数据。</p>
<p>在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入 PC，CPU 按照 PC 的指示从内存读取第一条指令（取指）。当执行指令时，CPU 自动地修改 PC 的内容，即每执行一条指令 PC 增加一个量，这个量等于指令所含的字节数（指令字节数），使 PC 总是指向下一条将要取指的指令地址。由于大多数指令都是按顺序来执行的，所以修改PC 的过程通常只是简单的对PC 加“指令字节数”。当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的目标地址。处理器总是按照 PC 指向取指、译码、执行，以此实现了程序转移。</p>
<h2 id="堆栈指针寄存器-SP-寄存器-R13"><a href="#堆栈指针寄存器-SP-寄存器-R13" class="headerlink" title="堆栈指针寄存器 SP (寄存器 R13)"></a>堆栈指针寄存器 SP (寄存器 R13)</h2><p>ARM处理器中通常将寄存器R13作为堆栈指针（SP）。ARM处理器针对不同的模式，共有 6 个堆栈指针（SP），其中用户模式和系统模式共用一个SP，每种异常模式都有各自专用的 R13 寄存器（SP）。它们通常指向各模式所对应的专用堆栈，也就是 ARM 处理器允许用户程序有六个不同的堆栈空间，ARM 处理器中的 R13 被用作 SP。当不使用堆栈时，R13 也可以用做通用数据寄存器。</p>
<p>由于处理器的每种运行模式均有自己独立的物理寄存器 R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的 R13，使其指向该运行模式的栈空间。这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入 R13 所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以保证异常发生后程序的正常执行。</p>
<h2 id="R14-子程序链接寄存器-LR-Link-Register"><a href="#R14-子程序链接寄存器-LR-Link-Register" class="headerlink" title="R14 子程序链接寄存器 LR(Link Register)"></a>R14 子程序链接寄存器 LR(Link Register)</h2><p>当执行子程序调用指令(BL)时,R14 可得到 R15 (程序计数器PC)的备份。在每一种运行模式下，都可用 R14 保存子程序的返回地址，当用BL或BLX指令调用子程序时，将PC的当前值复制给 R14，执行完子程序后，又将 R14 的值复制回 PC，即可完成子程序的调用返回。以上的描述可用指令完成。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">执行以下任意一条指令： </div><div class="line"><span class="keyword">MOV </span><span class="built_in">PC</span>,<span class="built_in">LR</span> </div><div class="line"><span class="keyword">BX </span><span class="built_in">LR</span> </div><div class="line">在子程序入口处使用以下指令将<span class="built_in">R14</span>存入堆栈： </div><div class="line"><span class="keyword">STMFD </span><span class="built_in">SP</span>！,&#123;,<span class="built_in">LR</span>&#125; </div><div class="line">对应的，使用以下指令可以完成子程序返回： </div><div class="line"><span class="keyword">LDMFD </span><span class="built_in">SP</span>！,&#123;,<span class="built_in">PC</span>&#125; </div><div class="line"><span class="symbol">R14</span> 也可作为通用寄存器。</div></pre></td></tr></table></figure>
<h1 id="ARM汇编指令总结"><a href="#ARM汇编指令总结" class="headerlink" title="ARM汇编指令总结"></a><a href="http://blog.csdn.net/daiyibo123/article/details/50240433" target="_blank" rel="external">ARM汇编指令总结</a></h1><hr>
<p>总结目的是为了看懂ARM返汇编程序含义。如果是抱着来看这篇blog的盆友，希望可以帮到你们；如果有错误，请多指出。谢谢！</p>
<hr>
<h2 id="ARM指令的一般格式"><a href="#ARM指令的一般格式" class="headerlink" title="ARM指令的一般格式"></a>ARM指令的一般格式</h2><p>arm指令字长为固定的32位。一条典型的arm指令编码格式如下：</p>
<p><img src="http://img.blog.csdn.net/20151210163339634" alt=""></p>
<p>一条典型的ARM指令语法格式如下所示：<br><img src="http://img.blog.csdn.net/20151210163410215" alt=""></p>
<p><strong>参数</strong><br>opcode:指令操作符编码</p>
<p>cond:决定指令的操作是否影响CPSR的值</p>
<p>S：决定指令操作是否影响CPSR的值</p>
<p>Rd：目标寄存器编码</p>
<p>Rn：包含第1个操作数的寄存器编码</p>
<p>shifter_operand表示第2个操作数</p>
<hr>
<h2 id="汇编指令执行条件"><a href="#汇编指令执行条件" class="headerlink" title="汇编指令执行条件"></a>汇编指令执行条件</h2><p>大多数ARM指令都可以条件执行，即根据cpsr寄存器中的条件标志位决定是否执行该指令：如果条件不满足，该指令相当于一条nop执行。</p>
<p>每条ARM指令包含4位条件码域，这表明可以定义16个执行条件。这16个条件码和他们的助记符（标记）如下：</p>
<p><img src="http://img.blog.csdn.net/20151210163509496" alt=""></p>
<hr>
<h2 id="操作数的运算处理方式"><a href="#操作数的运算处理方式" class="headerlink" title="操作数的运算处理方式"></a>操作数的运算处理方式</h2><p>一共有下面9种格式：</p>
<ul>
<li>[&lt; Rn&gt;, #+/-]</li>
<li>[&lt; Rn&gt;, +/-&lt; Rm&gt;]</li>
<li>[&lt; Rn&gt;, +/-&lt; Rm&gt;, &lt; shift&gt;#]</li>
<li>[&lt; Rn&gt;, #+/-]!</li>
<li>[&lt; Rn&gt;, +/-&lt; Rm&gt;]!</li>
<li>[&lt; Rn&gt;, +/-&lt; Rm&gt;, &lt; shift&gt;#]!</li>
<li>[&lt; Rn&gt;], #+/-</li>
<li>[&lt; Rn&gt;], +/-&lt; Rm&gt;</li>
<li>[&lt; Rn&gt;], +/-&lt; Rm&gt;, &lt; shift&gt;#</li>
</ul>
<p>总结一下我们可以对上面格式分类：例如:1~3为一类，4~6为一类，7~9为一类。同样的，我们也可以这样分类：1，4，7为一类，2，5，8为一类，3，6，9为一类。</p>
<p><strong>例子示范</strong></p>
<p>通过举例子来说明各个类型的意义。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">----------------<span class="meta">[&lt; Rn&gt;, #+/-&lt;offset_12&gt;]</span>：---------------</div><div class="line"></div><div class="line">LDR R0，[R1, #<span class="number">4</span>] <span class="comment">//将内存单元R1+4中的字读取到R0寄存器中。</span></div><div class="line"></div><div class="line">-------------------<span class="meta">[&lt; Rn&gt;, +/-&lt; Rm&gt;]</span>：-------------------</div><div class="line">LDR R0,[R1,R2]      <span class="comment">//将内存单元R1+R2中的字读取到R0寄存器中</span></div><div class="line"></div><div class="line">----------<span class="meta">[&lt; Rn&gt;, +/-&lt; Rm&gt;, &lt; shift&gt;#&lt;offset_imm&gt;]</span>------</div><div class="line">LDR R0,[R1,R2, LSL #<span class="number">2</span>]  <span class="comment">//将地址单元&#123;R1+R2*4&#125;中的数据读取到R0中</span></div><div class="line"></div><div class="line">-----------------<span class="meta">[&lt; Rn&gt;, #+/-&lt;offset_12&gt;]</span>!--------------</div><div class="line">LDR R0,[R1, #<span class="number">4</span>]     <span class="comment">//将内存单元R1+4中的字读取到R0寄存器中</span></div><div class="line">                    <span class="comment">//同时R1=R1+4</span></div><div class="line"></div><div class="line">---------------------<span class="meta">[&lt; Rn&gt;, +/-&lt; Rm&gt;]</span>!-----------------</div><div class="line">LDR R0,[R1, R2]!    <span class="comment">//将内存单元(R1, R2)中的字读取到R0寄存器中</span></div><div class="line">                    <span class="comment">//同时R1=R1+R2</span></div><div class="line"></div><div class="line">---------<span class="meta">[&lt; Rn&gt;, +/-&lt; Rm&gt;, &lt; shift&gt;#&lt;offset_imm&gt;]</span>!------</div><div class="line">LDR R0,[R1, R2, LSL #<span class="number">2</span>]!    <span class="comment">//将内存单元(R1+R2*4)中的数据读取到R0寄存器中</span></div><div class="line">                            <span class="comment">//同时R1=R1+R2*4</span></div><div class="line"></div><div class="line">------------------<span class="meta">[&lt; Rn&gt;]</span>, #+/-&lt;offset_12&gt;--------------</div><div class="line">LDR R0, [R1], #<span class="number">4</span>    <span class="comment">//将地址为R1的内存单元数据读取到R0中</span></div><div class="line">                    <span class="comment">//然后R1=R1+4</span></div><div class="line"></div><div class="line">----------------------<span class="meta">[&lt; Rn&gt;]</span>, +/-&lt; Rm&gt;-----------------</div><div class="line">LDR R0, [R1], R2    <span class="comment">//将地址为R1的内存单元数据读取到R0中</span></div><div class="line">                    <span class="comment">//然后R1=R1+R2</span></div><div class="line"></div><div class="line">---------<span class="meta">[&lt; Rn&gt;]</span>, +/-&lt; Rm&gt;, &lt; shift&gt;#&lt;offset_imm&gt;-------</div><div class="line">LDR R0, [R1], R2, LSL #<span class="number">2</span>    <span class="comment">//将地址为R1的内存单元数据读取到R0中</span></div><div class="line">                            <span class="comment">//然后R1=R1+R2*4</span></div></pre></td></tr></table></figure>
<h2 id="CPRS各位介绍"><a href="#CPRS各位介绍" class="headerlink" title="CPRS各位介绍"></a>CPRS各位介绍</h2><p>CPRS为状态寄存器，下面他各位的功能和代表的含义</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://img.blog.csdn.net/20151214215535449" alt="这里写图片描述"></h2><h2 id="word"><a href="#word" class="headerlink" title=".word"></a>.word</h2><p>.word expression就是在当前位置放一个word型的值，这个值就是expression</p>
<p><strong>例子示范</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_rWTCON: </div><div class="line"><span class="selector-class">.word</span> <span class="number">0</span>x15300000 </div><div class="line"><span class="comment">//就是在当前地址，即_rWTCON处放一个值0x15300000</span></div></pre></td></tr></table></figure>
<h2 id="macro"><a href="#macro" class="headerlink" title=".macro"></a>.macro</h2><p>宏定义</p>
<p><strong>参数</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">宏名称 .MACRO [形式参数]</div><div class="line">        ........</div><div class="line">        宏定义语句</div><div class="line">        ........</div><div class="line">        .ENDM</div></pre></td></tr></table></figure>
<p><strong>例子示范</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SWAP_REG   .MACRO   RE<span class="name">G1</span>,RE<span class="name">G2</span>   ; swap registers</div><div class="line">          XCH   A, RE<span class="name">G1</span></div><div class="line">          XCH   A, RE<span class="name">G2</span></div><div class="line">          XCH   A, RE<span class="name">G1</span></div><div class="line">          .E<span class="symbol">NDM</span></div></pre></td></tr></table></figure>
<h2 id="global"><a href="#global" class="headerlink" title=".global"></a>.global</h2><p>告诉编译器后续跟的是一个全局可见的名字[可能是变量，也可以是函数名]</p>
<h2 id="type"><a href="#type" class="headerlink" title=".type"></a>.type</h2><p>.type：用来指定一个符号的类型是函数类型或者是对象类型, 对象类型一般是数据, 格式如下:<br>.type 符号, 类型描述</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="@"></a>@</h2><p>这个是 GNU 汇编的规范. 就是注释.</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><hr>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>加指令</p>
<p><strong>例子示范</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">add</span> <span class="built_in">r1</span>,<span class="built_in">r2</span>,#<span class="number">1</span>    //表示<span class="built_in">r1</span>=<span class="built_in">r2</span>+<span class="number">1</span>， 即寄存器<span class="built_in">r1</span>的值等于寄存器<span class="built_in">r2</span>的值加上<span class="number">1</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="adr和adrl"><a href="#adr和adrl" class="headerlink" title="adr和adrl"></a>adr和adrl</h2><p>adr伪指令将基于PC相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中。adrl伪指令比adr伪指令可以读取更大范围的地址，其他功能一样。</p>
<p><strong>参数</strong></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ADR伪指令格式 ：ADR&#123;<span class="built_in">cond</span>&#125;  register, <span class="keyword">expr</span></div><div class="line">ADRL伪指令格式：ADRL&#123;<span class="built_in">cond</span>&#125;  register, <span class="keyword">expr</span></div></pre></td></tr></table></figure>
<p><strong>例子示范</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">adr </span>   <span class="built_in">r2</span>, mem_cfg_val  //存储相对位置</div><div class="line"><span class="keyword">adr </span>   <span class="built_in">r1</span>, mem_cfg_val  //存储相对位置</div><div class="line"><span class="symbol"></span></div><div class="line">mem_cfg_val:</div><div class="line">    ...</div></pre></td></tr></table></figure>
<hr>
<h2 id="align"><a href="#align" class="headerlink" title="align"></a>align</h2><p>.align的作用在于对指令或者数据的存放地址进行对齐，有些CPU架构要求固定的指令长度并且存放地址相对于2的幂指数圆整，否则程序无法正常运行，比如ARM。</p>
<p><strong>参考：</strong><br><a href="http://blog.csdn.net/xingyu19871124/article/details/7333622" target="_blank" rel="external">http://blog.csdn.net/xingyu19871124/article/details/7333622</a></p>
<hr>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><hr>
<h2 id="b和bl"><a href="#b和bl" class="headerlink" title="b和bl"></a>b和bl</h2><p>相对跳转指令。两条指令不同之处在于bl指令除了跳转之外，还将返回地址（bl的下一条指定的地址）保存在lr寄存器中。</p>
<p>BL.W表示该指令为32位指令，单独用BL 可能是16位的，也可能是32位，Keil为了区分 反汇编时 用BL.W 表示 32位，BL表示16位。</p>
<p><strong>例子示范</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">b fun1</div><div class="line"></div><div class="line">fun1:</div><div class="line">    .....</div></pre></td></tr></table></figure>
<h2 id="bic"><a href="#bic" class="headerlink" title="bic"></a>bic</h2><p>bic（位清除）指令对 Rn 中的值 和 Operand2 值的反码按位进行逻辑“与”运算</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BIC </span>   <span class="built_in">R1</span>,  <span class="built_in">R1</span>,   <span class="number">#0x0F</span></div><div class="line">#将<span class="built_in">R1</span>   低<span class="number">4</span>位清<span class="number">0</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><hr>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><hr>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><hr>
<h2 id="equ"><a href="#equ" class="headerlink" title="equ"></a>equ</h2><p>equ是类似于宏的作用，相当于#define。</p>
<p><strong>例子示范</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.equ</span>        MEM_CTL_BASE,       <span class="number">0</span>x48000000</div></pre></td></tr></table></figure>
<hr>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><hr>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><hr>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><hr>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><hr>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><hr>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><hr>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><hr>
<h2 id="long"><a href="#long" class="headerlink" title="long"></a>long</h2><p>.long:定义4字节数据，</p>
<p><strong>例子示范</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.long <span class="number">0x12345678</span>,<span class="number">23876565</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h2><p>这个指令是一个伪指令，他不是真实存在的指令，编辑器会把它扩展成真正的指令。</p>
<p>ldr指令从内存中读取数据到寄存器。</p>
<p><strong>例子示范</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>,<span class="number">=4096</span>    //<span class="built_in">r1</span> = <span class="number">4096</span></div><div class="line"></div><div class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>,[<span class="built_in">r2</span>,<span class="number">#4</span>]  //将地址为<span class="built_in">r2</span>+<span class="number">4</span>的内存单元数据读取到<span class="built_in">r1</span>中去</div><div class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>,[<span class="built_in">r2</span>]     //将地址为<span class="built_in">r2</span>的内存单元位数据读取到<span class="built_in">r1</span>中去</div><div class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>,[<span class="built_in">r2</span>],<span class="number">#4</span>  //将地址为<span class="built_in">r2</span>的内存单元的数据读取到<span class="built_in">r1</span>中，然后<span class="built_in">r2</span><span class="symbol">=r2</span>+<span class="number">4</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="ldm"><a href="#ldm" class="headerlink" title="ldm"></a>ldm</h2><p>ldm{cond} {!} &lt; register list&gt; {^}</p>
<p>批量访问内存，内存中批量读取数据到寄存器。从&lt; rn&gt; 对应的内存块中取出数据，写入 &lt; register list&gt;这些寄存器。</p>
<p><strong>参数</strong></p>
<ul>
<li><p>{cond}表示指定执行条件</p>
</li>
<li><p>表示内存变化的模式：</p>
<ol>
<li>ia(increment after):事后递增方式</li>
<li>ib(increment before):事先递增方式</li>
<li>da(decrement after):事后递减方式</li>
<li>db(decrement before):事先递减方式</li>
</ol>
</li>
<li>&lt; rn&gt;中保存着内存的地址，</li>
<li>{!}加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元地址。</li>
<li>&lt; register list&gt;表示寄存器列表，指令中寄存器列表和内存单元对应关系为：编号低得寄存器对应内存中得低地址单元，编号高的寄存器对应内存中的高地址单元。</li>
<li>{^}有两个含义：如果&lt; register list&gt;中有pc寄存器，它表示指令执行之后，spsr寄存器的值将自动复制到cpsr寄存器中–这常用于从中断处理函数中返回；如果&lt; register list&gt;中没有pc寄存器，{^}表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。</li>
</ul>
<p><strong>例子示范</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldmia </span><span class="built_in">sp</span>!,&#123;<span class="built_in">r0</span>-<span class="built_in">r12</span>,<span class="built_in">pc</span>&#125;</div><div class="line"></div><div class="line">//中断返回，“^”表示将spsr的值复制到<span class="keyword">cpsr</span></div><div class="line">//于是从irq模式返回被中断的工作模式</div><div class="line">//“！”使得指令执行后，<span class="built_in">sp</span><span class="symbol">=sp</span>+<span class="number">14</span>*<span class="number">4</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><hr>
<h2 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h2><p>mov指令可以把一个寄存器的值赋给另一个寄存器，或者把一个常数赋值给寄存器。</p>
<p><strong>例子示范</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov </span><span class="built_in">r1</span>,<span class="built_in">r2</span>   //<span class="built_in">r1</span> = <span class="built_in">r2</span></div><div class="line"><span class="keyword">mov </span><span class="built_in">r1</span>,<span class="number">#4096</span>    //<span class="built_in">r1</span> = <span class="number">4096</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="msr和mrs"><a href="#msr和mrs" class="headerlink" title="msr和mrs"></a>msr和mrs</h2><p>程序状态寄存器访问指令。</p>
<p>ARM处理器中有一个程序状态寄存器（cpsr），他用来控制处理器的工作模式，设置中断的总开关。</p>
<p><strong>例子示范</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">msr </span><span class="keyword">cpsr，r0 </span>//复制<span class="built_in">r0</span>到<span class="keyword">cpsr中</span></div><div class="line"><span class="keyword">mrs </span><span class="built_in">r0</span>，<span class="keyword">cpsr </span>//复制<span class="keyword">cpsr到r0中</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="mcr和mrc"><a href="#mcr和mrc" class="headerlink" title="mcr和mrc"></a>mcr和mrc</h2><p>MCR指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<p>MRC指令将协处理器的寄存器中数值传送到ARM处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。</p>
<p><strong>格式</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MCR&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125; p15, 0, <span class="tag">&lt;<span class="name">Rd</span>&gt;</span>, <span class="tag">&lt;<span class="name">CRn</span>&gt;</span>, <span class="tag">&lt;<span class="name">CRm</span>&gt;</span>&#123;,<span class="tag">&lt;<span class="name">opcode_2</span>&gt;</span>&#125;</div><div class="line"></div><div class="line">MRC&#123;<span class="tag">&lt;<span class="name">cond</span>&gt;</span>&#125; p15, 0, <span class="tag">&lt;<span class="name">Rd</span>&gt;</span>, <span class="tag">&lt;<span class="name">CRn</span>&gt;</span>, <span class="tag">&lt;<span class="name">CRm</span>&gt;</span>&#123;,<span class="tag">&lt;<span class="name">opcode_2</span>&gt;</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<ol>
<li><p>为指令执行的条件码。当忽略时指令为无条件执行。MCR2中，为Ob1111,指令为无条件执行指令。</p>
</li>
<li><p>为协处理器将执行的操作的操作码。对于CP15协处理器来说， 永远为0b000,当不为0b000时，该指令操作结果不可预知。</p>
</li>
<li><p>作为元寄存器的ARM寄存器，其值被传送到得协处理器寄存器中。</p>
</li>
<li><p>不能为PC，当其为PC时，指令操作结果不可预知。</p>
</li>
<li><p>作为目标寄存器的协处理器寄存器，其编号可能为C0，C1….C15。 附加的目标寄存器或者原操作数寄存器，用于区分同一个编号的不同物理寄存器。当指令中不需要提供附加信息时，将C0指定为，否则指令操作结果不可预知。</p>
</li>
<li><p>提供附加信息，用于区别同一个编号的不同物理寄存器。当指令中指定附加信息时，省略或者将其指定为0,否则指令操作结果不可预知。</p>
</li>
</ol>
<hr>
<h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><hr>
<h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><hr>
<h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><hr>
<h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><hr>
<h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><hr>
<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><hr>
<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p>str也是一条伪指令。str指令把寄存器的值存储到内存中。</p>
<p><strong>例子示范</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">str</span> <span class="built_in">r1</span>,[<span class="built_in">r2</span>,#<span class="number">4</span>]  //将<span class="built_in">r1</span>的数据保存到地址为<span class="built_in">r2</span>+<span class="number">4</span>的内存单元中</div><div class="line"><span class="keyword">str</span> <span class="built_in">r1</span>,[<span class="built_in">r2</span>]     //将<span class="built_in">r1</span>的数据保存到地址为<span class="built_in">r2</span>的内存单元中</div><div class="line"><span class="keyword">str</span> <span class="built_in">r1</span>,[<span class="built_in">r2</span>],#<span class="number">4</span>  //将<span class="built_in">r1</span>的数据保存到地址为<span class="built_in">r2</span>的内存单元中，然后<span class="built_in">r2</span>=<span class="built_in">r2</span>+<span class="number">4</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="stm"><a href="#stm" class="headerlink" title="stm"></a>stm</h2><p>stm{cond} {!} &lt; register list&gt; {^}</p>
<p>批量存储数据到内存，寄存器批量存储数据到内存。&lt; register list&gt;这些寄存器中得数据，批量写入到&lt; rn&gt; 对应的内存块中。</p>
<p><strong>参数</strong></p>
<ul>
<li><p>{cond}表示指定执行条件</p>
</li>
<li><p>表示内存变化的模式：</p>
<ol>
<li>ia(increment after):事后递增方式</li>
<li>ib(increment before):事先递增方式</li>
<li>da(decrement after):事后递减方式</li>
<li>db(decrement before):事先递减方式</li>
</ol>
</li>
<li>&lt; rn&gt;中保存着内存的地址，</li>
<li>{!}加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元地址。</li>
<li>&lt; register list&gt;表示寄存器列表，指令中寄存器列表和内存单元对应关系为：编号低得寄存器对应内存中得低地址单元，编号高的寄存器对应内存中的高地址单元。</li>
<li>{^}有两个含义：如果&lt; register list&gt;中有pc寄存器，它表示指令执行之后，spsr寄存器的值将自动复制到cpsr寄存器中–这常用于从中断处理函数中返回；如果&lt; register list&gt;中没有pc寄存器，{^}表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。</li>
</ul>
<p><strong>例子示范</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">stmdb </span><span class="built_in">sp</span>!,&#123;<span class="built_in">r0</span>-<span class="built_in">r12</span>,<span class="built_in">lr</span>&#125;</div><div class="line"></div><div class="line">//保存使用到得寄存器</div><div class="line">//<span class="built_in">r0</span>-<span class="built_in">r12</span>，<span class="built_in">lr</span>被保存在<span class="built_in">sp</span>表示的内存中</div><div class="line">//“！”使得指令执行后<span class="built_in">sp</span><span class="symbol">=sp</span>-<span class="number">14</span>*<span class="number">4</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h2><p>减指令</p>
<p><strong>例子示范</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sub</span> <span class="built_in">r1</span>,<span class="built_in">r2</span>,#<span class="number">1</span>    //表示<span class="built_in">r1</span>=<span class="built_in">r2</span>-<span class="number">1</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><hr>
<h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><hr>
<h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><hr>
<h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><hr>
<h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><hr>
<h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><hr>
<h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1><hr>
<p>ARM 指令注意点：</p>
<ol>
<li>一般指令需1个主时钟时间 </li>
<li>每次跳转增加3个主时钟时间（也许是2个，需要确认）</li>
<li>从RAM中取一个操作数多增加一个主时钟时间，以次类推 </li>
<li>保存一个结果到RAM中多增加一个主时钟时间，以次类推 </li>
<li>访问片内外设，增加一个外设时钟时间 注意伪指令ldr rn,=x需要从ram中取一个操作数。</li>
</ol>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/jscese/article/details/46547985" target="_blank" rel="external">http://blog.csdn.net/jscese/article/details/46547985</a><br><a href="http://blog.csdn.net/smalosnail/article/details/53048784" target="_blank" rel="external">http://blog.csdn.net/smalosnail/article/details/53048784</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ARM 中断]]></title>
      <url>http://noparkinghere.top/2018/03/22/2018/2018-03-22-arm-%E4%B8%AD%E6%96%AD/</url>
      <content type="html"><![CDATA[<p>几乎所有 MCU 都有中断，中断可以打断主程序的执行，实时地应对突发事件。一般情况下，我们可以把中断用于定时器、串口数据传输等，配套可以实现很多特殊操作。这边以 stm32 和 EFM32 为例，了解下中断的操作。</p>
<h2 id="中断简要描述"><a href="#中断简要描述" class="headerlink" title="中断简要描述"></a>中断简要描述</h2><p>由于使用的 ARM Mx 系列的内核，因此这几款处理器配置中断的过程都相似，具体步骤如下：</p>
<ul>
<li>配置相关模块（如：定时器、串口等）</li>
<li>选择开启模块的哪个中断标志位（即：中断使能标识），只有开启了该功能，才会在该事件发生时至位产生中断请求</li>
<li>NVIC 配置中断优先级，内核的不同这边会略有差别，在 NVIC-&gt;IP 中配置。</li>
<li>NVIC 使能该模块对应中断向量的中断。</li>
</ul>
<p>实际工作过程可以看出 NVIC 在内核中，而它掌管着整个中断，每个模块使能中断后，在发生中断时会给出一个中断请求信号给 NVIC，然后 NVIC 打断主程序。手册解释，当 NVIC 未被开启时会收到模块请求会挂起中断，而等待中断使能。这边可以理解为任何时候模块发送中断请求后，会将挂起位 ISPR 至位，如果中断开启的话，且没有高优先级的中断正在执行，则 ISPR 被清除，同时立即执行该中断；否则如果中断未被开启或者高优先级程序正在执行，则中断继续挂起等待执行。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>NVIC 配置中断优先级，一般有抢占优先级和响应优先级，详细内容可以参见内核手册，内核的不同这边会略有差别，如：M0 就没有响应优先级。</p>
<p>优先级的配置需要考虑多种因素，需要考虑主程序的功能、硬件设施、所有使用的中断等，一般来说没有固定的模式可以套用（可能缺少某些外设，内核需要休眠，中断程序需要在主程序中执行等），中断的优先级配置更多的是逻辑问题，逻辑上面没有漏洞即可行，这边还是会提供一些常用的方法，仅供参考（数值越小、优先级约高）：</p>
<ul>
<li>存储数据优先级 0</li>
<li>接受数据优先级 1</li>
<li>发送数据优先级 2</li>
<li>定时器优先级和其他中断优先级 3</li>
<li>按键优先级 5</li>
</ul>
<h2 id="中断技巧"><a href="#中断技巧" class="headerlink" title="中断技巧"></a>中断技巧</h2><p>中断的配合使用，可以实现很多特殊功能，如均匀脉冲的输出、串口数据的分帧、定时 DMA-uart 发送数据等。这边只举几个常用案例。</p>
<h3 id="串口数据分帧"><a href="#串口数据分帧" class="headerlink" title="串口数据分帧"></a>串口数据分帧</h3><p>思路：首先协议约定当超过三个波特率时间未收到数据，则认为一帧数据接受完成，因此，我们可以使用串口中断和定时器中断结合，每次串口中断接受到数据后，启动定时器计时，如果再次收到数据，定时器则清空重新计数，如果未收到数据定时器超时，则进入定时器中断，定时器中断中标记一帧接受完成。</p>
<hr>
<p>后续补充</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.sina.com.cn/s/blog_4fed55ce0100j7nd.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4fed55ce0100j7nd.html</a><br><a href="http://www.voidcn.com/article/p-wzqbmjzl-xr.html" target="_blank" rel="external">http://www.voidcn.com/article/p-wzqbmjzl-xr.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）不是技术也能看懂云计算，大数据，人工智能]]></title>
      <url>http://noparkinghere.top/2018/03/22/2018/2018-03-22-%EF%BC%88%E8%BD%AC%EF%BC%89%E4%B8%8D%E6%98%AF%E6%8A%80%E6%9C%AF%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      <content type="html"><![CDATA[<p><em>本文通俗易懂地介绍了云计算，大数据，人工智能，内容为转载整理，只用于个人收藏，请看<a href="https://www.cnblogs.com/popsuper1982/p/8505203.html" target="_blank" rel="external">原文链接</a>。</em></p>
<h1 id="（转载）不是技术也能看懂云计算，大数据，人工智能"><a href="#（转载）不是技术也能看懂云计算，大数据，人工智能" class="headerlink" title="（转载）不是技术也能看懂云计算，大数据，人工智能"></a><a href="http://www.cnblogs.com/popsuper1982/p/8505203.html" target="_blank" rel="external">（转载）不是技术也能看懂云计算，大数据，人工智能</a></h1><div class="postBody">

<div id="cnblogs_post_body" class="blogpost-body">

<p>我今天要讲这三个话题，一个是云计算，一个大数据，一个人工智能，我为什么要讲这三个东西呢？因为这三个东西现在非常非常的火，它们之间好像互相有关系，一般谈云计算的时候也会提到大数据，谈人工智能的时候也会提大数据，谈人工智能的时候也会提云计算。所以说感觉他们又相辅相成不可分割，如果是非技术的人员来讲可能比较难理解说这三个之间的相互关系，所以有必要解释一下。</p>
<p><span style="font-size: 24px">一、云计算最初是实现资源管理的灵活性</span></p>
<p>我们首先来说云计算，<span style="color: #333333">云计算最初的目标是对资源的管理，管理的主要是计算资源，网络资源，存储资源三个方面。</span></p>
<p><span style="color: #333333"><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304165200175-1916661625.png" alt=""></span></p>
<p><span style="color: #333333"> </span></p>
<p><span style="color: #333333; font-size: 20px">1.1 管数据中心就像配电脑</span></p>
<p><span style="color: #333333"> </span></p>
<p><span style="color: #333333">什么叫计算，网络，存储资源呢？就说你要买台笔记本电脑吧，你是不是要关心这台电脑什么样的CPU啊？多大的内存啊？这两个我们称为计算资源。</span></p>
<p><span style="color: #333333"> </span></p>
<p><span style="color: #333333">这台电脑要能上网吧，需要有个网口可以插网线，或者有无线网卡可以连接我们家的路由器，您家也需要到运营商比如联通，移动，电信开通一个网络，比如100M的带宽，然后会有师傅弄一根网线到您家来，师傅可能会帮您将您的路由器和他们公司的网络连接配置好，这样您家的所有的电脑，手机，平板就都可以通过您的路由器上网了。这就是网络。</span></p>
<p><span style="color: #333333"> </span></p>
<p><span style="color: #333333">您可能还会问硬盘多大啊？原来硬盘都很小，10G之类的，后来500G，1T，2T的硬盘也不新鲜了。(1T是1000G)，这就是存储。</span></p>
<p><span style="color: #333333"> </span></p>
<p><span style="color: #333333">对于一台电脑是这个样子的，对于一个数据中心也是同样的。想象你有一个非常非常大的机房，里面堆了很多的服务器，这些服务器也是有CPU，内存，硬盘的，也是通过类似路由器的设备上网的。这个时候的一个问题就是，运营数据中心的人是怎么把这些设备统一的管理起来的呢？</span></p>
<p><span style="font-size: 20px">1.2 灵活就是想啥时要都有，想要多少都行</span></p>
<p>管理的目标就是要达到两个方面的灵活性。哪两个方面呢？比如有个人需要一台很小很小的电脑，只有一个CPU，1G内存，10G的硬盘，一兆的带宽，你能给他吗？像这种这么小规格的电脑，现在随便一个笔记本电脑都比这个配置强了，家里随便拉一个宽带都要100M。然而如果去一个云计算的平台上，他要想要这个资源的时候，只要一点就有了。</p>
<p>所以说它就能达到两个方面灵活性。</p>
<ul>
<li><p>第一个方面就是想什么时候要就什么时候要，比如需要的时候一点就出来了，这个叫做时间灵活性。</p>
</li>
<li><p>第二个方面就是想要多少呢就有多少，比如需要一个很小很小的电脑，可以满足，比如需要一个特别大的空间，以云盘为例，似乎云盘给每个人分配的空间动不动就就很大很大，随时上传随时有空间，永远用不完，这个叫做空间灵活性。</p>
</li>
</ul>
<p>空间灵活性和时间灵活性，也即我们常说的云计算的弹性。</p>
<p>为了解决这个弹性的问题，经历了漫长时间的发展。</p>
<p><span style="font-size: 20px">1.3 物理设备不灵活</span></p>
<p>首先第一个阶段就是物理机，或者说物理设备时期。这个时期相当于客户需要一台电脑，我们就买一台放在数据中心里。物理设备当然是越来越牛，例如服务器，内存动不动就是百G内存，例如网络设备，一个端口的带宽就能有几十G甚至上百G，例如存储，在数据中心至少是PB级别的(一个P是1000个T，一个T是1000个G)。</p>
<p>然而物理设备不能做到很好的灵活性。首先它不能够达到想什么时候要就什么时候要、比如买台服务器，哪怕买个电脑，都有采购的时间。突然用户告诉某个云厂商，说想要开台电脑，如果使用物理服务器，当时去采购啊就很难，如果说供应商啊关系一般，可能采购一个月，供应商关系好的话也需要一个星期。用户等了一个星期后，这时候电脑才到位，用户还要登录上去开始慢慢部署自己的应用，时间灵活性非常差。第二是空间灵活性也不行，例如上述的用户，要一个很小很小的电脑，现在哪还有这么小型号的电脑啊。不能为了满足用户只要一个G的内存是80G硬盘的，就去买一个这么小的机器。但是如果买一个大的呢，因为电脑大，就向用户多收钱，用户说他只用这么小的一点，如果让用户多付钱就很冤。</p>
<p><span style="font-size: 20px">1.4 虚拟化灵活多了</span></p>
<p>有人就想办法了。第一个办法就是虚拟化。用户不是只要一个很小的电脑么？数据中心的物理设备都很强大，我可以从物理的CPU，内存，硬盘中虚拟出一小块来给客户，同时也可以虚拟出一小块来给其他客户，每个客户都只能看到自己虚的那一小块，其实每个客户用的是整个大的设备上其中的一小块。虚拟化的技术能使得不同的客户的电脑看起来是隔离的，我看着好像这块盘就是我的，你看这呢这块盘就是你的，实际情况可能我这个10G和您这个10G是落在同样一个很大很大的这个存储上的。</p>
<p>而且如果事先物理设备都准备好，虚拟化软件虚拟出一个电脑是非常快的，基本上几分钟就能解决。所以在任何一个云上要创建一台电脑，一点几分钟就出来了，就是这个道理。</p>
<p>这个空间灵活性和时间灵活性就基本解决了。</p>
<p><span style="font-size: 20px">1.5 虚拟世界的赚钱与情怀</span></p>
<p>在虚拟化阶段，最牛的公司是Vmware，是实现虚拟化技术比较早的一家公司，可以实现计算，网络，存储的虚拟化，这家公司很牛，性能也做得非常好，然后虚拟化软件卖的也非常好，赚了好多的钱，后来让EMC(世界五百强，存储厂商第一品牌)给收购了。</p>
<p>但是这个世界上还是有很多有情怀的人的，尤其是程序员里面，有情怀的人喜欢做一件什么事情呢？开源。这个世界上很多软件都是有闭源就有开源，源就是源代码。就是说某个软件做的好，所有人都爱用，这个软件的代码呢，我封闭起来只有我公司知道，其他人不知道，如果其他人想用这个软件，就要付我钱，这就叫闭源。但是世界上总有一些大牛看不惯钱都让一家赚了去。大牛们觉得，这个技术你会我也会，你能开发出来，我也能，我开发出来就是不收钱，把代码拿出来分享给大家，全世界谁用都可以，所有的人都可以享受到好处，这个叫做开源。</p>
<p>比如最近蒂姆·伯纳斯·李就是个非常有情怀的人，2017年，他因“发明万维网、第一个浏览器和使万维网得以扩展的基本协议和算法”而获得2016年度的图灵奖。图灵奖就是计算机界的诺贝尔奖。然而他最令人敬佩的是，他将万维网，也就是我们常见的www的技术无偿贡献给全世界免费使用。我们现在在网上的所有行为都应该感谢他的功劳，如果他将这个技术拿来收钱，应该和比尔盖茨差不多有钱。</p>
<p>例如在闭源的世界里有windows，大家用windows都得给微软付钱，开源的世界里面就出现了Linux。比尔盖茨靠windows，Office这些闭源的软件赚了很多钱，称为世界首富，就有大牛开发了另外一种操作系统Linux。很多人可能没有听说过Linux，很多后台的服务器上跑的程序都是Linux上的，比如大家享受双十一，支撑双十一抢购的系统，无论是淘宝，京东，考拉，都是跑在Linux上的。</p>
<p>再如有apple就有安卓。apple市值很高，但是苹果系统的代码我们是看不到的。于是就有大牛写了安卓手机操作系统。所以大家可以看到几乎所有的其他手机厂商，里面都装安卓系统，因为苹果系统不开源，而安卓系统大家都可以用。</p>
<p>在虚拟化软件也一样，有了Vmware，这个软件非常非常的贵。那就有大牛写了两个开源的虚拟化软件，一个叫做Xen，一个叫做KVM，如果不做技术的，可以不用管这两个名字，但是后面还是会提到。</p>
<p><span style="font-size: 20px">1.6 虚拟化的半自动和云计算的全自动</span></p>
<p>虚拟化软件似乎解决了灵活性问题，其实不全对。因为虚拟化软件一般创建一台虚拟的电脑，是需要人工指定这台虚拟电脑放在哪台物理机上的，可能还需要比较复杂的人工配置，所以使用Vmware的虚拟化软件，需要考一个很牛的证书，能拿到这个证书的人，薪资是相当的高，也可见复杂程度。所以仅仅凭虚拟化软件所能管理的物理机的集群规模都不是特别的大，一般在十几台，几十台，最多百台这么一个规模。这一方面会影响时间灵活性，虽然虚拟出一台电脑的时间很短，但是随着集群规模的扩大，人工配置的过程越来越复杂，越来越耗时。另一方面也影响空间灵活性，当用户数量多的时候，这点集群规模，还远达不到想要多少要多少的程度，很可能这点资源很快就用完了，还得去采购。所以随着集群的规模越来越大，基本都是千台起步，动辄上万台，甚至几十上百万台，如果去查一下BAT，包括网易，包括谷歌，亚马逊，服务器数目都大的吓人。这么多机器要靠人去选一个位置放这台虚拟化的电脑并做相应的配置，几乎是不可能的事情，还是需要机器去做这个事情。</p>
<p>人们发明了各种各样的算法来做这个事情，算法的名字叫做调度(Scheduler)。通俗一点的说，就是有一个调度中心，几千台机器都在一个池子里面，无论用户需要多少CPU，内存，硬盘的虚拟电脑，调度中心会自动在大池子里面找一个能够满足用户需求的地方，把虚拟电脑启动起来做好配置，用户就直接能用了。这个阶段，我们称为池化，或者云化，到了这个阶段，才可以称为云计算，在这之前都只能叫虚拟化。</p>
<p><span style="font-size: 20px">1.7 云计算的私有与公有</span></p>
<p>云计算大致分两种，一个是私有云，一个是公有云，还有人把私有云和公有云连接起来称为混合云，我们暂且不说这个。私有云就是把虚拟化和云化的这套软件部署在别人的数据中心里面，使用私有云的用户往往很有钱，自己买地建机房，自己买服务器，然后让云厂商部署在自己这里，Vmware后来除了虚拟化，也推出了云计算的产品，并且在私有云市场赚的盆满钵满。所谓公有云就是虚拟化和云化软件部署在云厂商自己数据中心里面的，用户不需要很大的投入，只要注册一个账号，就能在一个网页上点一下创建一台虚拟电脑，例如AWS也即亚马逊的公有云，例如国内的阿里云，腾讯云，网易云等。</p>
<p>亚马逊呢为什么要做公有云呢？我们知道亚马逊原来是国外比较大的一个电商，它做电商的时候也肯定会遇到类似双11的场景，在某一个时刻大家都冲上来买东西。当大家都冲上买东西的时候，就特别需要云的时间灵活性和空间灵活性。因为它不能时刻准备好所有的资源，那样太浪费了。但也不能什么都不准备，看着双十一这么多用户想买东西登不上去。所以需要双十一的时候，创建一大批虚拟电脑来支撑电商应用，过了双十一再把这些资源都释放掉去干别的。所以亚马逊是需要一个云平台的。</p>
<p>然而商用的虚拟化软件实在是太贵了，亚马逊总不能把自己在电商赚的钱全部给了虚拟化厂商吧。于是亚马逊基于开源的虚拟化技术，如上所述的Xen或者KVM，开发了一套自己的云化软件。没想到亚马逊后来电商越做越牛，云平台也越做越牛。而且由于他的云平台需要支撑自己的电商应用，而传统的云计算厂商多为IT厂商出身，几乎没有自己的应用，因而亚马逊的云平台对应用更加的友好，迅速发展成为云计算的第一品牌，赚了很多钱。在亚马逊公布其云计算平台财报之前，人们都猜测，亚马逊电商赚钱，云也赚钱吗？后来一公布财报，发现不是一般的赚钱，仅仅去年，亚马逊AWS年营收达122亿美元，运营利润31亿美元。</p>
<p><span style="font-size: 20px">1.8 云计算的赚钱与情怀</span></p>
<p>公有云的第一名亚马逊过得很爽，第二名Rackspace过的就一般了。没办法，这就是互联网行业的残酷性，多是赢者通吃的模式。所以第二名如果不是云计算行业的，很多人可能都没听过了。第二名就想，我干不过老大怎么办呢？开源吧。如上所述，亚马逊虽然使用了开源的虚拟化技术，但是云化的代码是闭源的，很多想做又做不了云化平台的公司，只能眼巴巴的看着亚马逊挣大钱。Rackspace把源代码一公开，整个行业就可以一起把这个平台越做越好，兄弟们大家一起上，和老大拼了。</p>
<p>于是Rackspace和美国航空航天局合作创办了开源软件OpenStack，如图所示OpenStack的架构图，不是云计算行业的不用弄懂这个图，但是能够看到三个关键字，Compute计算，Networking网络，Storage存储。还是一个计算，网络，存储的云化管理平台。</p>
<p>当然第二名的技术也是非常棒的，有了OpenStack之后，果真像Rackspace想象的一样，所有想做云的大企业都疯了，你能想象到的所有如雷贯耳的大型IT企业，IBM，惠普，戴尔，华为，联想等等，都疯了。原来云平台大家都想做，看着亚马逊和Vmware赚了这么多钱，眼巴巴看着没办法，想自己做一个好像难度还挺大。现在好了，有了这样一个开源的云平台OpenStack，所有的IT厂商都加入到这个社区中来，对这个云平台进行贡献，包装成自己的产品，连同自己的硬件设备一起卖。有的做了私有云，有的做了公有云，OpenStack已经成为开源云平台的事实标准。</p>
<p><span style="font-size: 20px">1.9 <span style="font-size: 20px">IaaS, 资源层面的灵活性</span></span></p>
<p>随着OpenStack的技术越来越成熟，可以管理的规模也越来越大，并且可以有多个OpenStack集群部署多套，比如北京部署一套，杭州部署两套，广州部署一套，然后进行统一的管理。这样整个规模就更大了。在这个规模下，对于普通用户的感知来讲，基本能够做到想什么时候要就什么什么药，想要多少就要多少。还是拿云盘举例子，每个用户云盘都分配了5T甚至更大的空间，如果有1亿人，那加起来空间多大啊。其实背后的机制是这样的，分配你的空间，你可能只用了其中很少一点，比如说它分配给你了5个T，这么大的空间仅仅是你看到的，而不是真的就给你了，你其实只用了50个G，则真实给你的就是50个G，随着你文件的不断上传，分给你的空间会越来越多。当大家都上传，云平台发现快满了的时候(例如用了70%)，会采购更多的服务器，扩充背后的资源，这个对用户是透明的，看不到的，从感觉上来讲，就实现了云计算的弹性。其实有点像银行，给储户的感觉是什么时候取钱都有，只要不同时挤兑，银行就不会垮。</p>
<p>这里做一个简单的总结，到了这个阶段，云计算基本上实现了时间灵活性和空间灵活性，实现了计算，网络，存储资源的弹性。计算，网络，存储我们常称为基础设施Infranstracture, 因而这个阶段的弹性称为资源层面的弹性，管理资源的云平台，我们称为基础设施服务，就是我们常听到的IaaS，Infranstracture As A Service。</p>
<p><span style="font-size: 24px">二、云计算不光管资源，也要管应用</span></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304165352365-1674249597.png" alt=""></p>
<p>有了IaaS，实现了资源层面的弹性就够了吗？显然不是。还有应用层面的弹性。这里举个例子，比如说实现一个电商的应用，平时十台机器就够了，双十一需要一百台。你可能觉得很好办啊，有了IaaS，新创建九十台机器就可以了啊。但是90台机器创建出来是空的啊，电商应用并没有放上去啊，只能你公司的运维人员一台一台的弄，还是需要很长时间才能安装好的。虽然资源层面实现了弹性，但是没有应用层的弹性，依然灵活性是不够的。</p>
<p>有没有方法解决这个问题呢？于是人们在IaaS平台之上又加了一层，用于管理资源以上的应用弹性的问题，这一层通常称为PaaS（Platform As A Service）。这一层往往比较难理解，其实大致分两部分，一部分我称为你自己的应用自动安装，一部分我称为通用的应用不用安装。</p>
<p>我们先来说第一部分，自己的应用自动安装。比如电商应用是你自己开发的，除了你自己，其他人是不知道怎么安装的，比如电商应用，安装的时候需要配置支付宝或者微信的账号，才能别人在你的电商上买东西的时候，付的钱是打到你的账户里面的，除了你，谁也不知道，所以安装的过程平台帮不了忙，但是能够帮你做的自动化，你需要做一些工作，将自己的配置信息融入到自动化的安装过程中方可。比如上面的例子，双十一新创建出来的90台机器是空的，如果能够提供一个工具，能够自动在这新的90台机器上将电商应用安装好，就能够实现应用层面的真正弹性。例如Puppet, Chef, Ansible, Cloud Foundary都可以干这件事情，最新的容器技术Docker能更好的干这件事情，不做技术的可以不用管这些词。</p>
<p>第二部分，通用的应用不用安装。所谓通用的应用，一般指一些复杂性比较高，但是大家都在用的，例如数据库。几乎所有的应用都会用数据库，但是数据库软件是标准的，虽然安装和维护比较复杂，但是无论谁安装都是一样。这样的应用可以变成标准的PaaS层的应用放在云平台的界面上。当用户需要一个数据库的时候，一点就出来了，用户就可以直接用了。有人问，既然谁安装都一个样，那我自己来好了，不需要花钱在云平台上买。当然不是，数据库是一个非常难的东西，光Oracle这家公司，靠数据库就能赚这么多钱。买Oracle也是要花很多很多钱的。然而大多数云平台会提供Mysql这样的开源数据库，又是开源，钱不需要花这么多了，但是维护这个数据库，却需要专门招一个很大的团队，如果这个数据库能够优化到能够支撑双十一，也不是一年两年能够搞定的。比如您是一个做单车的，当然没必要招一个非常大的数据库团队来干这件事情，成本太高了，应该交给云平台来做这件事情，专业的事情专业的人来自，云平台专门养了几百人维护这套系统，您只要专注于您的单车应用就可以了。</p>
<p>要么是自动部署，要么是不用部署，总的来说就是应用层你也要少操心，这就是PaaS层的重要作用。</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304171116823-2125176837.png" alt=""></p>
<p> 虽说脚本的方式能够解决自己的应用的部署问题，<span style="text-indent: 2em">然而不同的环境千差万别，一个脚本往往在一个环境上运行正确，到另一个环境就不正确了。</span></p>
<p><span style="text-indent: 2em">而容器是能更好的解决这个问题的。</span></p>
<p><span style="text-indent: 2em"><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304171549380-884329721.png" alt=""></span></p>
<p><span style="text-indent: 2em">容器是 Container，Container另一个意思是集装箱，其实容器的思想就是要变成软件交付的集装箱。集装箱的特点，一是封装，二是标准。</span></p>
<p><span style="text-indent: 2em"> </span></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304174029819-460006657.png" alt=""></p>
<p><span style="text-indent: 2em"> </span></p>
<p><span style="text-indent: 2em">在没有集装箱的时代，假设将货物从 A运到 B，中间要经过三个码头、换三次船。每次都要将货物卸下船来，摆的七零八落，然后搬上船重新整齐摆好。因此在没有集装箱的时候，每次换船，船员们都要在岸上待几天才能走。</span></p>
<p><span style="text-indent: 2em"> </span></p>
<p> <img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304174049081-1911645088.png" alt=""></p>
<p><span style="text-indent: 2em">有了集装箱以后，所有的货物都打包在一起了，并且集装箱的尺寸全部一致，所以每次换船的时候，一个箱子整体搬过去就行了，小时级别就能完成，船员再也不用上岸长时间耽搁了。</span></p>
<p><span style="text-indent: 2em"> </span></p>
<p><span style="text-indent: 2em">这是集装箱“封装”、“标准”两大特点在生活中的应用。</span></p>
<p><span style="text-indent: 2em"> </span></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304174111204-554853341.png" alt=""></p>
<p><span style="text-indent: 2em"> </span></p>
<p><span style="text-indent: 2em"> </span></p>
<p><span style="text-indent: 2em">那么容器如何对应用打包呢？还是要学习集装箱，首先要有个封闭的环境，将货物封装起来，让货物之间互不干扰，互相隔离，这样装货卸货才方便。好在 Ubuntu中的LXC技术早就能做到这一点。</span></p>
<p><span style="text-indent: 2em"> </span></p>
<p><span style="text-indent: 2em">封闭的环境主要使用了两种技术，一种是看起来是隔离的技术，称为 Namespace，也即每个 Namespace中的应用看到的是不同的 IP地址、用户空间、程号等。另一种是用起来是隔离的技术，称为 Cgroups，也即明明整台机器有很多的 CPU、内存，而一个应用只能用其中的一部分。</span></p>
<p><span style="text-indent: 2em"><span style="text-indent: 2em">所谓的镜像，就是将你焊好集装箱的那一刻，将集装箱的状态保存下来，就像孙悟空说：“定”，集装箱里面就定在了那一刻，然后将这一刻的状态保存成一系列文件。这些文件的格式是标准的，谁看到这些文件都能还原当时定住的那个时刻。将镜像还原成运行时的过程（就是读取镜像文件，还原那个时刻的过程）就是容器运行的过程。</span></span></p>
<p><span style="text-indent: 2em">有了容器，使得 PaaS层对于用户自身应用的自动部署变得快速而优雅。</span></p>
<p><span style="font-size: 24px">三、大数据拥抱云计算</span></p>
<p>在PaaS层中一个复杂的通用应用就是大数据平台。大数据是如何一步一步融入云计算的呢？</p>
<p><span style="font-size: 20px">3.1 数据不大也包含智慧</span></p>
<p>一开始这个大数据并不大，你想象原来才有多少数据？现在大家都去看电子书，上网看新闻了，在我们80后小时候，信息量没有那么大，也就看看书，看看报，一个星期的报纸加起来才有多少字啊，如果你不在一个大城市，一个普通的学校的图书馆加起来也没几个书架，是后来随着信息化的到来，信息才会越来越多。</p>
<p>首先我们来看一下大数据里面的数据，就分三种类型，一种叫结构化的数据，一种叫非结构化的数据，还有一种叫半结构化的数据。什么叫结构化的数据呢？叫有固定格式和有限长度的数据。例如填的表格就是结构化的数据，国籍：中华人民共和国，民族：汉，性别：男，这都叫结构化数据。现在越来越多的就是非结构化的数据，就是不定长，无固定格式的数据，例如网页，有时候非常长，有时候几句话就没了，例如语音，视频都是非结构化的数据。半结构化数据是一些xml或者html的格式的，不从事技术的可能不了解，但也没有关系。</p>
<p>数据怎么样才能对人有用呢？其实数据本身不是有用的，必须要经过一定的处理。例如你每天跑步带个手环收集的也是数据，网上这么多网页也是数据，我们称为Data，数据本身没有什么用处，但是数据里面包含一个很重要的东西，叫做信息Information，数据十分杂乱，经过梳理和清洗，才能够称为信息。信息会包含很多规律，我们需要从信息中将规律总结出来，称为知识knowledge，知识改变命运。信息是很多的，但是有人看到了信息相当于白看，但是有人就从信息中看到了电商的未来，有人看到了直播的未来，所以人家就牛了，你如果没有从信息中提取出知识，天天看朋友圈，也只能在互联网滚滚大潮中做个看客。有了知识，然后利用这些知识去应用于实战，有的人会做得非常好，这个东西叫做智慧intelligence。有知识并不一定有智慧，例如好多学者很有知识，已经发生的事情可以从各个角度分析的头头是道，但一到实干就歇菜，并不能转化成为智慧。而很多的创业家之所以伟大，就是通过获得的知识应用于实践，最后做了很大的生意。</p>
<p>所以数据的应用分这四个步骤：数据，信息，知识，智慧。这是很多商家都想要的，你看我收集了这么多的数据，能不能基于这些数据来帮我做下一步的决策，改善我的产品，例如让用户看视频的时候旁边弹出广告，正好是他想买的东西，再如让用户听音乐的时候，另外推荐一些他非常想听的其他音乐。用户在我的应用或者网站上随便点点鼠标，输入文字对我来说都是数据，我就是要将其中某些东西提取出来，指导实践，形成智慧，让用户陷入到我的应用里面不可自拔，上了我的网就不想离开，手不停的点，不停的买，很多人说双十一我都想断网了，我老婆在上面不断的买买买，买了A又推荐B，老婆大人说，“哎呀，B也是我喜欢的啊，老公我要买”。你说这个程序怎么这么牛，这么有智慧，比我还了解我老婆，这件事情是怎么做到的呢？</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304172910727-1535815123.png" alt=""></p>
<p><span style="font-size: 20px">3.2 数据如何升华为智慧</span></p>
<p>数据的处理分几个步骤，完成了才最后会有智慧。</p>
<p>第一个步骤叫数据的收集。首先得有数据，数据的收集有两个方式，第一个方式是拿，专业点的说法叫抓取或者爬取，例如搜索引擎就是这么做的，它把网上的所有的信息都下载到它的数据中心，然后你一搜才能搜出来。比如你去搜索的时候，结果会是一个列表，这个列表为什么会在搜索引擎的公司里面呢，就是因为他把这个数据啊都拿下来了，但是你一点链接，点出来这个网站就不在搜索引擎它们公司了。比如说新浪有个新闻，你拿百度搜出来，你不点的时候，那一页在百度数据中心，一点出来的网页就是在新浪的数据中心了。另外一个方式就是推送，有很多终端可以帮我收集数据，比如说小米手环，可以将你每天跑步的数据，心跳的数据，睡眠的数据都上传到数据中心里面。</p>
<p>第二个步骤是数据的传输。一般会通过队列方式进行，因为数据量实在是太大了，数据必须经过处理才会有用，可是系统处理不过来，只好排好队，慢慢的处理。</p>
<p>第三个步骤是数据的存储。现在数据就是金钱，掌握了数据就相当于掌握了钱。要不然网站怎么知道你想买什么呢？就是因为它有你历史的交易的数据，这个信息可不能给别人，十分宝贵，所以需要存储下来。</p>
<p>第四个步骤是数据的处理和分析。上面存储的数据是原始数据，原始数据多是杂乱无章的，有很多垃圾数据在里面，因而需要清洗和过滤，得到一些高质量的数据。对于高质量的数据，就可以进行分析，从而对数据进行分类，或者发现数据之间的相互关系，得到知识。比如盛传的沃尔玛超市的啤酒和尿布的故事，就是通过对人们的购买数据进行分析，发现了男人一般买尿布的时候，会同时购买啤酒，这样就发现了啤酒和尿布之间的相互关系，获得知识，然后应用到实践中，将啤酒和尿布的柜台弄的很近，就获得了智慧。</p>
<p>第五个步骤就是对于数据的检索和挖掘。检索就是搜索，所谓外事不决问google，内事不决问百度。内外两大搜索引擎都是讲分析后的数据放入搜索引擎，从而人们想寻找信息的时候，一搜就有了。另外就是挖掘，仅仅搜索出来已经不能满足人们的要求了，还需要从信息中挖掘出相互的关系。比如财经搜索，当搜索某个公司股票的时候，该公司的高管是不是也应该被挖掘出来呢？如果仅仅搜索出这个公司的股票发现涨的特别好，于是你就去买了，其实其高管发了一个声明，对股票十分不利，第二天就跌了，这不坑害广大股民么？所以通过各种算法挖掘数据中的关系，形成知识库，十分重要。</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173120622-1040592225.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173217309-1598751514.png" alt=""></p>
<p><span style="font-size: 20px">3.3 大数据时代，众人拾柴火焰高</span></p>
<p>当数据量很小的时候，很少的几台机器就能解决。慢慢的当数据量越来越大，最牛的服务器都解决不了问题的时候，就想怎么办呢？要聚合多台机器的力量，大家齐心协力一起把这个事搞定，众人拾柴火焰高。</p>
<p>对于数据的收集，对于IoT来讲，外面部署这成千上万的检测设备，将大量的温度，适度，监控，电力等等数据统统收集上来，对于互联网网页的搜索引擎来讲，需要将整个互联网所有的网页都下载下来，这显然一台机器做不到，需要多台机器组成网络爬虫系统，每台机器下载一部分，同时工作，才能在有限的时间内，将海量的网页下载完毕。</p>
<p><span style="font-size: 14px; font-family: 宋体"><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173243017-953751892.png" alt=""></span></p>
<p><span style="font-size: 14px; font-family: 宋体"> </span></p>
<p>对于数据的传输，一个内存里面的队列肯定会被大量的数据挤爆掉，于是就产生了基于硬盘的分布式队列，这样队列可以多台机器同时传输，随你数据量多大，只要我的队列足够多，管道足够粗，就能够撑得住。</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173256198-1194238978.png" alt=""></p>
<p>对于数据的存储，一台机器的文件系统肯定是放不下了，所以需要一个很大的分布式文件系统来做这件事情，把多台机器的硬盘打成一块大的文件系统。</p>
<p><span style="font-size: 14px; font-family: 宋体"><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173309193-29645192.png" alt=""></span></p>
<p><span style="font-size: 14px; font-family: 宋体"> </span></p>
<p>再如数据的分析，可能需要对大量的数据做分解，统计，汇总，一台机器肯定搞不定，<span style="font-size: 14px; font-family: 宋体">处理到猴年马月也分析不完，于是就有分布式计算的方法，将大量的数据分成小份，每台机器处理一小份，多台机器并行处理，很快就能算完。例如著名的Terasort对1个TB的数据排序，相当于1000G，如果单机处理，怎么也要几个小时，但是并行处理209秒就完成了。</span></p>
<p> <img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173340325-454046253.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173407555-1514738312.png" alt=""></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173430982-1156642033.png" alt=""></p>
<p>所以说大数据平台，什么叫做大数据，说白了就是一台机器干不完，大家一起干。随着数据量越来越大，很多不大的公司都需要处理相当多的数据，这些小公司没有这么多机器可怎么办呢？</p>
<p><span style="font-size: 20px">3.4 大数据需要云计算，云计算需要大数据</span></p>
<p>说到这里，大家想起云计算了吧。当想要干这些活的时候，需要好多好多的机器一块做，真的是想什么时候要，想要多少就要多少。例如大数据分析公司的财务情况，可能一周分析一次，如果要把这一百台机器或者一千台机器都在那放着，一周用一次对吧，非常浪费。那能不能需要计算的时候，把这一千台机器拿出来，然后不算的时候，这一千台机器可以去干别的事情。谁能做这个事儿呢？只有云计算，可以为大数据的运算提供资源层的灵活性。而云计算也会部署大数据放到它的PaaS平台上，作为一个非常非常重要的通用应用。因为大数据平台能够使得多台机器一起干一个事儿，这个东西不是一般人能开发出来的，也不是一般人玩得转的，怎么也得雇个几十上百号人才能把这个玩起来，所以说就像数据库一样，其实还是需要有一帮专业的人来玩这个东西。现在公有云上基本上都会有大数据的解决方案了，一个小公司我需要大数据平台的时候，不需要采购一千台机器，只要到公有云上一点，这一千台机器都出来了，并且上面已经部署好了的大数据平台，只要把数据放进去算就可以了。</p>
<p>云计算需要大数据，大数据需要云计算，两个人就这样结合了。</p>
<p><span style="font-size: 24px">四、人工智能拥抱大数据</span></p>
<p><span style="font-size: 20px">4.1 机器什么时候才能懂人心</span></p>
<p>虽说有了大数据，人的欲望总是这个不能够满足。虽说在大数据平台里面有搜索引擎这个东西，想要什么东西我一搜就出来了。但是也存在这样的情况，我想要的东西不会搜，表达不出来，搜索出来的又不是我想要的。例如音乐软件里面推荐一首歌，这首歌我没听过，当然不知道名字，也没法搜，但是软件推荐给我，我的确喜欢，这就是搜索做不到的事情。当人们使用这种应用的时候，会发现机器知道我想要什么，而不是说当我想要的时候，去机器里面搜索。这个机器真像我的朋友一样懂我，这就有点人工智能的意思了。</p>
<p>人们很早就在想这个事情了。最早的时候，人们想象，如果要是有一堵墙，墙后面是个机器，我给它说话，它就给我回应，我如果感觉不出它那边是人还是机器，那它就真的是一个人工智能的东西了。</p>
<p><span style="font-size: 20px">4.2 让机器学会推理</span></p>
<p>怎么才能做到这一点呢？人们就想：我首先要告诉计算机人类的推理的能力。你看人重要的是什么呀，人和动物的区别在什么呀，就是能推理。我要是把我这个推理的能力啊告诉机器，机器就能根据你的提问，推理出相应的回答，真能这样多好。推理其实人们慢慢的让机器能够做到一些了，例如证明数学公式。这是一个非常让人惊喜的一个过程，机器竟然能够证明数学公式。但是慢慢发现其实这个结果，也没有那么令人惊喜，因为大家发现了一个问题，数学公式非常严谨，推理过程也非常严谨，而且数学公式很容易拿机器来进行表达，程序也相对容易表达。然而人类的语言就没这么简单了，比如今天晚上，你和你女朋友约会，你女朋友说：如果你早来，我没来，你等着，如果我早来，你没来，你等着。这个机器就比比较难理解了，但是人都懂，所以你和女朋友约会，你是不敢迟到的。</p>
<p><span style="font-size: 20px">4.3 教给机器知识</span></p>
<p>所以仅仅告诉机器严格的推理是不够的，还要告诉机器一些知识。但是知识这个事儿，一般人可能就做不来了，可能专家可以，比如语言领域的专家，或者财经领域的专家。语言领域和财经领域知识能不能表示成像数学公式一样稍微严格点呢？例如语言专家可能会总结出主谓宾定状补这些语法规则，主语后面一定是谓语，谓语后面一定是宾语，将这些总结出来，并严格表达出来不久行了吗？后来发现这个不行，太难总结了，语言表达千变万化。就拿主谓宾的例子，很多时候在口语里面就省略了谓语，别人问：你谁啊？我回答：我刘超。但是你不能规定在语音语义识别的时候，要求对着机器说标准的书面语，这样还是不够智能，就像罗永浩在一次演讲中说的那样，每次对着手机，用书面语说：请帮我呼叫某某某，这是一件很尴尬的事情。</p>
<p>人工智能这个阶段叫做专家系统。专家系统不易成功，一方面是知识比较难总结，另一方面总结出来的知识难以教给计算机。因为你自己还迷迷糊糊，似乎觉得有规律，就是说不出来，就怎么能够通过编程教给计算机呢？</p>
<p><span style="font-size: 20px">4.4 算了，教不会你自己学吧</span></p>
<p>于是人们想到，看来机器是和人完全不一样的物种，干脆让机器自己学习好了。机器怎么学习呢？既然机器的统计能力这么强，基于统计学习，一定能从大量的数字中发现一定的规律。</p>
<p>其实在娱乐圈有很好的一个例子，可见一斑</p>
<p>有一位网友统计了知名歌手在大陆发行的 9 张专辑中 117 首歌曲的歌词，同一词语在一首歌出现只算一次，形容词、名词和动词的前十名如下表所示（词语后面的数字是出现的次数）：</p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p><colgroup><col style="width: 81px"><col style="width: 81px"><col style="width: 81px"><col style="width: 81px"><col style="width: 81px"><col style="width: 81px"></colgroup><br>| a | 形容词 | b | 名词 | c | 动词 |<br>| 0 | 孤独:34 | 0 | 生命:50 | 0 | 爱:54 |<br>| 1 | 自由:17 | 1 | 路:37 | 1 | 碎:37 |<br>| 2 | 迷惘:16 | 2 | 夜:29 | 2 | 哭:35 |<br>| 3 | 坚强:13 | 3 | 天空:24 | 3 | 死:27 |<br>| 4 | 绝望:8 | 4 | 孩子:23 | 4 | 飞:26 |<br>| 5 | 青春:7 | 5 | 雨:21 | 5 | 梦想:14 |<br>| 6 | 迷茫:6 | 6 | 石头:9 | 6 | 祈祷:10 |<br>| 7 | 光明:6 | 7 | 鸟:9 | 7 | 离去:10 |</p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>如果我们随便写一串数字，然后按照数位依次在形容词、名词和动词中取出一个词，连在一起会怎么样呢？</p>
<p>例如取圆周率 3.1415926，对应的词语是：坚强，路，飞，自由，雨，埋，迷惘。稍微连接和润色一下：</p>
<p>坚强的孩子，</p>
<p>依然前行在路上，</p>
<p>张开翅膀飞向自由，</p>
<p>让雨水埋葬他的迷惘。</p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>是不是有点感觉了？当然真正基于统计的学习算法比这个简单的统计复杂的多。</p>
<p>然而统计学习比较容易理解简单的相关性，例如一个词和另一个词总是一起出现，两个词应该有关系，而无法表达复杂的相关性，并且统计方法的公式往往非常复杂，为了简化计算，常常做出各种独立性的假设，来降低公式的计算难度，然而现实生活中，具有独立性的事件是相对较少的。</p>
<p><span style="font-size: 20px">4.5 模拟大脑的工作方式</span></p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>于是人类开始从机器的世界，反思人类的世界是怎么工作的。</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173542876-248664847.png" alt=""></p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>人类的脑子里面不是存储着大量的规则，也不是记录着大量的统计数据，而是通过神经元的触发实现的，每个神经元有从其他神经元的输入，当接收到输入的时候，会产生一个输出来刺激其他的神经元，于是大量的神经元相互反应，最终形成各种输出的结果。例如当人们看到美女瞳孔放大，绝不是大脑根据身材比例进行规则判断，也不是将人生中看过的所有的美女都统计一遍，而是神经元从视网膜触发到大脑再回到瞳孔。在这个过程中，其实很难总结出每个神经元对最终的结果起到了哪些作用，反正就是起作用了。</p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>于是人们开始用一个数学单元模拟神经元</p>
<p>这个神经元有输入，有输出，输入和输出之间通过一个公式来表示，输入根据重要程度不同(权重)，影响着输出。</p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173608115-399984901.png" alt=""></p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>于是将n个神经元通过像一张神经网络一样连接在一起，n这个数字可以很大很大，所有的神经元可以分成很多列，每一列很多个排列起来，每个神经元的对于输入的权重可以都不相同，从而每个神经元的公式也不相同。当人们从这张网络中输入一个东西的时候，希望输出一个对人类来讲正确的结果。例如上面的例子，输入一个写着2的图片，输出的列表里面第二个数字最大，其实从机器来讲，它既不知道输入的这个图片写的是2，也不知道输出的这一系列数字的意义，没关系，人知道意义就可以了。正如对于神经元来说，他们既不知道视网膜看到的是美女，也不知道瞳孔放大是为了看的清楚，反正看到美女，瞳孔放大了，就可以了。</p>
<p>对于任何一张神经网络，谁也不敢保证输入是2，输出一定是第二个数字最大，要保证这个结果，需要训练和学习。毕竟看到美女而瞳孔放大也是人类很多年进化的结果。学习的过程就是，输入大量的图片，如果结果不是想要的结果，则进行调整。如何调整呢，就是每个神经元的每个权重都向目标进行微调，由于神经元和权重实在是太多了，所以整张网络产生的结果很难表现出非此即彼的结果，而是向着结果微微的进步，最终能够达到目标结果。当然这些调整的策略还是非常有技巧的，需要算法的高手来仔细的调整。正如人类见到美女，瞳孔一开始没有放大到能看清楚，于是美女跟别人跑了，下次学习的结果是瞳孔放大一点点，而不是放大鼻孔。</p>
<p><span style="font-size: 20px">4.6 没道理但做得到</span></p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>听起来也没有那么有道理，但是的确能做到，就是这么任性。</p>
<p>神经网络的普遍性定理是这样说的，假设某个人给你某种复杂奇特的函数，f(x)：</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173627213-1028735538.png" alt=""></p>
<p>不管这个函数是什么样的，总会确保有个神经网络能够对任何可能的输入x，其值f(x)（或者某个能够准确的近似）是神经网络的输出。</p>
<p>如果在函数代表着规律，也意味着这个规律无论多么奇妙，多么不能理解，都是能通过大量的神经元，通过大量权重的调整，表示出来的。</p>
<p><span style="font-size: 20px">4.7 人工智能的经济学解释</span></p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>这让我想到了经济学，于是比较容易理解了。</p>
<p><img src="https://images2018.cnblogs.com/blog/635909/201803/635909-20180304173647419-351927988.png" alt=""></p>
<p>我们把每个神经元当成社会中从事经济活动的个体。于是神经网络相当于整个经济社会，每个神经元对于社会的输入，都有权重的调整，做出相应的输出，比如工资涨了，菜价也涨了，股票跌了，我应该怎么办，怎么花自己的钱。这里面没有规律么？肯定有，但是具体什么规律呢？却很难说清楚。</p>
<p>基于专家系统的经济属于计划经济，整个经济规律的表示不希望通过每个经济个体的独立决策表现出来，而是希望通过专家的高屋建瓴和远见卓识总结出来。专家永远不可能知道哪个城市的哪个街道缺少一个卖甜豆腐脑的。于是专家说应该产多少钢铁，产多少馒头，往往距离人民生活的真正需求有较大的差距，就算整个计划书写个几百页，也无法表达隐藏在人民生活中的小规律。</p>
<p>基于统计的宏观调控就靠谱的多了，每年统计局都会统计整个社会的就业率，通胀率，GDP等等指标，这些指标往往代表着很多的内在规律，虽然不能够精确表达，但是相对靠谱。然而基于统计的规律总结表达相对比较粗糙，比如经济学家看到这些统计数据可以总结出长期来看房价是涨还是跌，股票长期来看是涨还是跌，如果经济总体上扬，房价和股票应该都是涨的。但是基于统计数据，无法总结出股票，物价的微小波动规律。</p>
<p>基于神经网络的微观经济学才是对整个经济规律最最准确的表达，每个人对于从社会中的输入，进行各自的调整，并且调整同样会作为输入反馈到社会中。想象一下股市行情细微的波动曲线，正是每个独立的个体各自不断交易的结果，没有统一的规律可循。而每个人根据整个社会的输入进行独立决策，当某些因素经过多次训练，也会形成宏观上的统计性的规律，这也就是宏观经济学所能看到的。例如每次货币大量发行，最后房价都会上涨，多次训练后，人们也就都学会了。</p>
<p><span style="font-size: 20px">4.8 人工智能需要大数据</span></p>
<p><span style="font-family: SimSun, STSong"> </span></p>
<p>然而神经网络包含这么多的节点，每个节点包含非常多的参数，整个参数量实在是太大了，需要的计算量实在太大，但是没有关系啊，我们有大数据平台，可以汇聚多台机器的力量一起来计算，才能在有限的时间内得到想要的结果。</p>
<p>人工智能可以做的事情非常多，例如可以鉴别垃圾邮件，鉴别黄色暴力文字和图片等。这也是经历了三个阶段的。第一个阶段依赖于关键词黑白名单和过滤技术，包含哪些词就是黄色或者暴力的文字。随着这个网络语言越来越多，词也不断的变化，不断的更新这个词库就有点顾不过来。第二个阶段时，基于一些新的算法，比如说贝叶斯过滤等，你不用管贝叶斯算法是什么，但是这个名字你应该听过，这个一个基于概率的算法。第三个阶段就是基于大数据和人工智能，进行更加精准的用户画像和文本理解和图像理解。</p>
<p>由于人工智能算法多是依赖于大量的数据的，这些数据往往需要面向某个特定的领域(例如电商，邮箱)进行长期的积累，如果没有数据，就算有人工智能算法也白搭，所以人工智能程序很少像前面的IaaS和PaaS一样，将人工智能程序给某个客户安装一套让客户去用，因为给某个客户单独安装一套，客户没有相关的数据做训练，结果往往是很差的。但是云计算厂商往往是积累了大量数据的，于是就在云计算厂商里面安装一套，暴露一个服务接口，比如您想鉴别一个文本是不是涉及黄色和暴力，直接用这个在线服务就可以了。这种形势的服务，在云计算里面称为软件即服务，SaaS (Software AS A Service)</p>
<p>于是工智能程序作为SaaS平台进入了云计算。</p>
<p><span style="font-size: 24px">五、云计算，大数据，人工智能过上了美好的生活</span></p>
<p>终于云计算的三兄弟凑齐了，分别是IaaS，PaaS和SaaS，所以一般在一个云计算平台上，云，大数据，人工智能都能找得到。对一个大数据公司，积累了大量的数据，也会使用一些人工智能的算法提供一些服务。对于一个人工智能公司，也不可能没有大数据平台支撑。所以云计算，大数据，人工智能就这样整合起来，完成了相遇，相识，相知。</p>
</div></div>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[微视能够重获市场？]]></title>
      <url>http://noparkinghere.top/2018/03/11/2018/2018-03-11-%E5%BE%AE%E8%A7%86%E8%83%BD%E5%A4%9F%E9%87%8D%E8%8E%B7%E5%B8%82%E5%9C%BA%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p><strong>以下内容仅代表个人的看法。</strong></p>
<p>微视算是起了个大早赶了个晚集的又一个典型案例了。一般来说互联网公司普遍都很注重先发优势的，优酷和土豆，滴滴和快的都是典型代表。但也不乏失败的案例，个人先发优势确实相当重要，同等实力下先手互联网公司至少领先小半圈，再不济保命肯定没问题（当然也有不少作死的案例）。</p>
<p>个人看来，微视本该可以成为小视频的霸主的。原因至少有两点：</p>
<ul>
<li>微视早在 13 年就开始布局了，14 年更是可以在电视上看到微视的广告，当别的巨头还在想从微信中分一杯羹的时候，腾讯却已经开始布局微视，预感到了移动视频未来的火热。</li>
<li>微视作为腾讯的儿子，不可以说出生不好，至少研发运维宣传流量等都不要过分担心。</li>
</ul>
<p>再来说说微视失败的原因，这个就多了：</p>
<ul>
<li>起的过早，在 4G 网络刚开始商用，宽带等尚未完全普及，入网自费过高的年代，用户能够支付的还只是图片和问题，微视确实做的过早了，比最好的进入时间早了一年半。一般来说，对于创业型公司，熬一熬坚持一把，也许可以走下来，但很遗憾微视作为巨头旗下的某部门的某个业务很显然没有这么大的话语权。</li>
<li>始终未能找到盈利模式，缺乏创新。任何行业想要持续发展都需要不断摸索创新和获利，微视是一个烧钱货，做的够酷，吸引人的地方不够多，在早期拥有一批用户后，后续始终没有大长进。</li>
<li>虽是腾讯的儿子，可惜这个儿子不亲，作为巨头的子业务，有着血统的得天独厚，但却是把双刃剑，腾讯拥有微信、QQ （当年还有微博）等众多软件，在微信出来后连腾讯微博都认为是没价值的产品被砍掉了，微视作为一个试水产品，且短视频功能不断被集成在了微信和 QQ 中，其最终命运显而易见。</li>
<li>任何事情想要做成都需要恒心，腾讯过早地减少对微视的投入，微视在 14 年春节期间获得一定曝光度后，后续就再也没有了动静。且在 15 年，腾讯战略放弃微视。</li>
</ul>
<p>在快手抖音横行的时节微视重新上线有什么意义，腾讯能搅局短视频市场吗？</p>
<p>首先，由于抖音已经拥有了庞大的用户基础和众多视频分享者，基本上可以确定，微视很难再撼动抖音的地位，而快手作为腾讯的投资公司，产生正面冲突的可能性不大。虽然抖音和快手都做短视频，但还是有所差别的，抖音偏向炫（hua）酷（shao），快手偏亲（san）民（su）。用户群体上面也是有所不同，抖音的用户更多是学生、白领；快手则是普通打工者、小城镇居民偏多。</p>
<p>众所周知抖音是今日头条旗下产品，而今日头条和互联网巨头的关系呼之欲出。腾讯重启微视，一方面是想分一杯羹，至少腾讯有着雄厚的研发运维能力，且操控这庞大的流量和用户接口，如果想从对手手中切下一块蛋糕并非难事。另一方面微视会作为腾讯布局短视频邻域和快手的补充，微视重新归来主打着简约、酷炫等，几乎完全和抖音重叠。</p>
<p>腾讯如果下定决定将微视做下去的话，短期内市场环境不会大变，最终结果很难预料，得看腾讯舍得花多大的力气，愿意为微视引入多大的流量，以及今日头条如何见招拆招，还有各自团队创新和宣传能力。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[三目运算符]]></title>
      <url>http://noparkinghere.top/2018/02/01/2018/2018-02-01-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>三目运算符，又称条件运算符，指的是计算机语言（c,c++,java等）的重要组成部分。它是唯一有3个操作数的运算符，所以有时又称为三元运算符。一般来说，三目运算符的结合性是右结合的。</p>
<p>&lt;表达式1&gt; ? &lt;表达式2&gt; : &lt;表达式3&gt;; “?”运算符的含义是：先求表达式 1 的值，如果为真，则执行表达式 2，并返回表达式 2 的结果；如果表达式 1 的值为假，则执行表达式 3，并返回表达式 3 的结果。a ? b : c 简单理解方式为:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(a) </div><div class="line">&#123;     </div><div class="line">	<span class="keyword">return</span> b; </div><div class="line">&#125; <span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>三目运算符的合理使用可以精简话代码，与 if else 比执行效率可以提高约 30% 左右（来自实验数据）。</p>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p>首先必须注意三目运算符中有三个表达式，整体加上 ; 构成一个语句。表达式，是由数字、算符、数字分组符号（括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合，表达式都是有返回值的。</p>
<p><code>return x;</code> 语句无法作为三目运算符的表达式。典型的错误使用如： <code>(a&gt;1)?(return 0):(return 1);</code>。首先，三目运算符后跟的是表达式，而 <code>return x;</code> 为一个完整的语句，不是表达式无返回值；<code>return x</code> 既不是语句也不是表达式。因此 return 无法放到三目运算符中。但有时候为了灵活的使用，我们可以反过来将三目运算符放到 return 语句中。如： <code>return (a&gt;1 ? 0 : 1);</code> 这条语句是合法的，并且也经常被使用。</p>
<p>除此之外，部分编译器在使用三目运算符时，要求表达式 2 和 3 的返回类型一致。具体代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">fun1</span>(void)</div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">fun2</span>(void)</div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">int</span> <span class="selector-tag">fun3</span>(void)</div><div class="line"></div><div class="line">(a&gt;<span class="number">1</span>) ? <span class="selector-tag">fun1</span>() : <span class="selector-tag">fun2</span>();	<span class="comment">// 可行</span></div><div class="line">(a&gt;<span class="number">1</span>) ? (a=<span class="number">1</span>) : (a=<span class="number">2</span>);		<span class="comment">// 可行</span></div><div class="line">(a&gt;<span class="number">1</span>) ? <span class="selector-tag">fun1</span>() : (a=<span class="number">2</span>);		<span class="comment">// 报错</span></div><div class="line">(a&gt;<span class="number">1</span>) ? <span class="selector-tag">fun1</span>() : <span class="selector-tag">fun3</span>();	<span class="comment">// 可行</span></div></pre></td></tr></table></figure>
<p><code>(a&gt;1) ? fun1() : (a=2);</code> 的报错在于 <code>fun1()</code> 返回值为 void 而 <code>a=2</code> 返回值为整型。将两者类型修改为一致，成 <code>(a&gt;1) ? fun1() : (void)(a=2);</code> <code>(a&gt;1) ? fun1() : (void)fun3();</code> 即可编译通过。</p>
<p>有关 return 语句补充说明一点，<code>if (a&gt;1) {return 0}</code> 无法用三目运算符代替，只能用 if 语句来写，而 <code>if (a&gt;1) {a = 1}</code> 则可以用与运算符来写 <code>a&gt;1 &amp;&amp; a=1;</code></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[数据对齐]]></title>
      <url>http://noparkinghere.top/2017/12/22/2017/2017-12-22-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</url>
      <content type="html"><![CDATA[<h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><h2 id="PC-实验"><a href="#PC-实验" class="headerlink" title="PC 实验"></a>PC 实验</h2><p>这边使用的环境为 intel i7， windows 7 ，对齐问题未影响操作结果，只对操作性能有所影响，windows 操作系统下即便不考虑对齐问题，依然可以编译运行成功。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">unsigned char arr[<span class="number">50</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">164</span>, <span class="number">112</span>, <span class="number">157</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</div><div class="line"><span class="type">float</span> a;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  a = *(<span class="type">float</span>*)(&amp;arr[<span class="number">3</span>]);</div><div class="line">  printf(<span class="string">"%f<span class="subst">\n</span>"</span>, a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果: <code>1.230000</code></p>
<h2 id="MCU-下"><a href="#MCU-下" class="headerlink" title="MCU 下"></a>MCU 下</h2><p>MCU 选用 efm32hgxx 和 stm32f4xx 两款不同的芯片，对齐问题均会影响程序的实际运行。</p>
<p>错误代码：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">unsigned char arr[<span class="number">50</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">164</span>, <span class="number">112</span>, <span class="number">157</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line"><span class="type">float</span> *Ptr;</div><div class="line"><span class="type">float</span> tmp;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;   </div><div class="line">  <span class="type">float</span> tmp = *(<span class="type">float</span> *)(&amp;arr[<span class="number">3</span>]);  </div><div class="line">  __nop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误结果：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">仿真报异常，直接跳转到如下：</div><div class="line"><span class="symbol">HardFault_Handler</span>\</div><div class="line">                <span class="meta">PROC</span></div><div class="line">                <span class="meta">EXPORT</span>  HardFault_Handler          [WEAK]</div><div class="line">                <span class="keyword">B </span>      .</div><div class="line">                <span class="meta">ENDP</span></div><div class="line"></div><div class="line">仿真器查看：</div><div class="line"><span class="symbol">arr</span> 地址： <span class="number">0x20000000</span></div></pre></td></tr></table></figure>
<p>分析可知，问题出在 &amp;arr[3] 地址为 0x20000003，不为 4 的整数倍，不对齐，MCU 无法正确将该段地址解析成 float 等类型。解决这类问题，我们可以用 <code>__align(x)</code> 函数强制要求起始位置对齐，<code>__align(4)</code> 可以让变量对齐到 4 的整数倍地址。</p>
<h2 id="ARM-下的对齐"><a href="#ARM-下的对齐" class="headerlink" title="ARM 下的对齐"></a>ARM 下的对齐</h2><p>使用 <code>__align(num)</code> 可以强制让数据或类型对齐，这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时就要用到此命令<strong>align(8)进行修饰限制，来保证数据对象是相应对齐。这个修饰对象的命令最大是8个字节限制,可以让2字节的对象进行4字节对齐,但是不能让4字节的对象2字节对齐。</strong>align是存储类修改,他只修饰最高级类型对象，不能用于结构或者函数对象。</p>
<p>比如：__align(4) u8 mem1base[MEM1_MAX_SIZE];//保证分配的数组空间4字节对齐，同时保证数组首地址可被4整除</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">如果需要将数组中任意位置开始的一段转换为某类型的话，可以有多种方法，可以通过中间量数组，强制转化。</div><div class="line"></div><div class="line"><span class="comment">// 方法1，使用中间量数组，强制四字节对齐</span></div><div class="line"></div><div class="line">unsigned char arr[<span class="number">50</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">164</span>, <span class="number">112</span>, <span class="number">157</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</div><div class="line">__align(<span class="number">4</span>) unsigned char arrbuf[<span class="number">4</span>];   <span class="comment">// 注意对齐，否则仍会出错</span></div><div class="line"><span class="type">float</span> tmp;</div><div class="line">int main(void)</div><div class="line">&#123;   </div><div class="line">  for (int i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</div><div class="line">  &#123;</div><div class="line">    arrbuf[i] = arr[<span class="number">3</span>+i];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  tmp = *(<span class="type">float</span> *)&amp;arrbuf[<span class="number">0</span>];</div><div class="line">  __nop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法2，使用中间量 float 类型数据（本身就会对齐四字节），对该数据的各个位强制赋值</span></div><div class="line"></div><div class="line">typedef unsigned char u8;</div><div class="line">u8 arr[<span class="number">50</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">164</span>, <span class="number">112</span>, <span class="number">157</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</div><div class="line"><span class="type">float</span> res;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  for (int i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</div><div class="line">  &#123;</div><div class="line">    *((u8*)&amp;res+i) = arr[<span class="number">3</span>+i];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">采用上述操作后，可以看到 arrbuf 地址变成了 <span class="number">0x20000034</span>，再次取地址转换时，就可以成功了。</div></pre></td></tr></table></figure>
<h2 id="ARM-一字节对齐"><a href="#ARM-一字节对齐" class="headerlink" title="ARM 一字节对齐"></a>ARM 一字节对齐</h2><p><strong>packed   
</strong>packed是进行一字节对齐<br>1.不能对 packed 的对象进行对齐<br>2.所有对象的读写访问都进行非对齐访问<br>3.float及包含float的结构联合及未用<strong>packed的对象将不能字节对齐<br>4.</strong>packed对局部整形变量无影响<br>5.强制由unpacked对象向packed对象转化是未定义,整形指针可以合法定义为packed。<br><code>__packed int* p;  //__packed int 则没有意义</code><br>6.对齐或非对齐读写访问带来问题</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//定义如下结构此时b的起始地址一定是不对齐的  </div><div class="line">//在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from <span class="built_in">CL</span>]  </div><div class="line">//将下面变量定义成全局静态不在栈上</div><div class="line">__packed struct STRUCT_TEST  </div><div class="line">&#123;  </div><div class="line">  char a<span class="comment">;  </span></div><div class="line">  <span class="keyword">int</span> b<span class="comment">;  </span></div><div class="line">  char c<span class="comment">;  </span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line">static char* p<span class="comment">;  </span></div><div class="line">static struct STRUCT_TEST a<span class="comment">;  </span></div><div class="line"></div><div class="line">void Main()  </div><div class="line">&#123;  </div><div class="line">    __packed <span class="keyword">int</span>* q<span class="comment">;  //此时定义成 __packed 来修饰当前 q 指向为非对齐的数据地址下面的访问则可以  </span></div><div class="line"></div><div class="line">    p = (char*)&amp;a<span class="comment">;            </span></div><div class="line">    q = (<span class="keyword">int</span>*)(p+<span class="number">1</span>)<span class="comment">;        </span></div><div class="line"></div><div class="line">    *q = <span class="number">0x87654321</span><span class="comment">;   </span></div><div class="line">    </div><div class="line">/*     </div><div class="line">得到赋值的汇编指令很清楚  </div><div class="line">ldr      <span class="built_in">r5</span>,<span class="number">0x20001590</span> <span class="comment">; = #0x12345678  </span></div><div class="line">[<span class="number">0xe1a00005</span>]   <span class="keyword">mov</span>      <span class="built_in">r0</span>,<span class="built_in">r5</span>  </div><div class="line">[<span class="number">0xeb0000b0</span>]   <span class="built_in">bl</span>       __rt_uwrite4  //在此处调用一个写4<span class="built_in">byte</span>的操作函数   </div><div class="line">        </div><div class="line">[<span class="number">0xe5c10000</span>]   strb     <span class="built_in">r0</span>,[<span class="built_in">r1</span>,#<span class="number">0</span>]   //函数进行<span class="number">4</span>次strb操作然后返回保证了数据正确的访问  </div><div class="line">[<span class="number">0xe1a02420</span>]   <span class="keyword">mov</span>      <span class="built_in">r2</span>,<span class="built_in">r0</span>,lsr #<span class="number">8</span>  </div><div class="line">[<span class="number">0xe5c12001</span>]   strb     <span class="built_in">r2</span>,[<span class="built_in">r1</span>,#<span class="number">1</span>]  </div><div class="line">[<span class="number">0xe1a02820</span>]   <span class="keyword">mov</span>      <span class="built_in">r2</span>,<span class="built_in">r0</span>,lsr #<span class="number">16</span>  </div><div class="line">[<span class="number">0xe5c12002</span>]   strb     <span class="built_in">r2</span>,[<span class="built_in">r1</span>,#<span class="number">2</span>]  </div><div class="line">[<span class="number">0xe1a02c20</span>]   <span class="keyword">mov</span>      <span class="built_in">r2</span>,<span class="built_in">r0</span>,lsr #<span class="number">24</span>  </div><div class="line">[<span class="number">0xe5c12003</span>]   strb     <span class="built_in">r2</span>,[<span class="built_in">r1</span>,#<span class="number">3</span>]  </div><div class="line">[<span class="number">0xe1a0f00e</span>]   <span class="keyword">mov</span>      pc,<span class="built_in">r14</span>  </div><div class="line">*/  </div><div class="line"></div><div class="line">/*  </div><div class="line">如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败  </div><div class="line">[<span class="number">0xe59f2018</span>]   ldr      <span class="built_in">r2</span>,<span class="number">0x20001594</span> <span class="comment">; = #0x87654321  </span></div><div class="line">[<span class="number">0xe5812000</span>]   <span class="keyword">str</span>      <span class="built_in">r2</span>,[<span class="built_in">r1</span>,#<span class="number">0</span>]  </div><div class="line">*/  </div><div class="line">    //这样可以很清楚的看到非对齐访问是如何产生错误的  </div><div class="line">    //以及如何消除非对齐访问带来问题  </div><div class="line">    //也可以看到非对齐访问和对齐访问的指令差异导致效率问题  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：对于上述 char 类型转换为 float，无法通过 <strong>packed 执行，因为 </strong>packed 无法对 float 操作，而如果是 32 位整型则可以通过 __packed 来字节对齐。</strong></p>
<blockquote>
<p>参考链接：<br><a href="https://www.cnblogs.com/King-Gentleman/p/5940480.html" target="_blank" rel="external">https://www.cnblogs.com/King-Gentleman/p/5940480.html</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[英语语法--倒装句]]></title>
      <url>http://noparkinghere.top/2017/10/27/2017/2017-10-27-%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%80%92%E8%A3%85%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h2 id="否定型倒装"><a href="#否定型倒装" class="headerlink" title="否定型倒装"></a>否定型倒装</h2><ul>
<li>在正式文体中，如果将 never, seldom, rarely, little, hardly, scarcely, no sooner, no longer, nowhere 等含有否定意义的副词若位于句首，则其后的句子要用部分倒装。如：</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">后来我再也没见到过他了。</div><div class="line">I never saw him again.</div><div class="line">→Never did I see him again.</div><div class="line"></div><div class="line">他很少出去吃饭。</div><div class="line"><span class="keyword">He</span> seldom goes <span class="keyword">out</span> <span class="keyword">for</span> dinner.</div><div class="line">→Seldom does <span class="keyword">he</span> go <span class="keyword">out</span> <span class="keyword">for</span> dinner.</div><div class="line"></div><div class="line">她几乎没时间听音乐。</div><div class="line"><span class="keyword">She</span> hardly has time to listen to music.</div><div class="line">→Hardly does <span class="keyword">she</span> have time to listen to music.</div><div class="line"></div><div class="line">他几乎没有认识到他面临的危险。</div><div class="line"><span class="keyword">He</span> little realized the danger <span class="keyword">he</span> faced.</div><div class="line">→Little did <span class="keyword">he</span> realize the danger <span class="keyword">he</span> faced.</div></pre></td></tr></table></figure>
<ul>
<li>对于 not…until 句型，当 not until… 位于句首时，其后的主句要用倒装语序。如：</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">雨停了之后他才离开这房间。</div><div class="line">He didn’t leave <span class="keyword">the</span> room <span class="keyword">until</span> <span class="keyword">the</span> rain stopped.</div><div class="line">→Not <span class="keyword">until</span> <span class="keyword">the</span> rain stopped did he leave <span class="keyword">the</span> room.</div></pre></td></tr></table></figure>
<ul>
<li>某些起副词作用的介词短语，由于含有否定词，若位于句首，其后要用部分倒装。如：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">On <span class="literal">no</span> accounts must <span class="keyword">this</span> <span class="keyword">switch</span> be touched. 这个开关是绝不能触摸的。</div><div class="line">In [Under] <span class="literal">no</span> circumstances will I lend money <span class="keyword">to</span> him.无论如何我也不会再借钱给他了。</div></pre></td></tr></table></figure>
<h2 id="only-型倒装"><a href="#only-型倒装" class="headerlink" title="only 型倒装"></a>only 型倒装</h2><p>当一个状语受副词only的修饰且置于句首时，其后用部分倒装语序。如：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Only <span class="keyword">in</span> <span class="keyword">this</span> way can we learn English. 只有这样才能学会英语。</div><div class="line">Only <span class="keyword">then</span> did I understand what she meant. 只有到那时我才明白她的意思。</div><div class="line">Only <span class="keyword">for</span> the love <span class="keyword">of</span> his family does he <span class="keyword">do</span> such hard work. 只为了他对家庭的爱，他做这么辛苦的工作。</div></pre></td></tr></table></figure>
<h2 id="so-型倒装"><a href="#so-型倒装" class="headerlink" title="so 型倒装"></a>so 型倒装</h2><ul>
<li>当副词so后接形容词或副词位于句首时，其后通常用部分倒装。如：</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">So cold was <span class="keyword">the</span> weather <span class="keyword">that</span> we had <span class="keyword">to</span> stay <span class="keyword">at</span> home. 天气太冷，我们只好呆在家里。</div><div class="line">So fast <span class="keyword">does</span> light travel <span class="keyword">that</span> we can hardly imagine <span class="keyword">its</span> speed. 光速很快，我们几乎没法想象它的速度。</div><div class="line">So sudden was <span class="keyword">the</span> attack <span class="keyword">that</span> we had no <span class="built_in">time</span> <span class="keyword">to</span> escape. 袭击来得非常突然，我们来不及逃跑。</div></pre></td></tr></table></figure>
<ul>
<li>以 so 开头的句子还有这样一种倒装——表示前面提出的某一肯定的情况也同样适合于后者，这类倒装的基本结构是“so+助动词+主语”。如：</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">You are young and <span class="keyword">so</span> am I. 你年轻，我也年轻。</div><div class="line"><span class="keyword">She</span> likes music and <span class="keyword">so</span> <span class="keyword">do</span> I. 她喜欢音乐，我也喜欢。</div><div class="line"><span class="keyword">If</span> <span class="keyword">he</span> can <span class="keyword">do</span> it, <span class="keyword">so</span> can I. 要是他能做此事，我也能。</div></pre></td></tr></table></figure>
<h2 id="not-only-型倒装"><a href="#not-only-型倒装" class="headerlink" title="not only 型倒装"></a>not only 型倒装</h2><p>当not only…but also位于句首引出句子时，not only 后的句子通常用部分倒装形式。如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Not only is <span class="keyword">he</span> a teacher, but <span class="keyword">he</span> is also a poet. 他不仅是一位教师，而且是一位诗人。</div><div class="line">Not only did <span class="keyword">he</span> speak <span class="keyword">more</span> correctly, but <span class="keyword">he</span> spoke <span class="keyword">more</span> easily. 不仅他讲得更正确，也讲得更不费劲了。</div></pre></td></tr></table></figure>
<h2 id="省略连词-if-采用倒装的非真实条件句"><a href="#省略连词-if-采用倒装的非真实条件句" class="headerlink" title="省略连词 if 采用倒装的非真实条件句"></a>省略连词 if 采用倒装的非真实条件句</h2><p>在书面语中，条件从句可以不用连词 if, 而将谓语中的过去式移至主语之前，构成倒装。因此，当虚拟条件句的谓语部分含有 were, should, had 时，我们可以将连词if省略掉，而将它们置于句首其他成分不变。如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">如果是她负责，她会是另一种做法。</div><div class="line"><span class="keyword">If</span> <span class="keyword">she</span> were <span class="keyword">in</span> charge, <span class="keyword">she</span> would <span class="keyword">do</span> things differently.</div><div class="line">→Were <span class="keyword">she</span> <span class="keyword">in</span> charge, <span class="keyword">she</span> would <span class="keyword">do</span> things differently. </div><div class="line"></div><div class="line">万一你改变主意，谁也不会怨你。</div><div class="line"><span class="keyword">If</span> you should change your mind, <span class="keyword">no</span> <span class="keyword">one</span> would blame you.</div><div class="line">→Should you change your mind, <span class="keyword">no</span> <span class="keyword">one</span> would blame you. </div><div class="line"></div><div class="line">如果资方早些采取行动，就不会发生罢工了。</div><div class="line"><span class="keyword">If</span> the management had acted sooner, the strike wouldn’t have happened.</div><div class="line">→Had the management acted sooner, the strike wouldn’t have happened.</div></pre></td></tr></table></figure>
<p>参考链接：</p>
<blockquote>
<p><a href="http://www.yygrammar.com/Article/201112/2737.html" target="_blank" rel="external">http://www.yygrammar.com/Article/201112/2737.html</a><br><a href="http://www.360doc.com/content/14/0519/07/418127_378925640.shtml" target="_blank" rel="external">http://www.360doc.com/content/14/0519/07/418127_378925640.shtml</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTPS介绍]]></title>
      <url>http://noparkinghere.top/2017/10/18/2017/2017-10-18-https%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>看到一篇浅显易懂的 HTTPS 文章，<a href="https://juejin.im/post/59e4c02151882578d02f4aca" target="_blank" rel="external">谈谈 HTTPS 原文链接</a>，文章描述的技术细节较少，但能够大致了解 HTTPS 的原理，可以参考学习下。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>http://noparkinghere.top/2017/10/14/2017/2017-10-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>正则表达式(regular expression，通常写出 regex 或 re)描述了一种字符串匹配的模式（pattern，man 文档中出现 pattern 则代表可以使用正则表达式），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。其最常见的应用就是搜索字符串，经常用于搜索-替换操作。</p>
<p>linux 中 grep（Globally search a Regular Expression and Print，本身命令就是正则表达工具）、less、sed、vi 等诸多命令都可以使用正则表达式，另外正则表达式也可以用于许多编程语言，如： awk、C、C++、java、python等。</p>
<h2 id="基本和扩展正则表达式"><a href="#基本和扩展正则表达式" class="headerlink" title="基本和扩展正则表达式"></a>基本和扩展正则表达式</h2><h2 id="一般语法规则"><a href="#一般语法规则" class="headerlink" title="一般语法规则"></a>一般语法规则</h2><h2 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h2><blockquote>
<p>参考链接：<br><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="external">http://www.runoob.com/regexp/regexp-syntax.html</a><br><a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="external">http://linux.vbird.org/linux_basic/</a><br>《unix&amp;linux 大学教程》<br>《鸟哥linux私房菜》</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[为何要写博客？]]></title>
      <url>http://noparkinghere.top/2017/10/14/2017/2017-10-14-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>这段时间，看了很多人技术达人的博客，他们往往文笔精炼，内容深入浅出。也正因为如此，一度让我觉得是否自己还有写博客的必要，毕竟人家写的已经很详尽，基本能够解决读者的困惑，我直接收藏就行了，有没有必要再自己整理书写？</p>
<p>这一晃，一两个月过去了，这段时间都没有好好书写博客，一方面似乎很忙，学习收获跟不上博客更新的进度；另外写博客比较耗时间，往往比学习花的时间还长，写着写着就偷懒了；最主要的原因还是开头说的那样，心底似乎认为没有必要再重复整理。</p>
<p>这两天反省了下，从任何角度来说，坚持写博客都是必须的，上面的犹豫都是杞人忧天，自取烦恼。</p>
<h3 id="博客是对自己学习进步的鞭策，对现阶段的总结"><a href="#博客是对自己学习进步的鞭策，对现阶段的总结" class="headerlink" title="博客是对自己学习进步的鞭策，对现阶段的总结"></a>博客是对自己学习进步的鞭策，对现阶段的总结</h3><p>因为需要写博客，需要更新内容，往往迫使自己读更多的书，学更多的东西，体验更多的生活，只有如此你才可以写出有意义的文章。向来我将质量放在第一位考虑，要么不做要做就一定做好，因此，养成写博客的习惯能够督察我学习进步，想来刚开始写博客的那段时间，也是我最积极去学习探索的时间。</p>
<h3 id="不写永远也不会有写作的提高"><a href="#不写永远也不会有写作的提高" class="headerlink" title="不写永远也不会有写作的提高"></a>不写永远也不会有写作的提高</h3><p>很羡慕那些大神的博客，思路清晰，文笔简练，内容深入浅出，在被阮一峰老师那种清晰明了的技术博客震惊后，更是觉得自己写的文章实在不能看，曾经也研究过一段时间写作，但总是不得要领。</p>
<p>太急于求成一定不是好事，虽然我底子差离终点还很远，但至少我已经在路上，相信夜以继日一定会有所提高的，在合适的时间遇到某个经验的总结，也许我会一朝顿悟。</p>
<h3 id="博客是自己的名片"><a href="#博客是自己的名片" class="headerlink" title="博客是自己的名片"></a>博客是自己的名片</h3><p>作为一个技术从业者，博客可以说是我的名片，技术一直在更新，我写的内容也可能马上就会过时，但探索研究的初心不该变，是否善于思考总结也是评价一个技术人员能力的关键。</p>
<h3 id="别人的终究不是自己的"><a href="#别人的终究不是自己的" class="headerlink" title="别人的终究不是自己的"></a>别人的终究不是自己的</h3><p>世界上没有完全相同的两个人，别人的只是别人的，终究不是自己的，所有最适合自己的一定是经过自己加工总结的，过去我一直有一个误区，认为别人已经写的完美了，各方面都好，自己直接加个书签拿来用即可。仔细想来事实不尽如此，世上没有任何东西是完美的，浅显易懂的内容必定不够深入，太深奥的文章可能很多细节没有说陈述清楚，即便深入浅出的文章也可能在实践上有所不足。</p>
<p>如果一些内容我只是临时需要使用下，那我直接转载/收藏别人的文章即可，但如果需要深入理解学习的话，那我一定需要参考大量书籍和文章取长补短，最终才可能写出满意的内容。除此之外，只有经过自己提取总结再学习的内容才可能真正被掌握。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）Vim配置、插件和使用技巧]]></title>
      <url>http://noparkinghere.top/2017/10/13/2017/2017-10-13-%EF%BC%88%E8%BD%AC%EF%BC%89vim%E9%85%8D%E7%BD%AE%E3%80%81%E6%8F%92%E4%BB%B6%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>vim 研究了好一段时间，始终没有找到一篇能够清晰的指导配置 vim 的教程，网上的教程看了很多基本可以分为两类：</p>
<ul>
<li>对基础的命令操作介绍的特别详细，但却没有告诉你如何安装使用插件，这往往是做服务器运维的人所需要的。</li>
<li>已经将 vim 配置的很成功，github 提供了一键式安装脚本等，但除了安装外，并没有清楚告诉你他是怎么配置的。</li>
</ul>
<p>这边终于找到一个通俗易懂的 vim 配置教程，<a href="http://www.jianshu.com/p/a0b452f8f720" target="_blank" rel="external">详细原文</a>。</p>
<p>以下内容是自己的一些总结。</p>
<hr>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[读后感-人类简史]]></title>
      <url>http://noparkinghere.top/2017/10/11/2017/2017-10-11-%E8%AF%BB%E5%90%8E%E6%84%9F-%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
      <content type="html"><![CDATA[<p>断断续续前后可能花了几个月时间终于把《人类简史》读完了，之所以读的这么慢，并不是书写的不好，恰恰相反书写的很棒，主要因为个人这段时间比较忙，没有大片的时间，加上阅读这类书籍思考的比较多，每次阅读都要花较长时间才能进入状态。</p>
<p>整本书写的相当精彩，翻译的也特别到位，</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-战狼]]></title>
      <url>http://noparkinghere.top/2017/10/11/2017/2017-10-11-%E5%BD%B1%E8%AF%84-%E6%88%98%E7%8B%BC/</url>
      <content type="html"><![CDATA[<p>这部影片刚上映的时候就去看了，近来较忙，虽然在一些论坛上发表了自己关于该片的看法，但始终没有下笔。</p>
<p>说战狼值不值得看，那答案应该说是肯定的。虽然影片有着诸多的不足，但主题迎合中国观众、作品也狗良心，虽然被资本市场过度的炒作，但仍然是一部值得一看的作品。</p>
<p>整体来看，这部作品我可以给到 8 分，其中 7 分是基础分，1 分算是鼓励分（中国电影终于可以开始进入大片市场了）。</p>
<p>该片也是有着众多可圈可点之处的，比如：</p>
<ul>
<li>不像好莱坞电影过份去强调个人英雄主义，好莱坞主角光环强到爆炸，一个人摧毁一个军团，正义方基本从来不死人，可能很多人仍然吃这一套，但我从复联2出来后就彻底审美疲劳了。</li>
<li>场景也表现的不错，好莱坞电影普遍只见到爆破，看不到尸首，这就很纳闷，每次只见到人逃跑，其余的就都被活埋了？</li>
<li>好莱坞套路中令人恶心的主角为了救一个妇孺可以不顾大局，无视其他人的生死，本片基本没有这种情节，主角只是顺带救助某个人。</li>
<li>情节，文化，思想等也更加符合中国人的价值观，因此收到资本市场的热捧也是情理之中。</li>
<li>逻辑上还是合乎情理的，比如一开始反动势力撤军，我同伴就问我为啥撤，后来证明和我猜测一致。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不足的地方还是有不少的，比如张翰这个角色就满满的违和感，前面表现还是不错的，复合角色特征，后面无任何过度的情况下，突然就牛逼起来了，编剧逗我？</li>
<li>最后的坦克场景更是像真人秀，表现的还不如两辆汽车碰撞吸引眼球，可以看出制作水准和国外还有不小的差距。</li>
<li>也许是经费不足的原因，很多内容没表现的好，过度也较为突兀，和战狼1相比，明显可以感觉2拍的有点拖沓。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[失控]]></title>
      <url>http://noparkinghere.top/2017/08/30/2017/2017-08-31-%E5%A4%B1%E6%8E%A7/</url>
      <content type="html"><![CDATA[<p>这段时间，自我改变和提高自控力的过程，差不多从四月初开始的，前后也差不多养成并且实现了：晚上学习，seven，跑步，写作，冥想等任务，从一开始的写作，seven到后来能够每天胜任这么多任务，5个月时间总体来讲还是不错的，但潜在的问题一直没被重视，这边来总结一下，最近一周多的失控过程。</p>
<p>几个月的努力，已经让我具备了一定的自控能力，即便中途会有一两天间断，但基本都是可以轻松的回归的，这次失控也不例外，中途也是有多次完成了任务，但自己更想要看看失控的一个过程，方便更好的自控和认识自己，然而一旦失控了时间过长，想要回归，貌似就不是那么轻松了，原计划是一周时间，但现在看来已经有超过10天了，很多东西不再那么游刃有余了。</p>
<h2 id="失控原因"><a href="#失控原因" class="headerlink" title="失控原因"></a>失控原因</h2><h3 id="习惯未成自然"><a href="#习惯未成自然" class="headerlink" title="习惯未成自然"></a>习惯未成自然</h3><p>看似我已经有了超过 100 天的实践，但实际因为不断的添加任务，最新一次任务计划只有 20 天不到。</p>
<p>另外，虽然有 21 天养成 xx 的说法，但这只是第一步，每个人的习惯适应期并不同（100-360都有可能），根据我以往所做的事情分析，我的适应期应该在 250 天左右。</p>
<p>所以这次失控最本质上还是自己需要消耗力量去对抗，并没能够做到像睡觉吃饭那么随意。</p>
<h3 id="形势把控失误"><a href="#形势把控失误" class="headerlink" title="形势把控失误"></a>形势把控失误</h3><p>早在这次大失控之前，其实已经出现端倪了，之前有一段时间的写作，后来安排一周写作一次，总的来说还是较为合理的，但由于多方面原因（队友跑了，自己感觉没什么写，学习安排繁重，想要完成任务后写个大的等等），最终在完成多篇后，没有坚持下来，自己对这件事没有高度重视，其实这已经算是失控的开始了。</p>
<p>中间一直有运动，运动确实带来了不少改变，我也从中受益很多，原计划是每周跑步 3 次，但最终完成情况，却是每周经常只完成了两次。虽然其中有一定的天气因素，但更多是自身的问题，完全可以更加弹性的安排运动时间，而不该拖沓到指定的某天。</p>
<h3 id="没有良好习惯"><a href="#没有良好习惯" class="headerlink" title="没有良好习惯"></a>没有良好习惯</h3><p>一直以来，我睡的太晚都是因为任务没有完成，随着任务的加大，更应该合理的安排任务的进程，将过往的任务更加合理的安排出特定的执行时间，而不是进程拖到深夜。</p>
<p>拖沓到最后，很显然会带来很多个消极影响：</p>
<ul>
<li>睡觉越来越晚，影响休息时间</li>
<li>睡觉前仍在工作，不容易入眠，更容易焦虑，影响睡眠质量</li>
<li>任务完成品质不高，很容易为了完成而偷工减料</li>
<li>不容易养成习惯，因为有的任务不适合睡前做，很容易最终放弃</li>
<li>无法将一些计划任务合理的利用，比如运动冥想放在睡前往往不能利用他们完成后带来的好处</li>
</ul>
<h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><p>一直以来，我都觉得心态是能够坚持下来的最主要因素。先不说你完成的质量如何，但凡半途而废的，一般都是心态爆炸了。一个良好乐观的心态最起码能够支撑你坚持下去，而如果你只看到困难大，事情多，时间少，自己完成不了等等，最终你会被恐惧打败，而不是被任务本身。</p>
<h3 id="任务过重"><a href="#任务过重" class="headerlink" title="任务过重"></a>任务过重</h3><p>任务过重是本次大失控的导火索，一个只能抗 100 斤的人，硬压了 300 斤，最终他被压垮了。任务为何过重，很显然还是评估不足，未能掌握正确的信息：</p>
<ul>
<li>对自己能力评估过高，以为可以连续学习 3-4 小时满效率运作，但实际效率低下，只有 50% 左右的有效能耗。已具备的能力过度评估，如：背 6000 个单词，认为已经掌握了 3000，但实际只掌握了 2000 不到。</li>
<li>对时间太有信心，实际白天上班工作，早晚的学习时间只是刚刚好能够达到任务的底线时间</li>
<li>任务强度的评估不足，如：认为总共学习单词为 6500+，后来算下来是 7463 个，分配到每天就得多学 40 个单词，而往往就是最后这几十个成为无法逾越的屏障</li>
</ul>
<h2 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h2><h3 id="养成习惯"><a href="#养成习惯" class="headerlink" title="养成习惯"></a>养成习惯</h3><p>在固定的时间做固定的事情，这样不会需要到深夜查漏补缺，也不会给夜间留下太多负担。</p>
<h3 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h3><p>设想下完成任务之后的成就感；想象下完成之后，你就可以做什么，能够达到什么样的高度；另外安排的合理的奖惩游戏也有助于构建成就感。</p>
<h3 id="合理安排任务"><a href="#合理安排任务" class="headerlink" title="合理安排任务"></a>合理安排任务</h3><p>在正确的时间做正确的事情，安排任务前做足信息采集工作，尽可能的避免错误信息，任务安排具备弹性，每天给足至少 1h 左右的余量。</p>
<ul>
<li>每天优先完成例行安排，如运动、冥想、作息等，这些时间点，无特殊情况不能改变。</li>
<li>每个任务如果超时了，则最多多做 0.5h，遇到上面的例行安排，则例行安排完成后，接着上面的任务，任务超时 0.5h 仍未完成，则放弃该任务，视为未完成，做接下来其他的任务，后续根据情况对该完成任务进行重新评估修改。</li>
</ul>
<h3 id="不放弃的自我暗示"><a href="#不放弃的自我暗示" class="headerlink" title="不放弃的自我暗示"></a>不放弃的自我暗示</h3><p>既然已经完成了一小半，离最终目标也不远了；已经完成了一半，如果放弃就意味着前面所有的努力都白费了。</p>
<h3 id="谨小慎微"><a href="#谨小慎微" class="headerlink" title="谨小慎微"></a>谨小慎微</h3><p>勿以恶小而为之，一个小事的失控，后面可能会自尝苦果，可以偶尔的偷懒一次，但绝不能因为任何理由一下子放弃某个小习惯或者小目标。</p>
<ul>
<li>一次的放纵，后面的任务和时间表就都会受到影响，一旦受影响就很难完成，得花更多的精力。</li>
<li>现在的努力，一般短期内都会见到成效，而现在的懈怠，经常会面临需要用时，发现无法交货。</li>
</ul>
<h3 id="及时调整"><a href="#及时调整" class="headerlink" title="及时调整"></a>及时调整</h3><p>任务无法完成时，绝对不能硬脱。认识到任务无法完成时，你已经在超负荷运行了，超负荷运行这边并不提倡，如果这时候，还需要进一步加大马力，无疑会崩溃。遇到这种情况，应该休整一晚上，放弃目前的计划，第二天拟定出更适合自己的新计划，重新开始。信息的不充分是阻止任务完成的首要因素，有时候放弃也是一种前进。</p>
<h3 id="及时调整心态"><a href="#及时调整心态" class="headerlink" title="及时调整心态"></a>及时调整心态</h3><p>心态在任务中占到一半的比重，恐惧焦虑阻挡了大多数人前进。</p>
<p>庆幸的是，我找到了较好的调整方法：</p>
<ul>
<li>运动：如无特殊情况，每天慢跑 3-5KM</li>
<li>冥想：小睡后以及睡觉前，例行冥想</li>
<li>睡觉：中午小歇片刻不超过 20min，夜间睡眠在 7h 左右</li>
<li>娱乐：娱乐和工作学习一样重要，一般如无特殊情况，绝不剥夺每周六的娱乐放松时间</li>
</ul>
<h2 id="时间表"><a href="#时间表" class="headerlink" title="时间表"></a>时间表</h2><h3 id="工作日"><a href="#工作日" class="headerlink" title="工作日"></a>工作日</h3><ul>
<li>6:30 起床，喝水，一组 seven，外出散步</li>
<li>7:00-8:00 阅读，英语</li>
<li>8:15-12:00 工作</li>
<li>12:00-12:20 午餐</li>
<li>12:20-12:30 散步，晒太阳</li>
<li>12:30-12:45 nap</li>
<li>13:00-17:00 工作</li>
<li>17:00-17:20 nap</li>
<li>17:20-17:30 冥想</li>
<li>17:30-18:30 英语</li>
<li>18:30-19:30 晚餐，扇贝英语，快速复习之前学习的专业知识</li>
<li>19:30-20:00/20:30 跑步运动半小时以上</li>
<li>20:00/20:30-23:00 专业知识研究（22:00 洗澡）</li>
<li>23:00-23:30 不再安排任何学习任务，打卡总结，喝杯热牛奶，冥想等，酝酿休息</li>
<li>23:30 休息</li>
</ul>
<h3 id="假期"><a href="#假期" class="headerlink" title="假期"></a>假期</h3><ul>
<li>周六上午完成相关任务，如：英语，运动，专业学习</li>
<li>周六下午晚上娱乐休息，一周的放松时间，但注意，周六晚上前必须完成一篇周文章</li>
<li>周日正常工作学习，弥补本周未完成的任务</li>
</ul>
<p><em>任何时候都有必要劳逸结合，无论任务多紧，都不该剥夺晚上休息和周末放松时间，不给过大的压力，才能保持良好心态，也才会有足够的自控力。</em></p>
<h2 id="奖惩措施"><a href="#奖惩措施" class="headerlink" title="奖惩措施"></a>奖惩措施</h2><p>初始分数 0，每完成一个例行任务（日任务上限为 3） +1，未完成 -2；完成一个小目标（周任务） +5，未完成 -5；完成一个大目标（月任务）可晚两天完成 +10，放弃 -5，超时完成 +5；完成一个挑战（数月或半年的任务） +20，未完成不扣分。</p>
<p>在不正确的时间内（非假日休息时间），每做一件错事（如玩游戏，看电影，去网吧等），-5。</p>
<p>满 100 分，奖励自己一个想要的东西，分数为负，做额外惩罚，如：一周晚餐只喝粥，周六跑步 10 公里等。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Plan2017(下)-(3)]]></title>
      <url>http://noparkinghere.top/2017/08/30/2017/2017-08-28-Plan2017(%E4%B8%8B)-(3)/</url>
      <content type="html"><![CDATA[<p><strong>整体计划参照总纲，每阶段做的事情按照后面的细则来执行，尽量合理安排，让工作学习计划更加弹性，每个周期安排的任务少、时间尽可能的多以保证不会被一些事情所打算；一定要做好充足的休息和锻炼，计划的初衷是生活学习习惯的培养，因此优先多喝水，锻炼和休息。</strong></p>
<p><strong>经过一个多月来的实践，其中有一半的任务完成不错，另外仍然有很多比较局限或者不得要领。接下来一段时间准备实践一套英语学习法，由于占用的时间比较多，因此计划会有很大的调整，目标是将这套学习法较好的实现，并且通过它，找到真正适合自己的学习套路。</strong></p>
<h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p>在保证充足的休息和定期锻炼的前提下，更好的合理安排工作和学习，每天 10:00 后不额外安排新任务，所有工作学习任务确保 10:30 之前完成。</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>阅读多本畅销书籍，类型可以是：历史、时间管理、学习方法、经典小说、个人传记等。</p>
<p>主要阅读时间在：清晨 15 min，饭后 15min，睡前 15 min。</p>
<h3 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h3><p>无特殊情况下，工作日上午 7:30-8:00 ，晚上 5:00-6:00 作为英语的固定学习时间，完成的内容包括且不仅限于如下：</p>
<ul>
<li>《GRE 词汇精选》</li>
<li>《语法俱乐部》</li>
<li>《恋恋有词》 </li>
<li>英文小说阅读</li>
<li>扇贝英语阅读，单词等</li>
</ul>
<h3 id="计算机学习"><a href="#计算机学习" class="headerlink" title="计算机学习"></a>计算机学习</h3><p>由于之前执行效率不高，新任务加入等问题，计算机的学习计划全面挪后。</p>
<ul>
<li>C 语言基础回顾</li>
<li>详细研习 linux 的应用教程</li>
<li>数据结构和算法</li>
<li>深入研究学习 linux 程序开发</li>
<li>C++ 详细研究学习，掌握 Qt 的开发要领，设计多个程序</li>
</ul>
<h3 id="工作任务-充分利用工作时间，尽量不加班"><a href="#工作任务-充分利用工作时间，尽量不加班" class="headerlink" title="工作任务 (充分利用工作时间，尽量不加班)"></a>工作任务 (充分利用工作时间，尽量不加班)</h3><ul>
<li>进一步研究 EFM32 平台以及硬件软件内容，家用表研发项目推进</li>
<li>神舟开 stm32 案例整理，将 stm32 相关知识应用到家用表项目中(8.1-11.30)</li>
<li>仔细研究操作系统相关内容，ucos 内容整理研究(9.1-11.30)</li>
<li>研究 6S 项目(12.1-12.31)</li>
</ul>
<h3 id="作息-每晚保证-7h-以上的睡眠时间"><a href="#作息-每晚保证-7h-以上的睡眠时间" class="headerlink" title="作息 (每晚保证 7h 以上的睡眠时间)"></a>作息 (每晚保证 7h 以上的睡眠时间)</h3><ul>
<li>早 6:30 起床，一组冥想</li>
<li>工作日中午小息十几分钟，周末中午午休</li>
<li>7:30-8:00 17:00-18:00 英语学习</li>
<li>19:30-20:30 至少周二、周四、周六跑步</li>
<li>19:00-23:00 研究专业相关内容，每隔一个小时穿插（冥想，运动，洗漱等）</li>
<li>23:00 左右休息，最晚不超过 23:30</li>
<li>周末正常作息，清晨跑步锻炼，上午完成所有学习内容</li>
<li>周六下午及晚上休息，劳逸结合，周日正常工作学习，补偿之前欠缺内容</li>
</ul>
<hr>
<h2 id="英语-早晚学习，9h-week"><a href="#英语-早晚学习，9h-week" class="headerlink" title="英语 (早晚学习，9h/week)"></a>英语 (早晚学习，9h/week)</h2><h3 id="GRE-单词-25-天-8-1-8-25"><a href="#GRE-单词-25-天-8-1-8-25" class="headerlink" title="GRE 单词 25 天(8.1-8.25)"></a>GRE 单词 25 天(8.1-8.25)</h3><p>这段周期内，首要任务就是英语单词学习，其他一切任务靠边，早晨学习新单词 2h，晚上完成相关内容复习。</p>
<p>实际完整的学习周期在 55 天左右，后面的复习不对其他学习造成影响。</p>
<p>注意不断地总结经验和方法，希望可以将这套方法运用于其他学科内容的学习。</p>
<ul>
<li>[ ] 《GRE 词汇精选》初步学习，详细完成程度见详细表格(8.1-9.9)</li>
<li>[ ] 《GRE 词汇精选》学习加复习，详细完成程度见详细表格(9.11-9.30)</li>
</ul>
<h3 id="语法句子"><a href="#语法句子" class="headerlink" title="语法句子"></a>语法句子</h3><ul>
<li>[ ] 《语法俱乐部》学习(8.26-9.10)</li>
</ul>
<h3 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h3><ul>
<li>[x] 《恋恋有词》第一篇学习(6.1-7.30)书本初步复习相关内容，主要是单词和短语</li>
<li>[ ] 《恋恋有词》第二遍学习(9.11-9.22)，复习阅读句子为主</li>
<li>[ ] 《恋恋有词》第三遍学习(9.22-9.30)，将句子所有句子翻译一遍</li>
</ul>
<h3 id="长难句"><a href="#长难句" class="headerlink" title="长难句"></a>长难句</h3><ul>
<li>[ ] 《GRE 核心词汇精析》(10.1-11.1)</li>
<li>[ ] 《GRE&amp;GMAT 阅读难句教程》(10.1-12.30)</li>
</ul>
<h3 id="扇贝英语-8-1-12-30"><a href="#扇贝英语-8-1-12-30" class="headerlink" title="扇贝英语(8.1-12.30)"></a>扇贝英语(8.1-12.30)</h3><ul>
<li>[ ] 完成扇贝单词书的学习(1.1-12.31)</li>
<li>[ ] 每天两篇扇贝阅读(1.1-12.31)</li>
<li>[ ] 每天翻译一篇扇贝新闻文章(10.8-12.30)</li>
</ul>
<h3 id="英文书单-9-11-12-30"><a href="#英文书单-9-11-12-30" class="headerlink" title="英文书单(9.11-12.30)"></a>英文书单(9.11-12.30)</h3><ul>
<li>[x] 巴斯克韦尔猎犬(书虫版)</li>
<li>[ ] The Little Prince (重读)</li>
<li>[ ] 苏菲的世界</li>
<li>[ ] Harry Potter 1</li>
<li>[ ] Harry Potter 2</li>
<li>[ ] Harry Potter 3</li>
</ul>
<h2 id="2017-书单-起床后，和睡觉前阅读-15min-左右"><a href="#2017-书单-起床后，和睡觉前阅读-15min-左右" class="headerlink" title="2017 书单 (起床后，和睡觉前阅读 15min 左右)"></a>2017 书单 (起床后，和睡觉前阅读 15min 左右)</h2><h3 id="中文书单"><a href="#中文书单" class="headerlink" title="中文书单"></a>中文书单</h3><ul>
<li>[x] 腾讯传</li>
<li>[x] 悟空传</li>
<li>[x] 把你的英语用起来</li>
<li>[ ] 自控力</li>
<li>[ ] 刻意练习</li>
<li>[ ] 人类简史</li>
<li>[ ] 如何阅读一本书</li>
<li>[ ] 把时间当作朋友</li>
</ul>
<h2 id="2017-计算机学习-跑步日-2h，非跑步日-3h，周日补欠缺，21h-week"><a href="#2017-计算机学习-跑步日-2h，非跑步日-3h，周日补欠缺，21h-week" class="headerlink" title="2017 计算机学习 (跑步日 2h，非跑步日 3h，周日补欠缺，21h/week)"></a>2017 计算机学习 (跑步日 2h，非跑步日 3h，周日补欠缺，21h/week)</h2><h3 id="C-C-6-months-优先学习，重点在于实践"><a href="#C-C-6-months-优先学习，重点在于实践" class="headerlink" title="C/C++ (6 months 优先学习，重点在于实践)"></a>C/C++ (6 months 优先学习，重点在于实践)</h3><ul>
<li>[ ] 《传智播客 C++ 第三期》 C 语言基础篇，传智播客 C++ 第五期》对应结尾三节课 (9.10 日前)</li>
<li>[ ] 《郝斌数据结构 78节 60h》和《传智播客 C++ 第三期》 C 就业，代码实现基础数据结构 (9.25-10.22)</li>
<li>[ ] 《linux 编程相关书籍》+《linux C 编程一站式学习》+《传智播客 C++ 第五期》 linux-c 编程 (10.23-11.19)</li>
<li>[ ] 《传智播客 QT 教程》，利用闲暇时间快速入门 C++ 和 QT ，简单实践，不详细研究</li>
<li>[ ] 《linux 系统编程手册上、下》 (11.20-12.30)</li>
<li>[ ] 《传智播客 C++ 第五期》 C++ 就业，QT 教程，《传智播客 C++ 第五期》 C++ 数据库和shell，由于时间关系，该部分内容学习挪后到明年</li>
</ul>
<h3 id="linux-3h-week-系统学习，掌握牢固"><a href="#linux-3h-week-系统学习，掌握牢固" class="headerlink" title="linux (3h/week 系统学习，掌握牢固)"></a>linux (3h/week 系统学习，掌握牢固)</h3><ul>
<li>[ ] 《Unix&amp;Linux 大学教程》+《阿铭 linux 31 节》 (9.10-9.24)</li>
<li>[ ] 《马哥 linux 基础篇(22天课时-110h)》一周一课，配套《鸟哥 linux 私房菜》，多实践多操作(9.11-12.30)</li>
</ul>
<h2 id="作息"><a href="#作息" class="headerlink" title="作息"></a>作息</h2><h3 id="工作日"><a href="#工作日" class="headerlink" title="工作日"></a>工作日</h3><ul>
<li>6:30 起床，喝水，一组 seven，外出散步</li>
<li>7:00-8:00 阅读，英语</li>
<li>8:15-12:00 工作</li>
<li>12:00-12:20 午餐</li>
<li>12:20-12:30 散步，晒太阳</li>
<li>12:30-12:45 nap</li>
<li>13:00-17:00 工作</li>
<li>17:00-17:20 nap</li>
<li>17:20-17:30 冥想</li>
<li>17:30-18:30 英语</li>
<li>18:30-19:30 晚餐，扇贝英语，复习之前学习的专业知识</li>
<li>19:30-20:00/20:30 跑步运动半小时以上</li>
<li>20:00-22:30/23:00 专业知识研究（22:00 洗澡）</li>
<li>23:30 前休息</li>
</ul>
<h3 id="假期"><a href="#假期" class="headerlink" title="假期"></a>假期</h3><ul>
<li>周六上午完成相关任务，如：英语，运动，专业学习</li>
<li>周六下午晚上娱乐休息，一周的放松时间</li>
<li>周日正常工作学习，弥补本周未完成的任务</li>
</ul>
<hr>
<h2 id="实践改进"><a href="#实践改进" class="headerlink" title="实践改进"></a>实践改进</h2>]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Plan2017(下)-(2)]]></title>
      <url>http://noparkinghere.top/2017/08/01/2017/2017-08-01-plan2017(%E4%B8%8B)-(2)/</url>
      <content type="html"><![CDATA[<p><strong>整体计划参照总纲，每阶段做的事情按照后面的细则来执行，尽量合理安排，让工作学习计划更加弹性，每个周期安排的任务少、时间尽可能的多以保证不会被一些事情所打算；一定要做好充足的休息和锻炼，计划的初衷是生活学习习惯的培养，因此优先多喝水，锻炼和休息。</strong></p>
<p><strong>经过一个多月来的实践，其中有一半的任务完成不错，另外仍然有很多比较局限或者不得要领。接下来一段时间准备实践一套英语学习法，由于占用的时间比较多，因此计划会有很大的调整，目标是将这套学习法较好的实现，并且通过它，找到真正适合自己的学习套路。</strong></p>
<h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p>在保证充足的休息和定期锻炼的前提下，更好的合理安排工作和学习，每天 10:00 后不额外安排新任务，所有工作学习任务确保 10:30 之前完成。</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>阅读多本畅销书籍，类型可以是：历史、时间管理、学习方法、经典小说、个人传记等。</p>
<p>主要阅读时间在：清晨 15 min，饭后 15min，睡前 15 min。</p>
<h3 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h3><p>无特殊情况下，工作日上午 7:30-8:00 ，晚上 5:00-6:00 作为英语的固定学习时间，完成的内容包括且不仅限于如下：</p>
<ul>
<li>《GRE 词汇精选》</li>
<li>《语法俱乐部》</li>
<li>《恋恋有词》 </li>
<li>英文小说阅读</li>
<li>扇贝英语阅读，单词等</li>
</ul>
<h3 id="计算机学习"><a href="#计算机学习" class="headerlink" title="计算机学习"></a>计算机学习</h3><p>由于之前执行效率不高，新任务加入等问题，计算机的学习计划全面挪后。</p>
<ul>
<li>C 语言基础回顾</li>
<li>详细研习 linux 的应用教程</li>
<li>数据结构和算法</li>
<li>深入研究学习 linux 程序开发</li>
<li>C++ 详细研究学习，掌握 Qt 的开发要领，设计多个程序</li>
</ul>
<h3 id="工作任务-充分利用工作时间，尽量不加班"><a href="#工作任务-充分利用工作时间，尽量不加班" class="headerlink" title="工作任务 (充分利用工作时间，尽量不加班)"></a>工作任务 (充分利用工作时间，尽量不加班)</h3><ul>
<li>进一步研究 EFM32 平台以及硬件软件内容，家用表研发项目推进</li>
<li>神舟开 stm32 案例整理，将 stm32 相关知识应用到家用表项目中(8.1-11.30)</li>
<li>仔细研究操作系统相关内容，ucos 内容整理研究(9.1-11.30)</li>
<li>研究 6S 项目(12.1-12.31)</li>
</ul>
<h3 id="作息-每晚保证-7h-以上的睡眠时间"><a href="#作息-每晚保证-7h-以上的睡眠时间" class="headerlink" title="作息 (每晚保证 7h 以上的睡眠时间)"></a>作息 (每晚保证 7h 以上的睡眠时间)</h3><ul>
<li>早 6:30 起床，一组冥想</li>
<li>工作日中午小息十几分钟，周末中午午休</li>
<li>7:30-8:00 17:00-18:00 英语学习</li>
<li>19:30-20:30 至少周二、周四、周六跑步</li>
<li>19:00-23:00 研究专业相关内容，每隔一个小时穿插（冥想，运动，洗漱等）</li>
<li>23:00 左右休息，最晚不超过 23:30</li>
<li>周末正常作息，清晨跑步锻炼，上午完成所有学习内容</li>
<li>周六下午及晚上休息，劳逸结合，周日正常工作学习，补偿之前欠缺内容</li>
</ul>
<hr>
<h2 id="英语-早晚学习，9h-week"><a href="#英语-早晚学习，9h-week" class="headerlink" title="英语 (早晚学习，9h/week)"></a>英语 (早晚学习，9h/week)</h2><h3 id="GRE-单词-25-天-8-1-8-25"><a href="#GRE-单词-25-天-8-1-8-25" class="headerlink" title="GRE 单词 25 天(8.1-8.25)"></a>GRE 单词 25 天(8.1-8.25)</h3><p>这段周期内，首要任务就是英语单词学习，其他一切任务靠边，早晨学习新单词 2h，晚上完成相关内容复习。</p>
<p>实际完整的学习周期在 55 天左右，后面的复习不对其他学习造成影响。</p>
<p>注意不断地总结经验和方法，希望可以将这套方法运用于其他学科内容的学习。</p>
<ul>
<li>[ ] 《GRE 词汇精选》，详细完成程度见详细表格(8.1-9.23)</li>
</ul>
<h3 id="语法句子"><a href="#语法句子" class="headerlink" title="语法句子"></a>语法句子</h3><ul>
<li>[ ] 《语法俱乐部》学习(8.26-9.10)</li>
</ul>
<h3 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h3><ul>
<li>[x] 《恋恋有词》第一篇学习(6.1-7.30)书本初步复习相关内容，主要是单词和短语</li>
<li>[ ] 《恋恋有词》第二遍学习(9.11-9.22)，复习阅读句子为主</li>
<li>[ ] 《恋恋有词》第三遍学习(9.22-9.30)，将句子所有句子翻译一遍</li>
</ul>
<h3 id="长难句"><a href="#长难句" class="headerlink" title="长难句"></a>长难句</h3><ul>
<li>[ ] 《GRE 核心词汇精析》(10.1-11.1)</li>
<li>[ ] 《GRE&amp;GMAT 阅读难句教程》(10.1-12.30)</li>
</ul>
<h3 id="扇贝英语-8-1-12-30"><a href="#扇贝英语-8-1-12-30" class="headerlink" title="扇贝英语(8.1-12.30)"></a>扇贝英语(8.1-12.30)</h3><ul>
<li>[ ] 完成扇贝单词书的学习(1.1-12.31)</li>
<li>[ ] 每天两篇扇贝阅读(1.1-12.31)</li>
<li>[ ] 每天翻译一篇扇贝新闻文章(10.8-12.30)</li>
</ul>
<h3 id="英文书单-9-11-12-30"><a href="#英文书单-9-11-12-30" class="headerlink" title="英文书单(9.11-12.30)"></a>英文书单(9.11-12.30)</h3><ul>
<li>[x] 巴斯克韦尔猎犬(书虫版)</li>
<li>[ ] The Little Prince (重读)</li>
<li>[ ] 苏菲的世界</li>
<li>[ ] Harry Potter 1</li>
<li>[ ] Harry Potter 2</li>
<li>[ ] Harry Potter 3</li>
</ul>
<h2 id="2017-书单-起床后，和睡觉前阅读-15min-左右"><a href="#2017-书单-起床后，和睡觉前阅读-15min-左右" class="headerlink" title="2017 书单 (起床后，和睡觉前阅读 15min 左右)"></a>2017 书单 (起床后，和睡觉前阅读 15min 左右)</h2><h3 id="中文书单"><a href="#中文书单" class="headerlink" title="中文书单"></a>中文书单</h3><ul>
<li>[x] 腾讯传</li>
<li>[x] 悟空传</li>
<li>[x] 把你的英语用起来</li>
<li>[ ] 自控力</li>
<li>[ ] 刻意练习</li>
<li>[ ] 人类简史</li>
<li>[ ] 如何阅读一本书</li>
<li>[ ] 把时间当作朋友</li>
</ul>
<h2 id="2017-计算机学习-跑步日-2h，非跑步日-3h，周日补欠缺，21h-week"><a href="#2017-计算机学习-跑步日-2h，非跑步日-3h，周日补欠缺，21h-week" class="headerlink" title="2017 计算机学习 (跑步日 2h，非跑步日 3h，周日补欠缺，21h/week)"></a>2017 计算机学习 (跑步日 2h，非跑步日 3h，周日补欠缺，21h/week)</h2><h3 id="C-C-6-months-优先学习，重点在于实践"><a href="#C-C-6-months-优先学习，重点在于实践" class="headerlink" title="C/C++ (6 months 优先学习，重点在于实践)"></a>C/C++ (6 months 优先学习，重点在于实践)</h3><ul>
<li>[ ] 《传智播客 C++ 第三期》 C 语言基础篇，传智播客 C++ 第五期》对应结尾三节课 (8.6日前)</li>
<li>[ ] 《郝斌数据结构 78节 60h》和《传智播客 C++ 第三期》 C 就业，代码实现基础数据结构 (9.11-10.15)</li>
<li>[ ] 《linux 编程相关书籍》+《linux C 编程一站式学习》+《传智播客 C++ 第五期》 linux-c 编程 (10.16-11.11)</li>
<li>[ ] 《传智播客 QT 教程》，利用闲暇时间快速入门 C++ 和 QT ，简单实践，不详细研究</li>
<li>[ ] 《linux 系统编程手册上、下》 (11.20-12.30)</li>
<li>[ ] 《传智播客 C++ 第五期》 C++ 就业，QT 教程，《传智播客 C++ 第五期》 C++ 数据库和shell，由于时间关系，该部分内容学习挪后到明年</li>
</ul>
<h3 id="linux-3h-week-系统学习，掌握牢固"><a href="#linux-3h-week-系统学习，掌握牢固" class="headerlink" title="linux (3h/week 系统学习，掌握牢固)"></a>linux (3h/week 系统学习，掌握牢固)</h3><ul>
<li>[ ] 《Unix&amp;Linux 大学教程》+《阿铭 linux 31 节》 (8.26-9.10)</li>
<li>[ ] 《马哥 linux 基础篇(22天课时-110h)》一周一课，配套《鸟哥 linux 私房菜》，多实践多操作(9.11-12.30)</li>
</ul>
<hr>
<h2 id="实践改进"><a href="#实践改进" class="headerlink" title="实践改进"></a>实践改进</h2>]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[读后感-悟空传]]></title>
      <url>http://noparkinghere.top/2017/07/11/2017/2017-07-11-%E8%AF%BB%E5%90%8E%E6%84%9F-%E6%82%9F%E7%A9%BA%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p>最近电影版《悟空传》快上映了，于是突然想起来还在上学时似乎看过这部作品的同名小说，小说很短，也就 10 万字左右，前两天抽空翻了下。</p>
<p>好多年前看的《悟空传》小说，这部作品给我的印象不是特别深刻，甚至我无法想起当初到底有没有看完，直到这次将全书又翻了一下，我才确信以前是看完了的。</p>
<p>就看小说而言，我一直算是个记忆力比较强的人，几乎从来没有将一部作品看两边，即便十多年前看的小说至今仍然能够记忆犹新，而比较诧异的是，这部作品为何会让我没什么印象呢？下面细细道来。</p>
<p>《悟空传》算是一部有思想有内涵，抛开《西游记》的情节来说，《悟空传》对人物的性格，举动，故事的背景描述，因果反而更为合理些。</p>
<p>《西游记》让人困惑的是，孙悟空为何会被招安？天庭怎么就没有高手？神仙既已经知道因果，又为何还浪费时间去取经？整体上看来西游记更像是为了安排一个个任务而去取经，除了开头和结尾外，中间的内容似乎又都和主线没有多大的关系，每个都可以成为一个独立的剧情，更像是今天的动漫如：《名侦探柯南》、《哆啦A梦》这样的情节。故事整体缺少一个连续和环环相扣的发展。</p>
<p>《悟空传》的故事情节相比而言简单粗暴，故事主旨就是：我命由我不由天。唐僧、孙悟空都是想摆脱命运，让自己听从内心，真正可以做到自己主宰自己的命运。于是他们同神佛斗，同天斗，同自己斗。</p>
<p>《悟空传》故事的整体能够串成一条线，石猴不服命运去修道，不服上天去改生死簿，带领妖众逆天，被打倒后，看不得手下再受苦，不得不妥协被招安，但它并不属于这里，一次次的积怨终于爆发，于是大闹天宫，再次被如来镇压，洗去记忆然后流放，流放就是让“犯罪”的师徒四人去西天，然而并没有人知道西天在哪儿，却有着一个个阴谋在等待着他们。</p>
<p>第二次读《悟空传》才明白了它的一些情节和内容，这本书书写的手法过于诡异，不断地在过去和现在，真实和梦境，本我和超我中进行着跳跃，虽然很短的一本书，但旺旺看完你并不知道讲的什么，这也就是为何我第一次读的时候印象不深，只知道是一本悲剧作品。</p>
<p>书是一本值得一睹的书，但作者并没有阐述具体的表达内容，每个人看完后的感受也会截然不同。看了一下同名电影的预告，目测已经不抱有太大的期望了，书中的主旨在电影似乎得不到一点点的体现，留下来的似乎只有那些煽情的台词了。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Plan2017(下)-(1)]]></title>
      <url>http://noparkinghere.top/2017/06/30/2017/2017-06-30-plan2017(%E4%B8%8B)-(1)/</url>
      <content type="html"><![CDATA[<p><strong>整体计划参照总纲，每阶段做的事情按照后面的细则来执行，尽量合理安排，让工作学习计划更加弹性，每个周期安排的任务少、时间尽可能的多以保证不会被一些事情所打算；一定要做好充足的休息和锻炼，计划的初衷是生活学习习惯的培养，因此优先多喝水，锻炼和休息。</strong></p>
<h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><h3 id="阅读和英语-9h-week"><a href="#阅读和英语-9h-week" class="headerlink" title="阅读和英语 (9h/week)"></a>阅读和英语 (9h/week)</h3><ul>
<li>晨起阅读 15 分钟各种书籍左右，英语学习半小时</li>
<li>《恋恋有词》早上 7:30，晚上 5:00 学习 C-1h (6.1-7.30)</li>
<li>扇贝单词书完成(1.1-12.31)，扇贝新闻/阅读 3 本书(5.1-7.31)，一天一篇新闻翻译(9.1-10.30)</li>
<li>阅读中外书籍，详见书单(7.1-12.31)</li>
</ul>
<h3 id="计算机学习-21h-week"><a href="#计算机学习-21h-week" class="headerlink" title="计算机学习 (21h/week)"></a>计算机学习 (21h/week)</h3><ul>
<li>C/C++ 按照视频完整教程基础(6.18-10.29)，实践具体项目(10.1-12.30)进度和教程日期一致，多套图书辅助学习</li>
<li>《马哥 linux 基础篇(22天课时-110h)》1~2周一课，配套《鸟哥 linux 私房菜》，多实践(6.5-12.30)</li>
<li>linux-C 配套书籍阅读，编程学习和实践(7.1-12.30)</li>
<li>Qt 研究学习多个项目，完成相应的 C++ 案例研究(9.20-11.30)</li>
</ul>
<h3 id="工作任务-充分利用工作时间，尽量不加班"><a href="#工作任务-充分利用工作时间，尽量不加班" class="headerlink" title="工作任务 (充分利用工作时间，尽量不加班)"></a>工作任务 (充分利用工作时间，尽量不加班)</h3><ul>
<li>进一步研究 EFM32 平台以及硬件软件内容，家用表研发项目推进</li>
<li>神舟开 stm32 案例整理，将 stm32 相关知识应用到家用表项目中(8.1-11.30)</li>
<li>仔细研究操作系统相关内容，ucos 内容整理研究(9.1-11.30)</li>
<li>研究 6S 项目(12.1-12.31)</li>
</ul>
<h3 id="作息-每晚保证-7h-以上的睡眠时间"><a href="#作息-每晚保证-7h-以上的睡眠时间" class="headerlink" title="作息 (每晚保证 7h 以上的睡眠时间)"></a>作息 (每晚保证 7h 以上的睡眠时间)</h3><ul>
<li>早 6:52 起床，一组冥想</li>
<li>工作日中午小息十几分钟，周末中午午休</li>
<li>17:00-18:00 英语学习</li>
<li>19:30-20:30 周二、周四、周六跑步</li>
<li>19:00-23:00 研究专业相关内容，每隔一个小时穿插（冥想，运动，洗漱等）</li>
<li>23:00 左右休息，最晚不超过 23:30</li>
<li>周末正常作息，清晨跑步锻炼，上午完成所有学习内容</li>
<li>周六下午及晚上休息，劳逸结合，周日正常工作学习，补偿之前欠缺内容</li>
</ul>
<hr>
<h2 id="2017-英语-早晚学习，9h-week"><a href="#2017-英语-早晚学习，9h-week" class="headerlink" title="2017 英语 (早晚学习，9h/week)"></a>2017 英语 (早晚学习，9h/week)</h2><h3 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h3><ul>
<li>[ ] 《恋恋有词》第一篇学习(6.1-7.30)书本初步复习相关内容，主要是单词和短语</li>
<li>[ ] 《恋恋有词》第二《遍学习(8.1-8.31)，将句子所有句子翻译一遍</li>
<li>[ ] 《语法俱乐部》完成第一篇学习(9.1-9.30)</li>
</ul>
<h3 id="扇贝英语"><a href="#扇贝英语" class="headerlink" title="扇贝英语"></a>扇贝英语</h3><ul>
<li>[ ] 完成扇贝单词书的学习(1.1-12.31)</li>
<li>[ ] 每天两篇扇贝阅读(1.1-12.31)</li>
<li>[ ] 每天翻译一篇扇贝新闻文章(9.1-12.30)</li>
</ul>
<h2 id="2017-书单-起床后，和睡觉前阅读-15min-左右"><a href="#2017-书单-起床后，和睡觉前阅读-15min-左右" class="headerlink" title="2017 书单 (起床后，和睡觉前阅读 15min 左右)"></a>2017 书单 (起床后，和睡觉前阅读 15min 左右)</h2><h3 id="中文书单"><a href="#中文书单" class="headerlink" title="中文书单"></a>中文书单</h3><ul>
<li>[x] 腾讯传</li>
<li>[ ] 自控力</li>
<li>[ ] 刻意练习</li>
<li>[ ] 人类简史</li>
<li>[ ] 如何阅读一本书</li>
<li>[ ] 把时间当作朋友</li>
</ul>
<h3 id="英文书单"><a href="#英文书单" class="headerlink" title="英文书单"></a>英文书单</h3><ul>
<li>[x] 巴斯克韦尔猎犬(书虫版)</li>
<li>[ ] The Little Prince (重读)</li>
<li>[ ] 简爱(书虫版)</li>
<li>[ ] Harry Potter 1</li>
<li>[ ] Harry Potter 2</li>
<li>[ ] Harry Potter 3</li>
</ul>
<h2 id="2017-计算机学习-跑步日-2h，非跑步日-3h，周日补欠缺，21h-week"><a href="#2017-计算机学习-跑步日-2h，非跑步日-3h，周日补欠缺，21h-week" class="headerlink" title="2017 计算机学习 (跑步日 2h，非跑步日 3h，周日补欠缺，21h/week)"></a>2017 计算机学习 (跑步日 2h，非跑步日 3h，周日补欠缺，21h/week)</h2><h3 id="C-C-6-months-优先学习，重点在于实践"><a href="#C-C-6-months-优先学习，重点在于实践" class="headerlink" title="C/C++ (6 months 优先学习，重点在于实践)"></a>C/C++ (6 months 优先学习，重点在于实践)</h3><ul>
<li>[ ] 《传智播客 C++ 第三期》 C 语言基础篇，传智播客 C++ 第五期》对应结尾三节课 (6.25-7.23)</li>
<li>[ ] 《郝斌数据结构 78节》代码实现基础数据结构，60h (7.24-8.13)</li>
<li>[ ] 《传智播客 C++ 第三期》 C 就业，配套 linux-c 一站式学习(8.14-8.27)</li>
<li>[ ] 《传智播客 C++ 第五期》 C++ 就业，QT 教程 (8.28-10.29)</li>
<li>[ ] 《传智播客 C++ 第五期》 linux-c 编程 (10.30-11.30)</li>
<li>[ ] 《传智播客 C++ 第五期》 C++ 数据库和shell，归纳前面所有内容(12.1-12.29)</li>
<li>[ ] 《linux C 编程一站式学习》，《linux 系统编程手册》</li>
</ul>
<h3 id="linux-3h-week-系统学习，掌握牢固"><a href="#linux-3h-week-系统学习，掌握牢固" class="headerlink" title="linux (3h/week 系统学习，掌握牢固)"></a>linux (3h/week 系统学习，掌握牢固)</h3><ul>
<li>[ ] 《阿铭 linux 31 节》15h，闲时观看 </li>
<li>[ ] 《马哥教育 linux 》01-02 (6.10-6.30)</li>
<li>[ ] 《马哥教育 linux 》03-06 (7.1-7.30)</li>
<li>[ ] 《马哥教育 linux 》07-11 (7.31-8.27)</li>
<li>[ ] 《马哥教育 linux 》12-15 (8.28-9.30)</li>
<li>[ ] 《马哥教育 linux 》16-18 (10.1-10.29)</li>
<li>[ ] 《马哥教育 linux 》19-22 (10.1-11.26)</li>
<li>[ ] 练习归纳总结以上内容 (11.27-12.29)</li>
</ul>
<hr>
<h2 id="实践改进"><a href="#实践改进" class="headerlink" title="实践改进"></a>实践改进</h2><p>到六月底为止已经尝试了一个月，英语内容进度超过预期，阅读偶尔进行没有养成习惯，专业课虽然学过但课程内容太多进度偏慢还需改进，后续计划可能会适当调整，休息时间少半小时急需调整；做出调整，利用闲散时间完成扇贝英语打卡，强迫晚上早点休息，周末回家时间充分利用完成基本任务，戒掉频繁刷手机的毛病，影响工作学习效率，且每次占用一小段时间累计成大量时间。</p>
<p>转眼又七月下旬，经过研究总结，自控力本身作为消耗品，同时强制做太多事情很容易将他们消耗殆尽，且出现严重的疲乏状态。目前，英语早晚学习、运动、扇贝打卡完成度都比较良好；冥想、早起、linux 学习完成度一般；早睡、C/C++ 等进展较差。早睡早起、冥想、运动等都可以提升自身的身体素质，能够更好的培养自己的自控力，因此现阶段将重点放在这几个上面，一切以它们为中心，试行一个月的时间，每天在保证充足的运动和休息的前提下进行专业知识的学习，将 C/C++ linux 数据结构等学习时间缩短，每天不求任务量的完成，在 10:30 以前结束当天的工作学习，起床时间提前到 6:00-6:30，早上散步/跑步、阅读、英语等。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[知道了太多道理，因此没有过好这一生]]></title>
      <url>http://noparkinghere.top/2017/06/26/2017/2017-06-26-%E7%9F%A5%E9%81%93%E4%BA%86%E5%A4%AA%E5%A4%9A%E9%81%93%E7%90%86%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%B2%A1%E6%9C%89%E8%BF%87%E5%A5%BD%E8%BF%99%E4%B8%80%E7%94%9F/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[bash脚本基础学习]]></title>
      <url>http://noparkinghere.top/2017/06/17/2017/2017-06-17-bash%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shell 是类 UNIX 系统的外壳，使用 shell 用于实现人机交互的目的，我们通过它可以与内核之间进行交互，从而轻松完成一些操作。换句话说，我们可以认为 shell 就是一个人机交互方式，通过它，我们不需要有编程基础，不需要直接操作计算机内核则可以完成一些想要的工作；事实上 shell 可以分为图形化的 shell 和命令行 shell，我们用鼠标操作桌面也是一个图形化 shell 为我们提供了交互，这边主要讨论的是命令行 shell 的学习。</p>
<p>Shell有两种执行命令的方式：</p>
<ul>
<li>交互式（Interactive）：用户在终端输入一条命令，Shell就解释执行一条，并且可以直接显示结果。</li>
<li>批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令，而由于 shell 本身就被看做是一种脚本语言，也有变量和流程控制语句，因此它具备的功能远比 windows 下的批处理要强大。</li>
</ul>
<h3 id="常用-shell"><a href="#常用-shell" class="headerlink" title="常用 shell"></a>常用 shell</h3><p>shell 本身是作为类 UNIX 系统的外壳，而它本身并不是唯一的，也就是说当你使用 linux 操作系统时，你可以更换不同的 shell，常用的 shell 有： bash,zsh,dash,csh 等等。</p>
<h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>一般而言 MAC 电脑下默认的 shell 为 bash，ubuntu 等系统登录后，用户的默认 shell 为 bash，内部命令一共有40个。</p>
<h4 id="dash"><a href="#dash" class="headerlink" title="dash"></a>dash</h4><p>它比 Bash 小，只需要较少的磁盘空间，但是它的对话性功能也较少，而 ubuntu 等系统开启加载的 shell 为 dash (据说可以提高启动速度)。</p>
<h4 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h4><p>C shell 是一个交互式命令解释器和一种命令编程语言，采用的语法类似于 C 编程语言，共有 52 个内部命令。</p>
<h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><p>zsh 原本是一个 Linux 用户很少使用的 shell，虽然它功能强大，但由于配置过于复杂，难以学习，因此使用的人少，但这两年由于 <a href="http://ohmyz.sh/" target="_blank" rel="external">oh my zsh</a> github 等一些社区的流行，让 zsh 的使用越来越广泛，由于它更加人性化，功能更加强大，也成为越来越多人 UNIX 下的默认 shell。</p>
<h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>传统的程序设计语言，例如Fortran、Ada、Pascal、C、C++和Java，都是编译型语言；而像 awk、Perl、Python、Ruby 与 Shell 等都属于解释型语言，即脚本语言。</p>
<p>两者的区别是，编译型语言需要一次性编译成二进制代码，才可以被计算机执行，之后都是执行这个可执行程序，无需再编译因此执行速度快；解释型语言则是，解释器(interpreter)需要读取我们编写的源代码(source code)，并将其转换成目标代码(object code)，再由计算机运行，因为每次执行程序都多了编译的过程，因此效率有所下降。</p>
<h2 id="shell-的适用场景"><a href="#shell-的适用场景" class="headerlink" title="shell 的适用场景"></a>shell 的适用场景</h2><p>shell 脚本有着相当好的移植性，经过 POSIX 标准化，shell 脚本几乎可以在各种类 UNIX 操作系统上使用，并且最新的 windows 系统也将会加入 shell，也就是说，未来，几乎所有的 PC 都将支持 shell  脚本的使用。</p>
<p>shell 脚本开发较为简单，语法简单易学，通过调用各种工具可以轻松的实现某个功能，相比于 C、C++ 等可以说要简单的多。</p>
<p>shell 脚本同样有它不完美之处，有效率低，功能受限等问题，在如下情况下，一般不使用 shell：</p>
<ul>
<li>资源密集型的任务，尤其在需要考虑效率时（比如，排序，hash等等）。</li>
<li>需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算（这种情况一般使用C++或FORTRAN 来处理）。</li>
<li>有跨平台（操作系统）移植需求（一般使用C 或Java）。</li>
<li>复杂的应用，在必须使用结构化编程的时候（需要变量的类型检查，函数原型，等等）。</li>
<li>对于影响系统全局性的关键任务应用。</li>
<li>对于安全有很高要求的任务，比如你需要一个健壮的系统来防止入侵、破解、恶意破坏等等。</li>
<li>项目由连串的依赖的各个部分组成。</li>
<li>需要大规模的文件操作。</li>
<li>需要多维数组的支持。</li>
<li>需要数据结构的支持，比如链表或数等数据结构。</li>
<li>需要产生或操作图形化界面 GUI。</li>
<li>需要直接操作系统硬件。</li>
<li>需要 I/O 或socket 接口。</li>
<li>需要使用库或者遗留下来的老代码的接口。</li>
<li>私人的、闭源的应用（shell 脚本把代码就放在文本文件中，全世界- 都能看到）。</li>
</ul>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><h3 id="加入解释器说明"><a href="#加入解释器说明" class="headerlink" title="加入解释器说明"></a>加入解释器说明</h3><p>首先新建一个文件，一般我们取名为 xxx.sh，.sh 为扩展名，事实上你可以不加入这个扩展名，但为了方便我们自己了解，一般建议还是加上 .sh。</p>
<p>第一行输入 <code>#!/bin/bash</code>，“#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。如果你使用 csh ，你则在第一行输入 <code>#!/bin/csh</code>。</p>
<h3 id="如何运行脚本"><a href="#如何运行脚本" class="headerlink" title="如何运行脚本"></a>如何运行脚本</h3><p>以这段脚本代码为例，文件名为 tesh.sh：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Hello World !"</span></div></pre></td></tr></table></figure>
<p>我们有三种方法执行这段脚本。</p>
<ul>
<li>终端输入作为解释器参数： <code>bash test.sh</code>，注意这种方式运行的脚本，不需要在第一行指定解释器信息，因为不会起到任何效果，也就是说，你输入 <code>bash test.sh</code> 和 <code>dash test.sh</code> 很可能会得到不同的结果。</li>
<li>作为可执行程序：首先我们需要将文件变成可执行程序，一般而言，linux 下除非二进制可执行程序（编译生成的文件），一般的文本文件默认都是不可执行的，<code>chmod +x ./test.sh  #使脚本具有执行权限</code>，然后直接执行该文件，<code>./test.sh  #执行脚本</code>。注意，一定要写成 <code>./test.sh</code>，而不是 test.sh。</li>
<li><code>source ./test.sh</code> 使用 bash 的内置命令来运行脚本，source 可以用 <code>.</code> 符号来代替。</li>
</ul>
<p>source filename 与 sh filename 及 ./filename 执行脚本的区别:</p>
<ul>
<li>当shell脚本具有可执行权限时，用 sh filename 与 ./filename 执行脚本是没有区别得。./filename 是因为当前目录没有在 PATH 中，所有”.”是用来表示当前目录的。</li>
<li>sh filename 重新建立一个子shell，在子 shell 中执行脚本里面的语句，该子 shell 继承父 shell 的环境变量，但子 shell 新建的、改变的变量不会被带回父 shell，除非使用 export。</li>
<li>source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前 shell 里面执行，<strong>没有建立新的子 shell</strong>。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。</li>
</ul>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。</p>
<p>直接输出字符串：echo “hello world!”</p>
<p>输出变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o=<span class="string">"hello world!"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"the string is <span class="variable">$o</span>"</span></div></pre></td></tr></table></figure>
<p>显示结果重定向至文件：<code>echo &quot;It is a test&quot; &gt; myfile</code></p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>printf 命令用于格式化输出， 是 echo 命令的增强版。它是 C 语言 printf() 库函数的一个有限的变形，并且在语法上有些不同。注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。</p>
<p>printf 命令的语法：printf  format-string  [arguments…] format-string 为格式控制字符串，arguments 为参数列表。shell 中 printf 功能和用法与 C 语言中的 printf 函数类似，这边不再详细说明。</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>变量直接采用赋值语句，类似 C 语言，但变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样，一旦加入空格，则会报错。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firstValue=<span class="string">"hello"</span></div></pre></td></tr></table></figure>
<p>变量名的命名须遵循如下规则：</p>
<ul>
<li>首个字符必须为字母（a-z，A-Z）。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">your_name=<span class="string">"alading"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></div></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，如：<code>echo &quot;I am good at ${skill}Script&quot;</code></p>
<p><strong>推荐给所有变量加上花括号，这是个好的 shell 编程习惯。</strong></p>
<h3 id="重新定义变量"><a href="#重新定义变量" class="headerlink" title="重新定义变量"></a>重新定义变量</h3><p>已定义的变量，可以被重新定义，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">your_name=<span class="string">"alading"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></div><div class="line">your_name=<span class="string">"aladin"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;your_name&#125;</span></div></pre></td></tr></table></figure>
<p>注意，第二次赋值的时候不能写 $myUrl=”adin”，只有使用变量的时候才加美元符（$）。</p>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">your_name=<span class="string">"alading"</span></div><div class="line"><span class="built_in">readonly</span> your_name</div><div class="line">your_name=<span class="string">"aladin"</span></div></pre></td></tr></table></figure>
<p>运行脚本，结果如下：<br>/bin/sh: NAME: This variable is read only.</p>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令可以删除变量。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">your_name=<span class="string">"alading"</span></div><div class="line"><span class="built_in">unset</span> your_name</div><div class="line"><span class="built_in">echo</span> <span class="variable">$your_name</span></div></pre></td></tr></table></figure>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a><strong>特殊变量</strong></h3><p><strong>这边需要记住如下表格的内容，shell 脚本会频繁灵活的调用如下内容。</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或<strong>函数的返回值</strong>。</td>
</tr>
<tr>
<td>$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody>
</table>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$#</span> $* <span class="variable">$@</span> $? $$"</span></div></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">$./<span class="keyword">test</span>.<span class="keyword">sh</span> haha</div><div class="line"></div><div class="line">./<span class="keyword">test</span>.<span class="keyword">sh</span> haha 1 haha haha 0 14520</div></pre></td></tr></table></figure>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>可以使用 echo 命令的 -e 进行转义，-E 选项禁止转义，默认情况，不进行转义。</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\a</td>
<td>警报，响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格（删除键）</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符（tab键） </td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
</tbody>
</table>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">echo -e <span class="string">"Value1 \n"</span></div><div class="line">echo <span class="string">"Value2 \n"</span></div><div class="line"></div><div class="line">运行结果：</div><div class="line"><span class="meta">&gt;&gt;</span> Value \n</div><div class="line"><span class="meta">&gt;&gt;</span> Value2</div></pre></td></tr></table></figure>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>shell 中有许多内置的软件和命令，如： ls , pwd , date 等，我们可以在 shell 脚本中嵌入这些软件运行的结果。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">DATE=`date`</div><div class="line"><span class="built_in">echo</span> <span class="string">"Date is <span class="variable">$DATE</span>"</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">运行结果</div><div class="line"><span class="selector-tag">Sat</span> <span class="selector-tag">Jun</span> 17 15<span class="selector-pseudo">:19</span><span class="selector-pseudo">:56</span> <span class="selector-tag">CST</span> 2017</div></pre></td></tr></table></figure>
<h3 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h3><table>
<thead>
<tr>
<th>形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${var}</td>
<td>变量本来的值</td>
</tr>
<tr>
<td>${var:-word}</td>
<td>如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。</td>
</tr>
<tr>
<td>${var:=word}</td>
<td>如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</td>
</tr>
<tr>
<td>${var:?message}</td>
<td>如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。</td>
</tr>
<tr>
<td>${var:+word}</td>
<td>如果变量 var 被定义，那么返回 word，但不改变 var 的值。</td>
</tr>
</tbody>
</table>
<p>减号“—”和加号“+”分别是当变量无定义和有定义的时候返回Word，都不改变var；等于号“=”，不管有没有定义，都给var重新赋值，并返回Word；对于问号“？”，当变量没有定义的时候直接输出message并且退出，当变量有定义的时候，不执行任何操作，相当于直接跳过了。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>双引号里可以有变量，双引号里可以出现转义字符</li>
</ul>
<h4 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$&#123;<span class="comment">#parameter&#125;</span></div><div class="line">Parameter  <span class="built_in">length</span>.  The <span class="built_in">length</span> <span class="keyword">in</span> <span class="built_in">characters</span> <span class="keyword">of</span> <span class="keyword">the</span> value <span class="keyword">of</span> parameter <span class="keyword">is</span> substituted.</div><div class="line"></div><div class="line"><span class="built_in">string</span>=<span class="string">"abcd"</span></div><div class="line">echo $&#123;<span class="comment">#string&#125; #输出 4</span></div></pre></td></tr></table></figure>
<h4 id="提取子字符串："><a href="#提取子字符串：" class="headerlink" title="提取子字符串："></a>提取子字符串：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string=<span class="string">"alibaba is a great company"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment">#输出liba</span></div></pre></td></tr></table></figure>
<h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>=<span class="string">"alibaba is a great company"</span></div><div class="line"><span class="keyword">echo</span> `expr <span class="built_in">index</span> <span class="string">"$string"</span> <span class="keyword">is</span>`</div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>
<p>用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：array_name=(value1 … valuen)</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">array<span class="number">_n</span>ame=(<span class="keyword">value</span><span class="number">0</span> <span class="keyword">value</span><span class="number">1</span> <span class="keyword">value</span><span class="number">2</span> <span class="keyword">value</span><span class="number">3</span>)</div><div class="line">或者</div><div class="line">array<span class="number">_n</span>ame=(</div><div class="line"><span class="keyword">value</span><span class="number">0</span></div><div class="line"><span class="keyword">value</span><span class="number">1</span></div><div class="line"><span class="keyword">value</span><span class="number">2</span></div><div class="line"><span class="keyword">value</span><span class="number">3</span></div><div class="line">)</div><div class="line">单独赋值：</div><div class="line">array<span class="number">_n</span>ame[<span class="number">0</span>]=<span class="keyword">value</span><span class="number">0</span></div><div class="line">array<span class="number">_n</span>ame[<span class="number">1</span>]=<span class="keyword">value</span><span class="number">1</span></div><div class="line">array<span class="number">_n</span>ame[<span class="number">2</span>]=<span class="keyword">value</span><span class="number">2</span></div></pre></td></tr></table></figure>
<p>读取数组元素值的一般格式是：${array_name[index]}，同普通变量类似。</p>
<p>获取数组的长度：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 取得数组元素的个数</span></div><div class="line"><span class="attr">length</span>=<span class="variable">$&#123;#array_name[@]&#125;</span></div><div class="line"><span class="comment"># 或者</span></div><div class="line"><span class="attr">length</span>=<span class="variable">$&#123;#array_name[*]&#125;</span></div><div class="line"><span class="comment"># 取得数组单个元素的长度</span></div><div class="line"><span class="attr">lengthn</span>=<span class="variable">$&#123;#array_name[n]&#125;</span></div></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符基本上和 C 语言保持一致。</p>
<p>a=10<br>b=20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a - $b</code> 结果为 10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>==</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td>[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>a=10<br>b=20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ] 返回 true。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否相等，不相等返回 true。</td>
<td>[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>a=10<br>b=20</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td>[ ! false ] 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody>
</table>
<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>a=”abc”<br>b=”efg”</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否为0，不为0返回 true。</td>
<td>[ -z $a ] 返回 true。</td>
</tr>
<tr>
<td>str</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody>
</table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>file=”~/test.sh”</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td>[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td>[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td>[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是具名管道，如果是，则返回 true。</td>
<td>[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td>[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td>[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td>[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td>[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td>[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td>[ -e $file ] 返回 true。</td>
</tr>
</tbody>
</table>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以“#”开头的行就是注释，会被解释器忽略，sh 里没有多行注释，只能每一行加一个 # 号。</p>
<p>在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>if … else 语句的语法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ expression ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="literal">true</span></div><div class="line">fi</div></pre></td></tr></table></figure>
<p>expression 和方括号([ ])之间必须有空格，条件语句的主体内容前面必须有 tab 间隔，否则会有语法错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">a=10</div><div class="line">b=20</div><div class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> ！= <span class="variable">$b</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   <span class="built_in">echo</span> <span class="string">"a is not equal to b"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">运行结果：</div><div class="line">a is not equal to b</div></pre></td></tr></table></figure>
<p>if … else … fi 语句的语法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ expression ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="literal">true</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">true</span></div><div class="line">fi</div></pre></td></tr></table></figure>
<p>if … elif … fi 语句的语法为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ expression <span class="number">1</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">1</span> <span class="keyword">is</span> <span class="literal">true</span></div><div class="line">elif [ expression <span class="number">2</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">2</span> <span class="keyword">is</span> <span class="literal">true</span></div><div class="line">elif [ expression <span class="number">3</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> expression <span class="number">3</span> <span class="keyword">is</span> <span class="literal">true</span></div><div class="line"><span class="keyword">else</span></div><div class="line">   Statement(s) <span class="keyword">to</span> be executed <span class="keyword">if</span> <span class="literal">no</span> expression <span class="keyword">is</span> <span class="literal">true</span></div><div class="line">fi</div></pre></td></tr></table></figure>
<h3 id="测试语句"><a href="#测试语句" class="headerlink" title="测试语句"></a>测试语句</h3><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">num1=100</div><div class="line">num2=100</div><div class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] <span class="_">-eq</span> $[num2]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'The two numbers are equal!'</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">'The two numbers are not equal!'</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">结果：</div><div class="line">The two numbers are equal!</div></pre></td></tr></table></figure>
<p>test 的表述方法一般都可以直接用 if 来完成，这边只做个介绍，不推荐使用。</p>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></div><div class="line">模式1)</div><div class="line">    <span class="built_in">command</span>1</div><div class="line">    <span class="built_in">command</span>2</div><div class="line">    <span class="built_in">command</span>3</div><div class="line">    ;;</div><div class="line">模式2）</div><div class="line">    <span class="built_in">command</span>1</div><div class="line">    <span class="built_in">command</span>2</div><div class="line">    <span class="built_in">command</span>3</div><div class="line">    ;;</div><div class="line">*)</div><div class="line">    <span class="built_in">command</span>1</div><div class="line">    <span class="built_in">command</span>2</div><div class="line">    <span class="built_in">command</span>3</div><div class="line">    ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">echo <span class="symbol">'Input</span> a number between <span class="number">1</span> <span class="keyword">to</span> <span class="number">4</span>'</div><div class="line">echo <span class="symbol">'Your</span> number <span class="keyword">is</span>:\c'</div><div class="line">read aNum</div><div class="line"><span class="keyword">case</span> $aNum <span class="keyword">in</span></div><div class="line">    <span class="number">1</span>)  echo <span class="symbol">'You</span> <span class="keyword">select</span> <span class="number">1</span>'</div><div class="line">    ;;</div><div class="line">    <span class="number">2</span>)  echo <span class="symbol">'You</span> <span class="keyword">select</span> <span class="number">2</span>'</div><div class="line">    ;;</div><div class="line">    <span class="number">3</span>)  echo <span class="symbol">'You</span> <span class="keyword">select</span> <span class="number">3</span>'</div><div class="line">    ;;</div><div class="line">    <span class="number">4</span>)  echo <span class="symbol">'You</span> <span class="keyword">select</span> <span class="number">4</span>'</div><div class="line">    ;;</div><div class="line">    *)  echo <span class="symbol">'You</span> do <span class="keyword">not</span> <span class="keyword">select</span> a number between <span class="number">1</span> <span class="keyword">to</span> <span class="number">4</span>'</div><div class="line">    ;;</div><div class="line">esac</div><div class="line"></div><div class="line"></div><div class="line">输入不同的内容，会有不同的结果，例如：</div><div class="line">Input a number between <span class="number">1</span> <span class="keyword">to</span> <span class="number">4</span></div><div class="line">Your number <span class="keyword">is</span>:<span class="number">3</span></div><div class="line">You <span class="keyword">select</span> <span class="number">3</span></div></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>与其他编程语言类似，Shell支持for循环。for循环一般格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">command</span>1</div><div class="line">    <span class="built_in">command</span>2</div><div class="line">    ...</div><div class="line">    <span class="built_in">command</span>N</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。for 循环在使用过程中相当方便，可以将任意内容作为 in 的目标，然后可以快速的检索执行相关内容。例如，我们需要将 windows 下压缩的所有文件夹在 linux 下解压，则可以用 for 语句将文件以 gb2312 的模式解压，具体代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *.zip</div><div class="line"><span class="keyword">do</span></div><div class="line">    unzip -O Gb2312 <span class="string">"<span class="variable">$i</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">command</span></div><div class="line"><span class="built_in">do</span></div><div class="line">   Statement(s) <span class="built_in">to</span> be executed <span class="keyword">if</span> <span class="keyword">command</span> <span class="title">is</span> <span class="title">true</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<ctrl-d>结束循环。</ctrl-d></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'type &lt;CTRL-D&gt; to terminate'</span></div><div class="line"><span class="built_in">echo</span> -n <span class="string">'enter your most liked film: '</span></div><div class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Yeah! great film the <span class="variable">$FILM</span>"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h3 id="until-语句"><a href="#until-语句" class="headerlink" title="until 语句"></a>until 语句</h3><p>until 循环与 while 循环在处理方式上刚好相反，until 循环执行一系列命令直至条件为 true 时停止。</p>
<p>until 循环格式为：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">until</span> <span class="keyword">command</span></div><div class="line"><span class="built_in">do</span></div><div class="line">   Statement(s) <span class="built_in">to</span> be executed <span class="keyword">until</span> <span class="keyword">command</span> <span class="title">is</span> <span class="title">true</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>例如，使用 until 命令输出 0 ~ 9 的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">a=0</div><div class="line">until [ ! <span class="variable">$a</span> <span class="_">-lt</span> 10 ]</div><div class="line"><span class="keyword">do</span></div><div class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></div><div class="line">   a=`expr <span class="variable">$a</span> + 1`</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。</p>
<h3 id="continue命令"><a href="#continue命令" class="headerlink" title="continue命令"></a>continue命令</h3><p>continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高，Shell 函数也必须先定义后使用。</p>
<p>Shell 函数的定义格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span> () &#123;</div><div class="line">    list of commands</div><div class="line">    [ <span class="built_in">return</span> value ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>function 关键字可加可不加；函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"The function is to get the sum of two numbers..."</span></div><div class="line">    <span class="built_in">echo</span> -n <span class="string">"Input first number: "</span></div><div class="line">    <span class="built_in">read</span> aNum</div><div class="line">    <span class="built_in">echo</span> -n <span class="string">"Input another number: "</span></div><div class="line">    <span class="built_in">read</span> anotherNum</div><div class="line">    <span class="built_in">echo</span> <span class="string">"The two numbers are <span class="variable">$aNum</span> and <span class="variable">$anotherNum</span> !"</span></div><div class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</div><div class="line">&#125;</div><div class="line">funWithReturn</div><div class="line"><span class="comment"># Capture value returnd by last command</span></div><div class="line">ret=$?</div><div class="line"><span class="built_in">echo</span> <span class="string">"The sum of two numbers is <span class="variable">$ret</span> !"</span></div></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">The function <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">the</span> sum <span class="keyword">of</span> two numbers...</div><div class="line">Input <span class="keyword">first</span> <span class="built_in">number</span>: <span class="number">25</span></div><div class="line">Input another <span class="built_in">number</span>: <span class="number">50</span></div><div class="line">The two numbers are <span class="number">25</span> <span class="keyword">and</span> <span class="number">50</span> !</div><div class="line">The sum <span class="keyword">of</span> two numbers <span class="keyword">is</span> <span class="number">75</span> !</div></pre></td></tr></table></figure>
<p>函数返回值在调用该函数后通过 $? 来获得，不像 C 语言的直接调用赋值。</p>
<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value of the first parameter is <span class="variable">$1</span> !"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value of the second parameter is <span class="variable">$2</span> !"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value of the tenth parameter is <span class="variable">$10</span> !"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value of the tenth parameter is <span class="variable">$&#123;10&#125;</span> !"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The value of the eleventh parameter is <span class="variable">$&#123;11&#125;</span> !"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The amount of the parameters is <span class="variable">$#</span> !"</span>  <span class="comment"># 参数个数</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"The string of the parameters is $* !"</span>  <span class="comment"># 传递给函数的所有参数</span></div><div class="line">&#125;</div><div class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</div></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">The <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">first</span> parameter is <span class="number">1</span> !</div><div class="line">The <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">second</span> parameter is <span class="number">2</span> !</div><div class="line">The <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">tenth</span> parameter is <span class="number">10</span> !</div><div class="line">The <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">tenth</span> parameter is <span class="number">34</span> !</div><div class="line">The <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">the</span> eleventh parameter is <span class="number">73</span> !</div><div class="line">The amount <span class="keyword">of</span> <span class="keyword">the</span> parameters is <span class="number">12</span> !</div><div class="line">The <span class="keyword">string</span> <span class="keyword">of</span> <span class="keyword">the</span> parameters is <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">34</span> <span class="number">73</span> !<span class="string">"</span></div></pre></td></tr></table></figure>
<p>注意：$10 不能获取第十个参数，获取第十个参数需要${10}。当 n&gt;=10 时，需要使用${n}来获取参数，所以一般良好的方式是所有的变量参数调用时都加上 <code>{}</code> 。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。上面我们在使用 echo 的时候其实已经用到了输出重定向，这是 shell 下记录日志的常用方法。</p>
<p>命令输出重定向的语法为：</p>
<ul>
<li><code>command &gt; file</code> ： 表示创建 file 文件，将 command 的结果输出到 file 文件中，如果已经存在 file 文件，则直接覆盖源文件内容。</li>
<li><code>command &gt;&gt; file</code>： 表示创建 file 文件，将 command 的结果输出到 file 文件中，如果已经存在 file 文件，则不覆盖原文内容，而在文件末尾进行追加。</li>
</ul>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>和输出重定向一样，shell 命令也可以从文件获取输入，语法为：<code>command &lt; file</code>，这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<p>输入重定向到 users 文件，即：读取 user 文件下的内容，用 command 对这个文件内容进行处理。例如：<code>wc -l &lt; users</code>。</p>
<h3 id="标准错误文件"><a href="#标准错误文件" class="headerlink" title="标准错误文件"></a>标准错误文件</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。默认情况下，command &gt; file 将 stdout 重定向到 file</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。command &lt; file 将 stdin 重定向到 file。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。command 2 &gt; file，stderr 重定向到 file。</li>
</ul>
<p>一般我们可以这样操作，将 stdout 和 stderr 分别重定向到 file：<code>command &gt;&gt; file1 2 &gt;&gt; file2</code></p>
<h3 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 <code>/dev/null</code>，<code>command &gt; /dev/null 2&gt;&amp;1</code> 可以用来屏蔽 stdout 和 stderr。</p>
<p><em>本文是一个 bash 入门的基础语法笔记，主要参考学习和整理了如下链接的内容。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://c.biancheng.net/cpp/shell/" target="_blank" rel="external">http://c.biancheng.net/cpp/shell/</a><br><a href="http://blog.csdn.net/wangyangkobe/article/details/6595143" target="_blank" rel="external">http://blog.csdn.net/wangyangkobe/article/details/6595143</a><br><a href="https://zhidao.baidu.com/question/489742760031792892.html" target="_blank" rel="external">https://zhidao.baidu.com/question/489742760031792892.html</a><br><a href="http://blog.csdn.net/hansel/article/details/9817129" target="_blank" rel="external">http://blog.csdn.net/hansel/article/details/9817129</a><br><a href="http://www.360doc.com/content/13/1211/14/14541491_336331604.shtml" target="_blank" rel="external">http://www.360doc.com/content/13/1211/14/14541491_336331604.shtml</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[轻松上网]]></title>
      <url>http://noparkinghere.top/2017/06/09/2017/2017-06-09-%E8%BD%BB%E6%9D%BE%E4%B8%8A%E7%BD%91/</url>
      <content type="html"><![CDATA[<p>本文罗列和推荐一些科学上网的方法，其中有免费也有付费的，有很容易实现的也有需要折腾一下的，具体的话需要根据你的需求来决定。</p>
<h3 id="hosts-方式"><a href="#hosts-方式" class="headerlink" title="hosts 方式"></a>hosts 方式</h3><p><em>为了绕开 GFW ，能够访问谷歌等网站，我们经常会采取各种手段，但其中最简单的方式还是修改 hosts 文件。</em></p>
<p>Hosts 文件是一个用于存储计算机网络中节点信息的文件，它可以将主机名映射到相应的 IP 地址，实现 DNS 的功能，它可以由计算机的用户进行控制。这边就不再具体展开说明，详细文章可以<a href="https://noparkinghere.github.io/2017/06/08/2017/2017-06-08-hosts-%E6%96%87%E4%BB%B6%E4%B8%8A%E7%BD%91/" target="_blank" rel="external">参考</a></p>
<h3 id="VPN-上网方式"><a href="#VPN-上网方式" class="headerlink" title="VPN 上网方式"></a>VPN 上网方式</h3><p>由于众所周知的原因，国内用户被强大的 GFW 保（lan）护（jie）而无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook，需要去国外厂家查找某方面的资料等，就一定需要学会翻墙上网，该方面的能力甚至已经算是软件从业/科研人员的基本素养，因此一般也将翻墙称作科学上网。<a href="https://noparkinghere.github.io/2016/07/12/2016/2016-07-12-vpn推荐" target="_blank" rel="external">这篇文章</a>主要介绍使用付费 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。</p>
<h3 id="SS-上网"><a href="#SS-上网" class="headerlink" title="SS 上网"></a>SS 上网</h3><p>日常生活中，由于 GFW 的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器。具体文章可以<a href="https://noparkinghere.github.io/2016/11/25/2016/2016-11-25-vps-shadowsocks/" target="_blank" rel="external">参考</a></p>
<a id="more"></a>
<h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><table>
<thead>
<tr>
<th></th>
<th>hosts</th>
<th>VPN</th>
<th>vps-ss    </th>
</tr>
</thead>
<tbody>
<tr>
<td>价格</td>
<td>免费</td>
<td>免费版较难连接，付费版价格 200/year 左右</td>
<td>价格不等，30/year - 1000/year    </td>
</tr>
<tr>
<td>配置难易</td>
<td>配置简单，用过计算机的都能配置</td>
<td>一般对计算机比较熟悉的人都能够安装配置成功，某些时候可能会遇到些困难，但大都能解决</td>
<td>需要配置服务器端和客户端，如果自己搭建服务器的话，需要具备一定的 linux 基础    </td>
</tr>
<tr>
<td>稳定性</td>
<td>经常会失效，需要重新找 hosts 文件配置</td>
<td>较好，购买靠谱商家的 VPN 一般都能连接上，偶尔会有断线的情况</td>
<td>取决于你 VPS 的服务商，如果是二次打包分销的 VPS ，如果代理商过销的话会体验较差。    </td>
</tr>
<tr>
<td>适合人群</td>
<td>适合几周或几个月，偶尔需要翻墙上网的人</td>
<td>适合每天或者经常需要翻墙的人</td>
<td>适合每天或者经常需要翻墙的人</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hosts 文件上网]]></title>
      <url>http://noparkinghere.top/2017/06/08/2017/2017-06-08-hosts-%E6%96%87%E4%BB%B6%E4%B8%8A%E7%BD%91/</url>
      <content type="html"><![CDATA[<h3 id="host-方式"><a href="#host-方式" class="headerlink" title="host 方式"></a>host 方式</h3><p>在大多数 PC 操作系统中都有 hosts 文件，我们可以通过这类文件来达到 IP 访问一些网站或者屏蔽一些网站的效果。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-06-08-hosts-文件上网/1.gif" alt=""></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Hosts 文件是一个用于存储计算机网络中节点信息的文件，它可以将主机名映射到相应的IP地址，实现DNS的功能，它可以由计算机的用户进行控制。</p>
<p>Hosts 文件的存储位置在不同的操作系统中并不相同，甚至不同Windows版本的位置也不大一样， Windows NT/2000/XP/2003/Vista/win7：默认位置为%SystemRoot%\system32\drivers\etc\，但也可以改变。</p>
<p>例如 <code>c:\windows\system32\drivers\etc\</code> 动态目录由注册表键 <code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\ Services\Tcpip\Parameters\DataBasePath</code> 决定。 用记事本打开hosts文件，就可以看见了微软对这个文件的说明。Hosts文件文一般有如下面的基本内容 </p>
<a id="more"></a>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows. </span></div><div class="line"><span class="meta"># </span></div><div class="line"><span class="meta"># This file contains the mappings of IP addresses to host names. Each </span></div><div class="line"><span class="meta"># entry should be kept on an individual line. The IP address should </span></div><div class="line"><span class="meta"># be placed in the first column followed by the corresponding host name. </span></div><div class="line"><span class="meta"># The IP address and the host name should be separated by at least one </span></div><div class="line"><span class="meta"># space. </span></div><div class="line"><span class="meta"># </span></div><div class="line"><span class="meta"># Additionally, comments (such as these) may be inserted on individual </span></div><div class="line"><span class="meta"># lines or following the machine name denoted by a '#' symbol. </span></div><div class="line"><span class="meta"># </span></div><div class="line"><span class="meta"># For example: </span></div><div class="line"><span class="meta"># </span></div><div class="line"><span class="meta"># 102.54.94.97 rhino.acme.com # source server </span></div><div class="line"><span class="meta"># 38.25.63.10 x.acme.com # x client host </span></div><div class="line"></div><div class="line"><span class="meta"># 127.0.0.1  localhost</span></div></pre></td></tr></table></figure>
<p>在网络上访问网站，要首先通过 DNS 服务器把要访问的网络域名（XXXX.com）解析成XXX.XXX.XXX.XXX的IP地址后，计算机才能对这个网络域名作访问，这也是为何当你 DNS 无法访问时，输入网站名就没有反应，但一些联网的 APP （如 QQ，音乐播放器）却可以使用的原因。</p>
<p>除了铜鼓 DNS 自动解析域名外，我们还能够通过 Hosts 文件直接建立域名和 IP 的映射关系来达到访问目的，这种情况下就不需要再通过 DNS 来访问相应网站了。</p>
<h3 id="屏蔽网站"><a href="#屏蔽网站" class="headerlink" title="屏蔽网站"></a>屏蔽网站</h3><p>屏蔽网站也是一种常用的功能，一些网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。而另外一些情况则是，我们使用破解软件时，一些软件需要不断地联网认证你是否使用了盗版，我们也可以将这些网站给屏蔽。对于这些网站我们可以利用 Hosts 把该网站的域名映射到错误的 IP 或本地计算机的 IP，这样就不用访问了。约定 127.0.0.1 为本地计算机的 IP 地址, 0.0.0.0 是错误的 IP 地址。 </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在 <span class="selector-tag">Hosts</span> 中，写入以下内容： </div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">www</span><span class="selector-class">.XXXX</span><span class="selector-class">.com</span> #屏蔽的网站 <span class="selector-tag">A</span> </div><div class="line">0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span> <span class="selector-tag">www</span><span class="selector-class">.XXXX</span><span class="selector-class">.com</span> #屏蔽的网站 <span class="selector-tag">B</span> </div><div class="line">这样，计算机解析域名 <span class="selector-tag">A</span>和 <span class="selector-tag">B</span>时，就解析到本机<span class="selector-tag">IP</span>或错误的<span class="selector-tag">IP</span>，达到了屏蔽网站<span class="selector-tag">A</span> 和<span class="selector-tag">B</span>的目的。</div></pre></td></tr></table></figure>
<h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p><em>为了绕开 GFW ，能够访问谷歌等网站，我们经常会采取各种手段，但其中最简单的方式还是修改 host 文件。</em></p>
<p>修改 host 文件来科学上网，是一种比较传统的方式，优点是配置简单，无需安装第三方软件；缺点是经常会失效，需要你反复配置。</p>
<p>这边给出几个更新比较快的 hosts 资源，使用方法就是将这些 hosts 文件替代你操作系统中的原有文件，但值得注意的是，任何这些文件都是由民间网友提供的，并不能保证它绝对的安全，所以使用的话需自己考量和谨慎。</p>
<ul>
<li><a href="https://github.com/racaljk/hosts" target="_blank" rel="external">hosts</a>：老牌 hosts 文件，长期更新，比较稳定。</li>
<li><a href="https://github.com/wangchunming/2017hosts" target="_blank" rel="external">2017hosts</a>：具备详细的说明文件</li>
</ul>
<blockquote>
<p><a href="http://blog.csdn.net/tskyfree/article/details/41214829" target="_blank" rel="external">http://blog.csdn.net/tskyfree/article/details/41214829</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[为何你没法坚持专注？]]></title>
      <url>http://noparkinghere.top/2017/06/03/2017/2017-06-03-%E4%B8%BA%E4%BD%95%E4%BD%A0%E6%B2%A1%E6%B3%95%E5%9D%9A%E6%8C%81%E4%B8%93%E6%B3%A8%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>人有可能会天生具备更高的智商，更强壮的体魄，但除此之外，没有谁天生就会写字说话，也没有谁天生就能够坚持能够成功。</p>
<p>在经过这些的年的观察反思之后，我发现能够专注持久地去做一件事，这种品质对人来说格外重要，而评价一个人是否有能力，我相信这种品质应该可以占据了一半以上的评分。</p>
<p>人如何才能够做到专注？而又是怎么才能将专注做到很长时间的呢？这两个问题一直困扰了我很久。我始终相信专注和恒心即便与生理因素相关，但也不可能每个人生来就具备极大的差异性。通过我个人一些观察和发现，认识到除了生理因素外，应该至少有两点影响着一个人。</p>
<h3 id="习性"><a href="#习性" class="headerlink" title="习性"></a>习性</h3><p>从小的教育，家庭的氛围是一个不能忽略的因素，一个从小养尊处优衣来伸手饭来张口的孩子，天生就比别人体验的少，经历的磨难少，遇到的挫折少，往往他也会神经大条遇到困难时，更加倾向于选择放弃，而不是努力一把坚持一下挺过去。</p>
<p>不仅如此，一些小困难对于从小独立自主的人来说可能是家常便饭，但对于温室中的花朵却可能是无法承受之重。说这点并不是刻意贬低生活幸福美满的人，而是客观上面陈述一个事实，从小的经历，你做过的家务，你经历过的困难之后都会影响你的一生。</p>
<p>你经历过的越多，你就越有可能养成坚韧的品质，长此以往这些品质就会刻录到你的身体中，让你在做事时自然而然的可以比别人更加专注持久。</p>
<a id="more"></a>
<h3 id="压力"><a href="#压力" class="headerlink" title="压力"></a>压力</h3><p>一个不是特别有恒心，特别专注的人，也会有可能在一些时候努力干完一些事情，并取得不错的成就。但这些事情，可能并不是由你主导的成功，来自升学的压力，来自升职的压力等等可能会迫使三心二意的你突然发愤图强，激发了自身一切的潜能，最终获得了成功。</p>
<p>虽然说结果是美好的，但这其实并不是可持续发展可轻易复制的成功。因为虽然是你主导的事情，但动力来自于外界，而另一方面在做事时，你是受极大压力后最终爆发了自身的潜能，然后在几周甚至几个月后你成功了。人的潜能和精力都是有限的，你不可能在做完一件事后，再次爆发潜能，更不可能在持续高压下爆发几年的潜能，即便是几个月也已经让你精疲力尽了。</p>
<p>大多数的专注和恒心都属于压力因素引起的，而如果是长时间一定成都的压力则会形成上面提到的习性，能够将部分坚持的品质刻录到自己的行为习惯中去。</p>
<p>而对于那些不只是依靠外界压力，而想要让自己成为更加努力更加专注的人，该怎么去做呢？</p>
<h3 id="1-1-提升"><a href="#1-1-提升" class="headerlink" title="1.1 提升"></a>1.1 提升</h3><p>太大的压力必然会造成精神和肉体上面的压迫，长此以往，要么你被他击垮，要么你们两败俱伤（击败他后，你再次回归放纵）；另一方面，如果没有压力的话，你会始终过着安逸的日子，不会有任何改变和进步，一点点沉沦下去。</p>
<p>人的习性不是一天两天养成的，要做到无痛成长几乎不可能，但我们可以将痛苦降低，将战线拉长。我们可以使用 1.1 倍的压力，让自己略微感觉到痛苦的前提下稳步前行。</p>
<p>1.1 的压力在于你只在原有的基础上做一点点改变，比如，你原来 8 点起床，那么现在 7 点起床；而如果你提前到 6 点甚至 5 点，那么这样的压力就足以压倒一大半的人了。</p>
<p>1.1 的压力另一点表现在你只改变某一件事，而不是过高的评断自己，认为能够同时胜任多件事情，比如，提前到 7 点起床的你，还同时每天增加一个小时的英语学习时间，增加一个小时的写作时间，戒掉两个小时的看电视时间。这些方式只会让好高骛远的你提前选择放弃。</p>
<p>虽说 1.1 的稳步提升是一个好方法，但任何方法都要执行，1.1 方法需要长期的坚持，让它成为习惯后，你才可以再去做下一步的事情。</p>
<p>1.1 方法的优点是痛苦小，容易执行，而缺点同样明显，战线长，见效微。因此虽然容易执行，且容易坚持下来，但也仍然不排除一些情况下会打断你的节奏，让你回到原点。</p>
<hr>
<p>任何的改变都不可能无痛的，绝大多数人选择放弃都是因为这种自己与自己的斗争太过痛苦，而当自己无法承受这么大的压力并且自己的信心被击垮时，任务自然而然的就失败了。<strong>下面列出一些有可能会让你放弃，而回到原点的情景。</strong></p>
<h3 id="高估自己"><a href="#高估自己" class="headerlink" title="高估自己"></a>高估自己</h3><p>学会控制自己的基础是自知，知道自己喜欢什么，知道自己需要什么，自己能够承受多大的压力，自己能够为一件事坚持多久等等。</p>
<p>在你对自己不理解的前提下，为自己制定目标和任务时，往往并不是量身定制，甚至可以说你的目标和计划是为别人定制的。不少人拥有雄心壮志，但却没法把事情做好，往往是他们高估了自己的能力和状态。</p>
<p>在坚持了一些实践一段时间后，一些人已经自我感觉良好了，甚至认为自己习惯早已养成，可以增加新的目标了，然而事与愿违，冒失的增加新的任务后，让他们感觉压力倍增，在原有实践的压力和新任务的压力双重施压下，一些人最终没有挺住；另外，值得一提的是双重压力还不算可怕，可怕的是一些人在双重压力下仍然不自知，他们意识到了问题，但没有意识到问题在哪儿，因此他们甚至仍然在给自己添加新的任务。</p>
<p>很多幻想着一蹴而就地去完成任务，以为一学期的课可以通过一两天的努力就学完，这种事情会有发生，但不是常态。还有一些人明明有着充裕的时间，却迫不及待的想要看到成果，希望一下子就掌握某个技能，实践完某个东西，这些都缺乏对事情和对自己的评估，同时也缺乏耐心，这所导致的失败和放弃都是必然的结果。</p>
<h3 id="身体的不适"><a href="#身体的不适" class="headerlink" title="身体的不适"></a>身体的不适</h3><p>生病会打乱你的生活工作节奏，对于刚养成习惯的人，或者正在养成习惯的，这都是极大的考验，人在生病时体弱多病，做事情心有余而力不足，这是在所难免的。</p>
<p>所以“每天锻炼一小时，健康工作 50 年”是有道理的，人只有拥有了坚强的体魄，才更有可能具备顽强的精神，当你想要坚持做一件事之前，你一定需要将身体因素考虑在内。</p>
<p>不仅是生病时让你无法实践，当你生病好转后，人往往会处于一个疲惫期，另外之前所攒的“积分”也没了（计划任务被打乱了），就会不知所措，这时候就很容易放弃之前的任务，不怕你生病，怕就怕生病后的恢复期让你回不来。</p>
<h3 id="外界的诱惑"><a href="#外界的诱惑" class="headerlink" title="外界的诱惑"></a>外界的诱惑</h3><p>如果你周围的人都很瘦，你不可能会多胖；相反，如果你周围都是一群胖子，那你也会越来越胖，当你在晚上想睡觉时，你的胖基友很可能会怂恿着一起啃烧烤、吃夜宵。</p>
<p>和志不同道很合的人一起，最有可能的情况就是将你带偏。你们虽然志不同（你想减肥），但是道很合（相处愉快）。你刚刚养成的生活学习习惯，极有可能在几个晚上的聚餐、几天的朋友聚会后，很有可能再次让你回归解放前的生活状态。</p>
<p>鱼和熊掌不可兼得，如果你选择了天空，那你势必会离开草原。因此，当你尚在成长中时，拒绝诱惑的最佳方法永远是远离诱惑源。</p>
<h3 id="长期看不到进步所以选择放弃"><a href="#长期看不到进步所以选择放弃" class="headerlink" title="长期看不到进步所以选择放弃"></a>长期看不到进步所以选择放弃</h3><p>太多的人在实践的过程中，往往是因为几周或者几个月没有看到自己的进步，然后就觉得这么做是没有效果的，在他们看来，继续下去无异于浪费时间，放弃反而是明智之选。</p>
<p>我们这边只讨论坚持，是否有效果这需要具体问题具体分析。</p>
<p>很多事情在刚开始做的时候效果明显，但很可能之后的几个月甚至几年你都会感觉寸步难进，我们称之为瓶颈期，例如，学习英语时，我们也许在应试教育 4,6 级上感觉进步很快，但之后如果没有英语的氛围，而想要达到外国人水平就十分困难。</p>
<p>克服瓶颈期，一般两个方法，一个是靠长期的努力和坚持，相信铁杵磨成针，虽然你的进步慢到几乎无法察觉，但你总是在前进的，如果你方向没错的话，最终有一天你会达到目标。</p>
<p>另一种方法，则是我们一旦遇到瓶颈，就多思考多交流，交流就是指广泛地吸收他人的经验和建议，我们可以花几周甚至几个月时间通过阅读，听讲座等获得一些方法论，然后自己再总结出自己的方法论，让自己可以更快地迈过瓶颈期。</p>
<h3 id="短期内理想和现实冲突"><a href="#短期内理想和现实冲突" class="headerlink" title="短期内理想和现实冲突"></a>短期内理想和现实冲突</h3><p>一开始时的效果不佳让很多人觉得似乎这样做不对或者并不适合我，这种情况往往伴随着两个误区。</p>
<p>其中之一是期望值太高，你对一件将要进行的任务或者正在进行的任务抱有了不现实的认识和看法，以为做了这件事立马就可以获得什么什么。我们拿运动来举例说明，大家都知道运动能够给我们生活带来健康，但有个前提是它需要你持之以恒才可以带来效果，一些人刚开始运动两周，但发现体质并没有改善只有酸痛和累。我们在实践前，首先得大概弄明白这件事，而不是高过的评估它。</p>
<p>另一个需要注意的是：改变总伴随着心理和生理的不适。任何改变都需要我们颠覆原有的生活习惯和习性的，而当你需要做一件本来不擅长、不习惯的事时，你必然会消耗更多的体力和精力。我们再次拿运动来举例，当多年不运动的你开始跑步时，哪怕只是一公里，也会伴随着身体和精神上巨大的抗拒，而带来的结果很可能是你刚开始一两周跑步后，整个人都不好了，拉伤、疲惫、酸痛等等都可能接踵而来。因此，当你刚开始尝试着做某件事时，你最该祈求的应该是这件事给你带来的尽量少的痛苦，而绝不是它给你带来多大的好处。</p>
<h3 id="从绷紧到绷断"><a href="#从绷紧到绷断" class="headerlink" title="从绷紧到绷断"></a>从绷紧到绷断</h3><p>压力是我们的朋友，很多时候，适当的压力能够让我们精神集中，发挥超常，但是过度的压力下，你也可能会如橡皮筋一样最终绷断。</p>
<p>上学时，我们每上完一节课都会有相应的几分钟休息时间，这种间歇休息就是帮助我们调节自己，短期的休息可以帮助我们面对接下来的任务，同样我们必须选择合理的休息调整方式，充分利用好这短暂的休息时间。</p>
<p>而长期实践下来，我们势必会精神上疲惫，很可能最终养成的不是习惯，而是绷断，比如，你长期坚持工作学习，几周或者几个月下来，由于精神始终高度紧张得不到放松，你可能会病倒，更可能最终放弃任务。</p>
<p>即便是高中的紧张学习阶段，学校也会在一周的辛苦学习后，给予你半天的休息时间。因此，理想的方法还是周期性的休息，你可以将工作学习安排的很紧、事情很多，但在一周的忙碌后你至少还是需要有一天左右的放松时间（即便时间不允许，半天也是可以的）。</p>
<h3 id="孰轻孰重"><a href="#孰轻孰重" class="headerlink" title="孰轻孰重"></a>孰轻孰重</h3><p>因为工作而影响了学习，你该如何选择？</p>
<p>很多时候，一些外部因素打断了我们，让我们逼不得已地不得不间断原来的计划，我们痛苦的挣扎，两权相利取其重，你需要权衡做出选择。</p>
<h3 id="恐惧"><a href="#恐惧" class="headerlink" title="恐惧"></a>恐惧</h3><p>失败也会让人产生习惯，在做事情时，本该去考虑如何解决问题，将更多精力花在事情上，但一些经常失败的人，可能会潜意识地产生恐惧心理，还没有开始做事情，就已经退缩了。</p>
<p>有许多人并不是败在事情本身，而是输给了自己，往往很多事情一旦开始做之后并不难，但你想多了，人为的给自己制造了压力增加了恐惧，让你完成的任务大打折扣。</p>
<hr>
<p>to be continued …</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[初识冥想]]></title>
      <url>http://noparkinghere.top/2017/05/27/2017/2017-05-27-%E5%88%9D%E8%AF%86%E5%86%A5%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>冥想是瑜伽实现入定的一项技法和途径，把心、意、灵完全专注在原始之初之中；最终目的在于把人引导到解脱的境界。</p>
<blockquote>
<h2 id="冥想的作用"><a href="#冥想的作用" class="headerlink" title="冥想的作用"></a>冥想的作用</h2></blockquote>
<h3 id="提高专注"><a href="#提高专注" class="headerlink" title="提高专注"></a>提高专注</h3><p>通过冥想，可以让你做事情更加的专注，不容易会被外部事情打扰。现代工作压力生活紧张，很多人在做事情时，不再有一颗专注的心，很容易被手机信息、汽车鸣笛、同事聊天等打扰。很多人的实践证明，通过不断的练习，坚持冥想有助于提高专注力。</p>
<h3 id="平缓情绪"><a href="#平缓情绪" class="headerlink" title="平缓情绪"></a>平缓情绪</h3><p>运动和冥想都有助于让打扰产生内啡肽，让我们的情绪平复，快乐，从而更轻松的工作学习。并不是没有情绪，更是遇到很多事情能够更加的淡定，更加的平复，时刻知道自己在做什么，而不是发脾气失控。</p>
<h3 id="增加感知"><a href="#增加感知" class="headerlink" title="增加感知"></a>增加感知</h3><p>冥想打坐可以更加人的敏锐性，挖掘出人体的部分潜能，长期冥想后，你会发现感知能够所有加强，因为大脑得到了更好的锻炼，因此你会注意到更多细节，更多原来容易被忽视的东西。</p>
<h3 id="身心健康"><a href="#身心健康" class="headerlink" title="身心健康"></a>身心健康</h3><p>冥想可以让身心相结合，在打坐冥想时呼吸均匀，身体平复，能够帮助血液循环，让身体容易保持一个好的状态；冥想是对大脑的锻炼，身体锻炼能够强身健体，同样大脑也需要锻炼，让它更加健康。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-27-初识冥想/1.jpg" alt=""></p>
<a id="more"></a>
<blockquote>
<h2 id="如何进行冥想"><a href="#如何进行冥想" class="headerlink" title="如何进行冥想"></a>如何进行冥想</h2></blockquote>
<h3 id="调身"><a href="#调身" class="headerlink" title="调身"></a>调身</h3><h4 id="坐姿"><a href="#坐姿" class="headerlink" title="坐姿"></a>坐姿</h4><ul>
<li><a href="http://www.zhwdw.com/wdxg/yujia/6/92305.shtml" target="_blank" rel="external">坐姿</a>有：双盘、单盘、散盘等，对于初学者来说哪怕坐在凳子上也都是可以的，但一定要以稳定为前提，哪一种对你来说更容易，就选哪一种，刻意增加姿势难度反而不利于打坐冥想。</li>
</ul>
<ul>
<li><p>脊柱一定要直，打坐时身体是放松的，头不要弯，颈椎，胸，腰保持垂直慢慢往前倾，这时会感觉身体中心在脚上，然后身体在慢慢往后返回，这会让你感觉整个打坐会特别稳定且通常，上坐之前这个准备工作对初学者是必须的，注意，整个过程一定要保持脊椎挺直。</p>
</li>
<li><p>肩膀舒张，胸稍挺，从上到下慢慢的放松。</p>
</li>
<li><p>手结定印(左下右上)，双手大拇指微碰，放于脐下。</p>
</li>
<li><p>头中正，不上扬不下看也不歪斜，下巴微微内收，让颈椎比较正直，减少新陈代谢，帮助入静。</p>
</li>
<li><p>初学者练习时，将眼睛闭起来，有一定基础后，双眼留缝，意守人中。</p>
</li>
<li><p>舌顶上颚，舌头前半部分轻微顶住上颚，嘴唇微闭，上下牙齿留缝。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-27-初识冥想/2.jpg" alt=""></p>
<h3 id="调风"><a href="#调风" class="headerlink" title="调风"></a>调风</h3><p>调风实际就是控制呼吸，如果呼吸比较均匀，则心也会比较平静，人很多时候会被想法拖着走。嘴先闭合，嘴角微微上扬，鼻子先轻轻的慢慢的呼吸三口气，调整好坐姿后，再放松长长的呼吸三口气，呼吸要放松绵长，整个过程一定要放松不能紧张。</p>
<p>冥想的过程是一个反复体验，验证的过程，每个人只有亲身经历才会找到最适合自己的，注意的是整个过程需要放松但不懈怠。</p>
<h3 id="调心"><a href="#调心" class="headerlink" title="调心"></a>调心</h3><p>前面两部做充分后注意力就比较容易集中，开始进行调心，初学者，在冥想时将注意力集中在人中。</p>
<p>静坐一定要保持好心态：平常心，觉知心，持久心。</p>
<ul>
<li>平常心是告诉你不要台执着，保持心态平和，不强求。</li>
<li>觉知是让你一旦失神后可以立刻有觉悟能够回到起点。</li>
<li>持久是让你持续不断的学习，冥想不会一蹴而就，需要你不断的练习，(1+0.1)^365 = 37.78 即每天进步一点点。</li>
</ul>
<blockquote>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2></blockquote>
<ul>
<li>不在饱腹和饥饿时进行冥想。</li>
<li>保持空气流通，但不可迎风而坐，容易伤身体。</li>
<li>打坐时保暖，双膝，肩颈。</li>
<li>一步步来，肢体保持相对轻松舒适状态，最主要就是意识也需要保持放松的状态。</li>
<li>刚开始打坐时，坐姿不够稳健，准备一个两寸左右的软垫，让坐姿更加稳定。</li>
<li>冥想之前可以做一些瑜伽的动作帮助拉伸和入境。</li>
<li>身体状况不好，感冒或者特别疲惫时，应该先暂时不冥想而去养好身体。</li>
<li>中午午休时，不一定需要单盘双盘，可以坐在椅子上，保持身体坐直，呼吸顺畅。</li>
<li>每个人冥想时状态不同，有些初学者甚至出现头晕呕吐等，需要观察一段时间。</li>
</ul>
<blockquote>
<h2 id="推荐书单"><a href="#推荐书单" class="headerlink" title="推荐书单"></a>推荐书单</h2></blockquote>
<ul>
<li>《冥想5分钟，等于熟睡一小时》</li>
<li>《苹果禅》</li>
<li>《元气禅》</li>
<li>《正念的奇迹》</li>
<li>《改善情绪的正念疗法》</li>
<li>《与繁重的工作一起修行》</li>
<li>《禅者的初心》</li>
<li>《佛陀传》</li>
<li>《正见》</li>
</ul>
<hr>
<p>本文为听课所做笔记，后续仍然会进行一些内容更新。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[小白运动之路]]></title>
      <url>http://noparkinghere.top/2017/05/20/2017/2017-05-20-%E5%B0%8F%E7%99%BD%E8%BF%90%E5%8A%A8%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>写这篇文章时，我已经坚持跑了超过 100 天，累计有 100 公里左右，最近的日常运动一般在 3-5 公里之间，最远跑过一次 10 公里。</p>
<p>这段距离并不算远，并且也没能做到每天跑步，但基本上可以一周跑 3 次左右。开始运动前，我是一个运动纯小白，从小到大既没有运动细胞，也对运动不感冒，体育比赛之类的至今也从未看过。</p>
<p>之所以开始锻炼，原因应该有两个，一方面是工作和生活习惯不好身体亚健康，希望通过运动来改善生活；另一方面则是希望通过坚持一些事情来证明自己，坚持跑步锻炼显然也能够算是一件值得肯定的事情。</p>
<p>如果你身边有小伙伴一起运动跑步的话，则会更容易坚持下来，也可以共享欢乐，而如果你和我一样只能一个人锻炼跑步，想要改变一下的话，那这篇文章可能会对你有所帮助。</p>
<p>这片文章主要记录我个人从静止-&gt;运动的一些改变，也希望对读者有所帮助。</p>
<a id="more"></a>
<h3 id="运动复苏"><a href="#运动复苏" class="headerlink" title="运动复苏"></a>运动复苏</h3><p>在开始运动前，如果你已经多年没参加运动的话，建议可以先做些简单且容易养成习惯的运动，这边推荐的是 <strong>seven</strong>，seven 的特点就是简单粗暴，每次 7 分多钟，简单有效的运动练习。很多人都和我一样，对运动一无所知，仅仅是刚开始充满了热情，我也曾经尝试过<em>健身宝典</em>，<em>keep</em>，等等以及一开始就跑步的运动软件，但它们往往都对新人并不友好，一个是时间长，动辄 20 分钟，甚至半小时的运动，很多人不可能每天都会有这个时间，还有对器材的要求过多，动作难度大等等原因。</p>
<p>“seven” 的七分钟，只比五分钟多一点时间，一般也就是上厕所或者喝茶的时间，任何人任何时间点，只要你有想法，基本上都可以完成。</p>
<p>seven 的运动注意两点，一是难度大的动作，可以用不标准或者简化版的来代替，甚至如果有些动作你不喜欢也可以用自己喜欢的来代替；二是不要对自己太苛刻，初学者刚开始几天可能能够很好的完成，但后面发现腰酸背痛之类的，这时候你只要尽力完成就行。</p>
<p>对于新人来说，最重要的其实就是一切从简，用最简单最容易的方法，让你开始运动改变，从而养成一个每天动一下的运动习惯， seven 完全符合这一点。做 seven 的目的是为了运动复苏，帮助你找到运动的感觉和状态，当然能够出点汗之类的就更好了。差不多在你做完 seven 两周/一个月后就可以考虑做别的健身运动了，我的想法就是慢即是快，所以尽量给自己更多的调整适应时间，少一点目的性的想法。</p>
<h3 id="1-公里"><a href="#1-公里" class="headerlink" title="1 公里"></a>1 公里</h3><p>万丈高楼平地起，刚开始你跑不了马拉松，甚至 3 公里都可能要你半条命，但注意：先易后难，你永远在进步。</p>
<p>我第一次跑步的目标就是一公里，目标本身没问题，应该是可以完美执行的，但事实上，做任何事情前，还是得先研究下方法和技巧。</p>
<p>第一次跑步应该是我几十次中最最痛苦的一次，没跑完就已经全身酸痛，跑完呼吸都困难，且口中全是血腥味。去网上查了下，是毛细血管破裂，长久缺乏运动的人剧烈运动后都会有这种状况。</p>
<p>犯的错误主要有以下几点：</p>
<ul>
<li>缺乏理论知识，对跑步没有系统了解，让有氧运动变成了无氧运动，虽然速度并不快，但已经破坏了我那时的身体平衡。</li>
<li>鞋子穿的过小，由于一直不运动，那双鞋本身买的偏小，但因为平时走动少，也就没太多感觉。事实上跑步所穿的鞋一般是需要比你平时鞋码再大一号，尽量宽松为宜。</li>
<li>常识性错误，开始运动的时候穿的是牛仔裤，上体育时，老师不让穿，但也没大在意，因为平时穿习惯了，所以基本上没有其他款式的裤子。在运动受伤后，我也受到了深刻教训，坚持每次必定换整套的运动装备。</li>
</ul>
<p>由于以上一些原因，导致我运动受伤，且很久才恢复，因此从第一次运动到第二次间有大半个月时间（没发现受伤原因，没注重养护，太久不运动恢复力差），然后又运动又受伤，再才发现根本原因，果断购买装备。</p>
<p><strong>通过搜索引擎、知乎和自我总结，我的建议是：有一套运动服尽量做到宽松就行，两套运动鞋，经常换着穿可以避免养成错误的跑步姿势。</strong></p>
<p>刚开始跑步一定要注意几点：</p>
<ul>
<li>速度尽可能放慢，速度一定要慢，起初的跑步，由于并不是比谁跑的快，更不是比时间，对新手来说，能够完成既定的目标距离就是成功。</li>
<li>跑步时注意呼吸和步伐，更多关注这些会对相对减少你的疲惫感。</li>
<li>晚上多增加休息时间。初学者跑步多少会有点体力不足的，虽然说跑步能够增强体质，减少睡眠，让身心更加健康有活力等等，但这些都是长期的锻炼的功效，刚开始锻炼只会让你身心俱疲，每次锻炼耗尽体能，往往还会给你第二天带来负面影响，因此很多人有个误区，往往对运动学习等都抱有太大的期望，事实上任何事情都不可能一蹴而就，当你看不到改变或者有负面效果时，请再坚持一段时间。</li>
</ul>
<h3 id="3-公里"><a href="#3-公里" class="headerlink" title="3 公里"></a>3 公里</h3><p>第一个月由于受伤等原因，我始终保持在 1 公里的跑量，但 seven 没有落下。第二个月我将跑步逐渐从 1 公里提升到 3 公里，并且胜任。</p>
<p>这边开始就得提及一些跑步的辅助工具了，这段时间我用了<strong>悦跑圈</strong>这个软件，该软件不但可以有效的记录自己，而且悦跑圈还是有训练模式的，可以帮助你制定训练计划。但我这边并不推荐严格按照这个计划执行，一般我只是将它作为一个参考，户外运动对天气有一定的要求比如我生活的地方就经常会下雨，而且不可能每天你都有跑步的时间。所以我将跑步定为，每周完成 3 次，一般一天隔一天跑步。</p>
<p>另外一个要提及的就是，一公里你可能觉得还不错，因为毕竟路程短，一下子就结束了，但 3 公里时间并不会特别短，这时候如果你只跑步的话，会觉得特别无聊，身体的疲惫是次要的，精神的疲惫才是致命的，反反复复的话你会不断得想自己是不是累了，跑步真无聊不适合自己等等，当质变产生时，你也就放弃了。因此一个人跑步的话，我推荐买个耳机（蓝牙可能更加方便点），另外加一个臂包（放手机和钥匙，口袋有重物会严重影响跑步体验）。</p>
<p>我个人使用的是音频类软件，一个是自己下载的英文 ESLPOD ，另外一个是喜马拉雅 FM ，在跑步中，听一些有趣的东西能够分散你痛苦的注意力，同时你还能够收获一份快乐。</p>
<p>这个跑步里程已经不算短了，一定要做好合理的跑前跑和热身（尤其对于新手而言，以免受伤），我那段时间是跑前做一组 seven 然后再跑的，且跑步后往往会再走一两公里作为运动后的放松，后面会推荐一些更好的办法。</p>
<p>跑步后一小时内，别洗澡，且做好适当的保暖工作。跑步后身体毛孔舒张，体表大量热量散出，这时候冒然洗澡很容易感冒；另外也不宜过久的吹空调和吹风，一旦不注意也容易着凉。一般建议跑步完，做完拉伸后，可以看看书或者视频，这段时间你的身体会处于亢奋状态，看书学习效果都不错，但别过多降温吹风，因为一不注意就容易着凉；一个小时后，当身体热量降下来，并且略感疲惫时，可以洗个澡换个心情再做事。</p>
<h3 id="5-公里"><a href="#5-公里" class="headerlink" title="5 公里"></a>5 公里</h3><p>3 公里适应差不多花了我一个多月的时间，适应就是说跑步之后一两个小时，你的腿和身体就和平时一样了，且第二天没任何不适。万事开头难，如果你能够轻松跑完 3 公里的话，那么跑到 5 公里也就只是再稍微坚持下即可。</p>
<p>每次 3-5 公里的跑量占用时间不会过多，跑步的时间一般在 0.5h 左右，这也差不多是我现在习惯的跑量，更换装备-&gt;跑前拉伸-&gt;运动跑步-&gt;跑后拉伸，完整下来一般不到一个小时。我个人觉得夜间抽出 1h 左右的时间锻炼身体改善生活对大多数人来说都是比较合理的，锻炼后，你不仅身体上得到复苏和放松，并且晚上做别的事情也会更加舒适。</p>
<p>由于 seven 还是有点剧烈的，完整做完 seven 后，再跑步往往刚开始会有种力不从心的感觉。这边拉伸的话，推荐一个软件<strong>爱燃烧</strong>，这个软件添加运动计划后会有完整的跑前跑后拉伸动作演示，并且经常会玩出新姿势。</p>
<p>说一下运动时间的安排，我一般选择晚上 8:00-9:30 这段时间跑步，最晚会在 9:30 前结束运动，因为之前睡眠状况不好，我也去借鉴了很多人的经验和总结，如果你的睡眠质量不高，容易失眠的话，一般建议在睡前两小时停止运动，也就是说如果你 11:30 入睡，那么 9:30 就该停止运动了。运动确实是可以改善我们睡眠质量的，这点我深有体会，然而一开始刚锻炼时，由于运动时间过晚，睡眠环境吵等原因，也让自己一度难以入眠。运动完后，你的身体会持续亢奋一段时间，过晚运动的话，如果你本身睡眠就较差的话，那么这段时间你会更加亢奋的无法入眠，最终很可能辗转反侧造成失眠。</p>
<p>晚上的运动时间建议是：饭后一个小时，如果你睡眠不佳，那么超过 21 点的话，就别开始运动了。如果有可能的话，你可以选择早上运动，不是特别习惯的话，早上运动超复核，当天工作量大可能会对工作有影响；如果周末不是太忙的话，可以选择做点改变。</p>
<h3 id="10-公里"><a href="#10-公里" class="headerlink" title="10 公里"></a>10 公里</h3><p>10 公里仅仅只是再稍微坚持一把，从 5 公里到十公里的过程你的大脑报警频率已经很低，也就是说你的疲惫感会很久才出现一次，举例说明：我跑步时，一般 1-2 公里间会有种不想跑的感觉，然后 4 左右时会出现一次，但已经没有第一次强烈，之后可能会 8 公里左右才会预警（毕竟也只跑过一次，不是太清楚）。</p>
<p>虽然每隔一段时间会有一个疲惫期，但如果你听一些音频的话，就可以转移注意力，尤其的当内容比较有趣时，你甚至会忽略这些疲惫期而完全被音频所吸引。</p>
<h3 id="20-公里"><a href="#20-公里" class="headerlink" title="20 公里"></a>20 公里</h3><p>待写…</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我的运动跑步主要还是以锻炼身体为主，让你在没有教练，没有伙伴的前提下，能够更加无痛地坚持下来。总结下来，我的理念是，慢即是快，充分的做好每一步的基础，保持一直前行的动力，最终你也到达了终点；另外保持平和的心态，多些不为什么的坚持，心态好了，在执行的过程中，你也就少了目的和计较，而将注意力全部放在锻炼身体这件事上面。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[路由器配置简述]]></title>
      <url>http://noparkinghere.top/2017/05/16/2017/2017-05-16-%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p><em>本文不会深入讨论各种协议和原理，只针对家庭应用，这边详细介绍家庭使用路由器的各种配置和应用场景。</em></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>以下内容比较抽象，如果不需要具体了解的话，可以只看<strong>路由器交换机的大致区别</strong>。</p>
<p>Hub/集线器：集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。集线器工作于OSI/RM参考模型的物理层和数据链路层的MAC（介质访问控制）子层。工作原理：首先是节点发信号到线路，集线器接收该信号，因信号在电缆传输中有衰减，集线器接收信号后将衰减的信号整形放大，最后集线器将放大的信号广播转发给其他所有端口。</p>
<p>桥接：是指依据 OSI 网络模型的链路层的地址，对网络数据包进行转发的过程，工作在 OSI 的第二层。一般的交换机，网桥就有桥接作用。</p>
<p>AP（Wireless Access Point）：AP 就是传统有效网络中的 HUB，也是组建小型无线局域网时常用的设备。</p>
<p>NAT（Network Address Translation，网络地址转换）：当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。装有NAT软件的路由器叫做NAT路由器，NAT 之内的 PC 联机到 Internet 上面时，他所显示的 IP 是 NAT 主机的公共 IP。</p>
<p>调制解调器：Modulator（调制器）与Demodulator（解调器）的简称，中文称为调制解调器（港台称之为数据机），根据Modem的谐音，亲昵地称之为“猫”。它是在发送端通过调制将数字信号转换为模拟信号，而在接收端通过解调再将模拟信号转换为数字信号的一种装置。而随着光纤的普及，现在很多地方使用“光猫”，和传统的“猫”相比，“光猫”可以将数字信号转换为光信号进行传输，因此可以提供更快更稳定的上网体验。</p>
<p>交换机：交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。为接入交换机的任意两个网络节点提供<strong>独享</strong>的电信号通路。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。交换机只有一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，交换机根据 MAC 地址寻址传输数据，大家上网都相当于单独接入了因特网服务，在速度和账号方面互不影响。</p>
<p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）：是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段，在RFC 2131中有详细的描述。</p>
<p>WAN：广域网（WAN，Wide Area Network）也称远程网（long haul network ），一般端口或者设置时显示为 WAN ，表示这边控制的是外网，即因特网。</p>
<p>LAN：局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。显然这个表示的是你的内网，内网的意思就是说，你连接这个 IP 时，访问的实际是你的内部网络，而不是因特网，例如：路由器的管理地址：192.168.1.1/192.168.0.1</p>
<p>SSID：Service Set Identifier的缩写，意思是：服务集标识。SSID 技术可以将一个无线局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。SSID 最多可以有32个字符，无线网卡设置了不同的 SSID 就可以进入不同网络。SSID 通常由AP广播出来，通过操作系统的扫描功能可以查看当前区域内的 SSID。出于安全考虑可以不广播 SSID，此时用户就要手工设置 SSID 才能进入相应的网络。</p>
<p>路由器：路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host 到 host 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由器一般采用 DHCP 协议给不同的电脑分配不同的 ID 号(即IP地址)，利用不同网络的 ID 号(即IP地址)来确定数据转发的地址。另外值得注意的是：路由器通过一定配置，一般都可以当作交换机来使用。现在一般使用的无线路由器只是将有线改成了无线，不再受 LAN 口多少的限制。</p>
<p>路由器交换机的大致区别：交换机用来实现上网接入的扩展，通过电脑的 MAC 地址来识别通讯的主机；路由器会分配 IP 地址给各个电脑，然后通过不同电脑的 IP 地址来传输数据。交换机相当于对上一层的网络进行的扩展，每个接入用户都可以单独连接这个上网的入口，因此大家接入网络后互不影响，但坏处是，每个接入设备都必须有个上网的账号；路由器一般内置了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，在使用过程中，上路由器实际是管理了一个接入网络的入口，对大家进行统一管理，所有人公用一条入网的路口，因此大家上网要相互影响，但好处是所有人可以共用一个账号。</p>
<a id="more"></a>
<h3 id="路由器使用"><a href="#路由器使用" class="headerlink" title="路由器使用"></a>路由器使用</h3><p>下面说下，无路由器的上网方式：</p>
<ul>
<li>首先运营商会将网线拉入居室，该网络可以是传统的电话线/双绞线。</li>
<li>入户的信号线，需要通过调制解调器（猫）转换为数字信号，通过网线输出。</li>
<li>早期的电话上网或者无路由上网的情况，将猫出来的网线直接插入电脑，然后，使用操作系统中的，ADSL 拨号，拨号成功后，windows 右下角就会显示可以链接上网了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/1.png" alt=""></p>
<p>有路由器的方式，通过上图，我们可以看到，实际使用过程中，分为以下几步：</p>
<ul>
<li>首先运营商会将网线拉入居室，该网络可以是传统的双绞线，也可以是现在的光纤。</li>
<li>入户的信号线，需要通过调制解调器（猫）转换为数字信号，通过网线输出。注意，这边的话根据你宽带不同，可以是“普通猫”也可以是“光猫”，一般而言，这部分都是运营商帮弄好的，但不排除一些意外。</li>
<li>运营商的责任一般只到上面两个步骤，负责宽带入户/外网的接入，网线接入成功后，就不再是他们的职责了，路由器以及相关内网的布置一般由用户自己完成。</li>
<li>以无线路由器为例，用户需要将“猫”输出的网线插入到无线路由器的 WAN 口中，接着我们连接上无线路由器，连接的方法有两种，传统方法是将 LAN 口和 PC 链接；另一个方法是，无线路由器上点后会自动开启无线信号，一般是一个没有密码的开放网络（例如：TP-1212324324），使用手机连接这个网络后即可。</li>
<li>登录 LAN 无线路由管理地址，设置无线路由器，这边各个网络环境的不同设置也不一，后面详细讲解。</li>
<li>设置完无线路由器后，通过 LAN 后将网线引出插入电脑中，或者笔记本和手机链接上路由器的无线网络，就可以上网了。</li>
</ul>
<h3 id="路由器-LAN-管理地址使用"><a href="#路由器-LAN-管理地址使用" class="headerlink" title="路由器 LAN 管理地址使用"></a>路由器 LAN 管理地址使用</h3><p>有关路由器的管理地址，一般购买的路由器底部可以看到相关信息，如果根据这些信息仍然不能访问管理页面的话，则需要重置路由器。这边给出常用的一些路由器管理地址列表，但注意随着新产品的上线，很多地址未必有效了，实际使用还是以说明书为准。</p>
<table>
<thead>
<tr>
<th>品牌</th>
<th>LAN管理地址</th>
<th>用户名</th>
<th>密码</th>
</tr>
</thead>
<tbody>
<tr>
<td>TP-LINK</td>
<td>192.168.1.1</td>
<td>admin</td>
<td>admin</td>
</tr>
<tr>
<td>华硕</td>
<td>192.168.1.1</td>
<td>adsl</td>
<td>adsl1234</td>
</tr>
<tr>
<td>阿尔卡特</td>
<td>192.168.1.1</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>中兴</td>
<td>192.168.1.1</td>
<td>adsl</td>
<td>adsl831</td>
</tr>
<tr>
<td>华为</td>
<td>192.168.1.1</td>
<td>ADMIN</td>
<td>ADMIN</td>
</tr>
<tr>
<td>WST</td>
<td>192.168.0.1</td>
<td>root</td>
<td>root</td>
</tr>
</tbody>
</table>
<p>下面我们以 TP-LINK 为例进行详细讲解：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/3.png" alt=""></p>
<p>根据上图，我们可以看到路由器底部有详细的信息，使用你的手机/电脑连接上路由器后，我们使用浏览器访问上图的 <code>192.168.1.1</code> 这个地址，之后输入账户名密码，默认为 admin，就可以开始设置路由器了。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/4.png" alt=""></p>
<p>上图看到的是最近几年比较流行的新版路由器，新版路由器一般会更加人性化的给出一个“域名”，不需要访问 <code>192.168.1.1</code> 地址，直接访问这个域名既可以设置路由器。实际上，<code>toplogin.cn</code> 一般默认对应的地址为 <code>192.168.0.1</code>，也就是说输入 <code>toplogin.cn</code> 和 <code>192.168.0.1</code> 是一样的效果。</p>
<h3 id="单路由器组建网络"><a href="#单路由器组建网络" class="headerlink" title="单路由器组建网络"></a>单路由器组建网络</h3><p><em>这种方式，适合于两室一厅/三室一厅，路由器处于房子中间开放位置（不藏在箱子盒子内，各房间信号良好）。</em></p>
<p>在简单的家用无线网设置之前，我们需要先考察下“猫”是否被设置过，随着通讯设备越来越智能化，事实上，现在的“猫”大都已经集成了拨号上网的功能，服务较好的员工，会将你的账号和密码直接设置到“猫”中，而不再需要你通过路由器来拨号了。换句话说，“猫”中出来的网线直接就可以上网了，路由器只有管理局域网的作用。</p>
<p>这边以传统的 TP-LINK 为例，配置一个需要账号上网和局域网连接的路由器：</p>
<ul>
<li>用无线或网线连接路由器，成功后在地址栏中输入“192.168.1.1”（设置过程中路由器可能提示重启，但这个IP地址不变。），然后在弹出的窗口中，输入默认的用户名：admin 密码：admin。（一般这些信息都会贴在路由器背面）。如果你不是新买的路由器，按照我上面提供的方法无法访问的话（看路由器底部信息），则按下路由器的 reset 键 10 秒钟，重置路由器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/5.jpg" alt=""></p>
<ul>
<li>TP-LINK 提供了比较人性化的设置，新手的话可以直接使用设置向导，一直点击下一步，最后选择 ADSL 虚拟拨号。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/5532120-ff73e870f63bf834.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5532120-18fad7ecc1369f79.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5532120-1e7dd5a612fa82f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>接下来我们需要输入运营商给你账号和密码，这个就和网站的账号密码类似，只有有效的账号和密码验证通过后，运营商才会让你接入互联网。这个账户密码最好写在纸上贴在路由器上，否则下次如果重置路由器的话，需要打电话问运营商。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/5532120-fd11f0c6e0745fc7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>以上步骤基本设置成功后基本就完成了上网拨号的功能，但路由器还不只这些，我们需要进一步设置。</p>
<ul>
<li>如果你不是使用向导模式，就需要通过设置 WAN 口来实现拨号上网，这一步步骤和上面等同。一般我们选择自动连接，或者按需链接。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/6.jpg" alt=""></p>
<ul>
<li>既然使用了无线路由功能，那无线路由就得好好设置，在基本设置中，我们修改你的无线信号名称（SSID） 为自己常用名称，比如 home ，wifi 等，但注意老款路由器对中文支持不好，一般还是推荐用数字和字母来设置。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/7.jpg" alt=""></p>
<ul>
<li>修改你的 LAN 口设置，LAN 口设置的 IP 地址，为你开始登录管理路由器的地址，一般简单的家用的话，这个地址可以不用修改。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-16-路由器配置简述/8.jpg" alt=""></p>
<h3 id="多台路由器组建网络"><a href="#多台路由器组建网络" class="headerlink" title="多台路由器组建网络"></a>多台路由器组建网络</h3><p><em>这种适合于家庭路由器安装位置不佳，或者房间过多的情况，这时需要通过额外的一个路由器来增加一个信号源。</em></p>
<p>多台路由器建立网络时，这边多种解决方案，下面一个个来介绍：</p>
<h4 id="路由器-交换机"><a href="#路由器-交换机" class="headerlink" title="路由器+交换机"></a>路由器+交换机</h4><p>两台路由器连接时，其中一台路由器当交换机来使用，方法是：将第一台路由 器的 LAN 口用网线和 第二台无线路由器连接，这时第二台路由器就作为交换机使用，这台路由器没法分配 IP 地址，所有的 IP 分配由第一台路由器完成，第二台路由器这边相当于一个扩展的无线 hub，对它也无需进行额外配置。</p>
<h4 id="路由器-AP"><a href="#路由器-AP" class="headerlink" title="路由器+AP"></a>路由器+AP</h4><p>TP-LINK 售卖一些小型的路由器， 这些路由器信号弱一般只能覆盖一个房间，但为了方便设置，都提供了 AP 功能，使用该功能的话，基本上可以很方便的将路由器信号进行放大，无需额外的设置。</p>
<p>如果 AP 设置存在问题的话，这类路由器能够通过开关选择 route 模式，这时就相当于一个完整的路由器了，在 WAN 中不选择 ADSL 拨号，而选择动态分配 IP 即可。这时的分配方式是做一个二级路由，新的路由器再次建一个子网络。</p>
<h4 id="路由器-无线信号放大器"><a href="#路由器-无线信号放大器" class="headerlink" title="路由器+无线信号放大器"></a>路由器+无线信号放大器</h4><p>市面上现在有售卖一种无线信号放大器，该放大器，是将一个无线信号接收后放大出来，且对 SSID 和密码进行完整的克隆，产生一个相同 wifi 名和密码的信号，也就是说你在不需要连接新的 wifi 就可以上网。</p>
<h3 id="多台路由器和交换机组建网络"><a href="#多台路由器和交换机组建网络" class="headerlink" title="多台路由器和交换机组建网络"></a>多台路由器和交换机组建网络</h3><p><em>这种方式，适合于中小企业的公司网络，以及别墅使用，需要给多个房间留出有线网口</em></p>
<p>使用这个之前一定要明白路由器和交换机的大概区别，可以看上面的<strong>路由器交换机的区别</strong>。</p>
<p>这种方式建议将拨号设置在“猫”中（或者使用一个单独的拨号路由器），然后猫直接接入交换机，交换机再和每个电脑链接，如果需要使用无线网的话，交换机再分别和各个路由器连接，每台路由器设置时，选择动态 IP 方式，每个路由器所对应的 LAN 管理地址不能相同需要手动修改，否则的话会产生冲突，每个路由器建立单独的局域网提供通讯设备的访问。</p>
<blockquote>
<p>参考链接：<br><a href="https://zhidao.baidu.com/question/438038951.html" target="_blank" rel="external">https://zhidao.baidu.com/question/438038951.html</a><br><a href="http://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="external">http://www.cnblogs.com/Lynn-Zhang/articles/5754336.html</a><br><a href="https://wenku.baidu.com/view/fcc05bcdda38376baf1faea7.html" target="_blank" rel="external">https://wenku.baidu.com/view/fcc05bcdda38376baf1faea7.html</a><br><a href="http://www.192ly.com/basic/ap-mode-and-router-mode-difference.html" target="_blank" rel="external">http://www.192ly.com/basic/ap-mode-and-router-mode-difference.html</a><br><a href="http://baike.baidu.com/link?url=omJf1nxKnBwpWR6kznR4VRcxdhcXNfus-_O8-cohO7zrpHYuEAAtCTYOQ2CGacnjjYrCi0ao5xzYDcq0E3F_pq" target="_blank" rel="external">http://baike.baidu.com/link?url=omJf1nxKnBwpWR6kznR4VRcxdhcXNfus-_O8-cohO7zrpHYuEAAtCTYOQ2CGacnjjYrCi0ao5xzYDcq0E3F_pq</a><br><a href="http://blog.sina.com.cn/s/blog_7a6598170101017d.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_7a6598170101017d.html</a><br><a href="http://baike.baidu.com/item/AP/2760808" target="_blank" rel="external">http://baike.baidu.com/item/AP/2760808</a><br><a href="http://baike.baidu.com/item/HUB" target="_blank" rel="external">http://baike.baidu.com/item/HUB</a><br><a href="https://www.zhihu.com/question/21782368" target="_blank" rel="external">https://www.zhihu.com/question/21782368</a><br><a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8</a><br><a href="http://www.ruanyifeng.com/blog/2009/06/how_to_connect_2_routers_in_home_networking" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2009/06/how_to_connect_2_routers_in_home_networking</a><br><a href="http://www.ihref.com/read-16675.html" target="_blank" rel="external">http://www.ihref.com/read-16675.html</a><br><a href="http://jingyan.baidu.com/article/eae07827e3e9fc1fec548590.html" target="_blank" rel="external">http://jingyan.baidu.com/article/eae07827e3e9fc1fec548590.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[deepin体验]]></title>
      <url>http://noparkinghere.top/2017/05/12/2017/2017-05-12-deepin%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>Deepin 是由武汉深之度科技有限公司开发的Linux发行版。Deepin 是一个基于 Linux 的操作系统，专注于使用者对日常办公、学习、生活和娱乐的操作体验的极致，适合笔记本、桌面计算机和一体机。也就是说这个 linux 发行版和 ubuntu 是一样的定位，包含了所有您需要的应用程序，网页浏览器、幻灯片演示、文档编辑、电子表格、娱乐、声音和图片处理软件，即时通讯软件等等，适合于 PC 办公娱乐，对于略懂电脑的人来说可以用它来实现日常的操作从而取代 windows 。</p>
<p>Deepin 是中国最活跃的 Linux 发行版，Deepin 为所有人提供稳定、高效的操作系统，强调安全、易用、美观。其口号为“免除新手痛苦，节约老手时间”。到底是不是这样还有待考证，第一次使用 Deepin 的时候，应该是半年多以前，试用的是 15.3 ，当时也是大范围的更新，很多东西据说不是很稳定，但由于个人开始转战 linux 桌面没多久，也比较倾向于平铺式窗口管理器，所以个人基于 ubuntu 将窗口管理器换成了 awesome，现在用了将近一年，中间也出现过不少问题，尤其在中文输入法上问题繁多，且很多时候没有比价人性化的一些工具。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-12-deepin体验/1.png" alt=""></p>
<p>这次自己使用的一台台式机终于快不行了，眼看 Deepin 更新了 15.4，据官方称修复了不少 bug ，提高了稳定性，不过这个得时间的检验才能知道，之前为了看这个系统怎么样，特地在虚拟机里面装了下看看，15.3 在真实机器上装过也出过一次问题稳定性一般。</p>
<p>刚在台式机上面上了 15.4 上手不足一小时，就版本驱动的兼容性而言做的还是不错的，台式机配置：3代 i5 ，gt450 显卡，无线网卡版本不详，目前系统采用默认安装方式（原来硬盘分过两个区，不知道什么原因，在保留另外两个区的前提下无法手动格盘分区，只能覆盖了原来的一个系统盘分区进行默认安装）。</p>
<h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>最早知道 deepin 这个系统是因为当初想要找个体验好的截图软件，于是从网上发现了他们的开源项目，后来将截图工具单独移植到了我原来的 ubutnu 系统上去，该工具的好处就是截图方便，缺点就是启动速度慢，并且和我的 WM 匹配的很差，今天特地试了下了 deepin 版本的截图，发现速度确实快些，但并不是秒开约有 1~2 秒延时，和 windows 下的各类截图工具仍然有差距。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-12-deepin体验/2.png" alt=""></p>
<a id="more"></a>
<h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>输入法沿用了搜狗的输入法，为了能够输入中文，特地装的中文版的系统，怕装了英文版的，别键盘语言又出问题，之前的系统中文已经崩溃了，装不上去了。原来用 Ubuntu 的时候，用的也是 搜狗输入法，除了不支持账户登录，社区管理还软之外，某 bug 不修复之外，总的来说感觉还是很不错的，输入中文的体验和 windows 上没差别。</p>
<h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><p>状态栏直接帮设计了两种，一种是 windows 下的状态栏，另一种是类似 OS X 上的 docker，两种体验都还算不错。很多 linux 玩家喜欢倒腾这种，然而往往倒腾了好多天，用了一两天就崩溃了， deepin 在美观上面算是做的比较尽人意的。但目前下结论还太早，不知道这个系统能够支撑多久。系统还提供了几套皮肤主题可以供选择。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-12-deepin体验/3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-12-deepin体验/4.png" alt=""></p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>系统的设置做的还是比较人性化的，里面包含了天气等内容，常用的设置快捷键等一目了然，对于稍微会点电脑的人可以快速上手。大多数操作的都可以用户自己修改快捷键，并且还能够设置快捷键调用其他软件，定制型相比其他系统而已还是不错的。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-12-deepin体验/5.png" alt=""></p>
<h3 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h3><p>玩 linux 的话，可以说少不了终端，这个终端也是目前我看到的原生版里面最花哨的一个，具体的实用性有多大，还待考究。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-05-12-deepin体验/6.png" alt=""></p>
<h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p>deepin 为了迎合广大 windows 用户，特地做了一个功能强大的任务管理，具体 top 的绝大多数功能，同时最新版本还能监控各个软件网络资源占用情况。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他预装的软件还有不少如:网易云音乐，wps，steam等，这边就不详细说了，他们往往更加符合国人的使用习惯，我一般使用 linux 作为主电脑来完成日常的办公学习，所以 deepin 里面自带的软件我都比较熟悉，也都大都安装过，但这些软件不少和我原来的系统操作习惯和体验上配合不太好。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个系统应该是基于 debian 和 gnome 3 开发的，GUI 的外观上确实没话说，操作上面也比 windows 好些，但比定制的 WM 要差些，各种人性化的提示都算是继承了 windows ， OS X ，ubuntu 的优点，但这个 GUI 目测对电脑的配置要求不低，所以如果你想要在配置比较低的老电脑上面跑的话还是算了，但如果你有一台配置还不错的电脑，能够达到目前主流水准的话，还是可以安装这个系统体验一把的，这个系统的安装较简单，甚至比 windows 还要容易装，这边就不详细说明了。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机启动步骤]]></title>
      <url>http://noparkinghere.top/2017/05/09/2017/2017-05-09-%EF%BC%88%E8%BD%AC%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%AD%A5%E9%AA%A4/</url>
      <content type="html"><![CDATA[<p><em>本文介绍说明，计算机开机启动的步骤，这边以 ubuntu-linux 操作系统为例进行详细分析讲解，本文内容为转载整理，具体查阅如下链接。</em></p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/02/booting.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a><br><a href="https://wiki.deepin.org/index.php?title=%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" target="_blank" rel="external">https://wiki.deepin.org/index.php?title=%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B</a><br><a href="http://www.cnblogs.com/QLinux/articles/2540304.html" target="_blank" rel="external">http://www.cnblogs.com/QLinux/articles/2540304.html</a><br><a href="http://chrinux.blog.51cto.com/6466723/1192004" target="_blank" rel="external">http://chrinux.blog.51cto.com/6466723/1192004</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[从半途而废到每天坚持学英语]]></title>
      <url>http://noparkinghere.top/2017/05/03/2017/2017-05-03-%E4%BB%8E%E5%8D%8A%E9%80%94%E8%80%8C%E5%BA%9F%E5%88%B0%E6%AF%8F%E5%A4%A9%E5%9D%9A%E6%8C%81%E5%AD%A6%E8%8B%B1%E8%AF%AD/</url>
      <content type="html"><![CDATA[<p><em>首先这篇文章，并不是介绍学习英语的诀窍和法门，我个人顶多算是在学习英语的道路上，离目的地还是相当远的一段距离。如果你英语已经很好，或者有更好的方法和技巧，完全不需要观看本文。当然如果你愿意将你的方法分享给我，那我也会万分感谢。</em></p>
<p>在开始这段学习英语的历程之前，我的人生可以说是，基本上没有出现过可以长时间坚持下来的事情的，用一句话概括就是：想法很多，行动太少。其实，直到现在，我仍然是很多事情，想法太多，多到不够专注会打乱工作学习的节奏。</p>
<p>我个人而言，之前算是不具备坚持的品质和恒心，几乎可以囊括了所有半途而废品质的了。但在毕业几年后，我仍然选择重新开始学习英语，并且坚持了 850+ 天（两年多）。我的学习效率实在不高，生活中不具备太多英语学习的氛围，也基本没有需要用英语的地方，但随着两年多的学习，也算有了一些进步了。</p>
<p>我大学只险过了4级（这还得归功于高中还不错的英语底子），然而在开始学习英语之前，我已经大学毕业一年多，也有 4，5 年没怎么碰过英语了（差不多高考后就没在主观去学过英语），我个人觉得那时候，英语的水平应该和普通初中毕业生差不多吧。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>事情要从 14 年的年底说起，当时回老家工作，后来由于工作不满意又辞职了，所以整天在家无所事事，现在想来，当你感觉迷茫，空闲的时候，往往正是上天给你的馈赠，让你有充分的时间审视自己，发现新道路，学习新技能。某天下午无意间发现了扇贝这个软件，当时并不是说一定要去用这个软件的，而是突然有了几个念头：</p>
<ul>
<li>学习英语到底有没有用？从小学就开始学英语，学到现在还是这点水平，还是用不上，自己总觉得不甘心，难道这么多年的努力为了证明此路不通你该放弃？</li>
<li>现在在家也没有什么事情，就先学习学习，找点事情做做如何？</li>
<li>再怎么说，作为储备技能也算比较好的吧？万一将来真的需要用到呢？</li>
</ul>
<p>之所以选择这个软件，也是因为看评分很高，4.9 的评分让我也深表怀疑，于是去一个个评论看，可能看完不下一百条评论吧，得出的观点是，这个软件可以试下。当初我仍然是抱着怀疑态度的，原因是，我用了多年的智能手机，也算是一个 APP 重度使用者，当时市面上的主流学英语软件都用过，但似乎没有一款能够治得了我半途而废的毛病，用金山背单词应该是最久的估摸着连续有两个月（后来才发现这款软件设计的有问题，前一天任务无法完成后面会不断的增加你的学习量，两个月后的学习量变成了每天 1500 个单词，真是把人往死里逼）。</p>
<p>最开始使用扇贝时，我的目标很明确，就是先坚持一周下来再说，起初我用的是扇贝单词，每天学习 50+ 个单词，采用的是拼写模式，刚开始像打了鸡血一样，每天有的是时间，并且不断的加大学习量，学习时间从 40 分钟-200 分钟不等，然而你的兴奋期毕竟是有限的，你也不可能始终保持这种亢奋感。但为何我能够持续半年的时间每天学习这么久呢？又如何坚持下来的？现在看来是有原因的：</p>
<ul>
<li>自身的需求，其实我每日设定的学习任务并不多，也就是 50 个，完成这个任务一般也就 20 分钟。每天 10 多分钟的学习对大多数人来说是能够接受的，而如果你刚好闲着那就更觉得可以帮你打发时间了，所以起点低很重要，太高的起点对普通人来说一开始就意味着失败。之所以每天会学习一两个小时，是因为任务完成后，心有余力，然后又学习了额外的内容。</li>
<li>兴趣爱好，如果你很讨厌一个东西，那注定你很难把它学好，所以不说我一定有多喜欢英语，但至少还是不讨厌的。</li>
<li>扇贝有着比较好的鼓励策略，很早以前它就开始沿用了打卡这个方法，对于很多有强迫症的人来说，看到打卡日历上面缺勤是不能够忍受的，因为扇贝没有补签，所以你只能每天自己坚持完成任务。</li>
<li>奖励更加重要，在坚持的过程中，奖励是一个很好的反馈，现在看一些自控相关的书籍，都会强调奖励和反馈的重要性，这一点，扇贝每天会给坚持打卡的人积分和奖励，对连续坚持和坚持很久的人还会有徽章和额外奖励，也许当初我就是傻傻地冲着这小奖励来的。</li>
<li>轻松愉快的学习，用了将近一周时感觉比较疲乏了，突然发现，这个软件竟然还有个论坛，那段时间玩贴吧比较多，总是喜欢看帖子，这个论坛其实就相当于一个英语学习的贴吧，每次学完一段时间，都去上面逛逛看看人家的帖子经验和总结，看看娱乐类的帖子，又会让你满血复活。</li>
<li>“一个人走的快，一群人才会走得远”，很多人选择这个软件就是因为他强大的社区，在我使用这个软件两周后，突然发现有个群组，然后默默加了个群组，但当时不是太明白这是做什么的，结果该群组其他组员包括组长直接就失踪了，后来我多次逛论坛和其他小组的专区，最终选择了某排名靠前的小组。一加组后，发现新的挑战又来了（差不多是我用该软件一个多月后），但凡有一定排名的小组都注重团队荣誉，小组需要打卡，不打卡的人会被清理门户。加入小组又推着我走了很长一段距离。</li>
<li>如果只到以上内容，我想光背单词，谁能够这么无聊背个几年哇？说实在的，背单词绝对是一个无聊的过程，再有趣的方法久而久之也会变得无趣。很庆幸的是，我来到扇贝的时间刚刚好，那段时间，扇贝同时出了多款软件：听力，阅读，新闻。阅读却是检验你学习的好手段，因为你这么久积累的单词终于可以拿来用了，而这次使用你也不再是为了应付考试。后续阅读原版小说，看新闻等都为英语的提高起到了至关重要的作用。</li>
</ul>
<h3 id="后来"><a href="#后来" class="headerlink" title="后来"></a>后来</h3><p>在使用这个这个软件刚开始的 100 多天里，我算是比较认真的，每天差不多都会花 1h 以上时间在上面，一点也不懈怠，英语也确实有了明显的进步，100 多天差不多让我从快把英语淡忘恢复到了过去的最高水平。</p>
<p>何以见得是最高水平，因为那段时间，我每天差不多会背 200 左右的单词（新词数其实不多），把第一本单词书《大学生英语四级》差不多背完了，用拼写模式背完了整本单词书，这对于以前的我来说是很难想象的。另外一点就是在 4 级单词背了一半的时候，我读了人生第一本英文小说《小王子》，虽然这本书很小儿科，但万事开头难，之后看到新闻更有意思，也就养成了每天在扇贝上看新闻的习惯了。</p>
<p>之后英语给我的发展带来了一定的帮助，15 年年初的时候，找工作，虽然说英语不是硬性要求，但有的话还是加分项。直到现在我仍然比较庆幸当初有意识的去提高英语，因为工作的缘故，很多时候需要阅读外文的文档，文档如果读叉了，后面很多工作都会出问题，虽然说目前中文翻译的很多，但奈何一些小众新颖的东西还是只能硬着头皮去看官方手册。</p>
<p>后来的发展就不是特别顺畅了，工作后比较忙了，再加上缺少学习刺激，学习方法不是特别妥当，所以很长一段时间导致英语停滞不前。当初并没有去反省自身的因素，而是得过且过，熟悉领域的文档也基本能看懂，么天也有学，其他的也用不到，也没什么时间去忙别的等等。基于以上种种借口，导致大概有一年的时间，英语水平停滞，单词背完 4 级后就用了识记模式，毕竟学起来快，不折腾，阅读文章也都是走马观花，不求甚解只求大概。</p>
<p>因为以上原因，觉得先学着，反正不会退步就行，至少算是在前进。所以很长一段时间，几乎整个 2016 年，英语水平并没有太大提高，本来可以去多挑战一些外文原著之类的。16 年年底，察觉了问题的严重性，因为每次看文章加入了太多的新单词，选择单词书时也用了电视剧的单词书，导致很多单词来不及消化就开始强行学习，最终的结果就是混淆了一大堆的单词。</p>
<p>失败让人警醒，基于以上这点原因，终于痛定思痛，17 年将所有单词重置，重新开始学习，进一步将单词书扩大了一部分，重新开始拼写记忆。经过一段时间精读和拼写，又有了些进步。</p>
<p>就这两年自学英语，感觉就是，英语的学习确实不简单，并不像汉语到后面越学越容易，只需要将一些字组合即可，因为英语接受了太多的外来词汇导致一个表达意思往往有 n 多个源于不同语言的单词，每个单词对应同一个意思都还有细微的差别，好处是能够更加精准的描述某个东西，坏处就是难学，较难掌握这么大词汇量。正如某个小组所说的，第一母语是英语的人拥有 35000+ 的单词量，只有具备这么多的单词量你才可以流畅的看丰富的内容，这也难怪我看医学和影视类文章会一脸懵逼了。</p>
<p>总结下来，这两年还是有些进步的，至少可以看懂熟悉领域的文章了，能够看专业相关的文档了，偶尔去相关论坛回个帖，逛英文网站用英文版 APP 等等也没问题。这边还是不得不感谢扇贝的，如果当初没有遇到扇贝这个软件，不选择开始学英语的话，或许这些都不会发生，又或者还得再过几年我才开始重拾英语。</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>如果你使用扇贝的话，我作为打了 850+ 天的人，即便没有成功的经验，也可以交代点失败的总结。</p>
<h4 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h4><p>个人的学习计划，开始学习一定不要给太大的压力（有迫切提升需求和考试任务的除外），每天适合在 20 分钟左右的学习量，这样能够帮助你适应学习，也容易坚持下来，到后面习惯了可以调整学习量，工作忙的人不宜加量。</p>
<p>如果你喜欢偷懒，可以加入扇贝的学习计划，比如：新闻，炼句等，不完成相应计划就不能打卡。</p>
<h4 id="拼写模式"><a href="#拼写模式" class="headerlink" title="拼写模式"></a>拼写模式</h4><p>刚用扇贝时学的是四级单词，全部用拼写模式背诵的，记忆效果巩固的相当好。后来偷懒，连续识记了一年多的单词，事实证明效果相当差，最后的结果就是容易混淆一堆的单词，每次看到都觉得眼熟，然后会和其他某个长的差不多的混淆在一起。事实证明除非你聪明过人，过目不忘，不然还是老实用拼写，有时候拼写一个单词你需要试很多相近意思的单词，这也是一种提高。</p>
<h4 id="加入小组"><a href="#加入小组" class="headerlink" title="加入小组"></a>加入小组</h4><p>自学的过程注定不会太有趣，有人一起的话，可以让你跑的远些。可以加入某个认真负责的扇贝小组（注意：氛围差的小组只会把你拖下水），让组员共同来监督你的学习和进步。当然如果你没有合适的组，也可以来我们小组。</p>
<p>每个人的适应周期并不同，有的人 21 天，有的人也许一年，所以能够养成习惯并不是一件容易的事情，小组的意义也就是起到监督的作用。</p>
<h4 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h4><p>其实很好奇一些人可以一直背单词的，扇贝提供了新闻和读书，如果你不用他们来检验自己的话，学习往往会变得消化不良。建议没有时间的话，就看看新闻，扇贝新闻做的还是不错的，一般而言国内新闻比中文晚半天，国外新闻比中文早半天，看中文也是看，英文也是看，一段时间后，你会发现真没啥差别了。</p>
<p>如果你时间比较的充裕，心静的话，推荐还是看看小说吧，小说也许更加符合一些外国人的表述习惯，你需要接触更多的东西。</p>
<h4 id="提高兴趣"><a href="#提高兴趣" class="headerlink" title="提高兴趣"></a>提高兴趣</h4><p>提高英语学习兴趣的方法有很多，时间充裕的话，很多人都喜欢看美剧，当然精彩的美剧确实可以帮助你提高学习兴趣，但注意只沉迷于剧情则会有害无利，所以看美剧看电影往往需要你反复去看某一段内容的。</p>
<p>另外如果你时间充裕，建议可以去多逛逛国外的流行网站和论坛像 Facebook， google+，Twitter等，这些往往需要些技巧，如果你不具备这些技巧的话，也可以访问 <a href="www.reddit.com">reddit</a>，相当于英文版贴吧，可以充分发挥你看帖回帖的技能。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-速8]]></title>
      <url>http://noparkinghere.top/2017/04/30/2017/2017-04-30-%E5%BD%B1%E8%AF%84-%E9%80%9F8/</url>
      <content type="html"><![CDATA[<p>昨天去影院看了下《速度与激情8》，其实这部电影上映了已经快一个月了，最初的时候独占市场，而这个假期该片仍然保持着强劲的趋势，部分影院因为新片而降低了该片的排片率，但是由于持续的口碑和无对手，这几天影院又加大了该片的排片率。</p>
<p>总的来说这部电影算是对得起票价，能够看到炫酷的车技，震撼的爆破，还不错的剧情等等。</p>
<p>在我看来，《速度激情》这个系列是在第五部之后火爆起来的，很多电影往往都是越来越烂，越来越没人气和票房，比如《生化危机》，然而这部片子却是个意外，并且一部火过一部，票房在中国市场可以说是持续创造记录。</p>
<p>《速度与激情》这部电影，应该说是在不断迎合观众口味，调整自己适合市场，从最初的学校打架斗殴，地痞流氓，到后来的侠盗正义，再到特工，拯救地球的英雄等等。其实某种程度来说影片的类型早已不是一开始的了。但也许正因为如此这部片子才能大卖。</p>
<p>最近的几部《速度与激情》其实多少已经让我感觉审美疲劳了，芯片没太多可以挑剔的，但总感觉看不出什么惊喜，犹记得当初在看《速度与激情》的时候，主角塞车拉着金库在巴西街头狂奔的场景。那也许是整个系列最惊艳的时候，后来发生的所有内容都只是不断的将特效扩大做多。</p>
<p>一味的大制作，大场景也许能够吸引部分观众，但时间久了，大家也就对这个套路麻木了。《速度与激情》如果要想保持持久增长保持自己的票房神话，那一定需要找到新的爆发点。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待P10的“闪存门”]]></title>
      <url>http://noparkinghere.top/2017/04/25/2017/2017-04-25-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85p10%E7%9A%84%E2%80%9C%E9%97%AA%E5%AD%98%E9%97%A8%E2%80%9D/</url>
      <content type="html"><![CDATA[<p>华为作为国产手机的领军厂商，最近两年在市场上的表现大家有目共睹。然而天有不测风云，最近华为手机伴随着一系列的负面消息：取消防指纹涂层，混用闪存，混用内存。</p>
<p>作为普通消费者，你可能真不关心手机的具体配置，更不用说某些配置的型号的了。但混弄大众却是不可取的，毕竟群众的眼睛还是雪亮的，民间的电子爱好者和极客一天到晚盯着你，在众目睽睽下，还敢做出这样的事情，无异于找死。</p>
<p>根据目前所得到的信息，梳理下事情的缘由。</p>
<p>三星在 OLED 和存储芯片领域投资较早，几乎垄断了这两块，去年 OLED 让包括小米在内的多家厂家迟迟无法发布产品，大家也是有目共睹的。由于去年三星的 BOOM7 事件，该公司面临了巨大的损失，无论是利润还是股票都一落千丈，但是呢，三星却不想自吞恶果，于是就利用存储芯片来做文章，主要通过以下几点来控制涨价：1. 三星拥有新型存储芯片领域技术先进产能大，并且存储芯片市场出货本来就不算高，因此三星有很大的话语权；2. 大量采购生产的原材料，让一些存储芯片小厂家因为原料不足而产能低下； 3. 自家也是手机大厂，不采用本家芯片而提前大量购光其他厂家的货源，让竞争对手买不到货。通过以上这些商业手段，最终三星控制了整个存储芯片的市场。</p>
<p>关于存储芯片的价格飙涨和供应不足，其实去年就已经初现端倪了。一般来讲，华为这种公司不可能不知道，他们的供应商也一样会提前预警，并且像华为量大财大的客户肯定是能够优于其他国产厂家拿货的。综上可以看出，供应方面华为肯定是没有备足功课。</p>
<p>即便没有拿到足够的货源，那也不打紧，毕竟三星多次曾打压对手，几年前的 HTC 被截断供货打压的一蹶不振，去年的小米也因为 OLED 屏幕，导致产品延误了半年，华为之前其实应该也有过类似的经历这边就不具体说了。通过华为一致采用的配置可以看出，它并不想受控于供应商，尤其是像三星这样有直接竞争关系的，然而如何才能拜托供应不足呢？华为这次投机取巧，采用了瞒天过海的方式，直接将不同规格不同型号的两种部件：外存（ufs2.1、ufs2.0 和 emmc5.1）和内存（LPDDR3 和 LPDDR4）随机任意组合出售。</p>
<p>其实其他厂家之前也有过使用两家供应商货源的先例，例如，iPhone 之前同时用过三星和台积电两家代工的 SOC，性能测试查了 30% ，当时也有很多消费者投诉，但是，最起码你两者算是一个东西，虽有偏差但也只能认栽。另外也有过将不同存储芯片混用的先例，但人家最起码发布会或者宣传上没有高调的强调用的是 ufs2.1。之所以大家抓着这件事不放，主要是最好的 ufs2.1 和最差的 emmc5.1 完全不是一个时代的产物，性能差了 3 倍。</p>
<p>还有一点要补充的是，即便是供货不足，UFS2.1 不够用，你们还将部分用到荣耀 V9 上？这可是走性价比的机器，P10是你们家高端旗舰，价格摸到4000价位了，还缩水将 UFS2.1 给 V9 用，这内部资源的调度也是一绝。</p>
<p>华为这次给出的解释： 一部手机的体验是否流畅，不是单纯由某个单一部件性能决定的就有点自欺欺人了，存储部件的速度不可能对整体流畅没有影响。但用户并不是傻子，就算普通使用没有太大影响，想想同样的价格你买的东西比人家差了很多，这种差距多少会让人感觉买手机会像是在抽彩票一样，没抽到一脸懵逼。</p>
<p>华为别再自我膨胀，别再掩耳盗铃了，任何欺瞒消费者，损害消费者权益的事情都是不可取的，自圆其说虚假公关只会让大家更远离你，今天，你把用户当作傻逼，明天，用户就让你成为傻逼。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-人渣的本愿]]></title>
      <url>http://noparkinghere.top/2017/04/25/2017/2017-04-25-%E5%BD%B1%E8%AF%84-%E4%BA%BA%E6%B8%A3%E7%9A%84%E6%9C%AC%E6%84%BF/</url>
      <content type="html"><![CDATA[<p>前段时间看了《人渣的本愿》这部动漫，当时感觉还可以，但并不是特别想要看，所以就一直没看完。结果今天发现再找这个片子的时候，竟然已经找不到，广电总局已经封杀了。</p>
<p>这部动漫整体画风和其他的众多作品都不相同，整体上面虽然延续了小清新的风格，但是人物内心独白的几乎超过了说话的内容，在其他作品中可能比较少见的多个角色切片的方式，在这部动漫中却是随处可见。</p>
<p>说说为何这部动漫会被封杀了吧，该动漫是一部青春校园题材的作品，虽然不血腥不暴力，同《缘之空》和《日在校园》比画风显得要更加的唯美，但尺度之大甚至也超过了这两部作品。前两部作品也只是校园恋爱，暴力之类的，但《人渣的本愿》却是内容涵盖了早恋、约炮、NTR等一系列纷乱复杂的情节，里面的 4 角恋且附带旁支的关系更是秒杀了其他一切作品。</p>
<p>动漫时间并不长，静下心来观看可以看出内容还是很丰富的。可能这部动漫想要表达的东西太多，因此每个人看到的东西可能也不同。你可以看到很多内涵比如：绿茶为何这么多男人喜爱；女主从孤僻的傲慢走到了孤僻的温和；每个人寻寻觅觅的本愿究竟是什么等等。</p>
<p>这部 12 集另类青春题材的动漫还是很值得一看的，总的来说，可以用“唯美，内涵”来形容她。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）如何做到长时间（4 个小时以上）精神专注？]]></title>
      <url>http://noparkinghere.top/2017/04/24/2017/2017-04-24-%EF%BC%88%E8%BD%AC%EF%BC%89%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%95%BF%E6%97%B6%E9%97%B4%EF%BC%884-%E4%B8%AA%E5%B0%8F%E6%97%B6%E4%BB%A5%E4%B8%8A%EF%BC%89%E7%B2%BE%E7%A5%9E%E4%B8%93%E6%B3%A8%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p><em>本文为转载文章，可以参见<a href="https://www.zhihu.com/collection/42099846?page=1" target="_blank" rel="external">原文链接</a>。</em></p>
<p>首先，如果这个精神专注的意思是，一点都不分神，哪怕一秒钟，我认为是不可能的。<br>所以，我理解的是：走神或分心在可以忽略不计的范围内（如果你一定要说可以走神两秒钟，两秒不行三秒钟，再多就不行了，那么你还是自己去寻找神技吧。）</p>
<hr>
<h2 id="以下是质疑各种回答："><a href="#以下是质疑各种回答：" class="headerlink" title="以下是质疑各种回答："></a>以下是质疑各种回答：</h2><p>在这样的前提下，我觉得很多的答案都是不成立的。比如，注意力只能集中一段时间，比如30、40分钟。很多人都有一打游戏就打一个下午，打一个晚上的经历，没有人会说，打四十分钟我就必须要休息一段时间，否则接下来就集中不了精力。当然，你会说打一局中间有休息一下啊。恩，事实会证明你打完一下午或者一天你可能对游戏过程或者经历记忆犹新，中间那休息停滞的一下你根本不记得干了什么说了什么话。我觉得这样的分神就是忽略不计的。大家看电影打游戏的时候，有说我看半小时玩半小时就要休息五分钟么？（除了保护眼睛的需求）。</p>
<p>再举个例子，看武侠小说的时候，我猜绝大多数人都能长时间集中注意力。</p>
<p>所以，我听闻番茄工作法已久。但是我自己从来没用过。我很好奇的是，无数的人赞同他的时候自己是否用过。对这个问题我有很多疑问，要是打断的时候正好是我精力最集中的时候，怎么办？正是我突破某个难点的时候，怎么办？不停地这样中断，每一次中断我就要保存一次现在看到哪儿了，然后下一次开始的时候我再去进入状态，接上思维，这个开销可以忽略不计吗？还有不停的设置时间提醒自己，不嫌麻烦吗？</p>
<p>至于明天是deadline，如果明天是deadline，当然就能够长时间集中注意力了。如果明天不是deadline怎么办呢？等到了deadline再做？恩，这确实是一种方法，如果各位都喜欢玩这种高挑战动作而且保证自己不失手的话，我觉得这就是很好的方法了。或者我出于好心，再帮各位补充一种方法，没有deadline就创造deadline。这个，你要能够做到自己创造的deadline都和外界施加的deadline产生同样心理作用的话，也是很好的方法。可是，各位，有几个人能够愿意并且做到对自己产生强大的心理暗示把自己逼向死角呢？</p>
<a id="more"></a>
<hr>
<h2 id="我的回答："><a href="#我的回答：" class="headerlink" title="我的回答："></a>我的回答：</h2><p>如何做到长时间（4个小时以上）精神专注？<br>让你的注意力聚焦在你所做的事情上，你的处理速度趋近于你的接收速度，你的思维跟上你所做的事情的发展。然后保持，就OK了。</p>
<p>这好像是句废话，你问我如何长时间集中注意力，我第一句就说你的注意力要集中才能长时间集中注意力。但是这句废话就是问题的实质，我们下面各种例证来揭示这个实质。</p>
<p>当你看一部武侠小说的时候，你为什么能够两个多小时精神专注于这本武侠小说上呢？首先因为你的注意力很容易就放在这部武侠小说上，其次你的思维完全同步于武侠小说的发展，最后你的处理速度是趋近于你的接收速度的，（虽然你的大脑处理速度比正常阅读速度快很多，但是看武侠小说你可以跳过一些描写，脑补一些场景，所谓一目十行，再加上你的专注会放慢你的大脑速度。不信可以试想，同样是武侠小说，如果你不熟悉繁体字，突然看繁体竖排版的武侠小说，那么你能长时间保持专注吗？字都要认半天你怎么专注？）</p>
<p>同样，如果这是一本教科书，你就很难两小时精神专注于教科书上，首先，你就不一定感兴趣或者不想看教科书的内容，注意力就集中不了，其次就算你集中注意力开始看，你的处理速度是跟不上你的接受速度的，因为教科书的知识密度大，一页书包含了可能很多的信息，你大脑处理不过来。（这一点大家联想下数学教科书就能更深刻的体会），最后，由于处理不过来，你跟不上教科书的思维，可能因为你不知道他说这些是在干嘛，也可能因为你不知道他要干嘛，看了一会儿你自然就很容易地丢失了注意力。</p>
<p>大家试想，如果你去看电影的时候，心里面挂着的旁边的美眉或者帅哥究竟对你有没有好感，什么时候出手搞定她（他），你会像自己独自看电影时那么投入吗？可能看完电影你都不知道电影说了什么，因为你的注意力根本不在电影上。再试想，上课的时候，如果老师讲得简单，低于你的大脑处理速度，你是不是很容易就掏出手机来刷刷微博看看知乎了？如果老师讲得太难，你思维跟不上，都不知道他讲的是怎么一回事，你是不是也很容易就放弃了听课了？</p>
<p>所以为什么这种问题一旦提出，就有关于deadline的答案。因为deadline到来的时候，你根本无暇关注其他的事情，必须要去关注你手上的事情，必须要去处理你手上的事情，必须要跟上你手上的事情的发展。而一旦你进入了专注的状态，你自己都会主动排斥掉外界的打扰。比如，你打游戏的时候，到了饭点也经常顾不上吃饭；看电视剧正到精彩部分，有个人挡在电视机面前，你肯定怒喊他走开。所以你真正要干的事情就是去想办法让去让你的注意力聚焦在你所做的事情上，让你的处理速度趋近于你的接收速度，让你的思维跟上你所做的事情的发展。</p>
<h3 id="我们来讲一些具体的方法或者建议："><a href="#我们来讲一些具体的方法或者建议：" class="headerlink" title="我们来讲一些具体的方法或者建议："></a>我们来讲一些具体的方法或者建议：</h3><ul>
<li>对于本可以不需要手参与的事情，增加手参与一下，是特别好的一个方法。比如，看书的时候，同时手上做笔记。哪怕你一开始只是抄书。写字能够让你聚焦在你写的那一部分，由于写字速度的有限，对于特别难的内容，你可以理解一点写一点，写一点理解一点（特别指出，光抄但是不去理解，也就是说大脑不去处理也是白搭），对于简单的内容，写字也避免了浮躁地一目十行（不是一目十行不好，而是在不够专注的时候去增加接受速度很容易就让接受速度超过了你的处理速度，从而丢失掉专注）。而且同时在记笔记的过程中，你对书本的知识脉络有了掌握，跟上了书本讲述问题的节奏。这样很容易进入保持状态，具有一定的抗干扰能力，直到遇到无法抵抗的干扰或者中断。<br>对于你的手已经参与了进去了，比如我现在在写答案，那你的大脑必须要积极地去思考你手上的事情，现在在哪一步，下一步是什么，联系是什么。这个也不是废话，很多时候我们的大脑是在被动工作，而并非主动工作。举个阅读的例子。阅读长篇英文的时候，大家是不是会有经常看着看着就不知道看到哪儿去了的经历？这时你的大脑就不是在积极主动工作，而是被动工作的。事实是，如果你一边读一边想这段文字的他在表达什么，和上一段是什么联系，和文章主题是什么联系，说完这一段，下一段你预期他应该讲什么，到了下一段是否符合你的预期，如果符合的话你可以加快处理速度，如果不符合你就去修正你的预期。这样去阅读的话，那么你会发现你就不容易走神了。（当然这个active reading经常需要记笔记去辅助完成）</li>
<li>用一件你能够快速集中注意力的方法作为开头。我有一段时间学习之前都先看一会儿闲书。比如带上一本王小波的《沉默的大多数》。先看四五篇之后再开始学习我的专业内容。这就是让你自己先完成那三个步骤之后，进入保持状态后，再切换任务做你该做的事情。</li>
<li>在醒来之后没有多久开始。人刚醒来没多久的时候大脑中没有什么事情，这时候去开始一段长时间的专注任务是比较好的时机。如果你已经脑子里面充满杂事儿，那么你很难去单纯的聚焦在某一件事情上。</li>
<li>进行自我训练，每天都有一个长时间集中注意力的训练内容，保持自己在一个好的状态。如果我们把一次长时间集中注意力当做一场比赛，而你是一个运动员，你以为你可以到了比赛日直接上场吗？如果是，那么你就是一个业余体育爱好者，如果是一个专业的运动员，是需要赛前训练去达到能够比赛的状态以及通过训练去保持身体状态。同理，你的大脑也像你的肌肉一样，它需要对你全神贯注的挑战作出更为显著的反应，这会拓展你的大脑，使你的大脑在更高层次运作。所以，你可以采取训练的方法让自己适应长时间的集中注意力。训练内容是什么？首先，请你从一两小时的专注开始做起，而不是直接就要专注五六个小时。其次，淡化刷微博水人人聊微信这种类似活动在你生活中意义，让你浮躁的心安定下来。还有，你可以选择一个每天的例行时间，保持一个规律的习惯。</li>
<li>杜绝干扰（断网，断手机）。我是这个方法的使用者。这就是让你去没时间顾及或者说没法顾及别的东西。即当你一开始还没有专注于某事物的时候，或者当你处理速度大于接受速度的时候，你想去处理点别的，没有可处理的。当然，要是你能够顺利到达保持专注的阶段，这些不太大的干扰都不是问题。断网嘛，看这个问题：如何在联网的电脑上工作学习不走神？</li>
<li>用运动去唤醒你的身体，让你适当运动之后再开始，休息的时候也是让你的身体适当运动，而不是抱着冰淇淋去电视机面前坐着。这个意见的来源是那本所谓豆瓣拖延小组宝典的书《拖延心理学》。他说运动后会加强血液循环，让你的大脑得到更多的氧气，内啡肽，脑源神经营养因子。书上的大意是运动一个小时之后再开始。但是由于题目要集中四个小时以上的注意力，我认为这个运动量太大以至于你可能两三个小时之后就会感到困倦。所以适当的运动唤醒一下身体就好了。(UPDATE：我觉得这个方法是非常有效的，比如我最近就是如果人不太清醒就去游泳400m之后去洗个澡出去学习，能够让你的身体活跃起来后适应大脑需要高速运转的需求。当然运动完有时会有些许倦意，要挺住，可以配合一杯咖啡)</li>
<li>拒绝舒适。当你想要在床上躺着看四个小时的教科书，我觉得很难成功。同理在沙发上躺着，甚至在家里面呆着，都不利于你长时间保持注意力。我以前高中假期想要学习的时候都会去图书馆的自修室，现在要学习也不会在寝室学习。</li>
<li>对自己强烈地进行消极心理暗示。创造deadline是属于此法，你暗示自己今天不做就不行了。同理，你可以暗示自己这事情不做好就完蛋了，暗示自己现在不好好复习，GPA低了很多机会就没有了，人生从此暗淡了。诸如此类，但是一定要足够地强烈，把自己逼向死角，让自己的精神无处可逃，必须要聚焦在你手上的事情。就是注意别把自己逼疯了。同时还要说一句，之所以不建议用积极暗示，是因为怕你自己积极过度，想入非非，YY得无法聚焦了。<br>具体问题有具体手段，需要各位在实践中去发挥自己的想象力了。<br>比如，等到deadline再做是吧?</li>
</ul>
<hr>
<p>关于几个问题的实质：</p>
<ul>
<li>做你热爱的事情。兴趣，是促使你在第一下能够很容易地聚焦在你遇到的事情。人不可能永远都做自己热爱的事情，也不可能把所有的事情变成你热爱的事情。你只能是去充分理解你正在做的事情，至于理解前后你爱不爱它，那全看你自己了。我想，当你去试图理解你正在做的事情，你已经足够专注了。</li>
<li>保持运动、充足睡眠。保持运动是为了睡眠质量高，身体健康，醒着的时候精神状态好。精神状态好，你的机体都能发挥正常的功能，大脑能够正常处理它接受到的信息，眼睛能够正常地阅读。在极端情况下，比如明天deadline，即便你睡眠不足，我觉得你都会因为压力而刺激机体透支运转。所以保持运动是为了让你能够规律地长期地每天玩一次长时间集中精力。</li>
<li>番茄工作法。大问题划分成小问题，分而治之。集中精力二十五分钟当然比四个小时要容易许多。但是要是你二十五分钟都集中不了，那么番茄工作法不是白搭吗？难道变成工作十分钟休息五分钟？</li>
</ul>
<hr>
<p>最最后：<br>这个答案我编辑了三个小时了，没有使用番茄工作法，没有出现不可忽略的走神。当然，也没有坚持到四小时以上，因为三小时我已经做完了。（什么？三小时没做完，又没法继续高度专注了怎么办？人啊，不要执念于超出自己能力范围太多的事情，休息休息，到你想继续做了为止。）</p>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[人民的名义-不一样的解读]]></title>
      <url>http://noparkinghere.top/2017/04/23/2017/2017-04-23-%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>热播电视剧《人民的名义》最近成为全民讨论的话题，乍一看也许你真的以为它是一部理所当然的反腐力作，但事实并没有那么简单，《人民的名义》实则是一部纪实性中国官场百态。“人民的名义”这一词汇，在片中仅代表了现在官场的一种政治呼吁，我可以认为只是把过去封建时期官场口号“忠君如孝父”改成了现在的“忠于党和人民”，而在社会管理的体制上并没有太大突破。</p>
<p>目前中国官场的体制同过去相比并没有多大的改进，这点同明宋时期的朝堂如出一辙，国家提倡廉政就整体廉洁，国家经济繁荣就整体贪腐。甚至影片正派角色的命名都带有着浓浓的中国官僚谄媚特色，易学“习”，沙瑞“金”，侯亮“平”。</p>
<p>说了这么多，难能可贵的是，这部片子给了我们很大的解读空间，有点类似中国的政治课本（对国家主流价值观进行最为详尽的说明和解读，而对于深层次的道理往往用看似无关紧要的文字点到为止）。这种表面上看似正义终将战胜邪恶的社会主义政治改革大片，其中究竟埋藏着什么？下面我将一一对人物做分析。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/0.jpg" alt=""></p>
<a id="more"></a>
<h3 id="沙瑞金"><a href="#沙瑞金" class="headerlink" title="沙瑞金"></a>沙瑞金</h3><p>沙瑞金在全剧的戏份并不多，而他真的是一个勇于约束自我，自身很正直，全心全意为民的好领导吗？</p>
<p>实则，片中的沙瑞金就像高育良说的那样，就是新官到任，想要一举整垮汉东的旧势力，即便高育良没犯事，他也能给他整出事情来，让他倒台。沙瑞金还是很有政治手腕的，一方面在否定汉东的改革成果，另一方面还为自己辩解，安抚某副国级老领导。</p>
<p>而说到沙瑞金，那么他为何非要整高育良而不去整李达康呢？高育良是省委副书记，说了好听点就是虽然没啥实权，都是和沙瑞金官属同级，这点对沙瑞金的威胁就比较大了，毕竟两人不熟，另外高育良的汉大帮在汉东实则是真正的掌权者，公检法各个部门的头目都是他们的人，你说在这种情况下，沙瑞金不整高育良整谁？即便没有侯亮平也会有孙亮平或者李亮平，因为沙瑞金早已掌握了不少证据，一切尽在掌握中，侯亮平也只是沙瑞金手中的一把剑，加快了汉东固有政治体系崩塌的速度。</p>
<p>你真以为沙瑞金没有去整李达康吗？沙瑞金的初衷打算其实就是先整李达康，柿子都挑软的捏，先整掉一个小的再循序渐进的整大的。而李达康的这个人作风却又太过谨慎，沙瑞金旁敲侧击想尽一切办法想去挖李达康的问题，硬是挖不出什么严重的问题，顶多能够定个用人不慎的罪。看似沙瑞金和李达康相处和睦，但李达康毕竟不是沙瑞金的人，最后沙瑞金不但让李达康停在原职，还拉来了易学习来监视李达康，更不忘找田国富这位挚友来“监督”自己。而另一方面，作为一个优秀的领导往往知道用人唯贤的重要性，李达康虽然不会是自己人，但却会是对自己政绩有利的人。</p>
<p>沙瑞金就是打着反腐倡廉的口号，用最快的速度扫除异己，清理旧势力，让自己可以接手整个汉东的统治，正所谓一代君子一代臣。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/1.jpg" alt=""></p>
<h3 id="高育良"><a href="#高育良" class="headerlink" title="高育良"></a>高育良</h3><p>高育良也是全片的灵魂人物之一，是汉东的省委副书记，汉大帮的首领，代表着汉东的旧势力。高育良多年从事政治活动，虽然有一些任人唯亲的嫌疑，但基本上还是能够做到知人善任的。高育良的作风是，个人坚守底线，不贪污，不腐败，与人为善，亲戚朋友熟人能帮的都尽量帮，仅以上这些在中国官场就实属难得了。</p>
<p>高育良受美女诱惑，再婚生子，沙瑞金认为高育良个人问题没有向组织汇报，但事实上沙瑞金才来没多久，而高育良也离婚好多年了，高育良的婚姻状况原省委书记肯定是知道的，这点可以说是不存在欺瞒问题的。</p>
<p>高育良的问题出现在两个方面，一个用人不察，祈同伟等手下，已经是铁了心要拉他上船，高育良既然不肯收受贿赂，那就从高小凤下手；另一方面，就是以沙瑞金为代表的沙家帮有意要整他。说白了我们可以看清高育良和李达康的问题如出一辙，但有心人会留给李达康金蝉脱壳的时间，却注定要将高育良往死里整。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/2.jpg" alt=""></p>
<h3 id="李达康"><a href="#李达康" class="headerlink" title="李达康"></a>李达康</h3><p>李达康这个角色，算的上是中国政治界的一朵奇葩了，这样的人在李朝历代可能也都会存在，但属于非主流，而能够爬到高位的就更是少之又少了。利康达之所以能够位居省委，得益于两点，首先，他自身敢闯敢干有能力，有能力并没有用，是时代选择了李达康，而不是李达康改变了时代，李达康任职的时期刚好是改革开放的重要时期，这时候像李达康这种激进分子就尤为得到器重。另外一点，就是博弈的结果，面对日益强大的汉大帮，老省委书记为了制衡，得设计一个李家帮出来对抗一下，像李达康这种原来就和高育良有过节的人，舍他其谁呢？</p>
<p>李达康远非大家网络上所说的那样为党为民，他忠于的从来都是自己的政治抱负，只不过他的执政报复刚好和现在的政治主张“为人民当家”有所重叠，所以大家才会觉得李达康是个好官。李达康的特点可以表现在这几点：举贤避亲，用人不察，蛮狠指挥，溜须拍马，恪守底线。</p>
<p>举贤避亲，相信他家都可以看出来，只要和李达康沾亲带故的人，李达康都会像防备着毒蛇猛兽一般，敬而远之，哪怕对方再有能力和作为，他都惟恐举贤后给人落下话柄，或者出事后被牵连。</p>
<p>举贤避亲的结果往往就是用人不察，丁义珍和李达康只能算是普通的上下级关系，既然不亲，你又怎么知道他在干嘛呢？不拉帮结派，手下出了事情到底有没有做事，你都浑然不知，而善于拉帮结派的高育良最起码能够做到心中有数。</p>
<p>李达康的蛮狠专政是出了名的，早期在县里工作就帮人开会开死了，而该剧里面的孙连城更是成了李达康政治的牺牲品。孙连城算是一个没什么野心和作为的区长，但却受到李达康的多次逼迫，首先一上任就得为大风厂事件买单，区政府一下就变得亏空了，其次信访办整修还得按照银行的规格来，这个钱怎么来？</p>
<p>李达康也是深谙官场之道的人，不然不可能走到现在，对沙瑞金是一味的溜须拍马客气异常，谈及高育良时，也是多说好话不提供有用信息，与赵瑞龙的谈话也总是保持的对老省委书记谦卑的态度。</p>
<p>李达康身上最大的特点就是自制，他唯一的目标就是政绩，生活中极尽无聊无趣，可以说是几十年如一日般的过着苦行僧的生活，这也是为何面对无孔不入的腐化，他仍然可以高枕无忧的原因。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/3.jpg" alt=""></p>
<h3 id="祁同伟"><a href="#祁同伟" class="headerlink" title="祁同伟"></a>祁同伟</h3><p>祈同伟算是该剧的主角之一，有能力，有理想和报复。在学校时就是学生会主席，一直以来都是其他人的楷模，能吃苦能拼搏，在工作之初，冒着生命危险缉拿毒贩。在职务上，祈同伟年纪轻轻，应该不超过 45 岁，却早已是省公安厅长，并且可能会被提拔为副省长，可以看出祈同伟智商情商都高，手段也了得。</p>
<p>祁同伟的理想和李达康一样，就是要出人头地，实现宏达的政治抱负。只不过两者选择了不一样的道路，李达康靠业绩取胜，祁同伟却是靠关系上位。祈同伟最大的败笔就是自我膨胀无法无天，他可以把不识字的亲戚安排到公安机关，让伦奸犯逍遥法外，连老家的野狗都可以拉来当警犬，如此放任自由怎么可能不出事？但其实我根觉得这边编剧特意如此安排，祁同伟如此放纵又涉事很深这点在这儿是很说不通的。</p>
<p>祁同伟其实就是寒门子靠自己来权倾朝野，中国自古以来都有这种问题，贵族与寒门的对立博弈历久弥新。贵族看不起寒门为了利益不择手段，自私自利，人品败坏；寒门又瞧不上这些啃老族，不学无术，无才无能。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/4.jpg" alt=""></p>
<h3 id="侯亮平"><a href="#侯亮平" class="headerlink" title="侯亮平"></a>侯亮平</h3><p>侯亮平这个角色安插在这个官场大势中，在剧情上，应该来说没太多问题的，就好比鲶鱼掉入了沙丁鱼群中，激起了一连串的反应，有破坏规则的出现，才会有爆发矛盾和冲突。</p>
<p>侯亮平仍然算是全剧最违和的角色，总让人感觉是为了加入反腐的情节而特意安插进来的角色。因为侯亮平打着“人民的名义”的旗号，但他又凭什么代表着人民的名义，又凭什么出淤泥而不染，不被腐化？</p>
<p>全剧中，众多喊着为党为民的角色一旦被调查都是成了反面的典型，田国富和沙瑞金是不是也和赵徳汉一样虚伪我们不得而知，可以确认真正恪守住底线的只有李达康和陈岩石夫妇。但这是有缘由的，李达康是有着更大的理想和报复，说白了还是自私胜过了其他欲望；陈岩石夫妇所处的时代背景完全不相同，那个时代，确实可能会有如此高洁的人。侯亮平很聪明，并且也深谙官场之道，但他的不怕死，孑然一身，正气使然却来的很无厘头。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/5.jpg" alt=""></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>以上内容只代表个人的一些观点，该片中其他角色还有很多，比如：精致的利己主义者吴惠芬，可怜又可恨的女强人高小琴，被坑的无私无为区长孙连城，吃力不讨好的刘新建等等，限于篇幅，这边就详细展开分析了。</p>
<hr>
<p>写作时间：14:50-18:15</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[人民的名义-两个凤凰男的抉择]]></title>
      <url>http://noparkinghere.top/2017/04/22/2017/2017-04-22-%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89-%E4%B8%A4%E4%B8%AA%E5%87%A4%E5%87%B0%E7%94%B7%E7%9A%84%E6%8A%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<p>追剧追了很多天，终于把《人民的名义》看完了，这部电视剧尺度大，不造作，内容安排也很为合理，是近几年来少有的力作。本文涉及到对《人民的名义》这部电视剧的一些剧透，如果没有看完，并不想被剧透的，请出门左拐。</p>
<p>这部电视剧涉及到了很多社会问题和现象，本文就只对同为凤凰男的祈同伟和李达康进行讨论。</p>
<a id="more"></a>
<p>祈同伟算是该剧的主角之一，有能力，有理想和报复。在学校时就是学生会主席，一直以来都是其他人的楷模，能吃苦能拼搏，在工作之初，冒着生命危险缉拿毒贩。在职务上，祈同伟年纪轻轻，应该不超过 45 岁，却早已是省公安厅长，并且可能会被提拔为副省长，可以看出祈同伟智商情商都高，手段也了得。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/4.jpg" alt=""></p>
<p>李达康激进的改革派，作风霸道不讲理，可以说是一个接触的政治家，一心想要政绩，想要往上爬。多年的生活就像苦行僧一样，不近人情，不拉帮结派，没有任何娱乐和生活乐趣，唯一的爱好就是工作。和祈同伟比，李达康的仕途并不算很顺利，而他的升迁也全靠自己的政绩。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-23-人民的名义-不一样的解读/3.jpg" alt=""></p>
<p>祈同伟最终畏罪自杀了，一个有能力，情商智商都高的人为何会走到这一步？虽然李达康的老婆受贿被判了 10 多年，但他为何仍然可以混的风生水起？</p>
<p>个人判断，其实祈同伟在能力上面绝不逊色于李达康，两人都敢闯敢拼，其次祈同伟在智商和情商上面甚至要优越于李达康。但事实却是聪明反被聪明误，祈同伟无论在多少地方优越于李达康，但终究和李达康比他缺少了自律。</p>
<p>李达康在自律这件事上面做的甚至已经到了令人发指的地步，不光不近人情，且对有所有的亲朋好友都像对毒蛇猛兽一般避而远之。即便是李达康的老对手，杰出政治家高育良也防不胜防的被拉下马，但李达康却可以高枕无忧，这完全得益于他几十年如一日的苦行僧般的生活。</p>
<p>自律很重要，一个具备能力也充满野心的人如果缺乏自制的话，无疑这将会是很危险的事情，他们的失控损害的不仅仅是自己，更可能会是千千万万的人。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[MDK编译生成.bin文件]]></title>
      <url>http://noparkinghere.top/2017/04/20/2017/2017-04-20-mdk%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90-bin%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>使用 MDK 时，我们实际烧录的文件其实是 .axf 文件，所以一般情况下我们不需要编译出 .bin 或 .hex 文件。</p>
<p>生成 .hex 文件时，需要在工程打开状态 MDK 的 Options for Target 选项中，点击 Output 选项，在中间的  Create HEX File 的空白矩形框上打上勾即可。 .hex 文件可以使用第三方烧写工具烧录到 MCU 中，但是一些烧录工具或者芯片只支持 .bin 文件的烧录，这时候我们需要 MDK 能够输出 .bin 文件，并且 .bin 文件远要比 .hex 来的通用些。</p>
<p>下面说下如何生成 .bin 文件：</p>
<ul>
<li>打开 Options for Target ‘xxx’ 对话框，选择 User 标签页。</li>
<li>构选 Run User Programs After Build/Rebuild 框中的 Run#1 多选框，在后边的文本框中输入 <code>C:/Keil_v5/ARM/ARMCC/bin/fromelf.exe --bin -o ../OBJ/consumer.bin  ../OBJ/consumer.axf</code> ，这条命令类似于 gcc ，对于不同的版本 fromelf.exe 软件位置不同，如果找不到可以尝试手动搜索，如果设置完编译不成功则代表你的路径有问题需要仔细检查路径位置，目录的当前路径为 uvproj 工程文件所在位置，我的输出路径为工程目录上一级的下的 OBJ 文件夹。</li>
<li>重新编译文件，在 ./OBJ/ 文件夹下生成了 consumer.bin 文件。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-20-mdk编译生成-bin文件/1.png" alt=""></p>
<p>直接在 CMD.exe 下运行 fromelf 工具则可以看到所有的选项和基本命令，这边仅列出最常用的一些内容:</p>
<ul>
<li>–bin:输出二进制文件</li>
<li>–i32:Intel 32位Hex</li>
<li>–m32：Motorola 32位Hex</li>
<li>–output <file>:file为输出文件名</file></li>
<li>-o<file>:这个是armcc编译器命令,也可用于这里,指定输出文件的名字</file></li>
</ul>
<p>转换过程实际是：通过fromelf.exe工具进行转换，将 .axf 格式的文件转换成 .bin 格式的文件。你也可以不通过 MDK ，而是直接在 CMD.exe 窗口下运行 <code>C:/Keil_v5/ARM/ARMCC/bin/fromelf.exe --bin -o ../OBJ/consumer.bin  ../OBJ/consumer.axf</code> 手动将 .axf 文件 转换成 .bin 文件。</p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bash使用技巧]]></title>
      <url>http://noparkinghere.top/2017/04/19/2017/2017-04-19-bash%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>本文归纳总结了一些使用 bash 时的一些快捷键，命令技巧等，由于 bash 在类 unix 操作系统中最为常见，很多时候我们无法绕开它，因此了解并掌握这些技巧能够让你事半功倍。当然如果是个人使用的话我还是建议可以选择 zsh ，github 上面有 zsh 的配置方案，它能够给你带来更好的使用体验。</p>
<p>这边这更新我会用到的一些快捷操作和技巧，对于一些难用不常用的一概不提。</p>
<a id="more"></a>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 主要用来记录你已经输入过的命令，使用 history | less 可以查目前你输入过的命令。man bash 后查找 Readline Key Bindings 可以看到 bash 的默认热键。以下推荐一些最常用的快捷键和指令：</p>
<ul>
<li>!! 回车则执行上一条命令</li>
<li>使用 Ctrl-R 而不是上下光标键来查找历史命令。</li>
<li>Alt-. 把上一次命令的最后一个参数打出来，!$ 功能一样但不是太好用</li>
<li>Ctrl-L 清屏</li>
<li>Ctrl-H 用来代替 backspace 按键</li>
<li>Ctrl-D 向后删除一个字符和 Ctrl-H 方向相反</li>
<li>Ctrl-W 来删除最后一个单词，分隔符为空格。</li>
<li>Ctrl-U 来删除当前所在位置到行首</li>
<li>Ctrl-K 来删除当前所在位置到行尾</li>
<li>Ctrl-A 光标移动到行首</li>
<li>Ctrl-E 光标移动到行尾</li>
<li>Alt-F 光标向前移动一个单词</li>
<li>Alt-B 管标向后移动一个单词</li>
</ul>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><ul>
<li>cd ~ 打开当前用户的根目录</li>
<li>cd - 回到原来的目录</li>
</ul>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p><code>cat &gt;&gt; /tmp/test.txt &lt;&lt; &quot;EOF&quot;</code> 它能让你通过块文本符号来将段落插入文件中，通常用的符合是EOF(意思是 “End Of File”)，这是比较常见的一种文件内容追加技巧。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.tpircsboy.com/tech/bash-skills-part1/" target="_blank" rel="external">http://blog.tpircsboy.com/tech/bash-skills-part1/</a><br><a href="http://9530025.blog.51cto.com/9520025/1568806" target="_blank" rel="external">http://9530025.blog.51cto.com/9520025/1568806</a><br><a href="http://ahei.info/bash.htm" target="_blank" rel="external">http://ahei.info/bash.htm</a><br><a href="http://coolshell.cn/articles/8883.html" target="_blank" rel="external">http://coolshell.cn/articles/8883.html</a><br><a href="http://www.cnblogs.com/napoleon_liu/articles/1952228.html" target="_blank" rel="external">http://www.cnblogs.com/napoleon_liu/articles/1952228.html</a><br><a href="http://www.linuxidc.com/Linux/2015-03/114349.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2015-03/114349.htm</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）应该知道的LINUX技巧]]></title>
      <url>http://noparkinghere.top/2017/04/19/2017/2017-04-19-%EF%BC%88%E8%BD%AC%EF%BC%89%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84linux%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p><em>本文为一篇转载文章，可以参见<a href="http://coolshell.cn/articles/8883.html" target="_blank" rel="external">原文链接</a>。</em></p>
<p>这篇文章来源于Quroa的一个问答《What are some time-saving tips that every Linux user should know?》—— Linux用户有哪些应该知道的提高效率的技巧。我觉得挺好的，总结得比较好，把其转过来，并加了一些自己的理解。 首先，我想告诉大家，在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化。如果你看过《你可能不知道的Shell》以及《28个Unix/Linux的命令行神器》你就会知道Linux有多强大，这个强大完全来自于命令行，于是，就算你不知道怎么去做一个环保主义的程序员，至少他们可以让你少熬点夜，从而有利于你的身体健康和性生活。下面是一个有点长的列表，正如作者所说，你并不需要知道所有的这些东西，但是如果你还在很沉重地在使用Linux的话，这些东西都值得你看一看。 （注：如果你想知道下面涉及到的命令的更多的用法，你一定要man一点。对于一些命令，你可以需要先yum或apt-get来安装一下，如果有什么问题，别忘了Google。如果你要Baidu的话，我仅代表这个地球上所有的生物包括微生物甚至细菌病毒和小强BS你到宇宙毁灭）</p>
<blockquote>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3></blockquote>
<ul>
<li>学习 Bash 。你可以man bash来看看bash的东西，并不复杂也并不长。你用别的shell也行，但是bash是很强大的并且也是系统默认的。（学习zsh或tsch只会让你在很多情况下受到限制）</li>
<li>学习 vim 。在Linux下，基本没有什么可与之竞争的编译辑器（就算你是一个Emacs或Eclipse的重度用户）。你可以看看《简明vim攻略》和 《Vim的冒险游戏》以及《给程序员的Vim速查卡》还有《把Vim变成一个编程的IDE》等等。</li>
<li>了解 ssh。明白不需要口令的用户认证（通过ssh-agent, ssh-add），学会用ssh翻墙，用scp而不是ftp传文件，等等。你知道吗？scp 远端的时候，你可以按tab键来查看远端的目录和文件（当然，需要无口令的用户认证），这都是bash的功劳。</li>
<li>熟悉bash的作业管理，如： &amp;, Ctrl-Z, Ctrl-C, jobs, fg, bg, kill, 等等。当然，你也要知道Ctrl+\（SIGQUIT）和Ctrl+C （SIGINT）的区别。</li>
<li>简单的文件管理和权限管理 ： ls 和 ls -l (你最好知道 “ls -l” 的每一列的意思), less, head, tail 和 tail -f, ln 和 ln -s (你知道明白hard link和soft link的不同和优缺点), chown, chmod, du (如果你想看看磁盘的大小 du -sk *), df, mount。当然，原作者忘了find命令。</li>
<li>基础的网络管理： ip 或 ifconfig, dig。当然，原作者还忘了如netstat, ping, traceroute, 等</li>
<li>理解正则表达式，还有grep/egrep的各种选项。比如： -o, -A, 和 -B 这些选项是很值得了解的。</li>
<li>学习使用 apt-get 和 yum 来查找和安装软件（前者的经典分发包是Ubuntu，后者的经典分发包是Redhat），我还建议你试着从源码编译安装软件。</li>
</ul>
<a id="more"></a>
<blockquote>
<h3 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h3></blockquote>
<ul>
<li>在 bash 里，使用 Ctrl-R 而不是上下光标键来查找历史命令。</li>
<li>在 bash里，使用 Ctrl-W 来删除最后一个单词，使用 Ctrl-U 来删除一行。请man bash后查找Readline Key Bindings一节来看看bash的默认热键，比如：Alt-. 把上一次命令的最后一个参数打出来，而Alt-* 则列出你可以输入的命令。</li>
<li>回到上一次的工作目录： cd –  （回到home是 cd ~）</li>
<li><p>使用 xargs。这是一个很强大的命令。你可以使用-L来限定有多少个命令，也可以用-P来指定并行的进程数。如果你不知道你的命令会变成什么样，你可以使用xargs echo来看看会是什么样。当然， -I{} 也很好用。示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find . -name \*.py | xargs grep some_function</div><div class="line">cat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</div></pre></td></tr></table></figure>
</li>
<li><p><code>pstree -p</code> 可以帮你显示进程树。（读过我的那篇《一个fork的面试题》的人应该都不陌生）</p>
</li>
<li>使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).</li>
<li>了解可以发给进程的信号。例如：要挂起一个进程，使用 kill -STOP [pid]. 使用 man 7 signal 来查看各种信号，使用kill -l 来查看数字和信号的对应表</li>
<li>使用 nohup 或  disown 如果你要让某个进程运行在后台。</li>
<li>使用netstat -lntp来看看有侦听在网络某端口的进程。当然，也可以使用 lsof。</li>
<li>在 bash 的脚本中，你可以使用 set -x 来debug输出。使用 set -e 来当有错误发生的时候abort执行。考虑使用 <code>set -o pipefail</code> 来限制错误。还可以使用 trap 来截获信号（如截获ctrl+c）。</li>
<li><p>在 bash 脚本中，subshells (写在圆括号里的) 是一个很方便的方式来组合一些命令。一个常用的例子是临时地到另一个目录中，例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># do something in current dir</span></div><div class="line">(<span class="built_in">cd</span> /some/other/dir; other-command)</div><div class="line"><span class="comment"># continue in original dir</span></div></pre></td></tr></table></figure>
</li>
<li><p>在 bash 中，注意那里有很多的变量展开。如：检查一个变量是否存在: ${name:?error message}。如果一个bash的脚本需要一个参数，也许就是这样一个表达式 input_file=${1:?usage: $0 input_file}。一个计算表达式： i=$(( (i + 1) % 5 ))。一个序列： {1..10}。 截断一个字符串： ${var%suffix} 和 ${var#prefix}。 示例： if var=foo.pdf, then echo ${var%.pdf}.txt prints “foo.txt”.</p>
</li>
<li>通过 &lt;(some command) 可以把某命令当成一个文件。示例：比较一个本地文件和远程文件 /etc/hosts： diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</li>
<li>了解什么叫 “here documents” ，就是诸如 cat &lt;&lt;EOF 这样的东西。</li>
<li>在 bash中，使用重定向到标准输出和标准错误。如： some-command &gt;logfile 2&gt;&amp;1。另外，要确认某命令没有把某个打开了的文件句柄重定向给标准输入，最佳实践是加上 “&lt;/dev/null”，把/dev/null重定向到标准输入。</li>
<li>使用 man ascii 来查看 ASCII 表。</li>
<li>在远端的 ssh 会话里，使用 screen 或 dtach 来保存你的会话。（参看《28个Unix/Linux的命令行神器》）</li>
<li>要来debug Web，试试curl 和 curl -I 或是 wget 。我觉得debug Web的利器是firebug，curl和wget是用来抓网页的，呵呵。</li>
<li>把 HTML 转成文本： lynx -dump -stdin</li>
<li>如果你要处理XML，使用 xmlstarlet</li>
<li>对于 Amazon S3， s3cmd 是一个很方便的命令（还有点不成熟）</li>
<li><p>在 ssh中，知道怎么来使用ssh隧道。通过 -L or -D (还有-R) ，翻墙神器。<br>你还可以对你的ssh 做点优化。比如，.ssh/config 包含着一些配置：避免链接被丢弃，链接新的host时不需要确认，转发认证，以前使用压缩（如果你要使用scp传文件）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TCPKeepAlive=yes</div><div class="line">ServerAliveInterval=15</div><div class="line">ServerAliveCountMax=6</div><div class="line">StrictHostKeyChecking=no</div><div class="line">Compression=yes</div><div class="line">ForwardAgent=yes</div></pre></td></tr></table></figure>
</li>
<li><p>如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。那么，你可以按下 Alt-# ，于是这个命令关就被加了一个#字符，于是就被注释掉了。</p>
</li>
</ul>
<blockquote>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3></blockquote>
<ul>
<li>了解 sort 和 uniq 命令 (包括 uniq 的 -u 和 -d 选项).</li>
<li>了解用 cut, paste, 和 join 命令来操作文本文件。很多人忘了在cut前使用join。</li>
<li><p>如果你知道怎么用sort/uniq来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已解被 uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cat a b | <span class="built_in">sort</span> | uniq &gt; <span class="built_in">c</span>   # <span class="built_in">c</span> <span class="keyword">is</span> a union b 并集</div><div class="line">cat a b | <span class="built_in">sort</span> | uniq -d &gt; <span class="built_in">c</span>   # <span class="built_in">c</span> <span class="keyword">is</span> a intersect b 交集</div><div class="line">cat a b b | <span class="built_in">sort</span> | uniq -u &gt; <span class="built_in">c</span>   # <span class="built_in">c</span> <span class="keyword">is</span> <span class="keyword">set</span> difference a - b 差集</div></pre></td></tr></table></figure>
</li>
<li><p>了解和字符集相关的命令行工具，包括排序和性能。很多的Linux安装程序都会设置LANG 或是其它和字符集相关的环境变量。这些东西可能会让一些命令（如：sort）的执行性能慢N多倍（注：就算是你用UTF-8编码文本文件，你也可以很安全地使用ASCII来对其排序）。如果你想Disable那个i18n 并使用传统的基于byte的排序方法，那就设置export LC_ALL=C （实际上，你可以把其放在 .bashrc）。如果这设置这个变量，你的sort命令很有可能会是错的。</p>
</li>
<li>了解 awk 和 sed，并用他们来做一些简单的数据修改操作。例如：求第三列的数字之和： awk ‘{ x += $3 } END { print x }’。这可能会比Python快3倍，并比Python的代码少三倍。</li>
<li>使用 shuf 来打乱一个文件中的行或是选择文件中一个随机的行。</li>
<li>了解sort命令的选项。了解key是什么（-t和-k）。具体说来，你可以使用-k1,1来对第一列排序，-k1来对全行排序。</li>
<li>Stable sort (sort -s) 会很有用。例如：如果你要想对两例排序，先是以第二列，然后再以第一列，那么你可以这样： sort -k1,1 | sort -s -k2,2</li>
<li>我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在sort -t选项后输入<tab>字符），你可以先按Ctrl-V，然后再按Tab键，就可以输入<tab>字符了。当然，你也可以使用$’\t’。</tab></tab></li>
<li>如果你想查看二进制文件，你可以使用hd命令（在CentOS下是hexdump命令），如果你想编译二进制文件，你可以使用bvi命令（<a href="http://bvi.sourceforge.net/" target="_blank" rel="external">http://bvi.sourceforge.net/</a> 墙）</li>
<li>另外，对于二进制文件，你可以使用strings（配合grep等）来查看二进制中的文本。</li>
<li>对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）</li>
<li>如果你要分隔一个大文件，你可以使用split命令（split by size）和csplit命令（split by a pattern）。</li>
</ul>
<blockquote>
<h3 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h3></blockquote>
<ul>
<li>如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top (或更好的 htop), 还有 dstat 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop, iotop等（参看《28个Unix/Linux的命令行神器》）</li>
<li>要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意 “cached” 的值，这个值是Linux内核占用的内存。还有free的值。</li>
<li>Java 系统监控有一个小的技巧是，你可以使用kill -3 <pid> 发一个SIGQUIT的信号给JVM，可以把堆栈信息（包括垃圾回收的信息）dump到stderr/logs。</pid></li>
<li>使用 mtr 会比使用 traceroute 要更容易定位一个网络问题。</li>
<li>如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或 nethogs。</li>
<li>Apache的一个叫 ab 的工具是一个很有用的，用quick-and-dirty的方式来测试网站服务器的性能负载的工作。如果你需要更为复杂的测试，你可以试试 siege。</li>
<li>如果你要抓网络包的话，试试 wireshark 或 tshark。</li>
<li>了解 strace 和 ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用 -c 选项，你可以使用-p选项来attach上任意一个进程。</li>
<li>了解用ldd命令来检查相关的动态链接库。注意：ldd的安全问题</li>
<li>使用gdb来调试一个正在运行的进程或分析core dump文件。参看我写的《GDB中应该知道的几个调试方法》</li>
<li>学会到 /proc 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps.</li>
<li>如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。</li>
<li>使用 dmesg 来查看一些硬件或驱动程序的信息或问题。</li>
</ul>
<p>作者最后加了一个免责声明：Disclaimer: Just because you can do something in bash, doesn’t necessarily mean you should. ;) （全文完）</p>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[电器电子产品接口--视频接口]]></title>
      <url>http://noparkinghere.top/2017/04/18/2017/2017-04-18-%E7%94%B5%E5%99%A8%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E6%8E%A5%E5%8F%A3--%E8%A7%86%E9%A2%91%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>本文介绍有关家用黑电和数码电子产品的数据线以及接口，方便在购买时可以查阅，免得买错，或者混淆，注意这边只说明一些主流还算常用的接口，对于一些不常用的可能不会提及，注意一些常见的设备间可能会有重叠部分。</p>
<p>由于技术更新迭代的快，这边一篇文章实在无法将所有内容都阐述清除，这边绝对作为一个系列的文章进行发布，本文主要介绍常用家电和数码产品的视频接口。</p>
<blockquote>
<h3 id="电视机"><a href="#电视机" class="headerlink" title="电视机"></a>电视机</h3></blockquote>
<p>电视发展至今已经很多年了，各种接口也经历了多种更新，下面我只举例出几个比较常见的端口。</p>
<h4 id="S端子"><a href="#S端子" class="headerlink" title="S端子"></a>S端子</h4><p>S端子（S-Video）是早期电视中应用最普遍的视频接口之一，连接规格是由日本人开发的一种规格，S 指的是“SEPARATE（分离）”，它将视频数据分成两个单独的讯号（光亮度和色度）进行传送的模拟视频讯号，避免了混合视讯讯号输出时亮度和色度的相互干扰。S接口实际上是一种五芯接口，由两路视亮度信号、两路视频色度信号和一路公共屏蔽地线共五条芯线组成。</p>
<p>早期我们的有线电视 DVD 等设备，很多都是通过这个口来进行传输信号的，但由于它是模拟接口（对于今天数字设备则无法兼容）加上传输信号差等缺点，因此后来逐渐被其他接口所取代了，今天我们购买的一些电视机可能已经没有这个端口了。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/1.jpg" alt=""></p>
<a id="more"></a>
<h4 id="分量接口"><a href="#分量接口" class="headerlink" title="分量接口"></a>分量接口</h4><p>电视信号传输中传输视频信号的一种接口类型，把视频信号的亮度信息和色彩信息分开来，这样视频信号包括了分开传输的一路亮度信号和两路色差信号，因而避免了信号之间的串扰，与复合电视信号（亮度信号与色彩信号复合传输）和S端子相比有更高的图像质量。</p>
<p>分量视频接口/色差端子是在S端子的基础上，把色度（C）信号里的蓝色差（b）、红色差（r）分开发送，可以输入多种等级讯号，从最基本的480i到倍频扫描的480P，甚至720P、1080i等等。</p>
<p>有些家用电视上面可能会有这个接口，但该接口在民用领域，并没有普及开来，只有一些特殊设备仪器会采用该接口。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/2.jpg" alt=""></p>
<h4 id="AV接口"><a href="#AV接口" class="headerlink" title="AV接口"></a>AV接口</h4><p>复合视频接口（AV接口或Video接口），是当前电视机中最普遍的一种视频接口，几乎所有电视机、影碟机都具备这个接口。</p>
<p>它是音频、视频分离的视频接口，一般由三个独立RCA插头（又叫梅花接口、RCA接口）组成，其中V接口连接混合视频信号，为黄色插口；L接口连接左声道声音信号，为白色插口；R接口连接右声道声音信号，为红色插口。</p>
<p>这个接口可以说是完全起到了替代 S 端子作用的，几乎所有的老款电视机和液晶电视都具备这个口，而该端口也是数字机顶盒的标配。即便是高清数字电视普及的当代，为了兼容老旧设备，AV 接口仍然是出厂时的标配。</p>
<p>AV 视频接口本身也有着较大的缺陷，由于它也是模拟接口，用于数字显示设备时，需要一个模拟信号转数字信号的过程（家用数字机顶盒就起到了这个作用）。同时 AV 视频接口一般也只能稳定输出 480P 的视频，对于 720P 的视频都难以为继，更不用说现在 1080P，2K，4K等视频了。因此 AV 视频接口被淘汰也是个趋势，随着最近几年网络机顶盒的不断普及，新出来的网络机顶盒为了节省成本以及输出高质量的视频都不再配备 AV 视频接口了。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/3.jpg" alt=""></p>
<h4 id="HDMI接口"><a href="#HDMI接口" class="headerlink" title="HDMI接口"></a>HDMI接口</h4><p>目前最为流行的电视接口其实就是 HDMI 接口，HDMI 的英文全称是“High Definition Multimedia”，中文的意思是高清晰度多媒体接口。HDMI 接口可以提供高达 5Gbps 的数据传输带宽，是一种全数字化视频和声音发送接口，可以发送未压缩的音频及视频信号。同时无需在信号传送前进行数/模或者模/数转换，可以保证最高质量的影音信号传送。应用HDMI的好处是：只需要一条HDMI线，便可以同时传送影音信号。</p>
<p>HDMI 的接口分成A、B、C、D4种类型。 其中A类（Type A）是最常见的，一般平板电视或视频设备，都提供了这种尺寸的接口，Type A有19针，宽度为13.9毫米、厚度为4.45毫米，现在能看到的设备 99% 都是这样尺寸的 HDMI 接口。B类（Type B）非常罕见，C类（Type C）俗称mini-HDMI，D类（Type D）都极为罕见。</p>
<p>理论上来说 HDMI 应该是支持热插拔的，通常质量合格的 HDMI 接口，插拔寿命不会少于 5000 次，每天插拔能用 10 年，应该说是很耐用的。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/4.jpg" alt=""></p>
<p>另外 HDMI 可向下兼容于现今多数显示器，因此网上也有 HDMI-VGA 转接器。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/5.jpg" alt=""></p>
<p>HDMI 越来越普及，很多几年前的电视机可能只配备了一个 HDMI 口，但如今却需要接多个机顶盒的话，网上也同样可以购买到 HDMI 分配器。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/6.jpg" alt=""></p>
<h4 id="type-C"><a href="#type-C" class="headerlink" title="type-C"></a>type-C</h4><p>同 HDMI 相比，typc-C 是更加先进的一种接口，目前用 typc-C 作为视频输出的设备还不算多，如新款的 MacBook 以及极个别电视机产品。目前 MacBook 想要链接电视机还得通过如下图的转接线。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/7.png" alt=""></p>
<p>去年底，某电视机厂家好像出了一款 type-C 接口的电视机，但价格惊人。但目前来看 typc-C 确实能够从各方面提供更好的体验，未来也会成为主流。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/8.jpg" alt=""></p>
<blockquote>
<h3 id="电脑显示屏"><a href="#电脑显示屏" class="headerlink" title="电脑显示屏"></a>电脑显示屏</h3></blockquote>
<h3 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h3><p>视频图形阵列（英语：Video Graphics Array，简称VGA）是IBM于1987年提出的一个使用模拟信号的电脑显示标准。这个标准已对于现今的个人电脑市场已经十分过时。即使如此，VGA仍然是最多制造商所共同支持的一个标准，个人电脑在加载自己的独特驱动程序之前，都必须支持VGA的标准。例如，微软Windows系列产品的开机画面仍然使用VGA显示模式，这也说明其分辨率和载色数的不足。</p>
<p>计算机内部以数字方式生成的显示图像信息，被显卡中的数字/模拟转换器转变为 R、G、Ｂ 三原色信号和行、场同步信号，信号通过电缆传输到显示设备中。VGA接口应用于CRT显示器无可厚非，但用于连接液晶之类的显示设备，则转换过程的图像损失会使显示效果略微下降。</p>
<p>VGA 一般只用在比较老的电脑显示器上，电视上目前还没见过有这个接口的，虽然说电视机也是个更大的显示器，但早期时，电视和电脑还是作为不同的个体的，只不过随着屏幕的发展，现在电视和电脑已经愈加的同质化了。</p>
<p>虽然说 VGA 接口比较老，但现在 PC 机寿命都比较长，且淘汰的慢，很多年前买的普清显示器一般都支持这个接口，而过去几年购买的 1080P 的显示器绝大部分也仍然有这个接口，购买时最好查看一下。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/9.jpg" alt=""></p>
<h3 id="DVI"><a href="#DVI" class="headerlink" title="DVI"></a>DVI</h3><p>DVI 的英文全名为“Digital Visual Interface”，中文称为“数字视频接口”。是一种视频接口标准，设计的目的是用来传输未经压缩的数字化视频。DVI 和 HDMI 都是纯数字输出，但相比于 HDMI 而言， DVI 会根据信号源做出 1:1 的输出比例，而 HDMI 只会全屏输出。</p>
<p>相比于 VGA 的模拟信号输出而言，DVI 传输的是数字信号，数字图像信息不需经过任何转换，就会直接被传送到显示设备上，因此减少了“数字→模拟→数字”繁琐的转换过程，大大节省了时间，因此它的速度更快，有效消除拖影现象。</p>
<p>DVI一共分为5种标准。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-18-电器电子产品接口--视频接口/10.png" alt=""></p>
<h3 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h3><p>电脑的 HDMI 和电视机的是一个一样的，可以参考上文，不同的地方在于，电脑相当于机顶盒提供内容的输出，而电视机相当于显示器接收信号的输入。现在的笔记本设备一般都具备 HDMI 口，甚至一些新型产品会支持 HDMI（C/D型）输出，或者 type-C 视频输出。</p>
<p>另外很多新款的台式机也不再支持 VGA 口了，而显示器在市面上尤为的混乱，VGA ，DVI，HDMI 三种接口可以随机进行两两组合或者三个兼备进行售卖，虽然一般显示器都配备了接口线，但如果你的主机刚好和显示器接口错开了的话就比较麻烦了，因此购买时最好留意下这点。</p>
<hr>
<p>原本是想要写“常用家电和电子产品接口”的文章，结果发现仅写常用电器视频传输接口这块就花了很大的篇幅。</p>
<blockquote>
<p>参考链接：<br><a href="https://zhidao.baidu.com/question/1306267819671705139.html" target="_blank" rel="external">https://zhidao.baidu.com/question/1306267819671705139.html</a><br><a href="https://zhidao.baidu.com/question/361815903.html" target="_blank" rel="external">https://zhidao.baidu.com/question/361815903.html</a><br><a href="https://zhidao.baidu.com/question/257655037.html" target="_blank" rel="external">https://zhidao.baidu.com/question/257655037.html</a><br><a href="http://baike.baidu.com/link?url=Ctqf4Y10luyFAaCx-uwExjk6LsqV4VLc_vqDCH4r99YTRHindKkEVGoL7rYBYHlc6gj_nTZilOKwYG1FUfSAuy9UFvCyRc-bL1CNq8Lnv0Fm09mVj0f0tay8BDI8HO5K" target="_blank" rel="external">http://baike.baidu.com/link?url=Ctqf4Y10luyFAaCx-uwExjk6LsqV4VLc_vqDCH4r99YTRHindKkEVGoL7rYBYHlc6gj_nTZilOKwYG1FUfSAuy9UFvCyRc-bL1CNq8Lnv0Fm09mVj0f0tay8BDI8HO5K</a><br><a href="http://blog.csdn.net/huixingshao/article/details/43191105" target="_blank" rel="external">http://blog.csdn.net/huixingshao/article/details/43191105</a><br><a href="https://zh.wikipedia.org/wiki/HDMI" target="_blank" rel="external">https://zh.wikipedia.org/wiki/HDMI</a><br><a href="http://www.ithome.com/html/digi/104879.htm" target="_blank" rel="external">http://www.ithome.com/html/digi/104879.htm</a><br><a href="https://www.zhihu.com/question/19571221" target="_blank" rel="external">https://www.zhihu.com/question/19571221</a><br><a href="http://www.diffen.com/difference/DVI_vs_VGA" target="_blank" rel="external">http://www.diffen.com/difference/DVI_vs_VGA</a><br><a href="https://www.zhihu.com/question/53023975" target="_blank" rel="external">https://www.zhihu.com/question/53023975</a><br><a href="http://baike.baidu.com/link?url=68ZbVYPDyFicX09zbbQl36gZ2PwiqmgB-MbQnfhMJX5weZ9jp3OzMbT-NqTH_BafGl43xOb49MhBgHlJM1FK5LIiF_Ik2o8NltGeZFjNZj_8zrq2iO8-vVzQYCfqjzzMT2HNg879sUOsmNpwtEb5D_" target="_blank" rel="external">http://baike.baidu.com/link?url=68ZbVYPDyFicX09zbbQl36gZ2PwiqmgB-MbQnfhMJX5weZ9jp3OzMbT-NqTH_BafGl43xOb49MhBgHlJM1FK5LIiF_Ik2o8NltGeZFjNZj_8zrq2iO8-vVzQYCfqjzzMT2HNg879sUOsmNpwtEb5D_</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[动漫-进击的巨人]]></title>
      <url>http://noparkinghere.top/2017/04/18/2017/2017-04-18-%E5%8A%A8%E6%BC%AB-%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA/</url>
      <content type="html"><![CDATA[<p>等了很多年，《进击的巨人》这部动漫终于在今年 4 月出放映了，然而因为某些众所周知的原因，该片只可以海外播放。</p>
<p>其实最近几年国产动漫发展的风生水起，一部又一部小说被改变成了动漫，现在每周国漫的连载估计有 20 部以上，然而更多体现的却是良莠不齐，前几年某监管部门大量的封杀了一些认为不适合孩子看的动漫，当然其中包括《进击的巨人》。</p>
<p>《进击的巨人》这部动漫应该可以说是最近几年的力作，无论是画风场景的写实，还是说编排紧凑的剧情，以及对人性的剖析都会让你深陷其中。一般的动漫能够做到以上的某一点就基本上会大受追捧，如：画风唯美场景写实的《东京食尸鬼》，剧情紧凑高潮迭起的《fate》系列，剧情感人揭露深刻的《斩赤红之瞳》。而这部动漫却几乎囊括所有，因此不得不说这是一部相当难得的作品。</p>
<p>而透过这种表象，我们再来看看如今的国产电视剧，由于互联网的告诉发展和大量用户数据的泄漏。国产电视剧在拍摄前都会直接与利益挂钩，做了大数据分析，严格的寻找观众群体。因此今天我们不难看到很多的电视剧模版，大团圆结局，出售男色，千篇一律的剧情，故意拖沓的节奏等等。</p>
<p>国漫的发展目前整体看来还算是比较健康的，《画江湖》系列制作的很是精良，其他如《灵剑山》也能够反常理出牌，拍摄一些突破性的内容。当然也看到不少滥竽充数的作品，如：《灵域》越做越差的作品，《莽荒纪》乱用模版将主角整成了脑残。</p>
<p>希望国产也能够提供一些更加优秀的影视动漫作品，而不仅仅是为了盈利，为了多捞钱。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[健康饮食]]></title>
      <url>http://noparkinghere.top/2017/04/17/2017/2017-04-17-%E5%81%A5%E5%BA%B7%E9%A5%AE%E9%A3%9F/</url>
      <content type="html"><![CDATA[<p>昨天去上海科技馆玩了一圈，对这个地方印象一般，但快出馆的时候遇到一个志愿者老大爷，他的科普与讲谈让我印象十分深刻。</p>
<p>他虽然满头白发，一脸皱纹，看起来年纪应该很大了，估摸着应该有 80 岁左右了，但说话不急不缓，普通话标准，吐字清晰，思路逻辑都十分的强，很多方面感觉要远胜于我们这些身体亚健康的年轻人。</p>
<p>另一个让我印象深刻的是他讲述的内容也都是有临床案例的，一些身体器官他都有带来模型和标本，用最通俗易懂的语言讲一些专业性的内容讲解给大家，下面我罗列一些我听到的内容，由于我只是出馆时路过那边，一些内容说的可能不完整。</p>
<h3 id="阑尾"><a href="#阑尾" class="headerlink" title="阑尾"></a>阑尾</h3><p>大多数人都认为阑尾是身体中多余的，除了会痛没有别的功能。但事实上，人体中没有任何东西是多余的，人体是一个最最精密的仪器，一旦有问题他就会立刻表现出来，阑尾的功能恰恰就在与此，我们可能认为阑尾是身体中的警钟，当你身体出问题，吃了不好的东西时，阑尾先痛，就代表已经提出了预警了，所以这个时候你就该尤为的当心注意了。</p>
<h3 id="咽喉"><a href="#咽喉" class="headerlink" title="咽喉"></a>咽喉</h3><p>吃东西时，一般都经过牙齿咀嚼，再经过食道，最后才到肠胃，一般牙齿咀嚼少，下咽时就会影响到食道，食道很敏感的会察觉到大块物体，进一步的更加会印象到胃的消化。细嚼慢咽是有一定道理的，不仅能够帮助消化而且能够保护好食道。</p>
<p>咽喉能够承受的温度不得超过 80 度，而很多人吃东西会超过这个问题，麻辣烫等都会达到 85 度，而一些人不注意这点，长时间吃这些东西会让食道造成损伤，而损伤了就直接去切除，这些更严重的话甚至会导致咽喉癌。</p>
<h3 id="胰腺"><a href="#胰腺" class="headerlink" title="胰腺"></a>胰腺</h3><p>这一段内容实在记不得了。。。只记得后果严重，据说会回天乏术。</p>
<h3 id="睡前不饮食"><a href="#睡前不饮食" class="headerlink" title="睡前不饮食"></a>睡前不饮食</h3><p>睡前三小时，不可大量饮食，不然的话会影响你的休息睡眠。如果大量饮食的话，休息时，大脑部分神经要促使你休息，而另外部分却要工作促使你集中消化，这样一般都不会休息好，第二天精神状态差。</p>
<p>睡觉前半个小时，虽然睡前三小时不可大量的饮食，但这三小时之内，也是可以喝水，少量饮食的。但建议一般准备睡觉了，这个半小时之内不进行任何的饮食行为，水也不能喝。夜间不适合饮水太多，当然如果你喝水晚上并不会造成负担的话，也无所谓。</p>
<h3 id="饮水习惯"><a href="#饮水习惯" class="headerlink" title="饮水习惯"></a>饮水习惯</h3><p>推荐一个小时饮水一次，饮水应该作为一种习惯，建议的话是白天多喝水，大量饮水。</p>
<h3 id="不可吃的过多"><a href="#不可吃的过多" class="headerlink" title="不可吃的过多"></a>不可吃的过多</h3><p>胃就如一个气球，一旦吃的过多，就会撑起来，而你一旦吃的过多，很可能会撑破胃，另外长期的吃撑是一种不可取的行为，时间久了就会尾部下垂。</p>
<h3 id="三份饭两份素一份荤"><a href="#三份饭两份素一份荤" class="headerlink" title="三份饭两份素一份荤"></a>三份饭两份素一份荤</h3><p>中国人将吃饭并不是没有道理的，最主要的目的是让你吃饭而不是叫你吃菜。五谷杂粮，才是真正的主食，米饭的主要成分是糖和淀粉，这是人体所需要的主要能量，只有获取了足够的这些身体才能吸收消化，而你荤菜是不容易吸收消化的，体内吸收过多的油脂，体内的肝就会怠工，所谓怠工就是假工作，脂肪肝的形成就是因为油脂长期的吸附在你的肝上，已经阻断了肝的正常工作，如果仍然继续懈怠饮食，则随着时间的延长就可能会出现肝癌等病症。</p>
<h3 id="饭后多散步"><a href="#饭后多散步" class="headerlink" title="饭后多散步"></a>饭后多散步</h3><p>饭后散散步，有益于促进肠胃的蠕动，帮助消化。</p>
<h3 id="生活不可太精致"><a href="#生活不可太精致" class="headerlink" title="生活不可太精致"></a>生活不可太精致</h3><p>现在部分人生活太精致了，所有食物都是机器加工打磨好的，水果只喝果汁，其他食物也会处理过副食。肠胃需要你提供一些纤维和杂质进行打磨，长时间副食精加工的食物，肠胃会过度依赖，而退变积弱。同样有案例，某人长期享受这样的生活，看起来很精致，很注意保养，但肠胃弱不禁风，难得吃一次正常食物就闹出病来了。</p>
<hr>
<p>以上内容只是我个人整理，由于人多，很多加上是中途听讲的，很多内容可能描述的细节有错误或遗漏，一些内容也不大记得了。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自身学习生活问题分析]]></title>
      <url>http://noparkinghere.top/2017/04/14/2017/2017-04-14-%E8%87%AA%E8%BA%AB%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>最近生活学习状态相当差，应该来说是步入了最低点了。归根结底是心太大，执行力太差，所有忙活的东西都乱了套，周而复始恶性循环了。</p>
<p>仔细的想来，这种情况绝不是第一次了，在自律坚持的道路上，我好像总会时不时遇到障碍，最终导致我绝大部分事情没有做的下去，或者一开始就倒下了，又或者坚持了十天半个月倒下了。</p>
<p>之前分析过一些自身的问题，但总之并不彻底，这篇文章想要详细检讨下问题到底出在哪儿。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-14-自身学习生活问题分析/1.jpg" alt=""></p>
<h3 id="疲劳作战，恶性循环"><a href="#疲劳作战，恶性循环" class="headerlink" title="疲劳作战，恶性循环"></a>疲劳作战，恶性循环</h3><p>没有形成习惯的坚持，总会让我需要过度消耗自己的注意力还自控力。一件事情，即便不是太难做，但如果你每天都逼着自己去做，即便再美好的事情也会适得其反让你心生厌恶。</p>
<p>拿我自己来说，seven 这组运动每天只是需要花费 7 分钟，并且应该来说可以类似于一个游戏，让你做完后心生愉悦的。但是，这段时间，我每天都拖到快凌晨的时候，才开始做这个，每天像任务一样盼着赶紧完成，这很显然是违背初衷的，且不会认真的对待，更不可能达到理想的效果。认清这点对现阶段的我来说最为重要，我绝大多数放弃的原因都是因为完全没这个力气再去完成这些任务。</p>
<p>今后在对待我每天日程任务时，一定要严格按照时间点去做相应的事情，一旦错开了时间就会拖沓到最后，步入恶性循环。</p>
<h3 id="缺少准备，无应急能力"><a href="#缺少准备，无应急能力" class="headerlink" title="缺少准备，无应急能力"></a>缺少准备，无应急能力</h3><p>周末回家，朋友聚会，出去郊游等，都可能会让我无法按时执行上面的计划。</p>
<p>虽然任务我是一定会完成，但是扰乱了时间点，就会破坏我原有的日程，而破坏了日程后，又会让我萌生拖沓的侥幸心理。每次刚刚养成了上述的习惯，但是往往中间一两天的出行扰乱了计划，后面往往就触发了我的偷懒拖沓的心理，一朝回到解放前了。</p>
<p>这里提供两种方法，第一点是，谨小慎微，时刻保持清醒，审视自己，能够意识到自己偏离计划了，也才可能去纠正错误。第二点，及时更新计划，特殊问题特殊对待，只有有计划的人生才不会失控，突发情况一旦发生，就该计划好如何完成相关任务和工作，让变化成为计划的一部分才能够走的长远。</p>
<p>特殊突发情况无法妥善解决，谨小慎微，时刻保持清醒审视自己。</p>
<h3 id="一步错，步步错"><a href="#一步错，步步错" class="headerlink" title="一步错，步步错"></a>一步错，步步错</h3><p>计划和任务的完成不求完美，但一定要完成，往往因为上一个任务做的不够好，或者想做的更好，会用更多的时间去完善。这种做法对我来说很不可取。首先做的好，会消耗更多的脑力精力，消耗过多，往往让我疲惫；另外消耗了时间则下一步工作也不能完成的好，耽误了工作。如此看来这也是一种恶性循环的。</p>
<p>需要调节好心态，不做过多的强求，做完一个任务后，可以做一些运动或者冥想，在有能力且状态良好的情况增加难度。</p>
<h3 id="深陷其中，无法自拔"><a href="#深陷其中，无法自拔" class="headerlink" title="深陷其中，无法自拔"></a>深陷其中，无法自拔</h3><p>我个人对一些事情可能存在强迫症，一件事一旦做起来就会没日没夜，缺乏克制，这边表现在两点，一个是工作，另一个是娱乐。</p>
<p>工作方面就如上面说的那样，很多时候工作并不是特别急，但遇到了问题就想要能力今天解决，而工作性质觉得这个时间是不确定的，往往预计的半小时可能变成半天。这就使得本来晚上是要看书学习的，结果整晚都忙于工作了，造成的结果并不好。因为忙完工作，其他事情没有解决，所以晚上又得很晚睡，然后第二天因为睡得晚精神差，工作又忙完了，所以浑浑噩噩。</p>
<p>娱乐就更不用说了，一旦开始看电视剧或者小说，就真的想一下子能够看完，有好多次都会通宵达旦，这对我的生活学习冲击就不言而喻了。</p>
<p>对于工作来说，以后一定要三思而后行，考虑清除，是否后再做决定；而对于娱乐就更得慎之又慎，既然没法改变自身的习惯，那就远离这些毒源，绝不开在任务期间看小说，对视频要更加精挑细选不看连载完了的电视剧。</p>
<h3 id="远离蛊惑，保持专注"><a href="#远离蛊惑，保持专注" class="headerlink" title="远离蛊惑，保持专注"></a>远离蛊惑，保持专注</h3><p>专注相当重要，决定了你这件事能不能按时完成，更决定了你能不能做好这件事。</p>
<p>现在各种电子产品诱惑实在是太大太多了，我已经深受其害好多年。对我来说干扰我工作的可以分为两点，一个是手机，另一个是电脑。</p>
<p>很多人都有过被手机干扰工作的经历，时不时的刷刷朋友圈，看看微博，瞧瞧 QQ 群，扫下新闻等等，其实你真的没有这么重要，你得到只是注意力不集中。对我来说，也许是以前养成的一些坏习惯，尤其一旦工作闲下来就会时不时地把手机拿出来看，把上面的 APP 打开都刷一遍，即便没有消息这个过程也会浪费 5 分钟以上。仿佛看手机能够缓解我的焦虑，但事实上每次用完反而更加烦躁了。</p>
<p>关于手机这个问题，我提出 3 个方法：1.手机开启学生模式，限定自己白天在手机上面的使用习惯。2.直接关闭手机网络，大多数都是网络引起的问题。3.将手机设置为功能机模式。</p>
<p>而电脑的问题主要可以归结于网络问题，也是之前养成的一个习惯上网乱逛的习惯，需要强迫自己改掉坏毛病。因为两台电脑，以后上午如果没有意外情况则坚决不开可以上网的电脑。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-14-自身学习生活问题分析/2.jpg" alt=""></p>
<hr>
<p>有时候，可以适当的休息，小息一下并不会耽误多长时间，并且能够帮助恢复精神，也能够更好的完成一些事情。对现阶段的我来说，养成习惯，调整好心态才是最重要的，其他都不该过分强求，适当的工作任务完成后，再做一些提高自身的事情。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GithubPages+https]]></title>
      <url>http://noparkinghere.top/2017/04/13/2017/2017-04-13-githubpage-https/</url>
      <content type="html"><![CDATA[<h3 id="https-简介"><a href="#https-简介" class="headerlink" title="https 简介"></a>https 简介</h3><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</p>
<p>为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<ul>
<li>https 协议需要到 ca 申请证书，之前免费的证书比较少，所以一般国内只有财大气粗的网站使用该协议，但现在情况不同了，一些网站提供了免费的 HTTPS，可以试用下，个人用户往往功能不全，但是免费的。</li>
<li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比 HTTPS 协议安全。</li>
</ul>
<p>值得注意的是：HTTPS 可能会略微影响你的访问速度，但它足够安全，因此如果可以的话，建议都上 HTTPS，现在的各种流氓运营商恶意软件，往往会篡改 HTTP 页面的内容，如果你使用 HTTP 的话，当你访问京东商城时，可能会遇到京东主页被篡改，一些商品被链接到非官方网站；更有甚者，手机下载 APP 的网站被篡改，意外的下载了病毒软件。</p>
<h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。一般一个库的最大容量是 500M，如此大的容量写博客的话完全绰绰有余了，和其他方式相比，优点是不需要花钱买 VPS 而且定制性也更强；缺点是公有库的话会让你的内容可以被所有人看到。</p>
<p>原生 Github Pages 可以在线帮你将 jekyll 文件生成 html 文件，而其通过其他方式构建的网站，如 hexo 等则必须本地生成 html 将 html 上传后才可以正常访问，两者各有优缺点：</p>
<ul>
<li>jekyll 在线生成速度慢，且缺少比较好看精致的模板。</li>
<li>hexo 等其他页面可以做出很好的效果，但需要本地生成 html 较为麻烦。</li>
</ul>
<p>由于 github pages 的部署并不是特别容易，也相当于一个单独的篇幅，这边不再另做介绍，详细可以参考文章<a href="http://playingfingers.com/2016/03/26/build-a-blog/" target="_blank" rel="external">Github Pages + Jekyll 独立博客一小时快速搭建&amp;上线指南</a>和<a href="https://noparkinghere.top/2016/12/14/2016/2016-12-14-GithubPage+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">GithubPage+Hexo搭建博客</a>。</p>
<h3 id="https-部署"><a href="#https-部署" class="headerlink" title="https 部署"></a>https 部署</h3><p>该部分详细内容可以参考<a href="https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/" target="_blank" rel="external">Secure and fast GitHub Pages with CloudFlare</a>，这边只对这部分内容做个补充说明。</p>
<p>GitHub Pages 不支持上传SSL证书，我们采用 CloudFlare 提供的免费 HTTPS 服务。CloudFlare 是一家CDN提供商，它提供了免费的 HTTPS 服务(但不是应用 SSL 证书)。实现模式就是，用户到CDN服务器的连接为 HTTPS，而 CDN 服务器到 GithubPage 服务器的连接也为 HTTPS，但 GithubPage 服务器上不嵌入证书，我们可以采用如下图的方式 1 和方式 2 。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-13-GithubPages-https/1.png" alt=""></p>
<p>详细步骤可以分为以下几部：</p>
<ul>
<li>注册并登录 CloudFlare，并将自己域名下的 name server 修改为 CloudFlare 的 name server，那万网为例，就是在域名管理下，将DNS服务器从万网的地址改为 CloudFlare 提供的地址，例如：<code>boyd.ns.cloudflare.com</code> 和 <code>donna.ns.cloudflare.com</code>。</li>
<li>在 CloudFlare 的 DNS 中设置，因为你不存在 IP 地址，所以这边选用 CNAME，name 中填入你需要显示的域名名称，IPv4 中填入跳转的地址即 github pages 的地址。以上内容基本上任何域名服务网站都一样，不仅限于 CloudFlare。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-13-GithubPages-https/2.png" alt=""></p>
<ul>
<li>下面正式加入 HTTPS 服务，在 CloudFlare 的 Crypto 设置 SSL 为 Flexible 或者 FULL 均可，注意这边并不是立即生效的，需要等待一段时间。</li>
<li>在 CloudFlare 的 Page Rules 中设置路由规则，这边功能就比较多了，我们可以将它理解为一个具备小型功能的服务器，里面一些功能之前是需要通过自己服务器上面设置的。这边只说两种常用功能。其一，设置 <code>http://yoursite.com/*</code> 强制使用 HTTPS ，这样的话，所有访问 <code>http://yoursite.com/*</code> 的操作都会变为<code>https://yoursite.com/*</code> 。其二，可以将目标地址重定向，输入 <code>http://www.yoursite.com/*</code> 然后选择 forwarding URL ，选择 301 重定向，下面输入 <code>https://yoursite.com/*</code> 。这时，你访问 <code>http://www.yoursite.com/*</code> 时将会自动跳转到 <code>https://yoursite.com/*</code> 页面。<strong>注意：如果有多个规则的话，强制 HTTPS 的规则要放在第一位。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-13-GithubPages-https/3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-13-GithubPages-https/4.png" alt=""></p>
<p>注意：以上步骤设置后并非立即生效，需要等待一段时间。</p>
<h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><p>CNAME 中设置跳转的目标页面，一般 CNAME 设置后，会将你的域名作为主要显示域名，一般网站是不允许这么做的，Github Pages 加入了 CNAME 认证，只有两者一致的话，才会返回结果，否则返回错误页面，大多数网页也都是如此。注意这些设置不是立刻生效，我们可以这么验证，如果 CNAME 设置成功了，则会返回 <code>Invalid URL</code>，因为你的域名不被对方认可拒绝访问；而如果 CNAME 没有成功，则会跳出：<code>This page isn’t working</code>，代表服务器不响应。</p>
<p>采用 CNAME + CloudFlare 的 Page Rules 可以不需要本地服务器，即可完成域名的跳转，具体方法如下：</p>
<ul>
<li>需要建立一个 CNAME 跳转，名称可以是你需要跳转的地址，因为如果不设置的话，下面步骤可能不会生效。</li>
<li>我们只需要设置 Page Rules ，将里面的规则进行更改，如：可以将目标地址重定向，输入 <code>http://www.yoursite.com/*</code> 然后选择 forwarding URL ，选择 301 重定向，下面输入 <code>https://www.qq.com/*</code>，一般这个不是立刻生效，需要耐心等待，页面如果跳出 CloudFlare 相关信息，很可能是已经设置成功，但还没有生效。</li>
</ul>
<blockquote>
<p>参考链接：<br><a href="http://baike.baidu.com/link?url=2m1AdjLvBGnRv4lsaPqsNch_ZFdA_jp-YVdn4FBcZhszyRB7naHX2d9mLytRTtgCcv8qLczVjLKxVZJWFnOrmq" target="_blank" rel="external">http://baike.baidu.com/link?url=2m1AdjLvBGnRv4lsaPqsNch_ZFdA_jp-YVdn4FBcZhszyRB7naHX2d9mLytRTtgCcv8qLczVjLKxVZJWFnOrmq</a><br><a href="http://blog.csdn.net/u010887744/article/details/50762202" target="_blank" rel="external">http://blog.csdn.net/u010887744/article/details/50762202</a><br><a href="https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/" target="_blank" rel="external">https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/</a><br><a href="https://www.seozac.com/seo/301-redirect/" target="_blank" rel="external">https://www.seozac.com/seo/301-redirect/</a><br><a href="https://www.zhihu.com/question/20376047?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/20376047?sort=created</a><br><a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a><br><a href="http://jekyllcn.com/docs/github-pages/" target="_blank" rel="external">http://jekyllcn.com/docs/github-pages/</a><br><a href="http://www.freebuf.com/articles/neopoints/45822.html" target="_blank" rel="external">http://www.freebuf.com/articles/neopoints/45822.html</a><br><a href="http://blog.csdn.net/u011244202/article/details/57106544" target="_blank" rel="external">http://blog.csdn.net/u011244202/article/details/57106544</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git控制版本方法]]></title>
      <url>http://noparkinghere.top/2017/04/12/2017/2017-04-12-git%E6%8E%A7%E5%88%B6%E7%89%88%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在做项目的过程中不断有新的实验和需求，软件的版本也不断的更改，很多时候建了一个又一个复制件目录，v0.1,v0.2,vxxx.xxx，往往把自己都绕进去了。因为这些原因，开始使用 GIT 版本控制器，到现在来说已经用了快一年了，但仍然会有很多这方面的问题，由于我做的是嵌入式开发，往往经常会对硬件进行修改，本文对嵌入式项目进行总结，希望可以找到一个可行性高的项目管理方法。</p>
<p>本文的内容主要针对嵌入式项目研发过程中，可能出现的版本控制，对其他纯软件项目可能并不是特别有效，这边仅给出我自己的方法，如有更好的方法希望可以给出建议。</p>
<p>这边先给出一段我以前写的，网上参考的 git 的分支方案：</p>
<p><strong>在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ul>
<li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>
<li>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</li>
<li>每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>
</ul>
<p><strong>团队合作示意图：</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png" alt=""></p>
<a id="more"></a>
<p>在原来的基础上进一步修改，我给出的方案是： </p>
<ul>
<li>master 分支只用来初始化版本库后，承担第一个文件（.gitignore）的提交，后续不将其他内容合并到master 上。</li>
<li>嵌入式项目在研究阶段如果加入一些功能的话往往无可避免的会更改一些硬件，我建议以每个已经制版了的硬件作为一条独立分支，直接接在 master 之后，这样可以让所有的分支结构看起来比较有条例。</li>
<li>注意上面是已经制板出来的电路作为一个分支结构，也就是说至少这个版本在一定时间内是一个比较成熟的版本，并不是每次手动更改电路都在 master 后建立一条分支。出现新的硬件版本后，因为新的 board_new 分支接在 master 后，几乎没有内容，可以直接将 这天分支快速合并到现在 board_old 的开发位置。</li>
<li>每个制板电路后，在新建可能局部修改硬件的小分支，该分支是接在板分支之后的不直接和 master 分支关联，每次的新功能和小改动都基于这些小分支，这边有两种方法，一种是进一步采用递归，基于 board 建立硬件主分支，其他软件功能性都作为这些硬件改动的从分支，但这种虽然想起来清晰，但操作起来很繁琐而容易出错；另一种是，按照重要性，只将可能出现重用的一些重要功能建立新分支，其他的不再建立分支。</li>
<li>一般来说每次硬件的改动都将不会返回上一个版本的硬件，也就是说老的 board_old 分支将不会再使用，但我们最好做好版本控制，可以将内容保存清除，方便万一查看。但也可能某个实验会改回原来的硬件版本，这个时候我建议是手动对比最新版本和老版本的区别（diff），不要使用合并，如果你没对 board_old 进行过修改的话，虽然是可以快速合并的，但仍然不建议这么做。</li>
</ul>
<p>下面是一个大体思路示意图：</p>
<hr>
<p>后续有新的发现，仍然会更新本文。</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[共享单车体验]]></title>
      <url>http://noparkinghere.top/2017/04/10/2017/2017-04-10-%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>大学时在南京上的学，时隔多年没有去这座城市了，今天去南京某学校转了一圈，让人最大的感触应该算是共享单车。仔细想一下，似乎大学生永远都是新鲜事物的主力军，而每几年大学生活就会有翻天覆地的变化，从开始有电脑，到网络的普及，从开始有手机到智能机的普及，从校园一卡通到移动支付的普及等等，今年也许最流行的要数共享单车了。</p>
<p>共享自行车这个项目其实已经被运营了很多年了，早在7,8年前，很多城市就有了政府组织的市民代步车，几年前我在南邮也见到了校园共享车。共享单车在学生中流行不是没有理由的，主要的原因应该可以归结为以下几点：</p>
<ul>
<li>很多校园比较大，占地 2/3 千亩的学校，上一节课往往要走很远，学生去食堂出校门也比较远，因此自行车往往成必备，首先可以看出学生是有这个市场需求的。</li>
<li>一些学校地处偏远，交通不便，学生去做公交地铁需要走几公里路，共享单车也帮解决了这个问题。</li>
<li>学生自己购车价格不便宜，并且存在被偷的风险。</li>
</ul>
<p>以前我一直都是用摩拜单车，骑行的距离比较短。今天在学校中，主要还是看到了 ofo 和摩拜单车。下面就两者，说下体验和差别：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-10-共享单车体验/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="ofo"><a href="#ofo" class="headerlink" title="ofo"></a>ofo</h3><p>ofo 的创业团队是一群大学生，他们也是瞄准了大学生在自行车上面的需求，也是国内最早做共享单车的，但随着节能减排的推广，以及很多人发现短途旅行骑车比公交更合适，现在共享单车也已经在普通大众中火了起来。</p>
<p>ofo 的车是传统自行车，采用的是密码锁，用户上传车牌号，服务器下发密码，用户通过密码解锁就可以骑车了。ofo 车的优点是骑起来轻松，坐起来也舒服些，缺点是采用传统轮胎，维护成本高，校园中大量的 ofo 车轮胎没有气，车子无法解锁，晚上回来的时候，大量的人在找 ofo 的车，但很少有人能够找到可用的。另外 ofo 车不带定位系统，你只能随缘找车，骑车。</p>
<h3 id="摩拜单车"><a href="#摩拜单车" class="headerlink" title="摩拜单车"></a>摩拜单车</h3><p>相比 ofo ，摩拜的创业过程则完全不同，摩拜是有着明确的市场定位以及丰富市场经验的一群人做的一个项目。从一开始摩拜就是定位城市共享单车，目的是解决最后市民出行“最后一公里问题”。让大家可以骑车锻炼身体，短途旅行不坐公交，不开私家车。摩拜单车全部是都是只能车，自带 GPS 定位，能够通过远程验证解锁，轮胎不需要打气维护，自带充电装置等等。优点是，我们很容易找到摩拜的车，解锁成功率也很高，车的利用率高损坏较少，外观时尚漂亮（听到周围有女生评价比较喜欢摩拜的外观）。缺点，车身太过笨重，非打气轮胎让骑行十分艰难，上坡基本上骑不上去，路不太平整的地段骑车相当痛苦。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们可以看出看出摩拜和 ofo 截然不同的特点，两者各有利弊。而最新的消息现实 ofo 已经在出智能车了，最新的 ofo 车会配备北斗锁，通过北斗导航定位单车，然后同时也能够提供简单的通讯功能。希望未来的单车可以具备：定位，手机解锁，轻便，车身可调节等特点。</p>
<p>提供另外一点设想，共享单车的主要目的是共享和出行，对于一些每天需要使用单车的人来说，目前一次 1 元左右价格仍然显得昂贵，希望未来可以提供包月或者包年服务，基本可以以等同于自己购买自行车的价格来使用共享单车。对于特定的人群如：学生等，可以提供 10/月的服务，这样既减少的学生买车被偷的风险，又可以让车的使用率活起来，现金直接到位。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS个人云服务器选择]]></title>
      <url>http://noparkinghere.top/2017/04/09/2017/2017-04-09-VPS%E4%B8%AA%E4%BA%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<p><em>首先声明，本人并非从事运维工作，玩服务器等也纯属业余爱好，个人作为一个web菜鸟，仅仅是能够安装系统，基本使用 linux 的一些操作，具体原理了解并不多。本文主要是针对那些和我一样的业余爱好者，想体验下云服务，且又不知道该如何选择的用户。</em></p>
<p>虽然个人博客搭建了也有一段时间了，但一直都是投机取巧占用了其他网站的服务器，没使用自己的服务器，经过半年的摸索，也体验过多家的云服务（这边仅是体验，并没有长期使用），下面写写个人的小结。</p>
<p>要使你的网站能够被访问，首先得申请个域名，当然不申请域名，你搭建的服务也可以通过 IP 地址直接访问的，但是一般都不这么做，固定 IP 地址的价格还是很昂贵的，不再本文讨论范畴之内，这边讨论下域名申请，一个可以 .site,.top,.xyz 结尾的一级域名一年也只要几块钱，但请注意，申请域名的时候目前支持备案的并不多（不备案的域名，使用国内服务器的话，就会强制你下线，不让访问），常用可以备案的域名为 .cn .com .org .edu 等。推荐购买域名国内的话可以去万网看看，定期会有打折，而国外也有一些网站，这边就不一一例举，免费的域名建议不要使用，因为每隔一两个月或者几天就可能被收回去。一个 .site 结尾的域名，可能价格才几元钱，所以如果只是想要买个玩玩的话，这些是不错的选择，但是如果你是商业用途，建议还是购买 .com .cn 结尾的域名，因为你需要国内的服务器让你的客户稳定访问，而要能够稳定访问，你的域名必须得备案。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>首先谈及下国内第一大，云服务提供商阿里云，阿里云收购了原来万网的一系列服务，目前在 VPS 领域可以说是提供服务最完善，用户群体最多，功能最强的网站了，当然，价格也最贵，不是一般的非商业用户所能够承受的，对于我这样的非专业人士来说，上云暂时也仅仅是体验服务，学习研究之类的，所有阿里云会选择按量购买，毕竟个人觉得按月购买每个月价格还是蛮高的，如果不是有特别需求，或者盈利性质的网站，你可以选择按量购买，也就是说按你用来购买，不用的时候就关闭服务。这类似于手机流量一样，用多少流量卖多少，不用的时候就将服务关闭掉。</p>
<p>阿里云的特点：</p>
<ul>
<li>稳定，毕竟国内最大的提供商</li>
<li>价格昂贵，选择高带宽需要额外收费</li>
<li>功能多，操作界面美观，商务范十足</li>
</ul>
<h3 id="腾讯云试用"><a href="#腾讯云试用" class="headerlink" title="腾讯云试用"></a>腾讯云试用</h3><p>腾讯云注册后有5-7天的免费使用时间，个人感觉这个对从来没接触过云服务，第一次试用的同学来说，还是很不错的，最起码可以自己尝试搭建一些小型的网站如：博客之类的还是很不错的，当然时间很宝贵，要试用的话，还是得抓紧时间。腾讯云的体验各种活动要比阿里云多不少，但操作略显简陋，只能说具备基本的功能。</p>
<p>腾讯云特点：</p>
<ul>
<li>还算稳定，也算是国内的大公司</li>
<li>同样，价格不便宜，比阿里云略低，选择不同的带宽需要额外付费</li>
<li>功能基本具备，界面体验等一般</li>
</ul>
<a id="more"></a>
<h3 id="搬瓦工（BandwagonHost-VPS）"><a href="#搬瓦工（BandwagonHost-VPS）" class="headerlink" title="搬瓦工（BandwagonHost VPS）"></a><a href="https://bwh1.net/" target="_blank" rel="external">搬瓦工</a>（BandwagonHost VPS）</h3><p>目前来说国外性价比较高的一个 VPS 服务商，过去有过一些精巧型的服务提供，一个 500M 的硬盘，可能年付费才几美金。最大的特点就是价格便宜：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span> GB SSD RAID<span class="number">-10</span> Disk Space</div><div class="line"><span class="number">256</span> MB RAM</div><div class="line"><span class="number">500</span> GB Transfer</div><div class="line">Gigabit port</div><div class="line">Multiple locations</div><div class="line"></div><div class="line">$<span class="number">2.99</span>/month</div></pre></td></tr></table></figure>
<p>如上所示，一个 VPS 价格才 $3/month 这意味着一年才 ￥200 多，国内的公司提供的同等服务，基本上都要 500-1000 元，且是限制带宽的，默认为 1M 带宽，而国外都是 100M/1000M 带宽。</p>
<h3 id="vultr"><a href="#vultr" class="headerlink" title="vultr"></a><a href="https://www.vultr.com/pricing/" target="_blank" rel="external">vultr</a></h3><p>这网站也是国外比较出名的一个高性价 VPS 服务商，价格与搬瓦工差不多，竞争关系，时高时低。最低套餐如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">20</span> GB SSD</div><div class="line"><span class="number">512</span> MB RAM</div><div class="line"><span class="number">500</span> GB Bandwidth</div><div class="line">$<span class="number">2.5</span>/month</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-09-VPS个人云服务器选择/1.png" alt=""></p>
<p>可见以上这个套餐还是很划算的，每个月不到 20 块，就可以享受这种套餐，20 GB SSD 首先速度有保证，其次也基本上能够完成你的所有实验用途了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上内容只列举了目前为止，我所体验过得 VPS 服务，当然国内也有很多小型服务商，可能价格会略微便宜，但之前打听过，价格也不低，目前情况不得而知。优先建议的话是选择国外的 VPS 来体验（因为能看本文的绝不会是从事商业用途的），国外的 VPS 购买后可以用来做什么？这边不具体展开详细说明，只做一个简要的说明参考：</p>
<ul>
<li>购买国外的 VPS 可以用来搭建科学上网服务（也就是绕过 GFW）</li>
<li>搭建个人的博客，毕竟外国提供带宽很大，博客访问都是不错的，不用于商业用途应该没有影响</li>
<li>学习服务搭建，用虚拟机虽然也能学习服务搭建，但毕竟没有实际操作来的更爽，更加直观（虽然 VPS 也是个虚拟机），搭建服务后，你可以在互联网中实际访问，这是虚拟机无法带给你的成就感。</li>
</ul>
<hr>
<p>后续有新的体验和经验，仍然会更新…</p>
<p>To be continued…</p>
<p>写作时间：20:30-21:30</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PC下的C项目开发工具]]></title>
      <url>http://noparkinghere.top/2017/04/07/2017/2017-04-07-pc%E4%B8%8B%E7%9A%84c%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>这篇文章主要讲述基于 x86 下的 C 项目开发工具，对于 ARM 等其他平台的开发不再本文的谈论范围内。</p>
<p>C 语言问世已经有 40 年的时间了，40 年足够一个婴儿步入壮年，现在的程序语言可谓百花齐放，对于老式的 C 由于主要在做嵌入式开发，往往缺少一个 x86 平台下的调试器，VS 支持 VC，而 VC 则是兼容 C 语言的，可能能够调试 C 的程序，但是 VS 由于主要支持的是 VC，对 C 的语法也都是基于 C++ 的，一些问题无法显现出来，而即便可以支持 C 语言，可能是 C89 的标准，不支持新的语法格式。老牌的 GDB 虽说功能极度强大，但是只能说是神器，命令行的操作方式，让新手或者即便不是新手也很难将这个工具用的好，反正我是用一次忘一次，且用起来很麻烦。</p>
<a id="more"></a>
<p>我要找的工具是需要具备 GDB 的功能，同时又具备友好的 GUI 交互的，中间我试用过 ddd，可惜该工具也太过古老了，图形界面和现在的风格完全不符合，并且一些功能用起来有点莫名其妙，然后就没再作进一步的研究了。除了 ddd 我还尝试过 Kdevelop，然而该软件过于小众，虽然有文档，但问题会频繁出现，且缺少相关的 FAQ，windows 下的 Kdevelop 更是几乎没有查有意义的参考解答。</p>
<p>偶然在 stackoverflow 看到 Eclipse CDT 是可以调试 C/C++ 项目的，其调用的工具就是 GDB，能够将 GDB 命令的输出结果转成 GUI 的界面清晰陈列给用户，注意本文只是提供一种我个人认为比较好的方式，其他内容可以参考下面的链接。</p>
<p>Eclipse 算是一个老牌的 IDE 了，可以嵌入一些开发组件，让它能够完成你的工作，其大名在 JAVA 界可能比较火些。Eclipse 支持多个平台的开发，同时载入调试工具也可以选用多种多个平台的工具。</p>
<p>目前使用 Eclipse 调试 C 程序感觉都比较良好，能够自动帮列出函数中变量的值，内存中的地址等等信息，基本上完全继承了 GDB 的强大之处。目前刚刚开始研究 Eclipse 还并不是特别熟悉，后续会进一步挖掘 GDB 这个调试工具。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="https://www.ibm.com/developerworks/library/os-eclipse-cdt-debug2/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/library/os-eclipse-cdt-debug2/index.html</a><br><a href="http://www.eclipse.org/cdt/downloads.php" target="_blank" rel="external">http://www.eclipse.org/cdt/downloads.php</a><br><a href="http://stackoverflow.com/questions/79023/is-there-a-c-gdb-gui-for-linux" target="_blank" rel="external">http://stackoverflow.com/questions/79023/is-there-a-c-gdb-gui-for-linux</a><br><a href="http://wiki.jikexueyuan.com/project/eclipse/eclipse-run-configuration.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/eclipse/eclipse-run-configuration.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kindle 使用技巧总结]]></title>
      <url>http://noparkinghere.top/2017/04/06/2017/2017-04-06-kindle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>kindle 是亚马逊出品的一个阅读产品，这几年在阅读界可以说是异常的火爆，改变了很多人的阅读习惯。kindle 本身可以代表一个跨平台的软件，其支持 windows，Android，IOS等；同时，kindle 也可以算是亚马逊推出的一款电子产品。</p>
<p>kindle 的优点是可以支持多个平台，同步你的阅读记录，打开平板或者 kindle 硬件可以直接阅读你的书籍，挡在公交车上或者外出时，也可以随时用手机阅读。</p>
<p>kindle 的成功主要源于电纸书这个产品，电纸书采用的是不发光的仿真纸质屏幕，可以让你阅读时减少眼睛的疲惫感。最关键的一点是，你可以在 kindle 上轻松地找到大量阅读资源。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-06-kindle-使用技巧总结/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="获取资源方式"><a href="#获取资源方式" class="headerlink" title="获取资源方式"></a>获取资源方式</h3><p>kindle 的阅读资源获取可以分为以下是那种方式：</p>
<h4 id="官方商城"><a href="#官方商城" class="headerlink" title="官方商城"></a>官方商城</h4><p>通过官方的 kindle 阅读商城，我们可以购买电子书籍，一般的电子书籍往往都不是免费的，当然这些书籍要比实体书籍便宜不少。</p>
<h4 id="数据线传输"><a href="#数据线传输" class="headerlink" title="数据线传输"></a>数据线传输</h4><p>可以将你自己的电子书通过 USB 数据线传入 kindle 中，这也是一种比较好的方法，你可以自己从网上找到你需要的电子书，然后将他们在 kindle 中查看， kindle 原生支持 TXT,PDF,MOBI,AZW，一般 MOBI 格式表现最佳，我们也优先选择这个格式。</p>
<h4 id="邮箱推送"><a href="#邮箱推送" class="headerlink" title="邮箱推送"></a>邮箱推送</h4><p>邮箱推送应该是 kindle 最方便的一点，你可以将你的内容通过邮箱直接发送到你的 kindle 设备/软件中。</p>
<p>具体操作如下：登录亚马逊的官网-&gt;在我的账户中点击管理我的内容和设备-&gt;设置-&gt;添加认可的电子邮箱-&gt;使用认可的电子邮箱发送电子书文件到设备邮箱中。</p>
<p>当您使用〖发送至Kindle〗电子邮箱发送个人文件时，您的文件会自动保存到Kindle图书馆中。你每个 kindle 设备都会对应一个不同的“〖发送至Kindle〗电子邮箱”，因此当你需要发送文件时，需看清除要发送到哪个设备上，而每个设备对应的电子邮箱地址是可以任意修改的。</p>
<p>现在亚马逊国内的服务器相当稳定，一般来说同步文档，立刻可以在其他设备上面看到，如果没有的话可以尝试手动同步，实在不行，你可以在亚马逊设备的管理界面中：我的内容-&gt;显示个人文档-&gt;选择操作选项-&gt;发送到其他-&gt;选择你要指定的设备发送即可。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-04-06-kindle-使用技巧总结/2.png" alt=""></p>
<h3 id="资源下载网站"><a href="#资源下载网站" class="headerlink" title="资源下载网站"></a>资源下载网站</h3><p>目前市面上有很多提供 kindle 方式，我们罗列出三种方式。</p>
<h4 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h4><p>通过网盘的检索方式，我们可以使用<a href="http://www.xilinjie.com" target="_blank" rel="external">西林街</a>对书籍进行搜索，一般有可能能够找到对应的电子书籍，但检索效率不高。</p>
<h4 id="微信推送"><a href="#微信推送" class="headerlink" title="微信推送"></a>微信推送</h4><p>市面有很多提供电子书服务的微信公号，如：kindle图书馆之类的，这种服务号一般推送起来也比较方便，服务号绑定目标邮箱地址（上面提到的kindle 设备邮箱），亚马逊官网信任你的推送地址。然后在服务号中输入书名，打开推送即可。这种服务号，往往新书需要办理会员，或者推送本书有所限制。</p>
<h4 id="网址推送"><a href="#网址推送" class="headerlink" title="网址推送"></a>网址推送</h4><p>和微信推送类似，也有一些网站可以提供 kindle 电子书本地下载以及邮箱推送服务，需要操作的步骤和微信推送基本相同：信任邮箱，设备邮箱地址。这边推荐一个网站：<a href="http://www.kindlepush.com" target="_blank" rel="external">kindle推</a>。同时可以阅读知乎的一篇有关<a href="https://www.zhihu.com/question/20093221" target="_blank" rel="external">如何获取电子书资源的文章</a>，文末的参考网址同样值得一看。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="手机版-kindle-设备在亚马逊官网的设备中无法找到"><a href="#手机版-kindle-设备在亚马逊官网的设备中无法找到" class="headerlink" title="手机版 kindle 设备在亚马逊官网的设备中无法找到"></a>手机版 kindle 设备在亚马逊官网的设备中无法找到</h4><p>注意，国内的亚马逊和国外的亚马逊不是同一个网站，账号数据不进行共享，也就是说你同一个邮箱可以在两个地方同时注册，手机版本的 kindle 在第一次启动时会让你选择地区，如果你选择了美国，kindle 则会连接国际版的服务器，这样的话，你的所有数据只能在亚马逊国际上面找到。</p>
<p>因此在使用 kindle 时，需要将多个设备在同一个网站网站上面注册，建议选用亚马逊中国版，速度各方面都会比较稳定。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>随着科技的发展，人们的生活越来越多的被改变，而 kindle 让阅读变的随处可行，让你可以随时查看字词解释，不久的将来也许消耗资源的纸质书籍将会真正被电子书籍所取代。</p>
<blockquote>
<p>参考链接：<br><a href="https://www.zhihu.com/question/19712951" target="_blank" rel="external">https://www.zhihu.com/question/19712951</a><br><a href="https://www.zhihu.com/question/20093221" target="_blank" rel="external">https://www.zhihu.com/question/20093221</a><br><a href="https://www.zhihu.com/question/31313562" target="_blank" rel="external">https://www.zhihu.com/question/31313562</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯传读后感]]></title>
      <url>http://noparkinghere.top/2017/04/05/2017/2017-04-05-%E8%85%BE%E8%AE%AF%E4%BC%A0%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      <content type="html"><![CDATA[<p>上周末阅读完的一本书，之前写过一篇阅读初感，总的来说这本书值得一看，但并不是让人特别满意。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-23-腾讯传读后初感/1.jpg" alt=""></p>
<a id="more"></a>
<p>下面说一下阅读这本书的感受吧，该书的前 2/3 可以让人阅读起来特别的轻松，仿佛真的是赋予了腾讯人物的形象，一点点的阐述它的诞生，成长，壮大。值得一看的是作者文笔顺畅，让人如阅读一本小说般的轻松自如；并且，书中的内容时间也都是基于事实，人物的陈述，基本上不会被作者主管意识所带偏。</p>
<p>然而，后 1/3 腾讯从立足互联网后，如何从壮大到争霸这一段就写的相当混乱了，腾讯这家公司很不同于别的公司，每个部门都相当于一个独立的个体，鼓励竞争和内部创业，但作者在写多条主线时却不能得心应手，往往写的很混乱，每个点都是带过一笔，却又不详细深究，而这一段内容甚至不如网络上所找到的详细。一个巨无霸公司的单身，并不可能仅是依靠那么几个人，而腾讯显然在多个业务领域都是领先于竞争对手的，而另外部分领域如：搜索，网购又是最终失败了的。作者只是简单地详尽的阐述出，游戏，IP，音乐领域为何成功，没能将代表人物起到的贡献列出来；而对搜索，网购等如何失败又没有进行分析和解答。</p>
<p>作者开篇时提及，该书花费了作者多年的时间考察，采访，耗费了大量的心血才最终完成，但我只想说，也许早期的作者在写这本书时，还没有微信，没有移动互联网，开始一两年的时间，作者是尽心尽责地去做访谈，做调研，思考和分析的，可以看出全书前一半内容写的很是认真的。后一半，随着移动互联网发达起来，自媒体，微创业等越来越普及，作者安奈不住心思好好写作了，开始写的越来越急，内容也越来越乱，经不起推敲了。文章中甚至可以看出有一部分内容已经有过调研或者采访，却没能把内容完整的呈现给作者，而最后的更是越写越快，急着结束了。</p>
<p>总的来说，该书还是要比其他的自传写的好，全篇前 2/3 很值得一读的，虽然后面确实写的不咋的，但也基本上将 1998-2016 表述完整了。</p>
<p>有关腾讯这家企业，之所以能够发展到今天，我想主要依靠五点：</p>
<ul>
<li>危机意识：腾讯仅是依靠 QQ 这种 Windows 平台下的入门级应用起家的，依托于其他平台，如：中国移动，微软等等，即便拥有数亿用户，但自始至终，它都缺乏安全感，任何的风吹草动都可以击垮它。一旦被用户抛弃它就什么都没有了，所以腾讯数十年如一日，始终在扩展自己的业务，不断想着通过其他手段来赚钱。如果微信不属于腾讯的话，可以说，腾讯的市值只有现在的三分之一不到，而微信也只是腾讯多个基于手机通讯 APP 内部创新项目中的一个。</li>
<li>把握时局：对于中国这种市场能够明察秋毫，QQ 并非国内最早的 IM 软件，但只有它活下来了，因为早期别的 IM 软件都很大，而国内带宽小，腾讯 QQ 可以做到就只有 1M 不到，这显然更加符合国内的市场环境，且这么多年来，腾讯的产品始终符合国情和市场环境。短信服务，拥抱移动梦网等让 QQ 赚到了第一桶金，手机需要软件，腾讯立马可以做出一个微信（更加适合移动互联网的软件）。</li>
<li>产品优良：马化腾自诩为产品经理，可以看出在腾讯在产品上面确实是做到精益求精的，尽管 QQ 看上去仍然这么幼稚，但它就是击败了 MSN ，有着很多别人没有或者很久才加上去的适用功能。腾讯这家公司的产品虽然被很多人说抄袭，但不得不说他们产品就是能够做的好，这家公司也总是：别人先创新，我抄袭后再超越对手（走别人的路，让别人无路可走）。举两个移动端的例子，微信功能很强大，但可以兼容各种手机，对于三四年前的手机也能够流畅运行，较少卡顿，而支付宝，淘宝等，手机开启后可能会卡顿很久才能正常工作，另外同为后台开启，微信的耗电比支付宝，淘宝都少的多。支付宝，淘宝其实也不是特别差，比京东手机 APP 要好不少，但和微信比缺失差的颇多。再举个例子，最近比价热门的手游王者荣耀，这种游戏对手机配置要求还是比较高的，最起码我三年前的手机刚开始是玩不了的，但让人惊奇的是，这个游戏出来一年后，经过不断的优化，竟然同一款手机现在可以比较流畅的玩这个游戏了。</li>
<li>模式创新：无可厚非，腾讯赚钱主要就来自收费模式的创新，通过 Q 币购买虚拟物品，充值会员，提供 QQ 秀，空间正版音乐，正版免费漫画等等。这些中有的寻求到了直接变现的方法，而有的则慢慢培养用户习惯，希望之后可以创造更多的财富值。</li>
<li>市场导向：腾讯做的产品从来都是以市场为驱动进行追逐的，就如同乔布斯说的那样：杰出的艺术家创造，伟大的艺术家剽窃。很多人将马化腾比作中国版的比尔盖茨，同样都等着别人先做小白鼠，他们在后面仔细观察，然后再后发制人干掉先驱垄断市场。而腾讯所有的产品都是必须要有市场价值和意义的，在这家公司不谈情怀，即便 QQ 早期的设计者喜欢 linux 所以采用了企鹅作为图标，但 QQ 自始至终都没有一个 linux 版本的，因为小众的用户对他们来说缺乏意义。</li>
</ul>
<p>个人认为腾讯的成功可以归功于上面几点，以上五点只分析它自身的成功原因，当然资本运作也可以算，但每家成功的公司都具备这点，不会单独列出来提及。另外开放策略，个人认为和腾讯的成功关系并不大，腾讯只不过不再想成为万夫所指，所以才勉强开放，而事实上，它自家的产品就足够优秀，往往领先合作者一大截，但打着开放的口号，自己吃肉总给留点汤给别人吧，所以腾讯才将自己 1/10 左右给合作伙伴做。而事实上我认为，很多投资的公司，做的远不如腾讯，京东的手机 APP 是我目前为止用的最烂的应用，且腾讯入股后，这家公司就再也没有什么长进了。同为入股公司，搜狗在拿下了 SOSO 还有拥有了腾讯多个软件入口后，反而市场表现还不如出道没多久的360搜索和神马搜索。近年来创业成功的公司，如：美团，滴滴等，都应该感谢 360，也是自 3Q 大战之后，腾讯开始不再明目张胆的抄袭搞垮对手了。</p>
<p>虽然腾讯这家公司在业界的口碑一直不佳，一直在模仿，从未有创新，但无可否认，这家公司确实极具实力，在国际科技巨头中也有一席之地，现如今和百度比起来，在无论是决策还是产品上都不可同日而语。而同阿里比的话，两者都算是各有特色，阿里拥有着良好的口碑和情怀，且自身的业务体量很大，但想要做大布局，有腾讯这样的对手在，确实极为困难。现如今腾讯已经完成了当年陈天桥的梦想，真正将这家公司打造成了在线生活–网络迪士尼。</p>
<p>竞争的世界很残酷，未来的互联网更是如此，我们永远看不清未来究竟会发生什么，也许明天人工智能会成为新的科技革命，今天我们所不耻的百度会成为最大的巨头，今天风光无两的大公司会纷纷倒下，未来就是因为无法预测，我们才格外期待吧，期待明天的腾讯也可以带给我们不同。</p>
<hr>
<p>写作时间：20:00-21:30</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-我是英雄]]></title>
      <url>http://noparkinghere.top/2017/04/04/2017/2017-04-04-%E5%BD%B1%E8%AF%84-%E6%88%91%E6%98%AF%E8%8B%B1%E9%9B%84/</url>
      <content type="html"><![CDATA[<p>晚上看了一部僵尸题材的电影：《我是英雄》，说起这个题材其实早就被电影游戏玩烂了，欧美的僵尸片可以说没有 100 部也有 50 部了。</p>
<p>欧美僵尸题材中最出名的应该算是《生化危机》系列了，这部电影从大约十年前就开始连载了，前段时间有出了第六部。欧美可以说已经把这个题材真的玩烂了，这种电影往往都是在凑剧情，炫特效，这么多年过来，仍然在走着动作特效片，一般的观众大都也审美疲劳了。即便最新的《生化危机6》也是有着冗余的动作场景和特效场景，全片一大半时间在彰显特技，因此评分不可能特别高。</p>
<a id="more"></a>
<p>亚洲现在也开始拍僵尸片了，前段时间比较火的《釜山行》就是这个题材的典型，该片算是近几年来最成功的商业片了，剧情很完整的刻画了人性，且内容不拖沓，很充实，当然结局不算完美。</p>
<p>今天看得《我是英雄》，是日本的一部僵尸片，整体观影是不如《釜山行》的，虽然可以说和《釜山行》一样，是平凡人面对僵尸的各种人性百态，但该片太对得起名字了，真的叫《我是英雄》，全片的主角光环太过严重，给人的感觉就是想要将一个胆小无能的普通人塑造成英雄，然后刚好想到了僵尸题材，然后就硬套上去了，虽然说《釜山行》也是将亲情题材和僵尸进行整合，但人家不违背常识和逻辑，各个地方衔接的都恰到好处。</p>
<p>整体来看，《我是英雄》对于观影要求不高的人来说可以看看，和《釜山行》以及《寄生兽》这种另类题材片还有着不少的差距。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-乘风破浪]]></title>
      <url>http://noparkinghere.top/2017/04/03/2017/2017-04-03-%E5%BD%B1%E8%AF%84-%E4%B9%98%E9%A3%8E%E7%A0%B4%E6%B5%AA/</url>
      <content type="html"><![CDATA[<p>今晚观看了电影《乘风破浪》，这部电影是今年春节的贺岁片，听看过的人都说算是贺岁电影中比较不错的了，当然这个前提也会死基于现在这么差的国内电影水准的。</p>
<p>《乘风破浪》是韩寒的第二部作品，第一部是几年前的一个公路片，主题和风格上，两者基本保持一致。在这部电影中，也是能够看到韩寒作为一个导演是有着很大的进步的。</p>
<a id="more"></a>
<p>《乘风破浪》主要内容是一个年轻人穿越回过去，见证了自己的父亲和母亲的一段历史，通过亲眼所见来消除父子多年的矛盾和不睦。其实这种主题的电影已经被玩过很多次了，之前也看过欧美的小短片，有过这种教育题材的视频。</p>
<p>该电影之所以觉得不错，应该可以归功于以下几点：</p>
<ul>
<li>剧情三关比较的真，随着这总题材被玩的很多，但玩的好的并不多。</li>
<li>演员演技都还比较到位，剧中的演员都可以说是实力派的明星。</li>
<li>轻戏剧类型，太过承重的文艺/故事片很难让人耐心看下去，如：白日焰火等</li>
</ul>
<p>总结下来，这部电影还是值得茶前饭后一看的。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[跑步一周的体验]]></title>
      <url>http://noparkinghere.top/2017/04/01/2017/2017-04-01-%E8%B7%91%E6%AD%A5%E4%B8%80%E5%91%A8%E7%9A%84%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>在三月的月初，我开始有计划的参加一些运动，最开始的时候，每天完成一组 seven（某知名手机 APP 的组合运动）。个人一直很羡慕那些能够长跑，能够跑马拉松的人，于是试着开始跑步，可惜由于太久没参加运动，以及缺乏运动常识，导致我第一次跑步就受伤了，之后有两周的时间左脚一走路就剧痛。</p>
<p>在这周一开始，我觉得休息的差不多了，于是又开始跑步的计划，这周总共跑了 4 次，每次距离都在 1KM 左右，时间也都在 5 分多钟，个人感觉还是比较满意的。算上最开始的一次，这段时间总共有 5 次，下面说下我在这段时间的经验总结，也许对于刚跑起来的你有所启迪：</p>
<a id="more"></a>
<h3 id="慢速"><a href="#慢速" class="headerlink" title="慢速"></a>慢速</h3><p>速度一定要慢，期初的跑步，由于并不是比谁跑的快，更不是比时间，对新手来说，能够完成既定的目标距离就是成功。由于长时间没运动，我第一次跑步冲的太快，导致跑了一半不到就没后劲了，后面完全是靠痛苦的死撑下来的，跑完步站都站不起来，且口中全是血腥味，肌肉拉伤了。这种状况显然是得不偿失的，对身体有损害，且很长一段时间不能在运动，运动讲究的还是循序渐进，可耻循序发展。</p>
<p>因此，通过总结，我这边得出，对于初学者，很久没有运动的人，一开始跑步距离控制在 1KM 左右，并且你需要尽可能慢的控制自己的速度，甚至可能和你走的速度差不多，你需要做的仅仅是出点汗，再最后一段距离时，稍微坚持下就可以完成目标。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>运动前一定要做好热身运动，建议在 1min 左右的时间，推荐办法可以是做脚踝关节的拉伸，如：跪坐在脚上，拉伸可以减少你运动过程可能造成的损伤。但注意不要作任何稍剧烈的运动，初学者的体质往往都是亚健康或者缺乏锻炼人群，也许一组 seven 下来,你就已经不能跑完你的目标了。</p>
<p>一双好的鞋对跑步来说至关重要，我第一次跑步时，穿的鞋偏紧，这种鞋平时穿着不太走动无所谓，一旦跑步就很致命了。跑步首先注意要有一双合脚的鞋，具备的基本条件是舒适和宽松，这样也会减少你受伤的可能性；另外推荐在舒适的基础上，最好还要买大一号的鞋，因为长跑后，脚会明显的肿胀，原本合适的鞋这时候往往就不合适了。</p>
<p>跑步前脱去外套，对于这种季节来说可能一开始偏冷，但一旦跑起来你必然会出一身汗，所以这点也是必须的。</p>
<p>使用相应的跑步电子产品，相关的电子产品很多，如运动手环，手机 APP 悦跑圈等，这些软件都能够帮你记录运动数据，跑完回看信息，能够帮你总结提高。</p>
<h3 id="呼吸"><a href="#呼吸" class="headerlink" title="呼吸"></a>呼吸</h3><p>跑步的呼吸节奏也是很重要的，虽然我是个初学者，但尝试过在意呼吸节奏时，往往能够介绍你跑步过程中的乏力疲惫感，能够让你速度更快，跑的更远。呼吸我这边的建议是：尽可能减少每分钟呼吸的频率，而增加每次呼吸的周期（时间长度）。</p>
<h3 id="休息"><a href="#休息" class="headerlink" title="休息"></a>休息</h3><p>跑步完成后，可以在走相应的一段距离，这边建议 500M-1KM 。跑完步身上有大量的热量，在室外的话，慢走，可以帮助你将热量散去。另外，慢走一段距离有益于你平复自己的身体和心理状态。</p>
<p>初学者跑步多少会有点体力不足的，虽然说跑步能够增强体质，减少睡眠，让身心更加健康有活力等等。但这边我要泼个冷水，长期的锻炼才会有以上的功效，刚开始锻炼只会让你身心俱疲，每次锻炼耗尽体能，往往还会给你第二天带来负面影响。</p>
<p>因此，就我最近的观察体验来说，初学者应该在原有的基础上增加睡眠时间，睡眠可以帮助你更快的进行肌肉的修复，你不该一开始就对运动有误解，且抱有太高的期望。另外，运动确实能够有效的增加你深度睡眠状态的，于情于理，你都该让自己更好的休息，只有这样你才可以良性循环，让运动坚持下来。</p>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>在运动时，对于初学者，我们要保持精神的集中，不该去听歌或者分散精力做别的事情。因为我们刚刚开始跑步，我们的每次运动都可以带来新的不同感受，所以我们需要精神集中在跑步这件事上面，如：调整步伐，让自己消耗更少的体力走的更快；现阶段什么样的速度比较适合你；你计划跑多远，以什么样的速度能够达成目标等等。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>跑步我只是个初学者，还有很多地方需要不断的更新改进，希望自己能够越跑越远，达成自己想要的目标。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[assert调试机制]]></title>
      <url>http://noparkinghere.top/2017/03/31/2017/2017-03-31-assert%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>程序的调试排错往往会占用整个工作的绝大多数时间，很多高级语言都拥有一整套的调试方法。C 语言虽然比较底层，但在调试程序时，也可以使用我之前推荐的 GDB等调试工具，但很多高手绝对不会仅依赖于调试工具，大多数人还是喜欢在开发时用 assert 来排查错误，而开发结束后，更有一些人会使用更加高效完整的日志库等来监控可能出现的 bug。</p>
<h3 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C 标准库"></a>C 标准库</h3><p>C 标准库中自带了 assert.h 这个文件，可以说前人在使用时已经将排错考虑细致了，我们加入这个功能后即可以直接使用 assert 进行调试了，函数声明：<code>void assert(int expression);</code> expression 这可以是一个变量或任何 C 表达式。如果 expression 为 TRUE，assert() 不执行任何动作。如果 expression 为 FALSE，assert() 会在标准错误 stderr 上显示错误消息，并中止程序执行。实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> a;</div><div class="line"></div><div class="line">   <span class="built_in">printf</span>(<span class="string">"请输入一个整数值： "</span>);</div><div class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</div><div class="line">   assert(a &gt;= <span class="number">10</span>);</div><div class="line">   <span class="built_in">printf</span>(<span class="string">"输入的整数是： %d\n"</span>, a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">请输入一个整数值： <span class="number">2</span></div><div class="line">a: a.c:<span class="number">22</span>: main: Assertion `a &gt;= <span class="number">10'</span> failed.</div><div class="line">[<span class="number">1</span>]    <span class="number">9632</span> <span class="built_in">abort</span> (core dumped)  ./a</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>网上查了下，没能找到 assert 标准库的函数原型，于是自己写了个简易版本的 assert ：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define assert(<span class="name">expr</span>) ((<span class="name">void</span>)((<span class="name">expr</span>) || (<span class="name">_assert</span>(<span class="name">__FILE__</span>,__LINE__),<span class="number">0</span>)))</div><div class="line"></div><div class="line">void _assert(<span class="name">const</span> char *file, int line)</div><div class="line">&#123;</div><div class="line">    printf("%s:%d", file, line);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="MCU-自带库-assert-实现"><a href="#MCU-自带库-assert-实现" class="headerlink" title="MCU 自带库 assert 实现"></a>MCU 自带库 assert 实现</h3><p>这边我们以国内广泛使用的 stm32 v3.5.0 官方库为例，使用STM32库函数的时候，你会发现带参数的库函数前面都有assert_param语句。</p>
<p>assert_param语句是用于程序开发的时候，调试用的检测语句。默认是不开启的，你可以无视它的存在。但是，当你在调试程序的时候，可以打开这个检测机制，调试完了再关闭。具体代码如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Exported macro <span class="comment">------------------------------------------------------------*/</span></div><div class="line"><span class="comment">#ifdef  USE_FULL_ASSERT</span></div><div class="line"></div><div class="line">/**</div><div class="line">  * @brief  The assert_param macro <span class="keyword">is</span> used <span class="keyword">for</span> function's parameters check.</div><div class="line">  * @param  expr: If expr <span class="keyword">is</span> <span class="literal">false</span>, <span class="keyword">it</span> calls assert_failed function which reports </div><div class="line">  *         <span class="keyword">the</span> <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> source <span class="built_in">file</span> <span class="keyword">and</span> <span class="keyword">the</span> source line <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">the</span> call </div><div class="line">  *         <span class="keyword">that</span> failed. If expr <span class="keyword">is</span> <span class="literal">true</span>, <span class="keyword">it</span> returns no value.</div><div class="line">  * @retval None</div><div class="line">  */</div><div class="line">  <span class="comment">#define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))</span></div><div class="line">/* Exported functions <span class="comment">------------------------------------------------------- */</span></div><div class="line">  void assert_failed(uint8_t* <span class="built_in">file</span>, uint32_t line);</div><div class="line"><span class="comment">#else</span></div><div class="line">  <span class="comment">#define assert_param(expr) ((void)0)</span></div><div class="line"><span class="comment">#endif /* USE_FULL_ASSERT */</span></div></pre></td></tr></table></figure>
<p>如果我们想要使用 assert_param 就需要定义加入 <code>#define USE_FULL_ASSERT</code> 语句，另外我们可以发现 assert 判定失败时会调用 assert_failed() 函数，但值得注意的是， ST 的固件库中没有预留这个函数的原型，因此我们需要手动创建这个 assert_failed 函数，以下提供一个可供参考的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_failed</span><span class="params">(<span class="keyword">uint8_t</span>* file, <span class="keyword">uint32_t</span> line)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/* </span></div><div class="line">		注意：编译器 Build Output 栏是不会报错的，这边使用的是 MCU 数据如何输出，</div><div class="line">		需要根据具体情况分析，一般 MCU 都会把结果输出到串口。 </div><div class="line">	 */</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Wrong parameters value: file %s on line %d\r\n"</span>, file, line); </div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外 assert_failed()/_assert 函数基本上是所有判定失败后都需要调用的函数，具体要根据你平台提供的库而定，有些 MCU 平台是预留了 assert_failed 这种函数的，你不需要重新定义，只需要略加补充方法即可。例如 EFM32 提供的 assert 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG_EFM) || defined(DEBUG_EFM_USER)</span></div><div class="line"></div><div class="line"><span class="comment">/* Due to footprint considerations, we only pass file name and line number, */</span></div><div class="line"><span class="comment">/* not the assert expression (nor function name (C99)) */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assertEFM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EFM_ASSERT(expr)    ((expr) ? ((void)0) : assertEFM(__FILE__, __LINE__))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EFM_ASSERT(expr)    ((void)(expr))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assertEFM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span></div><div class="line">&#123;</div><div class="line">  (<span class="keyword">void</span>)file;  <span class="comment">/* Unused parameter */</span></div><div class="line">  (<span class="keyword">void</span>)line;  <span class="comment">/* Unused parameter */</span></div><div class="line"></div><div class="line">  <span class="comment">/* 预留用来定制你需要的操作 */</span></div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">  &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>assert 调用基本上大同小异，错误时直接终止程序或者死循环，同时能够提供代码出错位置即可。开发时，不适用 assert 也是可以满足绝大多数需求的，但这时你往往需要自己写语句让错误输出出来，assert 仅是提供了一个更加便捷的操作方式而已。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.runoob.com/cprogramming/c-macro-assert.html" target="_blank" rel="external">http://www.runoob.com/cprogramming/c-macro-assert.html</a><br><a href="http://www.rationmcu.com/stm32/1508.html" target="_blank" rel="external">http://www.rationmcu.com/stm32/1508.html</a></p>
</blockquote>
<hr>
<p>写作时间：21:38-22:17</p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-最终幻想15]]></title>
      <url>http://noparkinghere.top/2017/03/30/2017/2017-03-30-%E5%BD%B1%E8%AF%84-%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B315/</url>
      <content type="html"><![CDATA[<p>有段时间没看电影了，前几天偶然在豆瓣上面看到《最终幻想15》正在上映，于是从网上下载下来，今晚看了下。</p>
<p>就特效而言，该片还是可圈可点的，这部电影的特效应该算是顶级的水准了，一些景物建筑场景往往让你很难分辨出真伪。然而，该片的特效并非无人能及，虽然说是目前这种系列里面最顶级的，但也存在很多的不足。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-30-影评-最终幻想15/1.jpg" alt=""></p>
<a id="more"></a>
<p>首先，和前作比，这部电影制作特效上面肯定是有很大进步的，但进步并不多，前两部作品可以说是在 CG 电影领域颠覆性的，甩开竞争对手几条街，具备很多超前的黑科技，这部作品并没能在 3D 领域和同行拉开差距。</p>
<p>虽然算是力作，比国内的《爵迹》之流特效好不少，但随着现在 3D 动画越来越成熟，国内的一些作品和欧美的其他作品在部分表现上面甚至要好过《最终幻想15》。《最终幻想15》的动作场景过多，且一些地方人物动作不连冠，这点表现的甚至不如国内《画江湖》系列，虽然这种不连冠的场景很少，但总感觉怪怪的。另外作品对光阴的处理老实说进步不大，虽然人物细节已经很多了，但光阴反射处理的一般，因此人物总会缺少真实感，这方面和迪士尼的一些动画还是有差距的。</p>
<p>值得吐槽的还是剧情吧，老是说看完没明白讲的内涵是什么，虽然《最终幻想系列》作品一直以来都有着超前/另类的价值观，但前两部多少还是可以接受的，这部就真的不明觉厉了，剧情的评价就是：人物塑造糟糕的不行，各种迷一样的动机，内奸多到爆，最后帝国灭亡了。如果剧情只是这样，我觉得还可以，最起码主题就是陈述一个国家是如果自取灭亡的，国王是怎么搬起石头砸自己的脚的。关键价值观还是帝国灭亡才是一个开始，主角守卫国土，结局已经不能用语言来表达了。</p>
<p>以上内容并非我写的混乱，而是这部作品前奏还算 OK，中间表现也凑活，后半段全是选特效再编排了一个迷一样的结局（明明都亡国了，却好像刚建国一样）。如果，以上内容都是续集的铺垫，那还可以稍加谅解，但终究而言一部如此混乱的电影还是很难带给观众舒适的感受的。</p>
<hr>
<p>写作时间：19:30-22:00</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言回调函数]]></title>
      <url>http://noparkinghere.top/2017/03/29/2017/2017-03-29-c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>使用 C 语言编程时，一般可以将函数调用增加一层封装，这样做可以让函数的使用更加灵活多变。</p>
<p>回调函数可以让函数功能调用起来更加的灵活，以下几种方式则是 C 语言中，实现代码重用的方法，他们由简单到灵活，也都是存在特定的使用背景的。</p>
<h3 id="宏定义封装"><a href="#宏定义封装" class="headerlink" title="宏定义封装"></a>宏定义封装</h3><p><code>＃define MacroFunction() Afunction(a, b, c)</code> 将Afunction(a, b, c)的常用用法作为一个整体进行封装，这种封装形式，在后续使用时，如果需要修改值的话，可以直接修改<code>＃define MacroFunction() Bfunction(a, b, c)</code> 而无需再进行其他操作。但同时也存在问题，如果我们需要将一半的 Afunction(a, b, c) 改为 Bfunction(a, b, c) 就较为麻烦，如果采用这种方式的话就只能一个个查看替换了。遇到这种情况时，下一种方法是更好的选择。</p>
<a id="more"></a>
<h3 id="静态入口函数"><a href="#静态入口函数" class="headerlink" title="静态入口函数"></a>静态入口函数</h3><p>静态的入口函数，保证函数名相同，利用标志位调用子函数。这样的典型应用很多，比如说网卡驱动里面有一个入口函数Nilan（int FunctionCode，Para*）。具体的参数是什么记不清楚了。不过NiLan的主体是这样的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Long Nila（int FunctionCode，Para*）</div><div class="line">&#123;</div><div class="line">   Switch(FunctionCode)</div><div class="line">   &#123;</div><div class="line">	   Case SendPacket: send(….)</div><div class="line">	   Case ReceivePacket: receive(…)</div><div class="line">	   ...</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写到这里大家明白什么意思了吧。保证相同的函数名就是说：网卡驱动是和pNA+协议栈互连的，那么如何保证pNA+协议栈和不同的驱动都兼容呢，一个简单的办法就是仅仅使用一个入口函数。</p>
<p>另外即便是一些初学者在写程序时，也会潜移默化地使用这种方法，如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int Fun(int flag)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (flag == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		A<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (flag &gt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		B<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		C<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过改变如果函数的参数值，来调用内部的各个函数。这样的做法是可以进化的：如果以后想调用新的函数，增加相应的函数参数值就好了。</p>
<p>层与层之间的互连接口是很小的（这里是一个入口函数），一般是采用名字解析的办法而不是具体的函数调用（利用FunctionCode调用函数，Nilan仅仅实现名字解析的功能）。</p>
<h3 id="回调-CALLBACK-函数"><a href="#回调-CALLBACK-函数" class="headerlink" title="回调(CALLBACK)函数"></a>回调(CALLBACK)函数</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>回调函数才是本文的重点，它比上面的两种方法更加灵活，定制性更强。它使得一个函数可以在不重新编译的情况下实现功能的添加。一般使用回调函数可能存在有以下两点问题：</p>
<ul>
<li>效率降低：回调函数使用了函数指针，一般会先访问函数指针找到函数存放的实际地址，然后才是真正的函数调用，同直接调用函数比，多了一个寻址函数存储位置的过程（普通函数在编译时已经转换成了地址常亮，而函数指正仍然作为一个变量使用）。性能问题现在已经不做过多的考虑，指正调用本身就比较快，且现在机器性能都过剩。</li>
<li>会导致程序的“支离破碎”：在程序中，你读到一个函数指针的时候，并不知道这个函数指针指向的是哪个函数，调用食会让程序碎片化严重。这点我暂时还不是太明了。</li>
</ul>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>使用回调函数可以把调用者与被调用者分开。调用者不关心谁是被调用者，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</p>
<h4 id="有关函数指针"><a href="#有关函数指针" class="headerlink" title="有关函数指针"></a>有关函数指针</h4><p>回调函数并不属于 C 语言最基本的用法，应该算是 C 语言使用的一个技巧，可以让 C 操作起来更加灵活，但灵活的代价就是你要对 C 语言比价熟悉，函数指针，指针函数等能够区分清除。</p>
<p>函数指针是指向函数的指针变量，即本质是一个指针变量。指向函数的指针包含了函数的地址，可以通过它来调用函数。声明格式如下：类型说明符 (*函数名)(参数)。</p>
<p>注意：函数名本身就是代表着指针/地址，因此并不需要再去取地址，使用 &amp;/* 是没有太大的意义的。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void (*fptr)();</div><div class="line">void Function(void)</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 以下两句等价 */</div><div class="line">fptr=&amp;Function;</div><div class="line">fptr=Function;</div><div class="line"></div><div class="line">/* 以下两句等价 */</div><div class="line">x=(*fptr)();</div><div class="line">x=fptr();</div></pre></td></tr></table></figure></p>
<p><strong>虽然 <code>fptr=&amp;Function; 和 x=(*fptr)();</code>写起来都更加复杂，但是有些程序员倾向于使用这种格式，因为它明确指出是通过指针而非函数名来调用函数的，这边我也推荐使用这种写法。</strong></p>
<h4 id="常规步骤"><a href="#常规步骤" class="headerlink" title="常规步骤"></a>常规步骤</h4><p>一般编写这一系列回调及主调函数时，可以分为以下几个步骤：</p>
<ul>
<li>定义指向回调函数的类型，使用 typedef，如：<code>typedef int (*typefun)(int);</code> 表示 typefun 类型指向了类似于 <code>int Test(int num)</code> 这样的一个函数。</li>
<li>调用回调函数的函数，有个形参类型为 typefun，代表我们使用这个函数时，会将回调函数作为参数传递给这个函数。</li>
<li>开始调用，将回调函数的地址（即函数名）作为实参直接传递给调用回调函数的这个主调函数。</li>
</ul>
<p><strong>认真分析，我们可以发现，回调函数的使用就是传递了函数的地址，与传递普通变量的地址并没有实质的区别。</strong></p>
<h3 id="案例具体分析"><a href="#案例具体分析" class="headerlink" title="案例具体分析"></a>案例具体分析</h3><p>下面举个回调函数的简单实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*typefun)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> num)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"The %d th charactor is: %c/n"</span>, i, (<span class="keyword">char</span>)(<span class="string">'a'</span> + i%<span class="number">26</span>));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caller</span><span class="params">(<span class="keyword">int</span> n, typefun ptr)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 也能写成这样: void Caller(int n, int (*ptr)(int)) ,typedef 定义更加方便使用</span></div><div class="line">	(*ptr)(n);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	Caller(<span class="number">30</span>, Test); <span class="comment">//相当于调用Test2(30);</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的例子过于简单，并没有多大的实际意义，但我们通过这样的例子可以看出回调函数和上面讲述的静态入口函数都是在原本的函数上面多加了一层封装，为了让函数调用起来更加灵活多变。</p>
<p>更进一步，利用回调函数，C 语言能够实现很多技巧性的操作，下面扩充一个例子，用回调函数来实现的一个简单泛型程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/* 以下的泛型只是举例，如果需要比较浮点型，字符型则需要补充完善回调函数 */</div><div class="line"></div><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line">typedef int (*cmp)(void *, void *);</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    char *name;</div><div class="line">    <span class="built_in">float</span> score;</div><div class="line">&#125; stru_member, *pstru_member;</div><div class="line"></div><div class="line">void *Max(void *p[], int len, cmp fun)</div><div class="line">&#123;</div><div class="line">    void *res = p[0];</div><div class="line">    <span class="keyword">for</span> (int i = 0; i &lt; len; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ((*fun)(p[i], res))		// 这边等价于 <span class="keyword">if</span> (fun(p[i], res))</div><div class="line">        &#123;</div><div class="line">            res = p[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int comp(int *a, int *b)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (*a &gt; *b)</div><div class="line">        <span class="built_in">return</span> 1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int mcomp(pstru_member a, pstru_member b)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (a-&gt;score &gt; b-&gt;score)</div><div class="line">        <span class="built_in">return</span> 1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">return</span> 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int *pres;</div><div class="line">    int data[5] = &#123;1, 12, 30, 4, 5&#125;;</div><div class="line">    int *pdata[5] = &#123;&amp;data[0], &amp;data[1], &amp;data[2], &amp;data[3], &amp;data[4]&#125;;</div><div class="line">    pres = Max((void **)pdata, 5, (cmp)&amp;comp);		// 这边等价于 pres = Max((void **)pdata, 5, (cmp)comp);	</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pres);</div><div class="line"></div><div class="line">    stru_member mem[3] = &#123;&#123;<span class="string">"no.1"</span>, 99.6&#125;, &#123;<span class="string">"no.2"</span>, 91.4&#125;, &#123;<span class="string">"no.3"</span>, 95.5&#125;&#125;;</div><div class="line">    pstru_member pmem[3] = &#123;&amp;mem[0], &amp;mem[1], &amp;mem[2]&#125;;</div><div class="line">    pstru_member pres2 = Max((void **)pmem, 3, (cmp)&amp;mcomp);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s:%f\n"</span>, pres2-&gt;name, pres2-&gt;score);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><p>软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调和异步调用。同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用；回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知。同步调用是三者当中最简单的，而回调又常常是异步调用的基础。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-29-c语言回调函数/1.gif" alt=""></p>
<p>这几种调用方式并不完全是 C 语言中的常用方式，往往我们需要加入一些小技巧才可以完成这些功能的实现。</p>
<h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>现在有 A B C 三个事件，首先，A 事件完成了才可以触发 B 事件，然后 B 事件完成了，才可以触发 C 事件。这中间，如果 A 事件休眠了一段时间，B 也不得不等待，同样 B 出了问题，C 会等待 A 和 B 更长时间。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> A complete</div><div class="line"><span class="keyword">do</span> B</div><div class="line"><span class="keyword">else</span> </div><div class="line"><span class="built_in">wait</span> A</div><div class="line"></div><div class="line"><span class="keyword">if</span> B complete</div><div class="line"><span class="keyword">do</span> C</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">wait</span> B</div></pre></td></tr></table></figure></p>
<p>这种就是典型的阻塞机制，无论如何我们只能等待上一个任务的完成，如果没有完成我们只能继续等待，这样造成的问题是，我们一直在浪费系统资源。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">void</span></span>)</div><div class="line">&#123;</div><div class="line">    int temp = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(!temp)&#123;  </div><div class="line">      temp = wait(funA());  </div><div class="line">    &#125;    </div><div class="line">    temp = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(!temp)&#123;  </div><div class="line">      temp = wait(funB());  </div><div class="line">    &#125;  </div><div class="line">    temp = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">while</span>(!temp)&#123;  </div><div class="line">      temp = wait(funC());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。</p>
<p>对于一般的结构化语言，可以通过回调函数来实现回调。回调函数也是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数。在面向对象的语言中，回调则是通过接口或抽象类来实现的，我们把实现这种接口的类成为回调类，回调类的对象成为回调对象。对于象C++或Object Pascal这些兼容了过程特性的对象语言，不仅提供了回调对象、回调方法等特性，也能兼容过程语言的回调函数机制。</p>
<p>大家应该看到了，有两种做法，一种是先发送信号（执行回调函数），然后继续执行下面的代码。同样可以先执行代码再发送信号。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> A <span class="keyword">Message</span>  </div><div class="line">send <span class="keyword">to</span> b   </div><div class="line"><span class="keyword">do</span> A  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> B <span class="keyword">Message</span> From b  </div><div class="line"><span class="keyword">do</span> B  </div><div class="line">send <span class="keyword">to</span> c  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> B complete  </div><div class="line"><span class="keyword">do</span> C  </div><div class="line"><span class="keyword">message</span> from c</div></pre></td></tr></table></figure>
<p>这种就是在函数的参数中带有一个其他函数指针，当需要的时候我们可以通过函数指针名进行调用其他函数即发送消息到其他函数。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">A</span></span>, callback)</div><div class="line">&#123;  </div><div class="line">   callback();  </div><div class="line">   funA();  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void callback()</div><div class="line">&#123;  </div><div class="line">   funB();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">F tell A  </div><div class="line">  <span class="keyword">do</span> A  </div><div class="line">  <span class="keyword">time</span> <span class="number">2</span> hours  </div><div class="line">  <span class="keyword">if</span> A <span class="keyword">complete</span> Report <span class="keyword">to</span> F  </div><div class="line">F tell B  </div><div class="line">  <span class="keyword">do</span> B  </div><div class="line"> <span class="keyword">time</span> <span class="number">1</span> hours  </div><div class="line">  <span class="keyword">if</span> B <span class="keyword">complete</span> Report <span class="keyword">to</span> F  </div><div class="line">F tell C  </div><div class="line">  <span class="keyword">do</span> C  </div><div class="line"> <span class="keyword">time</span> <span class="number">1.5</span> hours  </div><div class="line">  <span class="keyword">if</span> C <span class="keyword">complete</span> Report <span class="keyword">to</span> F  </div><div class="line">F tell D  </div><div class="line">  <span class="keyword">do</span> D  </div><div class="line">  <span class="keyword">time</span> <span class="number">3</span> hours  </div><div class="line">  <span class="keyword">if</span> D <span class="keyword">complete</span> Report <span class="keyword">to</span> F</div></pre></td></tr></table></figure>
<p>四个程序虽然有先后次序整体上看是依次执行的，但是执行的过程中，我们并不会因为前面的代码没有执行完，而不执行。</p>
<p><em>回调函数在 C 语言中太过常用，往往一些高级的操作都需要使用这个技巧，后续还会更新一些关于回调函数技巧使用的一些文章。</em></p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://c.biancheng.net/cpp/html/1202.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/1202.html</a><br><a href="http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="external">http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html</a><br><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">https://www.zhihu.com/question/19801131</a><br><a href="http://blog.csdn.net/tzshlyt/article/details/52993282" target="_blank" rel="external">http://blog.csdn.net/tzshlyt/article/details/52993282</a><br><a href="http://www.cnblogs.com/kunhu/p/3713370.html" target="_blank" rel="external">http://www.cnblogs.com/kunhu/p/3713370.html</a><br><a href="http://www.cnblogs.com/kunhu/p/3700610.html" target="_blank" rel="external">http://www.cnblogs.com/kunhu/p/3700610.html</a><br><a href="http://blog.csdn.net/dan_blog/article/details/7897852" target="_blank" rel="external">http://blog.csdn.net/dan_blog/article/details/7897852</a><br><a href="http://bbs.bccn.net/thread-457131-1-1.html" target="_blank" rel="external">http://bbs.bccn.net/thread-457131-1-1.html</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-callback/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-callback/</a><br><a href="http://xenyinzen.wikidot.com/reship:080123-8" target="_blank" rel="external">http://xenyinzen.wikidot.com/reship:080123-8</a></p>
</blockquote>
<hr>
<p>写作时间：21:39-22:56</p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言来实现面向对象编程]]></title>
      <url>http://noparkinghere.top/2017/03/29/2017/2017-03-29-c%E8%AF%AD%E8%A8%80%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>阅读本文之前先要对 C 语言有个比较深入的认识，能够灵活的使用指针，结构体，回调函数等。</p>
<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html" target="_blank" rel="external">http://blog.codingnow.com/2010/03/object_oriented_programming_in_c.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GDB使用小结]]></title>
      <url>http://noparkinghere.top/2017/03/28/2017/2017-03-28-gdb%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近研究了下 GDB，这是一款调试工具中的神器，其实很久以前就有涉及过这款软件，但是由于交互不直观，太多的命令，操作较为复杂等原因，因此我一直以来都很少使用这个工具，实在没办法的时候往往也都是采用插入输出来排查错误。</p>
<p>百度百科的介绍如下：UNIX及UNIX-like下的调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在 UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。</p>
<h3 id="前期操作"><a href="#前期操作" class="headerlink" title="前期操作"></a>前期操作</h3><ul>
<li>使用命令：<code>gcc -g -o test test.c</code> 生成可运行程序，注意：在编译时要加上-g选项，生成的可执行文件才能用gdb进行源码级调试。</li>
<li>使用 <code>gdb test</code> 正式进入调试过程。</li>
</ul>
<a id="more"></a>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>进入调试过程后，才能够开始用 gdb 这个工具对程序的运行状态进行控制和观察。具体操作步骤如下：</p>
<ul>
<li>run（或r）： 从头开始连续运行程序，和不适用 GDB 直接执行程序效果一致。</li>
<li>start ： 开始执行程序，停在main函数第一行语句前面等待命令。</li>
<li>backtrace（或bt）： 查看各级函数调用及参数。</li>
<li>frame（或f）： 帧编号 选择栈帧。</li>
<li>finish 连续运行到当前函数返回为止，然后停下来等待命令。</li>
<li>list（或l）： 列出源代码，接着上次的位置往下列，每次列10行；list+行号 ： 列出从第几行开始的源代码；list+函数名 列出某个函数的源代码。</li>
<li>next（或n）： 执行下一行语句，和 step 的区别在于，不进入子函数。</li>
<li>step（或s）： 执行下一行语句，如果有函数调用则进入到函数中。</li>
<li>break（或b）： 行号 在某一行设置断点；break 函数名 在某个函数开头设置断点；<code>break x if y</code> 设置条件断点，注意 break 加入条件语句往往比较常用，能够更加准确的调到循环语句的第 n 步。</li>
<li>delete breakpoints ： 断点号 删除断点。</li>
<li>disable breakpoints 断点号 禁用断点。</li>
<li>continue（或c）： 从当前位置开始连续运行程序，被 break 后一般可以使用该语句。</li>
<li>set var ： 修改变量的值，可以在任何地方使用改制重新修改某一个变量值，更加方便监测和判断。</li>
<li>print（或p）： 打印表达式的值，通过表达式可以修改变量的值或者调用函数。</li>
<li>display+变量名 ： 跟踪查看某个变量，每次停下来都显示它的值。</li>
<li>undisplay 跟踪显示号 取消跟踪显示。</li>
<li>info（或i）+locals ： 查看当前栈帧局部变量的值，使用该命令前，先用 backtrace 命令（简写为bt）查看函数调用的栈帧，再用 frame（或f）选择栈帧；info（或i） breakpoints 查看当前设置了哪些断点。</li>
<li>watch ： 设置观察点，可以具体的查看数组的某个值，如：watch input[5]。</li>
<li>info（或i）watchpoints : 查看当前设置了哪些观察点。</li>
<li>x ： 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量。可以查看越界的一些信息，如定义 tmp 数组长度为 5，通过 watch 可以查看 tmp[5] tmp[6] 等的数据。</li>
<li>quit（或q）： 退出gdb调试环境。</li>
</ul>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>由于真正开始研究接触 GDB 时间不长，原本是想这个 IDE 来监控的，可惜找不到体积小巧，功能强大的，所以还是决定研究下 GDB，这边仅能够基本操作 GDB，后续有什么新的发现，会继续补充。</p>
<hr>
<p>To be continued…</p>
<p>写作时间：21:50-22:28</p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kdevelop 使用问题]]></title>
      <url>http://noparkinghere.top/2017/03/27/2017/2017-03-27-kdevelop-%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>在使用 C 语言想要做些测试时，往往找不到比较好的调试工具，一般 C 语言现在都会作为 C++ 附带的内容，很多现代编译器都不再单独列出来了。另一方面，keil 之类的软件虽然专业使用 C 语言做开发，但他们往往都是交叉编译的，不提供 windows 平台下的开发，可能可以选择编译器，但目前来说我没有找到。</p>
<p>之前写过一篇文章<strong>notepad++和MinGW</strong>也是介绍如何将 notepad++ 配置为一个简易的 C 语言开发工具的，但比较遗憾的是，这个仅能算是一个简单的 C 语言开发工具， notepad++ 暂时还没有发现如何能够编译一个大的工程。另外做项目开发的话，调试相当重要，很可能需要要借助于 GDB 之类的工具监控数据。</p>
<p>今天发现了一款名为 Kdevelop 的 IDE，Kdevelop 是一个开源软件，且支持多种编程语言，体积不大，也能够接收。然而由于该软件过于小众化，目前仍然没有发现如何在 windows 下编译调试 C 程序。</p>
<p>暂时问题比较多，可能需要一段时间才能够解决这个问题，目前能够查到的有关 Kdevelop 的内容一般都是 linux 下的，另外 <a href="https://userbase.kde.org/KDevelop4/Manual/WindowsSetup" target="_blank" rel="external">Kdevelop 官网</a>关于 windows 下软件的配置也不够详细，仅有环境变量配置，而且是否配置成功有关现象等也描述含糊。</p>
<a id="more"></a>
<hr>
<p>本文先写个大概，未必能够解决这个问题，且软件过于小众，如果能够发现更佳的调试工具，应该就不会更新了。</p>
<p>本文暂时不会再接着更新，参考查阅了多个网站，都显示 Kdevelop 太过小众，虽然有文档，但问题会频繁出现，且缺少相关的 FAQ，windows 下的 Kdevelop 更是几乎没有查到任何相关内容。</p>
<p>C 的开发工具已经使用了 eclipse-CDT ，该软件可以直接调用 GDB 并提供一个友好的 GUI 调试界面，相关内容可以查看我的文章。</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[能做和做好]]></title>
      <url>http://noparkinghere.top/2017/03/26/2017/2017-03-26-%E8%83%BD%E5%81%9A%E5%92%8C%E5%81%9A%E5%A5%BD/</url>
      <content type="html"><![CDATA[<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力月小结]]></title>
      <url>http://noparkinghere.top/2017/03/26/2017/2017-03-26-%E5%91%A8%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>定期的总结十分重要，以后可能会两-四周写一次总结性文章。</p>
<h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>最近一周，状态十分的差，主要表现在不但没有达成之前的目标，而且反而退步了，之前的日程如下：</p>
<ul>
<li>洗漱+准备早餐 7:00-7:20</li>
<li>学习英语 7:20-8:00</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00 后开始上英语课</li>
<li>上课后，一组 seven </li>
<li>17:30 之后阅读推荐书籍</li>
<li>看书到 18:10 以后</li>
<li>18:30 吃晚餐</li>
<li>一般 19:30 左右才开始写文章，写作时间不固定，技术类文章 2h 大概完成个初稿，随笔类文章一般在 1h 左右</li>
<li>其他时间任意安排</li>
<li>23:00 前休息</li>
</ul>
<a id="more"></a>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>这周时间状态急转直下，目前的状态却是：</p>
<ul>
<li>7:30-8:00 扇贝英语的学习，单词，听力，新闻等，效果奇差，因为赶时间，往往将原来至少需要 50 分钟的任务压缩到了半小时不到。</li>
<li>8:00-8:15 吃早餐，去公司</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-18:30 加班或者上网闲逛，白天效率不高，导致这段时间会浪费时间</li>
<li>18:00-19:30 晚餐、散步时间</li>
<li>19:30-23:00 事实上这段时间，只完成了简书一篇文章的内容，而这篇文章也只用了不到一个小时，另外有一组 seven，其他时间不知道都都去哪儿了。</li>
<li>23:30 左右入睡</li>
</ul>
<p>仔细分析这周为何不但不进步，反而退步了？</p>
<ul>
<li>这周不再上英语课了，导致 17:00 不回宿舍，相关一系列任务如：上课，阅读，seven 整个这一个半小时的任务完全紊乱了。</li>
<li>和同时一起搭伙，吃饭时间变动了，效率也变低了，最主要晚上吃的太多等原因导致睡眠不好。</li>
<li>由于晚上睡眠不好，一般只有 1h 的深度睡眠，早上疲乏，无法完成早上任务，白天工作效率也不高。</li>
<li>待在宿舍就学习方面而言，不是太习惯看书，需要重点改掉这个毛病，另外网络差，电脑键盘差配置不同，以及吃临时容易分心等问题都让时间不知觉的溜走了。</li>
<li>看一本《腾讯传》的书，每天事实上也没看多久，但因为上述所有计划都紊乱了，导致晚上虽然只看了 1/2h 但却占用了别的时间，一步错步步错。</li>
<li>身体不适，由于睡眠还有之前脚肌肉拉伤引起的一系列问题。</li>
</ul>
<h3 id="下周"><a href="#下周" class="headerlink" title="下周"></a>下周</h3><p>下周一定要回归到原来的节奏上，严格执行，不断优化调整自己的状态，大致如下：</p>
<ul>
<li>洗漱+准备早餐 7:00-7:20</li>
<li>学习英语 7:20-8:00</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00 后开始上英语课</li>
<li>上课后，一组 seven </li>
<li>17:30 之后阅读推荐书籍</li>
<li>看书到 18:10 以后</li>
<li>18:30-19:30 吃晚餐，散步</li>
<li>19:30-21:00 学习时间</li>
<li>21:00-21:30 运动时间，跑步或者哑铃</li>
<li>21:30-22:30 写作，控制在一个小时之内</li>
<li>23:00 前休息</li>
</ul>
<p>严格的执行，虽然精神上面比较疲乏，但最起码都还可以完成，不会像这周这样全部混乱，之后的计划还会不断地修正，希望自己可以锻炼良好的身体素质，另外也能有个高效的学习习惯。</p>
<hr>
<p>写作时间：21:15-22:10</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待TIM]]></title>
      <url>http://noparkinghere.top/2017/03/25/2017/2017-03-25-tim-%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>腾讯是一家 98 年成立的公司，早期靠 PC 端 qq 起家，数年前移动互联网普及后，又依靠微信再次巩固了自己霸主的低位，数十年来在即时通讯领域无论是国内还是国际上都几乎没有公司可以与之匹敌，2016 年底，腾讯又低调的推出了 TIM 这款 IM (即时通讯)软件。</p>
<h3 id="TIM-的过去"><a href="#TIM-的过去" class="headerlink" title="TIM 的过去"></a>TIM 的过去</h3><p>早在 MSN 进入中国的时候起，腾讯就一直想要进入商务通讯领域，虽然说 qq 在商务领域一直占有着 50% 左右的市场，但过多的消息提示和广告弹窗让用户往往不厌其烦，加之期初的 qq 设计以及受众人群向来都是低幼化群体（低年龄，低收入，低地位）。因此中产阶层和都市白领历来对 qq 不屑一顾，即便 MSN 再难用，他们也会觉得具备高品味。而 qq 占用的 50% 市场也主要是中小型企业，主要得益于 qq 强大的功能和市场。</p>
<p>早在十多年前，腾讯就开始布局商用 IM 领域，这么多年也推出过多款 PC 端 IM 产品，如： RTX，TM，企业微信等。</p>
<p>RTX 一般是局域网自建服务器使用，虽然是十多年前的版本，但基本功能都具备，算是一个成熟的产品，目前仍然有些中小型公司内部正在使用，但值得一提的是 RTX 仅是内部使用，虽然 RTX 在腾讯能够找到 2015 等新版本，但在企业内部不会受到太大重视，往往很多企业还在用最早期的版本，同样腾讯也不指望通过它能够获得多少实际收益。</p>
<p>TM 算是 qq 的一个变种，也是腾讯从普通消费市场走向商业市场的一次试水，TM 直接导入了 qq 数据，在 qq 的基础上，将图标和界面进行了修饰，让整体看起来更加商务化些，同时加入了名片等根据商业气息的功能。但较为遗憾的是，同 qq 相比，TM 只能算是阉割版的 qq，无法起到不可或缺的作用，更糟糕的是 多年的摸索，TM 仍没有摸索出一套自己的商业发展道路。因此，对于这种需要一定人力物力，却没法建立自己存在感的产品，往往只能不了了之。</p>
<a id="more"></a>
<h3 id="TIM-的现在"><a href="#TIM-的现在" class="headerlink" title="TIM 的现在"></a>TIM 的现在</h3><p>介绍完上面内容 ，下面主角登场。TIM 是由腾讯在 2016 年 11 月发布的客户端应用，TIM 是针对办公场景的 IM 客户端应用程序，TIM 是轻聊的 QQ，更方便办公,TIM 用在 QQ 轻聊版的基础上加入了协同办公服务的支持，而且可使用 QQ 号登录，好友、消息完全同步，支持多人在线编辑 Word、Excel 文档等。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-25-tim-使用/1.png" alt=""></p>
<p>我们可以仔细分析下 TIM 的特点：</p>
<ul>
<li>TIM 的联系人直接通过 qq 进行导入，因此仅作为 IM 软件的话，你是可以用 TIM 代替 qq 的。</li>
<li>TIM 在 PC 端使用常规 qq 完全不同的登录风格界面，这种将 风格和布局更加紧凑，更适合办公使用。</li>
<li>TIM 在 手机端界面基本和 qq 保持风格一致，目前来看手机在办公领域仍然不能作为主流。</li>
<li>TIM 用于商务办公，因此继承了 TM 的特点，有许多商务办公的特质，如：无广告，qq 空间，会员之类的增值服务，也没有 qq 秀，qq宠物等低幼化功能。</li>
<li>TIM 可以将非工作联系了进行隐藏，对使用 qq 没有任何影响。</li>
<li>TIM 推出了在线文档编辑的功能，可以将传统 office 套件下的 word 和 excel 搬到浏览器下多人协同办公，这似乎是 TIM 向 SAAS（软件即服务）进军的一个信号。</li>
</ul>
<p>TIM 可以看作是 TM 的复活产品，之所以复活，很大一部分原因是因为网络版的 office 套件，受 Google Drive 的影响，SAAS 越来越受到追捧，而目前国内看来，并没有发现一款可以媲美 Google Drive 套件的产品，腾讯这次又是通过对一个创新领域的抄袭加上微创新来实现弯道超车，之所以成为微创新，主要因为和国外相比，国内用户往往更倾向 IM+邮箱，在线协同办公+ IM 能够带来比在线协同办公+邮箱更佳的体验。</p>
<p>就目前来看，在线文档编辑的功能应该可以算是给部分企业提供便捷的，毕竟一方面正版 office 软件价格昂贵，另一方面多人协同编辑极具优势。但 TIM 离一个真正能够吸引用户的商业产品而言，仍然有不少的路要走：</p>
<ul>
<li>协同办公的功能仍然不够丰富。就目前看来 TIM 可以拿得出手的协同办公主要有三个：远程协助，word，excel。但无论是数量还是质量都和 Google Drive 差距颇大， Google Drive 得益于应用市场，可以提供更多的第三方应用；TIM 的 word 和 excel 目前都只具备最基础的功能，而 Google Drive 的产品已经基本上可以代替 Microsoft office 了。</li>
<li>TIM 仍未能切住用户的痛点。使用 qq 谈业务的用户，最看重的往往是聊天记录，因此不少用户都开开通超级 qq 会员来保存聊天记录，目前看来 TIM 还无法做到这点。</li>
<li>qq 一直缺乏上下级管理权限。虽然受员工喜欢，但却不受老板待见，TIM 只是将 qq 的功能导入过来，仍然没能够解决老板管理员工的问题，不能讨好管理钱包的人，也就不能真正走入商业市场。</li>
<li>未能将微信联系人也整合进 TIM。qq 和 微信同为腾讯的产品，微信因为用户量更广，因此在办公领域也占有一席之地，TIM 仅是将 qq 的数据导入过来，却没有将微信的数据也导入下来，同时挂“qq+微信”和 同时挂“TIM+微信”好像并没有区别。</li>
<li>手机版本的 TIM 同之前腾讯的 QQi，QQ轻聊版等无论是界面还是功能都没有什么区别，甚至说手机版的 TIM 和 QQ 本身也没什么不同，如果 TIM 和之前的 TM 一样，可有可无的话，注定活不久，即便是手机端也同样如此。</li>
</ul>
<h3 id="TIM-的将来"><a href="#TIM-的将来" class="headerlink" title="TIM 的将来"></a>TIM 的将来</h3><p>腾讯向来喜欢在某些市场成熟了再后发制人，而腾讯的这类产品一般也会悄悄的上线，等大家察觉的时候，往往他已经是一家独大了。下面是我个人对 TIM 的一些看法，TIM 可以通过将 qq 会员具备的一些功能，SAAS，其他一些附加功能一起打包出租给商业用户来谋求一杯羹，预测 TIM 可能的发展方向：</p>
<ul>
<li>初期，同当年的微信背靠 qq 导入流量一样，TIM 会依靠 qq 和微信来导入商业用户的流量，同时如果能够将微信和 qq 的通讯功能合二为一，在办公领域往往比较让人待见。腾讯在商用领域根基薄弱，但通过 qq 和微信的话，可以让他有个无痛的过渡期。</li>
<li>中期，会进一步完成从 IM 软件到 SAAS 的转换，TIM 会提供 office 办公套件，腾讯云，在线 OA 系统等多种服务，这阶段主要靠用户来挖掘服务内容和形式，不断的改进自身的产品。</li>
<li>后期，加入 BOSS 管理账号，这个阶段 TIM 已经不再依赖微信和 qq 了，BOSS 的账号可以对其他子账号拥有绝对的权限，查聊天记录，授权，删号等等，由于 SAAS 也日趋成熟，可以走上商业化的发展道路。各家公司如果需要使用 TIM 的 BOSS 账号，SAAS 的增值服务，就需要向腾讯付费。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TIM 究竟会走什么样的道路目前还尚未清晰，或许几年后 TIM 会成为 办公领域的一匹黑马引领国内新的云办公潮流，又或者 TIM 终将如他的爹 TM 一样被用户所淡忘，而纵观腾讯历史，也有过多次失利，但却几乎没有过同一战场失利两次的经历，因此 TIM 的发展还是多少让人有些期待的。</p>
<hr>
<p>写作时间：21:15-22:56</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[混乱局面下的中国手机市场]]></title>
      <url>http://noparkinghere.top/2017/03/24/2017/2017-03-24-%E6%B7%B7%E4%B9%B1%E5%B1%80%E9%9D%A2%E4%B8%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E6%89%8B%E6%9C%BA%E5%B8%82%E5%9C%BA/</url>
      <content type="html"><![CDATA[<p>今天正值周五，也是华为上半年发布旗舰手机的日子。从华为开始做手机时，我就一直用的他家手机，包括，荣耀1，荣耀2，荣耀3，荣耀6。然而透过数据不难发现，只到荣耀6，之所以如此，很大的原因在我这个手机买了将近 3 年，至今仍在使用。这边也许很多人会褒奖它质量好，然而，现在换手机的人大多数并非是因为手机坏了，之所以我不去换手机根本原因在于市面上找不到满意的产品。</p>
<p>今天的发布会，一如以往，我并没有特地去看，我也并非一个真正的花粉，这些年见证了很多手机厂商潮起潮落，更多的是对这个市场已经麻木。</p>
<a id="more"></a>
<p>回归正题，本文题为“混乱局面下的中国手机市场”，之所以混乱是因为各大厂家都不知道该做出怎样的产品。目前手机市场的萧条可以分为以下几点：</p>
<ul>
<li>产品互相抄袭：显然今天 P10 的发布就是对 iphone 6 外观的抄袭，虽然实现了自身的突破，如色彩多样化，窄边框高屏占比等，但一丑遮所有，外观上的娘性，注定了整个产品缺少特色，而任何一个微创新几乎都被各家模范和抄袭。</li>
<li>模式抄袭：从互联网营销到饥饿营销，从线下推广到巨资广告。代表互联网的小米和代表线下的 OV 基本上被各大模仿者抄了个遍。产品上做不出文章，就都开始在渠道上下功夫，虽说是本木导致，但也没办法。</li>
<li>产品长久缺乏创新：从 iPhone 的指纹识别之后，基本上手机市场再无刚需创新了。无论是 3D 按压和OLED 节能，还是 IP67和红魔识别，都并非能给普通用户带来实际价值的创新。仅凭这些就让很多人失去了对手机数码产品的兴趣，更无法让老用户又购买新机的欲望。</li>
<li>一年 32 场演唱会：说来并非玩笑，去年华为，小米，魅族，几乎都是隔三差五就会开场发布会，每家一年光手机就发布了 20 多款。魅族去年 n 多场演唱会，发布的手机几乎都找不到任何差别；华为今年更是不断的推出一款又一款的青（yan）春（ge）版手机。</li>
<li>手机厂家的迷茫：智能手机催生了一次智能普及的科技革命，在经过过去 10 年的发展，早已成熟，如今可以增长的份额越来越少，OV 两家在年初时就已经对今年的市场不抱有太高的期望，而各家厂家也无法拿出有诚意的产品。开发布会，打广告，提供智能设备，加入 AI 技术等等都是期望在探（mi）索（mang）中可以找出一条活路。</li>
</ul>
<p>PC 在手机的冲击下，早已没落多年，透过手机，我们可以看到目前主流的科技市场。我们有理由相信，苹果引爆了移动互联网让我们可以安度 08 年的金融危机，但自 07 年智能手机发布到现在已经过去了十年时间，根据以往的经验可以判断一场革命可以让市场振兴繁荣 10 年，而我们下一个 10 年又在哪儿呢？会是人工智能吗？而这真的会是一场属于大家的繁荣吗？</p>
<hr>
<p>写作时间：22:15-22:55</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[腾讯传读后初感]]></title>
      <url>http://noparkinghere.top/2017/03/23/2017/2017-03-23-%E8%85%BE%E8%AE%AF%E4%BC%A0%E8%AF%BB%E5%90%8E%E5%88%9D%E6%84%9F/</url>
      <content type="html"><![CDATA[<p>最近阅读了《腾讯传》这本书，顾名思义，该书是一本传记类书籍，主角是腾讯公司。这本书刚看了 1/3，但还是想把就该书而言的读后感写出来，本文不会讨论书中的情节，仅仅描述为何这个书与众不同。</p>
<p>我个人大约是小学快毕业的时候开始阅读课外书籍的，至今也有十多年的时间了，过去个人比较偏爱小说，现在也阅读了一些技能类书籍和传记文学作品。</p>
<p>之前我也阅读过一些个人传记，但往往都不是很满意的，本身对这类书不是太偏好，然后阅读的过程往往都是比较艰辛的，需要耐下心来，一点点的读，往往一本这类书籍都会看个十天半月，但结果却更糟糕，上次读的书是一本介绍马云的，阅读的过程就很艰辛，花了好多天时间，然后读完才发现上了当，全书都是在神话吹捧主角，完全和不符合开头所谓的绝对客观真相，另外书中对细节负面消息后续谈论极少。</p>
<p>《腾讯传》这本书给我的感受就极为特别，像是在看一本小说，让人想一探接下来的情节。书以一个时间轴，通过所有的事情，每个和腾讯相关人的事情侧面的刻画腾讯的成长过程，一步步的给你展现出这段历史，书中也将很多被神话疯传的谣言给去掉了，平实的把一些真相讲出来。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-23-腾讯传读后初感/1.jpg" alt=""></p>
<a id="more"></a>
<p>既然这本书值得一览，那总是有些可圈可点之处的，这边列出我的看法：</p>
<ul>
<li>首先，作者：吴晓波，应该算是有点名气的作家了。能够将这样一类书，写成仅靠内容就吸引人的，可以键作者写作功底了得，文章的语言平实，可以将故事婉婉道来，而一些事件的介绍又不缺诙谐幽默。</li>
<li>其次，每节开头均有两段引用语，国外学者的文字，预示着科技给生活的改变，而故事相关人物的引用语则预示接下来剧情的主要矛盾点。</li>
<li>再者，故事主角的腾讯，所有其他人物都是配角，每个人都不自带主角光环，都有睿哲的一面，又往往包含一些失误的地方，文章就目前来看，写的都还算客观。</li>
<li>另外，文章以腾讯为背景，穿插了很多时间线，各家互联网公司都会在小说中，轮番出场，全书更像是一本中国互联网的历史书籍，看这本书更像是我们这代人在缅怀过去。</li>
<li>最后，腾讯传以平实的语言去讲述这样一个公司的成长壮大，从有到无的过程，代入感很强，所有的描述都只是为了讲述这件事，仅会在某些地方穿插一些作者的观点，并不会左右读者的思维，且这些结论性内容过度都极为自然，实属不易。</li>
</ul>
<p>在我个人看来，这本书是很值得一阅的，详细的书评，在完成阅读后再写上。</p>
<hr>
<p>写作时间：21:52-22:15</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待多说关闭服务]]></title>
      <url>http://noparkinghere.top/2017/03/22/2017/2017-03-22-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%A4%9A%E8%AF%B4%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>今天浏览个人博客时，无意中发现多说有一栏通知，期初还以为是个人授权到期，点开一看吓了一跳：<strong><a href="http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241" target="_blank" rel="external">重要通知: 多说即将关闭</a></strong>。有些遗憾，毕竟算是国内首屈一指的网站评论系统了，然而细想一下，又觉得理所当然。</p>
<h3 id="多说简介"><a href="#多说简介" class="headerlink" title="多说简介"></a>多说简介</h3><p>多说是一款追求极致体验的社会化评论框，可以用微博、QQ、人人、豆瓣等帐号登录并评论。多说帮助用户搭建更活跃，更互动的评论平台，功能强大且永久免费。它正在改变网站与用户之间，用户与用户之间的互动方式。这个专门基于社交网络的评论系统，能够轻松的帮网站主搭建自己互动性极强的社区，让留言的用户都有“家”的感觉。</p>
<p>官方简介如下：</p>
<p>让评论更活跃、互动性更强的评论系统，永久免费且容易安装用微博、QQ、人人、豆瓣等帐号轻松评论和分享<br>智能识别垃圾评论、稳步提升网站流量。</p>
<a id="more"></a>
<h3 id="关闭原因"><a href="#关闭原因" class="headerlink" title="关闭原因"></a>关闭原因</h3><p>一年前，我个人开始把多说加到自己的博客上面的，但现在看来，是时候将其下架了。去年年底的时候 GFW 开始拦截 disqus 后，很多用户也只用选用国内的一些评论系统了，目前来看，多说关闭的并不是突发事情，在过去一年到现在多说的评论系统经常会突发各种问题，比如无法评论，无法加载，无法显示某些功能等等，现在看来那时就已经初现端倪了。</p>
<p>评论一个业务/服务为何会关闭，最主要的原因就是赚不到钱，去年争议比较大的网站同样如此，虽然大片的用户在使用，但就是因为赚不到钱，加上 ZF 打压，所以诸如华为云，360网盘等等就顺水推舟都关闭了自己的服务，反观百度网盘作为重灾区依旧能够生龙活虎，不难发现，问题本质就是出在钱上面。多说在国内没能够找到真正的付费用户，因此不难想象他最终的命运。</p>
<p>国内大多数软件/服务都是抄袭的国外的，这边我们并不讨论抄袭这个问题，因为抄袭的好的软件也有很多成功的典型，如：qq，qq空间，新浪微博等等，甚至很多公司都再他们的祖先倒下后还能够创造意想不到的市场效益。多说同样是一款本土化的国外软件，然而，他并没有那么幸运走到最后。</p>
<p>分析原因大致如下：</p>
<ul>
<li>国内网络公司更加注重利益，因此更多的是把东西捏在自己手上，只有用户在自己手上才放心踏实，因此可以看到国内的几乎没有评论系统的商业用户，加上国内的开发人员很多，大小网站都有自己的一套评论系统，这显然就决定了多说难以转到商业用户的钱。</li>
<li>国内自己搭建个人博客的一般知识层次都不会太差，通常也都会翻墙，多少看得懂英语，与其用多说，很多人更愿意使用 disqus，因此普通用户流量不足，跟无法产生更多的消费用户。</li>
<li>一个模仿者却还没有始祖做的出色，可能多说之前做过一些特色功能，但我很不幸没有看到，至少在体验上面来说除了引入了国内的社交平台授权外，其他无论在界面美观，易用性，功能上面都不如 disqus。未能根据国内用户的习惯进行更多尝试，自身不够优秀的前提下，做再多别的也是枉然。</li>
<li>ZF 压力，由于某些特殊的原因，国内对网民言论等进行了史上最严格的监管，多说本身因为管理经营上比较开放，因此很多为未备案的网站都可以使用多说，而这点无疑是和国情相背的。</li>
</ul>
<h3 id="其他可能"><a href="#其他可能" class="headerlink" title="其他可能"></a>其他可能</h3><p>以下为个人的一些看法，国内评论系统一般为博客用户使用，然而百度等国内网站在搜索文章时往往都很少能够检索到博客中的内容，相反百度文库，百度百科，知乎等等商业网站会排在首位具备更高的曝光度。多说完全在可以在满足市场的前提下，开辟自己的博客/文章导航网站，分类推荐各种文章，可以链接到各个博客或者经过协商授权后，将文章截取归类后重新整理出来，并附上原文链接。然后可以通过广告点击赚钱，当然这种归类的模式有点类似现在比较知名的码字网站简书之类的，但区别在于可以支持更多的私人博客，同时他也可以对小白用户开发，提供在线 markdown 写文，把私人博客内容和无博客在线用户两者结合在一些，同时站内也可以同做一个自己的搜索引擎，专门搜索个人博客和网络博客中的内容。</p>
<blockquote>
<p>参考链接：<br><a href="http://baike.baidu.com/link?url=HUxf8KHqE-r6ah0eo8w9FpAssSFtHcF2rWQEmEhnJlQ-fA0pdp74W4gbV2rHrt-pgN5ci4tzznb5sZZQ4Zj8cndR3COZeeXpEGxRAAsJFyO" target="_blank" rel="external">http://baike.baidu.com/link?url=HUxf8KHqE-r6ah0eo8w9FpAssSFtHcF2rWQEmEhnJlQ-fA0pdp74W4gbV2rHrt-pgN5ci4tzznb5sZZQ4Zj8cndR3COZeeXpEGxRAAsJFyO</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[MCU内/外部启振]]></title>
      <url>http://noparkinghere.top/2017/03/21/2017/2017-03-21-mcu%E5%86%85-%E5%A4%96%E9%83%A8%E5%90%AF%E6%8C%AF/</url>
      <content type="html"><![CDATA[<p>振荡电路相当于 MCU 的心脏，需要为 MCU 提供频率和脉冲，因此一个精准可靠的振荡电路对于 MCU 来说相当重要。</p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>振荡电路一般可以分为：LC振荡器，RC振荡器，晶体振荡器。</p>
<ul>
<li>LC振荡器：LC振荡电路主要用来产生高频正弦信号，一般在1MHz以上。它与RC振荡电路的不同之处在于它由电感和电容组成。所以命名为LC振荡器。</li>
<li>RC振荡器：若用电阻，电容元件组成选频网络，就称为RC振荡器，一般用来产生1Hz-1MHz的低频信号。RC选频网络的选频作用不如LC谐振荡回路，故RC振荡器的波形和稳定度比LC振荡器差。</li>
<li>晶体振荡器：晶体振荡器是指从一块石英晶体上按一定方位角切下薄片（简称为晶片），石英晶体谐振器，简称为石英晶体或晶体、晶振；而在封装内部添加IC组成振荡电路的晶体元件称为晶体振荡器。其产品一般用金属外壳封装，也有用玻璃壳、陶瓷或塑料封装的。</li>
</ul>
<p><em>根据以上三种可以设计出多种不同的电路。</em></p>
<a id="more"></a>
<h3 id="晶振和振子"><a href="#晶振和振子" class="headerlink" title="晶振和振子"></a>晶振和振子</h3><p>晶体全称叫晶体谐振器(crystal resonator)，是一种谐振器，具有压电特性,不能输出信号。</p>
<p>晶振全称叫晶体振荡器(crystal oscillator)，是一种振荡器，振荡电路由晶体、主振有源器件、主振电容等元器件组成，能够输出信号。通常我们所指晶振时往往喜欢用 crystal 其实这是不准确，而国外有的文档却喜欢用 oscillator，一般在表述时，两者其实是一个东西。</p>
<p>MCU 自带的内部振荡器，一般是 RCO （RC-oscillator），而外部配置的振荡电路可以是 RCO （RC-oscillator），也可以是有源晶振 XO（crystal resonator）。</p>
<p>使用RC振荡是电容充放电；而使用晶振振荡时，晶振也是电容性质，它比RC振荡的电流大，如果你摸过正在工作的各种晶振，会发现有些晶振发热，而RC振荡从无发热现象；这在各种单片机中都适用。相对于单片机电路，使用外部晶振更耗电一些，因为外部晶振分为无源和有源，当用有源时，功耗那是明显高的，因为有源外部晶振需要从电源吸取能量。</p>
<p>但使用内部晶振虽然能耗低，但晶振的稳定度和频率控制的都很差，很多都达到了 5% 以上的误差，仅作为不精准的定时简单的使用还可以，稍严格一些的场景都无法满足要求。</p>
<p>使用内部振荡器往往可以配置 RCO 让 MCU 获得某些/某段特定的时钟频率，灵活度更高些；而使用外部晶振的话，一般晶振频率是固定的，MCU 仅能够对该频率进行分频或者倍频。</p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://www.eetrend.com/blog/100024294" target="_blank" rel="external">http://www.eetrend.com/blog/100024294</a><br><a href="https://zhidao.baidu.com/question/464742897.html" target="_blank" rel="external">https://zhidao.baidu.com/question/464742897.html</a><br><a href="http://blog.csdn.net/qq_29350001/article/details/51142250" target="_blank" rel="external">http://blog.csdn.net/qq_29350001/article/details/51142250</a><br><a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E6%8C%AF%E8%8D%A1%E5%99%A8" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E6%8C%AF%E8%8D%A1%E5%99%A8</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[accessport问题总结]]></title>
      <url>http://noparkinghere.top/2017/03/21/2017/2017-03-21-accessport%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AccessPort 是一款用于 PC 机串口(RS232)调试、监控的软件，作用于驱动层之前，可以和其他串口工具同时使用，监控串口的通讯数据。特点：</p>
<ul>
<li>监控串口：具有端口监控功能，可以监控、拦截、保存所收发的数据（ NT/2K/XP/Vista/Win7）。</li>
<li>串口调试：支持常用的串口操作功能，支持大数据量的收发、保存，支持自动发送。</li>
<li>动态变参：在不改变当前所打开端口的情况下，能动态改变端口参数（如：波特率、校验位、流控制等）。</li>
<li>双模编辑：数据发送区内嵌十六进制编辑器（类似 UltraEdit），支持十六进制&lt;=&gt;文本双模式切换编辑，支持 unicode。</li>
<li>国际版本：国际版，支持多国语言。</li>
<li>无需安装：界面友好，方便易用。</li>
</ul>
<a id="more"></a>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>用于串口调试，支持常用的 110-256000 波特率，支持自定义波特率。</li>
<li>能以字符或十六进制接收或发送任何数据，能发送、接收任意大小的文件。</li>
<li>在不改变当前所打开端口的情况下，能动态改变端口参数（如：波特率、校验位、流控<br>制等）。</li>
<li>数据发送区可实时编辑、发送文本数据。</li>
<li>能将所接收的原始数据以及显示数据分别保存。</li>
<li>数据发送区允许设置发送周期，自动发送数据。</li>
<li>可调试的端口范围是 COM1-COM255，支持扩展端口(USB&lt;-&gt;RS232)。</li>
<li>可设置字体、文字颜色、背景颜色。</li>
<li>允许将发送区的数据在接收区回显，模拟终端操作。</li>
<li>允许发送区数据以回车键作为发送操作信号。</li>
<li>Terminal 模式支持自动应答功能，支持 Hex、 Text、浮点数等类型。</li>
<li>Terminal 模式支持预定义数据发送，支持 Hex、 Text、浮点数等类型。</li>
<li>Monitor 模式支持彩色文本显示,便于更好的区分、观察数据.</li>
<li>允许 Monitor 模式下拦截到的数据以十六进制或字符方式显示。</li>
<li>允许接收区在接收到的数据后添加回车字符(CRLF)，便于观察数据。</li>
<li>可将 Terminal 模式下接收到的数据按照十六进制文本方式导出到文件或剪贴板。</li>
<li>允许保存程序环境变量。</li>
<li>定义热键，方便操作。</li>
<li>国际版，支持多国语言。</li>
<li>数据发送区内嵌十六进制编辑器，支持 unicode。</li>
<li>支持串口监控功能，可以监控串口设置以及收发的数据。</li>
<li>在线自动更新提示功能，当有可用新版本时提示用户下载。</li>
<li>本程序线程安全，可以同时启动多个副本调试多个串口。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>AccessPort 通常不作为串口调试工具使用，虽然你也可以直接用该软件来监控串口数据，但一般因为 AccessPort 可以运行在驱动层之上，所以往往我们用 AccessPort 来监控你上位机软件调用驱动的一些操作。AccessPort 本身不会占用串口，因为它不会像其他串口工具一样去进行数据收发，而仅作为监控你驱动层被调用的一种工具。</p>
<p>一般而言需要先开启 AccessPort 的监控功能，然后再开启你的上位机软件，这样 AccessPort 才可以监控你的软件。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>关闭 AccessPort 需要格外的小心，说白了 AccessPort 类似通过某种不合法的途径来获取你正常软件调用驱动时的状态，因此会有系统崩溃蓝屏的风险，注意做好数据备份。</p>
<p>值得注意的是，停止 AccessPort 监控或者关闭该软件时会可能系统崩溃，<strong>一般串口链接了设备，并打开了 AccessPort 启用了该串口时；如果未在 AccessPort 下关闭该串口或者关闭 AccessPort，而直接移除了该串口的外设的话，则会导致系统崩溃，这种情况下即便再接上该设备或关闭 AccessPort 已经无法补救。</strong></p>
<p>这时，你需要注意软件关闭的先后顺序，一般我们可以试下以下几种方法：</p>
<ul>
<li>插入串口/usb 前，关闭 AccessPort 。</li>
<li>拔掉串口/usb 前，关闭 AccessPort 。</li>
<li>先关闭上位机软件串口，再关闭 AccessPort 。</li>
<li>最后移除串口外设。</li>
</ul>
<p>以上几种方式，需要逐一尝试，不同的电脑出现的情况不同，但基本是上面中的某一种/几种情况不会发生系统崩溃，具体原因据称可能是根据你使用的 usb 转串口的驱动（不同的 usb 转换芯片有不同的驱动）有关系。</p>
<p>windows 7 电脑上关闭时步骤：先关闭串口，并退出所有上位机软件，然后 Accessport 停止监控，<strong>最后移除串口外设</strong>。</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[我眼中的写作]]></title>
      <url>http://noparkinghere.top/2017/03/19/2017/2017-03-19-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%86%99%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>大约是一年前，开始搭建自己的博客，然后陆续开始码字，去年写作的题目有大约 80 多个，虽然只完成了大概一半左右，但毕竟刚开始写作算是有个好的开始。一方面个人博客主要写的是技术博客，有的内容自己没有切身实践过也不敢太轻易下结论，而有的内容仍然在不断更新中，因此不可能将所有文章都写完，另外一方面也认识到写作确实算是比较消耗时间的，没有足够的时间很难写出让自己满意的文章。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-19-我眼中的写作/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="写作的内容"><a href="#写作的内容" class="headerlink" title="写作的内容"></a>写作的内容</h3><p>小时候上语文课老师就让大家写日记，写周记，当时一直感觉很痛苦，然而现在让我码字已经不再有这种感觉了，相反很多时候我会觉得时间不够用，加入这个写作训练营很大的成都上是为了每天可以挤出更多的时间，完成之前的一些写作内容，以及可以提高下自己的写作能力。为何年少时找不到素材可写，现在又会有很多东西需要去写呢？最重要的应该是经历，一个孩子每天过着：学校–家，两点一线的生活，周而复始。你设想下，在这样的生活下如何能写出绚烂多彩的日记而不是流水账呢？</p>
<p>每个成年人都有权力选择自己想要的生活的，因此我们完全可以为自己创造条件来经历不一样的自我。例举几个写作题材的例子：</p>
<ul>
<li>如果你今天是骑行了，你可以写一篇文章说明下健身有意身体，骑行让自己有怎样不同体验。视角不同写作内容也不会相同，同样是骑行，因为路上现在有很多租借单车，透过单车你也可以讨论今年单车为何变得越来越火了。</li>
<li>比如你周末心血来潮，学了下几年来一直想学的 PS，你同样可以写个教程，把你做的某个案例总结出来，虽然你可以只是模仿的别人的，但每个人在做的时候必定会有不同，可能某个细节原教程没说的清楚，你可以文章中重点强调下，再比如，你根据原教程，做了些微创意等，也都可以写出来。</li>
<li>出行旅游这个基本不用说，攻略，照片，景点评价基本上人人都可以写出超长的连载文章。</li>
<li>突然对美食有兴趣，周末做了一道菜，同样可以配上图文教程，详细写下步骤，最后总结出优点和不足等等。</li>
<li>工作上的一些问题更是有太多的可写内容，从为人处世到技术难题，从创业心得到失业感想等等。</li>
<li>兴趣爱好永远是写作的最佳话题，对音乐/绘画/电子产品/军事等感兴趣，都可以让你写出独到的见解和十分有价值的内容。</li>
</ul>
<h3 id="写作的意义"><a href="#写作的意义" class="headerlink" title="写作的意义"></a>写作的意义</h3><p>就我个人的观点来说，写作和做其他事情一样，最重要的一点是有意义（或者说有价值），有价值又可以分为两点，对自己有价值或者对他人有价值。</p>
<p>我写文章的主要初衷是记录自己一些工作学习上面的内容，可以说我最本质上写作的目的就是对自己有价值，遇到一个问题，或者解决了一个问题，都会把他记录下来，下次如果再面对这种问题时，可以快速的查阅自己以前总结的文章，类似用文字来代替大脑，帮我做更多详细的记录，通过这些问题我可以提高自己的工作学习效率。</p>
<p>提一下另外一点对他人有价值。我写的文章虽然说初衷是为了帮助自己做知识的管理，但既然发布到网上了，也是希望更多的网友在遇到和我同样问题的时候，能够通过我的文章找到解决办法，少走一些歪路。很多网络作家写小说是希望他人可以得到愉悦，写影评也是希望让别人更懂这部电影或者不让浪费时间看这部电影，类似的例子也是不胜枚举。</p>
<h3 id="回看作品"><a href="#回看作品" class="headerlink" title="回看作品"></a>回看作品</h3><p>每次写完基本上都会回看自己的内容，这样一方面可以修改一些明显的语法字词错误，另外有新的灵感也可以补充一些内容。如果是隔了很久的一篇文章，又有了新发现，需要补充，这时候还会把全文再重新阅读一遍，文章结构上面可能还会重构，甚至会重写。复看的过程很重要，是一个真正提高自己的过程。</p>
<hr>
<p>写作时间：19:50-20:30</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[别人眼中的运动--参考]]></title>
      <url>http://noparkinghere.top/2017/03/18/2017/2017-03-18-%E5%88%AB%E4%BA%BA%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%BF%90%E5%8A%A8-%E5%8F%82%E8%80%83/</url>
      <content type="html"><![CDATA[<p>最近几年越来越多的人将健身看作是头等大事，而保持健康的最佳途径无外乎三点：饮食，作息，运动。因此，国内健身运动也变得越来越火，基本上已经达到了全民健身的地步。本人因为工作原因还有其他内在原因，一直运动较少，最近加入了运动训练营，希望可以养成运动健身的习惯，针对我们运动族的大神<a href="http://www.jianshu.com/u/cbece912d4e9" target="_blank" rel="external">@Janetff</a>进行了一些请教，本文将内容梳理总结下来。</p>
<h3 id="人物介绍"><a href="#人物介绍" class="headerlink" title="人物介绍"></a>人物介绍</h3><ul>
<li>姓名：得姐</li>
<li>坐标：包容性很强的深圳</li>
<li>生日：5.29</li>
<li>职业：永远的学生</li>
<li>擅长领域：运动，营养，迷路</li>
<li>朋友对自己的总结：认真的逗比</li>
<li>今年最想实现的目标：完成西藏尼泊尔深度游</li>
<li>去年有什么值得骄傲的事情：跟自控力lab成长一年，从三分钟热度重度患者成功转型，并通过自身状态影响改变一批人；完成两次全马</li>
<li>进群最想做什么：带领大家养成良好的运动习惯，收获健康，努力过成自己想要的模样</li>
<li>对于运动你想说的是：运动会让你发现不一样的自己</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-18-别人眼中的运动-参考/1.jpg" alt=""></p>
<a id="more"></a>
<p><strong>详细的问题内容如下：</strong></p>
<h3 id="工作日作息安排"><a href="#工作日作息安排" class="headerlink" title="工作日作息安排"></a>工作日作息安排</h3><ul>
<li>5:00-5:30 起床+煮早餐</li>
<li>5:30-6:30 跑步+看书+冥想</li>
<li>6:30-7:30 冲凉，做饭，化妆</li>
<li>7:30-7:50 吃早餐</li>
<li>8:00-8.30 上班途中听书或新闻</li>
<li>8:30-12:00 上午工作时间</li>
<li>12:30 健身房撸铁/看电影+午休</li>
<li>14:30-17:30上班</li>
<li>18:30 吃晚饭</li>
<li>19:30 打拳/听课/应酬</li>
<li>11:30 睡觉（最近正在调整早睡）</li>
</ul>
<h3 id="休息日作息安排"><a href="#休息日作息安排" class="headerlink" title="休息日作息安排"></a>休息日作息安排</h3><ul>
<li>5:30 起床跑步，长距离跑步</li>
<li>8:00 冲凉吃早餐</li>
<li>10:00-15:00 图书馆</li>
<li>16:00 约饭或逛街</li>
</ul>
<p><em>休息日有时候也许会短途城市周边游</em></p>
<h3 id="每天才睡-5-6-小时，会不会睡眠不足"><a href="#每天才睡-5-6-小时，会不会睡眠不足" class="headerlink" title="每天才睡 5/6 小时，会不会睡眠不足"></a>每天才睡 5/6 小时，会不会睡眠不足</h3><p>平时会进行冥想恢复精神，中午也会少量的休息，会在某个特定的周末好好休息一下，但是发现根本睡不了那么多。</p>
<p>笔者注：很多大神都睡眠比较少，有的甚至只睡 3/4 小时，但他们仍然能够每天保持高的工作效率和活力。也许坚持长期健身确实可以比较好的改善你体质，让你不再那么容易疲乏。</p>
<h3 id="减肥健身之前的作息"><a href="#减肥健身之前的作息" class="headerlink" title="减肥健身之前的作息"></a>减肥健身之前的作息</h3><p>一句话：<strong>之前的作息时间是黑白颠倒。</strong></p>
<p>笔者注：通过上文已经可以看出，一个良好的作息对生活的改善有多么重要，改变之前的<a href="http://www.jianshu.com/u/cbece912d4e9" target="_blank" rel="external">@Janetff</a>我见到过，但现在的她绝对是女神级别的，虽然她自称年级大，但我们都比较怀疑她是不是 95 后，甚至 99 年的组友都觉得她比自己小。</p>
<h3 id="改变的缘由"><a href="#改变的缘由" class="headerlink" title="改变的缘由"></a>改变的缘由</h3><p>失恋</p>
<p>笔者注：很多人发生巨大改变会是因为一些事情的刺激，而对于生活如常的普通人，想要做出改变确实可能往往会缺少恒心和毅力，因此做出改变的这一步也许对大多数人是最困难的一步。</p>
<h3 id="现在的生活给自己带来了怎样的改变？"><a href="#现在的生活给自己带来了怎样的改变？" class="headerlink" title="现在的生活给自己带来了怎样的改变？"></a>现在的生活给自己带来了怎样的改变？</h3><p>这样改变的结果就是每天都感觉比别人多活了几个小时，精神状态保持很好，不再乱发脾气，爱上看书。</p>
<h3 id="像我这样的没有运动基础，明年年初想跑半马，如何制定方案"><a href="#像我这样的没有运动基础，明年年初想跑半马，如何制定方案" class="headerlink" title="像我这样的没有运动基础，明年年初想跑半马，如何制定方案"></a>像我这样的没有运动基础，明年年初想跑半马，如何制定方案</h3><p>首先根据自身情况，运动不是一蹴而就的，没有运动基础的话，两三个月就想跑几十公里是很不现实的，将近一年的时间慢慢积累是可行的。零运动基础，之前没有跑过步的话，可以先从快走和慢跑之间切换，开始时，每天跑两公里，跑不动了就换快走，然后周末进行一次三公里的尝试，最开始需要提升一下心肺功能。运动的第一步就是先跑起来，行动起来，再坚持下来，只有行动起来才有可能进行后期的训练。每次跑完后，记录下感觉，我再给你进行后期的调整。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对现代人来说运动可以说是<strong>饮食，作息，运动</strong>三者中最重要的，因为通过运动我们可以调整作息，通过运动我们可以改善饮食习惯。我也亲眼所见周围有不少人因为运动让自己改变了多年的恶习，精神面貌也越来越好了，因此下一步在我脚肌肉拉伤恢复后，就准备行动起来了，希望来年这个时候，我也可以真正成为运动族的一员。</p>
<hr>
<p>写作时间：20:36-21:47</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[英语表述问答]]></title>
      <url>http://noparkinghere.top/2017/03/17/2017/2017-03-17-%E8%8B%B1%E8%AF%AD%E8%A1%A8%E8%BF%B0%E9%97%AE%E7%AD%94/</url>
      <content type="html"><![CDATA[<p>本内容的主要出处是扇贝的<a href="https://www.shanbay.com/web/ask/answers/" target="_blank" rel="external">你问我答</a>。</p>
<h3 id="“at-the-eleventh-hour”居然不是“在十一点”的意思？"><a href="#“at-the-eleventh-hour”居然不是“在十一点”的意思？" class="headerlink" title="“at the eleventh hour”居然不是“在十一点”的意思？"></a>“at the eleventh hour”居然不是“在十一点”的意思？</h3><p>“the eleventh hour”指的是“最后关头；最后时刻”，所以“at the eleventh hour”表示“在最后的关头”，真的不是“在十一点”的意思啦！比如，“At the eleventh hour, the hero appeared and saved the life of the heroine.”就是“在最后时刻，男主角出现，救了女主角”的意思。</p>
<h3 id="你知道“张三李四”怎么说吗？"><a href="#你知道“张三李四”怎么说吗？" class="headerlink" title="你知道“张三李四”怎么说吗？"></a>你知道“张三李四”怎么说吗？</h3><p>中文里的“张三”“李四”都是假设的名字，表示“无关紧要的人；普通人”，而“Tom”“Dick”“Harry”在英语文化里，都是极其常见的男性名字，三个名字连在一起“Tom, Dick, and/or Harry”就可以表示“普通人；随便什么人”，和中文的“张三李四”十分契合。比如，“This painting is not for every Tom, Dick and Harry.”就是说“这幅画曲高和寡，不是随便什么张三李四都看得懂”的意思。</p>
<h3 id="你知道“紫色”为何高贵吗？"><a href="#你知道“紫色”为何高贵吗？" class="headerlink" title="你知道“紫色”为何高贵吗？"></a>你知道“紫色”为何高贵吗？</h3><p>在古代，紫色染料提取自一种珍贵的海螺，这种海螺数量稀少，加上整个制作工艺非常繁琐，所以，紫色布料十分昂贵，成为权力和财富的代名词以及皇家王室的特供。“born to the purple”就表示“出身皇室”。很好，高贵端庄优雅矜持，我想我要开始喜欢紫色了～</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[健康饮食]]></title>
      <url>http://noparkinghere.top/2017/03/16/2017/2017-03-16-%E5%81%A5%E5%BA%B7%E9%A5%AE%E9%A3%9F/</url>
      <content type="html"><![CDATA[<p><em>本文内容，来自今晚听的荔枝微课，是由得姐传授的健康饮食经验，总结下来的笔记。</em></p>
<p>每个人体质不同，有些人吃多少都不会胖，相反他们还需要增肥，而有的人一吃就会胖，需要不断地节制。</p>
<h3 id="肥胖原因"><a href="#肥胖原因" class="headerlink" title="肥胖原因"></a>肥胖原因</h3><p>现在人的肥胖有各种原因，懒惰，吃货，出差，不愿浪费粮食等等。</p>
<h4 id="多出来的那一口"><a href="#多出来的那一口" class="headerlink" title="多出来的那一口"></a>多出来的那一口</h4><p>不愿浪费粮食，多出了的一口饭往往最后会强撑着吃下去，这个会是生活中很多人一条比较常见的习惯，虽然是小习惯，但往往我们很多人会每次吃饭都多出来那一部分，每次都不舍得扔掉，然后强行塞给已经吃饱了的胃，而健康饮食的过程中很多人是一般不会吃的完全饱的，更何况是你吃多出来的那一口呢？！而往往很多人，因为这几毛钱多出来的那一口，日积月累多长出了几十斤的肉，然后又由于各种肥胖病，由不得不去健身，去找教练，这一去都是几千块，真所谓得不偿失。</p>
<p>这边并不是提倡浪费粮食，你能够做到做的和吃的刚好均衡这样是最好的。而事实上，我们很难把握这个度数，往往做一顿饭并不只会你一个人吃，所以经常会做多，往往我们抱着这种思想，多了可以留到下一顿，但事实是我们毫无节制的拼命吃，最后多了并不多，然后就思索当然的认为多一点大家分了吧。</p>
<p>每顿饭，我们宁可少做，别多做，现代人并非像过去人，因为各种原因，所有必须要多吃，比如：需要付出大量的体力劳动吃饱了才有力气干活，这顿不吃没准就没有下一顿了等等。现代人往往都会实物过剩，因此我们每顿可以做出尽可能少的食物，虽然你没有吃饱，但你绝对不饿，而且健康的饮食就是保持 7 分饱的程度，另外长时间保持这种饮食习惯，久而久之也会让你的饭量随之而减少。最后，健康饮食是提倡多顿少量，如果你正餐没能吃饱，之后也可能通过水果饼干等补充体力。</p>
<a id="more"></a>
<h4 id="基因因素"><a href="#基因因素" class="headerlink" title="基因因素"></a>基因因素</h4><p>脂肪易储存这是由人类祖先决定，在食物匮乏的时代，让能够储存脂肪的人更加容易活下来，因为大量的脂肪存储不仅可以抵御寒冷，而且在没有食物的时间可以幸存到下次捕猎。</p>
<p>女性比男性更容易长胖，也是由基因间接决定，通常来说，女性普遍比较偏静，而男性偏动，因此在摄入同样多的能量时，男性同胞往往可以比女性燃烧更多的脂肪，因此会稍瘦于女性。</p>
<p>谈到基因问题的时候，我们首先要正视自己肥胖的问题，首先肥胖并非不正常的，而恰恰相反，你吃多少能够存储多少，这正证明了你惊人的生存力，只是时代不一样了，这个时代不缺乏粮食，而我们以瘦为美，因此我们需要和自己的身体做斗争，为了不让脂肪可以存储下来，我们一般可以通过两点：1.摄取更加少量的食物。2.让脂肪燃烧掉。而这两点一般就是我们所指的健康减肥。</p>
<p>其他因素这边就不一一累述。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>网络有很多减肥：21 天减肥法，苹果减肥法，段餐减肥法等等，且很多不负责网站会各种标题党，让你误以为真。我们需要做的就是总结经验，找到一种适合自己的饮食方法和训练方案，无论是减肥还是增肌，一定要拥有一个健康的饮食结构。欲速则不达，你越快的减肥，身体越会表达不满。</p>
<p>人体的三大能量物质：蛋白质，碳水化合物和脂肪，这边大家上生物课都听过，就不对这三种物质做详细解释。</p>
<p>碳水化合物选择：低 GI （血糖生成指数）食物为主，如：多吃红豆，全麦粉，玉米，紫薯，土豆等，减脂的朋友多吃粗粮瘦肉代替粳米和五花肉。低 GI 食物在胃中消化慢，不容易被吸收，血糖不容易升高，不容易饿。虽然碳水化合物对肥胖有很大的影响，但健康饮食不能断粮，人体大脑需要他们来提供能量，没有他们你会无精打采失去健康，我们只需要杜绝添加剂和外加糖即可。如果每 100g 食物中，糖超过 15g 则属于高糖食物，工作学习很容易糖超标，限制糖的摄入量是减肥的关键。</p>
<p>蛋白质：蛋白质并不能给人体供能，但是能够提供 20 多种氨基酸，蛋白质不会引起血糖波动，但会帮助人体新陈代谢，需要注意选择优质蛋白和烹饪方式，减脂远离油炸食品。</p>
<p>脂肪：脂肪可以分为：饱和脂肪，不饱和脂肪。饱和脂肪主要来自动物的肉和内脏，日常生活中难免摄入饱和脂肪，但可以尽量少用食用油，不饱和脂肪来自于干果，鱼类，对心血管有利，反式脂肪也属于不饱和脂肪，但对人体有害，减肥一定要戒除甜品，奶油等。饱和脂肪过高容易造成动脉堵塞，一份中份爆米花的饱和脂肪 &gt;  培根+鸡蛋+巨无霸汉堡+牛排。脂肪推荐：橄榄油，花生油，椰子油，核桃，鱼油胶囊，杏仁等。</p>
<p>具体摄入量为多少，男性为两份下图，女性为一份下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-16-健康饮食/1.jpg" alt=""></p>
<ul>
<li>手掌决定蛋白质分量</li>
<li>拳头决定蔬菜分量</li>
<li>手掌环形区域决定碳水化合物的分量</li>
<li>大拇指决定脂肪分量</li>
</ul>
<h3 id="餐饮"><a href="#餐饮" class="headerlink" title="餐饮"></a>餐饮</h3><p>早餐：粥/无糖豆浆+玉米/鸡蛋+苹果</p>
<p>应酬餐：保持理性，少动筷子多聊天，先喝汤，再吃粥，然后蔬菜，最后吃肉。一口肉三口菜，先吃容易消化的物品，一半以上的菜多吃凉拌清蒸少油，不点或者少点煎炸菜品，用汤水代替碳酸饮料。点餐可以不推脱先点自己能吃的热量少的菜，再由别人点餐，免得没有东西可以吃。</p>
<h3 id="增重增肌"><a href="#增重增肌" class="headerlink" title="增重增肌"></a>增重增肌</h3><p>多吃复合类的碳水化合物，如：米饭，面条，麦片，玉米，红薯，足够蛋白质，如：牛肉，鱼虾等营养价值高的东西，可以选择小吃多餐，每天 4-6 顿。除了注意饮食一定要注意训练，增肌，需要做力量训练，减少消耗比价大的有氧运动。</p>
<h3 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h3><p>讲究营养和健身锻炼的目的，保证营养平衡，优先选择热量低营养含量高的食物，坚持以粗，素，淡，果和蔬菜为主的杂粮的方式，而且少吃经过腌，熏，炸，烤的食物，食物经过加工的越多，营养破坏越多。</p>
<p>进食时间，控制在 15-20 分钟左右，食物细嚼慢咽。学会看营养成分表，不吃多糖多盐的食物。</p>
<p>空腹晨跑，身体素质不好不要轻易尝试，建议服用氨基酸，保护肌肉，提高基础代谢。</p>
<p>运动前后如何吃，运动前 1h-1.5h 少吃点，刚吃饱至少留 0.5h 消化时间，少喝水和太多纤维，否则容易胃胀和肌肉抽筋。运动后要补充碳水化合物做补充。</p>
<p>长期健康的关键：均衡饮食，定期运动，乐观心态，充足睡眠，足够水分。切勿急功近利，循序渐进的塑身。</p>
<hr>
<p>文章由于听的是语音，很多内容和图片整理起来太过繁琐，且个人没有运动基础，不怎么会归类。详细内容可以咨询 @<a href="http://www.jianshu.com/u/cbece912d4e9" target="_blank" rel="external">Janetff</a></p>
<p>写作时间：20:30-22:30</p>
<p>To be continued…</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[新版射雕英雄传有多好，现在的电视剧就有多烂]]></title>
      <url>http://noparkinghere.top/2017/03/14/2017/2017-03-14-%E6%96%B0%E7%89%88%E5%B0%84%E9%9B%95%E8%8B%B1%E9%9B%84%E4%BC%A0%E6%9C%89%E5%A4%9A%E5%A5%BD%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%94%B5%E8%A7%86%E5%89%A7%E5%B0%B1%E6%9C%89%E5%A4%9A%E7%83%82/</url>
      <content type="html"><![CDATA[<p>今年年初的时候看了某网站的独播剧，新版《射雕英雄传》，当时看了几集感觉还可以，，上周末休息，一下子看了接下来的几集，总的来说对这个片子影响不错，剧情比较遵从原著，内容详实，道具场景不敷衍，打斗场景也还看得过去，里面随便一个配角都是老戏骨，演的也都是代入感强可圈可点。主角黄蓉，演的确实算是这么多版黄蓉里面绝对可以名列前茅的，郭靖演的还行，但没啥亮点。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-14-新版射雕英雄传有多好，现在的电视剧就有多烂/1.jpg" alt=""></p>
<p>如果你觉得本文是要推销这部电视剧，那你就大错特错了，本文是要通过这部剧来说下目前中国的影视作品。说实在的，我上一次完整看的新版国产电视剧应该是搜狐的自制剧《无心法师》，差不多也是一两年前的作品了，该部电视剧也算是良心作品。回想起来这两年其实国产电视剧一直爆发着惊人的产量，然而这个质量嘛，我也就呵呵了。</p>
<a id="more"></a>
<p>首先说下前段时间比较火的《三生三世十里桃花》，为了有始有终，这部电视剧完整的看了第一集和最后一集，中间别人在看的时候拐了两眼。当看完第一集的时候，我当时发了一个状态吐槽了下，而事实确实是我看完第一集后就默默地关了视频，重新将 10 年前的《风云1》拿出来看了一遍，差不多过年期间将《风云1》完整的看一遍。以前没有发现现在电视剧和过去的差距，看完《风云1》之后发现电视剧塑造的每个人物的形象性格都是有缘由的，人物的选择命运等等都有着很强的相关性，剧情的逻辑性前后联系也很紧密，没有莫名其妙的剧情，人物的武功境界也都是循序渐进能够看出每个人之间的差别差距，通过努力之后的进步。</p>
<p>而反观现在的电视剧，从《三生三世十里桃花》开始，第一个场景，某女 VS 某男，这也能算是神仙？就这种比逗？导演组这是在逗我吗？90 年代的《天龙八部》都比这个有气势的多。再来看下去年的《诛仙》，男主角无脑开挂，每次一发怒就爆表，每次打斗都只用一下，每次都没看出他哪儿有进步。《花千骨》里面的虫子是从《蓝猫淘气三千问》里面跑出来的吧？</p>
<p>当然利益驱动是很能够理解的，虽然导演组也知道拍的剧情很脑残，无内涵，模板都用烂了，明星又涨价了，哪有钱做特效哇？还得花钱打广告呢，花钱开发手游呢。通过上述种种，我们不难发现为何现在的演员都演成面瘫了，现在的特效为啥都是5毛钱的了。</p>
<p>说到模板我们由不得不提现在现在主流模板剧情了，如果你是一个电视剧导演，但如果你连玛丽苏的模板格式都不能够信手拈来，那估计在影视圈都是没有立足之地的。我们可以说下常用的玛丽苏模板形式：单纯萌新女主出厂–&gt;恋上绝壁厉害的男主–&gt;女主因傻白甜被多名”优秀”的男同胞爱慕–&gt;万恶的女二千方百计迫害女主–&gt;多名男配为女主赴汤蹈火，但女主只钟情男主–&gt;女主被女二迫害后，突然变得强大，反过来干掉了女二–&gt;男女主历经坎坷，中间尽可能多的赚泪点–&gt;最终男女主走在了一起，过上神仙眷侣的日子。</p>
<p>由于通过大数据的分析，各方面统计，目前 75% 以上泡剧的都为女性同胞，而男性大都看电影，玩游戏等等，所以不能看出为了博取绝大多数的用户需求，各大导演苦练玛丽苏技能，期待有着一日能够拿出自己的玛丽苏代表作品，而这些剧情中间尤以《花千骨》，《三生三世十里桃花》最为出名，当然早期的《甄嬛传》等也可以归类为这种作品，但毕竟那时模板尚未成型，且该剧在当时还有部分亮点的。</p>
<p>除了玛丽苏的模板，小鲜肉也算是一个广大女性同步喜爱的模板，该作品的影子就更是随处可见了，且使用门槛更低，这边就不做剧情陈述。</p>
<p>目前电视剧虽然产量众多，但每年值得一看的太少，很多用户也渐渐的发现现在国产动漫的层次都会比电视剧深刻不少，画质，内涵，声优等等也都迎来了前所未有的高质量，这边不得不为国产电视剧默哀三分钟。</p>
<p>回到这部电视剧，其实新版《射雕英雄传》放在 5 年以前，并不能算是一部优秀的电视剧，甚至很多人会很不屑这样的翻拍片，许多人哼之以鼻，一天到晚翻拍有意思吗？然而怎么也想不到 5 年以后的今天很多人却也会津津有味看着翻拍剧，只因为看遍热播电视剧却发现实在没有一个能够看得下去的，能够不是看了第一集就可以猜出结尾的。</p>
<hr>
<p>写作时间：21:10-22:33</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力lab周总结]]></title>
      <url>http://noparkinghere.top/2017/03/13/2017/2017-03-13-%E8%87%AA%E6%8E%A7%E5%8A%9Blab%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>参加自控力lab训练营有了两周时间，也完成了十多篇的文章，总的来说有所进步，目前完成任务包括：每日英语学习，写作，锻炼。仅是这些的话，之前一个星期就已经能够做到，但由于作息时间不当，很多事情完成的不够好，甚至形成了恶性循环，这周部分内容还是有所改善的。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>目前每天的任务基本可以比较好的完成，且这周将 seven 运动的时间提前了，这样夜间不会再仓促了。写作效率等方面有了显著的提高，基本可以控制一篇文章从理清思路到完成在 1h 之内，一些不需要查找资料的甚至半小时内可以完成。作息时间刚刚开始起步，希望可以坚持做到早上完成单词新闻等的学习，不将英语学习留到晚上。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>时间没能够得到充分有效的利用，很多时候，尤其是晚上没能很好的把握时间，事实每晚至少还是可以抽出 1h 以上的时间学习研究的，但往往都会浪费不少的时间摸手机，或者无目的地闲逛网页。下阶段会增加时间的有效利用率，可以考虑加入番茄工作法等，另外杜绝摸手机的习惯。</p>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>参加训练营之初，是写过计划的，现在会对最终目标进行些调整：</p>
<ul>
<li>6:30 左右 前起床</li>
<li>6:30-7:00 晨练等内容，买早餐</li>
<li>7:00-8:00 扇贝英语的学习，单词，听力，新闻等</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-17:20 在线英语学习</li>
<li>17:20-18:00/18:20 阅读推荐书籍</li>
<li>18:00/18:20-19:00 晚餐、散步时间</li>
<li>19:00-21:30 自我学习时间，完成相应学习计划</li>
<li>21:40-22:40 将时间尽量控制的短</li>
<li>23:00 左右入睡</li>
</ul>
<hr>
<p>写作时间：19:50-20:32，9:30-10:00，总时长超过一个半小时。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[影评-盛开的樱花林下]]></title>
      <url>http://noparkinghere.top/2017/03/12/2017/2017-03-12-%E5%BD%B1%E8%AF%84-%E7%9B%9B%E5%BC%80%E7%9A%84%E6%A8%B1%E8%8A%B1%E6%9E%97%E4%B8%8B/</url>
      <content type="html"><![CDATA[<p>同样这部动漫也是受简书笔友 @见月酱 毒害推荐，说实在的这个动漫相当难找，百度百科只介绍了这本小说，并附带了提及有该小说的动漫电影，却没有对电影做任何的介绍，而豆瓣上面也只能搜到这本小说，对电影也为做提及。通过多次查找，最终通过某网盘搜索引擎搜到了该视频。</p>
<p>完整的分上下两章看完了这部电影/视频，看完后最大的感受就是乱入和故弄玄虚。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-12-影评-盛开的樱花林下/1.jpg" alt=""></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>山贼本身还算善良的，只抢钱财不杀人，但意外之下杀了人抢了一个女人。 那女人先用背自己，捡发簪开始试探山贼，通过种种事情山贼被该女人操纵了，开始犯道德上的错误，他杀那堆老婆，不过这样也越来越接近那个女人了，这个山贼虽然还保有一丝心灵不安，但是这个来自未知世界的女人对他来讲诱惑力太大了，女人让他们一起去了京城，进一步，又诱惑山贼去杀人，每天山贼通过杀人，带人头回来来取悦该女人。在京城的一段时间，山贼慢慢了解了未知的事实，发现不是那么回事，想要回到山林，结果女人还是利用了他的无防范，准备先安抚再作打算。视频埋下伏笔，女人留条子给野猪妹说“我很快会回来”。但是偶尔路经山贼最害怕的樱花树下 正值落英缤纷，在接天接地自然野生而存在的男主所掌控的世界，这突然而现的妖艳樱花绝对是山林间很奇怪的存在。让男人突然意识到女人是个妖怪，然后在樱花树下将女人给掐死了。</p>
<a id="more"></a>
<h3 id="乱入"><a href="#乱入" class="headerlink" title="乱入"></a>乱入</h3><p>该电影是一部以古代日本为题材的作品，但中间为了搞怪，卖萌和轻松，会穿插许多现代设备，如耳机，手机，照片等等，让人看的尴尬症都犯了。全剧情本身是投入着血腥诡异的特点的，但中间往往喜欢突然插入这种搞怪的元素，未免让我感觉是不是入错了片场。</p>
<h3 id="故作玄虚"><a href="#故作玄虚" class="headerlink" title="故作玄虚"></a>故作玄虚</h3><p>电影的前面整个内容还可以看，虽然说有点血腥暴力重口味，但至少主线内容还能够体现是一个一身武艺的乡野村夫被一个腹黑女调教成了刽子手。结局的剧情就很诡异了，让人感觉是强行要和樱花扯上关系，山贼每次遇到樱花都会无缘无故的恐惧这本身作品中就没有交代清楚，最后一场樱花树下的镜头更是特意混淆观众，留下了三组镜头，伴随着三种可能的结局：</p>
<ol>
<li>樱花树下，男人清楚的认识，原来女人是女鬼，于是把女人掐死了。</li>
<li>女人被山贼掐死后，男人发现是自己惧怕樱花产生了幻觉，把自己爱的女人当成女鬼给掐死了。</li>
<li>最后一幕镜头是只有男人一个人倒在樱花树下，也可以想成，男人产生了幻觉，实际上自己被女人给弄死在了樱花树下。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>据说电影是为了透露樱花不仅仅是表现浪漫，在古代樱花往往显现着血腥诡异等，但总的来说，该作品三观不正，主线混乱，没有给出一个完整值得一看的剧情和主题，不推荐去看，当然你也未必能够找得到片源。</p>
<hr>
<p>写作时间：20:30-21:05</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[透过分时租赁车看未来的交通]]></title>
      <url>http://noparkinghere.top/2017/03/11/2017/2017-03-11-%E9%80%8F%E8%BF%87%E5%88%86%E6%97%B6%E7%A7%9F%E8%B5%81%E8%BD%A6%E7%9C%8B%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BA%A4%E9%80%9A/</url>
      <content type="html"><![CDATA[<p>最近几个月共享交通工具都特别火热，无论是共享汽车还是共享单车都焕发着蓬勃生机。先不说用户对这些共享交通工具的看法，仅是减少私家车使用，鼓励人们绿色出行，以及资本市场的认可，政府的支持等等就可以看出，共享出行这块虽然刚刚起步，但还是有很大的市场环境的。</p>
<p>今天同事办了一张分时租赁的汽车卡，带我一起去体验了把。关于汽车的具体信息，办理手续等等我了解的不是太清楚，这边仅仅就我知道的一些做个说明，租赁大概分为以下步骤：</p>
<ul>
<li>手机 APP 就附近或者指定地点查找汽车，如果有的话，可以选择一辆你要预约的汽车，APP 上面会有汽车的相关信息。</li>
<li>到达汽车附近，仔细查看你的车，有没有什么损坏或者问题。</li>
<li>将充电电源拔掉，外部刷卡（类似ETC），提车。</li>
<li>自己驾驶出行，费用为 30元/h，按照分钟进行计费，0.5元/min。</li>
<li>还车，需要按照指定要求，例如关闭发动机，关闭车灯，接上充电桩，手机 APP 检测通过方还车成功。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-11-透过分时租赁车看未来的交通/1.jpg" alt="timg.jpg"></p>
<h3 id="个人体验"><a href="#个人体验" class="headerlink" title="个人体验"></a>个人体验</h3><h4 id="快"><a href="#快" class="headerlink" title="快"></a>快</h4><p>快可以有两点说明，一个是预约方便，拿车快；另一个是纯电动汽车，速度快。就驾驶体验而言，这个车还是感觉可以的，抛开外观等其他因素，仅汽车行驶而言，体验可以达到 15 万左右的汽车级别。虽然车身比一般两厢的车还要少不少，但因为是纯电动的汽车，车前身可以节省不少的空间，因此车厢乘坐空间还是很宽裕的，中控全触摸屏，手刹等也全都是电子控制。另外驾驶速度快，驾驶过程安静无声，给汽车的体验可以说加分不少。</p>
<h4 id="繁"><a href="#繁" class="headerlink" title="繁"></a>繁</h4><p>借车方便，开车和还车不易，这方面主要还是全自动话没有管控原因，对于没用过这个车的人，第一次入手而且还是电动汽车，刚上来你就不知道如何解锁，然后解锁晚，不仔细阅读说明书，你不知道手刹的按钮在哪儿，手刹松开还要二次启动等等，虽然中控做的很智能现代化，但对于开惯老式车的人无疑还是有个适应过程的，而这个过程往往缺少专人指点。由于汽车是联网监控的，还车时，如果你运气不好，也会花不少时间，多项检测指标，检测不通过，你得反复启动尝试才行。</p>
<h4 id="乱"><a href="#乱" class="headerlink" title="乱"></a>乱</h4><p>乱可以体现在很多地方，首先是租赁汽车，前一个使用者可能会把车子弄得一团糟，其次，还车地点也乱，APP 好不容易查到一个还车点，结果发现是被私人或者单位占领了，比如某企业合作，或者在公安局里面，且这些地方保安都不让你停进去。最后一点，就是车子存在违规违章损坏等等可能引起的纠纷实际很难落实到位，很多开这个车的，可能只有驾照很少开车，这就存在安全隐患，其次，车辆缺少监管措施，很可能还存在无证驾驶的情况。</p>
<h3 id="预见"><a href="#预见" class="headerlink" title="预见"></a>预见</h3><p>现在，由于私家车越来越多，城市建设跟不上，可用停车位明显不足，大量机动车的使用，也带来了很多的安全隐患，而共享出行恰恰可以解决这些问题，虽然刚刚起步，仍然存在诸多的不足，但随着几个核心技术的成熟和发展，在未来几年内，可能会成为我们出行的一种主流方式。</p>
<p>共享出行，可以说是一整套的解决方案，至少会包括：监控，无人驾驶，线下维护，网络分析调度等等。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-11-透过分时租赁车看未来的交通/2.jpg" alt="timg.jpg"></p>
<p>我们可以设想以下，在未来的某一天，我们准备出门时，只需要打开智能设备，提前预约一辆车到楼下，通过控制中心的调度，根据你的时间，会安排附近有空闲时间的一辆车自动开到你的出发地点，你看到车后，直接可以上车，出发，无人驾驶系统，会将你准确的送到目的地，如果你采取慢行模式（价格更加便宜，允许中途载人），汽车会中途载其他乘客，到达目的地后，你直接下车， APP 自动付费。共享汽车接送完所有乘客后，发现有一个故障，会关闭接客服务，自动到最近维修点去维护。维护完成后继续工作，已经进入夜晚，需要用车已经不是那么多，大部分车驶入郊区维护充电，为城市节省资源和空间；少部分车继续在各个街道巡逻，为乘客提供及时的便捷服务。</p>
<hr>
<p>写作时间：21:05-22:15</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[PDF内容获取]]></title>
      <url>http://noparkinghere.top/2017/03/08/2017/2017-03-08-pdf%E5%86%85%E5%AE%B9%E8%8E%B7%E5%8F%96/</url>
      <content type="html"><![CDATA[<p>其实 PDF 转 word 已经不算是什么新兴技术了，大约 10 年左右的时候，我在网上通过一些本地转换工具/在线转换工具，以及汉王OCR等软件，就已经可以把 PDF 导成 word 或者获取 PDF 文件中的绝大多数内容了。而随着软件技术的不断发展，最近的一些新兴软件在转换效率等上面也做的越来越出色，目前大多数的 PDF 文档几乎都可以完美转换成 word 格式。</p>
<p>在正文之前，首先安利一个 PDF 软件，国内出名的算是<strong>福昕阅读器</strong>了，该软件的特点就是速度快，占用资源少，功能多（虽然他也有很多缺点，但和同类 PDF 软件比已经可以甩开别人好几条街了）。这边就 PDF 中的内容获取，我们可以分为三类，以下针对他们也会一一详细介绍。</p>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p>并不是每个人都需要获取 PDF 文件中全部内容的，很多时候我们在阅读一个 PDF 文档时，也许只是需要摘录他的一句话，或者获取一小段文字。这个时候往往可以在 PDF 中直接选中这段文字，右击或使用快捷键复制。但往往有些人会特意为难我们，他们会在自己的 PDF 文件上面进行加密，让你只能阅读文件，却没法对文件内容进行任何复制，标注等操作。如果遇到这种问题，可以使用我这边提供的一个小工具，<a href="https://pan.baidu.com/s/1qY6RaSc" target="_blank" rel="external">pdfunlocker</a>，如果无法解密，可以去找新版的软件。。</p>
<p>这边介绍两个比较好用的 PDF 小工具：<a href="https://pan.baidu.com/s/1o8Gy34A" target="_blank" rel="external">FreePic2Pdf+PdgCntEditor</a>。解锁后的文件很多会丢失目录，可以通过软件 PdgCntEditor 获取文档目录编辑。同时 FreePic2Pdf 软件（批量将图片导出成 PDF 文档）可以和 PdgCntEditor 一起使用，</p>
<a id="more"></a>
<h3 id="文字转成-word"><a href="#文字转成-word" class="headerlink" title="文字转成 word"></a>文字转成 word</h3><p>虽然计算机发展了很多年，但仍然有不少人会使用 word 来进行排版和编辑。他们也希望所有获得的文档都是 word 类格式（包括 .doc .docx等等）的，这样他们就可以对文档中的内容进行任意的增删改查了，虽然说 PDF 出现就是为了规范格式，让一般人无法轻易的对其中的内容做修改，但仍然有很多人乐此不疲的想这么做。PDF 转 word 的软件可以说是相当繁多且良莠不齐，这边我们只推荐一款： PDF-to-Word 该软件网上很容易找到，这边就不给出链接了，当然其他还有很多可以将 PDF 转成 word 的工具，如在线网站 <a href="https://smallpdf.com/pdf-to-word" target="_blank" rel="external">smallpdf</a>， <a href="https://www.pdftoword.com/" target="_blank" rel="external">nitropdf</a>等等。</p>
<h3 id="图片转-word"><a href="#图片转-word" class="headerlink" title="图片转 word"></a>图片转 word</h3><p>并不是所有的 PDF 都可以轻易转成 word，以上那类 PDF 转 word 的软件，很多都只适用于文字的转换，换言之，就是本来文字内容你就是可以选择的，软件要做的只是讲文字内容自动复制出来，进行重新排版，然后生成 word 文件给你看。但现在很多 PDF 文件的内容都不是文字格式的，很多内容是扫描件，或者是手工拍的照片，更有胜者将文字转成了图片在导入到 PDF 中。这些无疑都增加了你导出内容的难度，然而，这些问题也只能难道过去你的，对 OCR 技术如此成熟的今天，只要不是手写内容，基本上都可以 100% 的识别出来。下面我们介绍下几款这种软件：</p>
<ul>
<li>汉王 OCR：好像是 05 的一款软件，国内比较早涉及这款领域的一个软件，识别率不是很高，但也基本可以识别，优点是不要联网，可以离线直接使用。</li>
<li>Google drive：你可以把 Google 邮箱中的内容直接通过 Google drive 打开，右击 PDF 用 word 打开，然后你会惊奇的发现，PDF 中图片的内容已经变成了可以编辑的文字了。目前而言，Google drive 中的 PDF 插件是用户体验最好的一种方式，几乎可以满足所有的 PDF 转 word 编辑，然而使用该服务需要联网，因此你需要科学上网。</li>
<li>oneNote：Microsoft office 全家桶中的一员大将，oneNote 中自带 OCR 功能，你可以在插入中找到找到它，这个软件 windows 7 中好像是没有的，其他最新系统到底面不免费就不得而知了。</li>
<li>WPS：该软件大家应该也比较熟悉，算是国内 office 软件的霸主了。用 WPS 打开你的 PDF 文档，最上方就会出现 word 转 pdf 的选项，以及图片转文字功能，对于辨识度较高的图片常规读取里面的内容是没问题，但该功能算是 WPS 的一个增值服务，如果需要转成 word 或者识别度好，则是需要会员服务的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上这些软件都是一看就会用的软件，这边不再具体给出软件的教程，如有疑问可以自己多尝试，或者直接网络搜索。</p>
<hr>
<p>写作时间：21:00-22:08</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[输出均匀的PWM脉冲]]></title>
      <url>http://noparkinghere.top/2017/03/08/2017/2017-03-08-%E8%BE%93%E5%87%BA%E5%9D%87%E5%8C%80%E7%9A%84pwm%E8%84%89%E5%86%B2/</url>
      <content type="html"><![CDATA[<p>PWM 脉冲输出方式千奇百怪，这边主要是要求两点：</p>
<ul>
<li>输出指定个数的 PWM 脉冲</li>
<li>让指定个数的 PWM 脉冲，尽可能均匀的分布在一定的时间内。</li>
</ul>
<p>首先假设 1s 内需要输出 n 个脉冲（n &lt; 100，且 n 是个变量），需要在 1s 内让这 n 个脉冲尽可能均匀的分布，这边提供 3 种解决方法，供参考。</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>不需要提前计算好下 1s 需要输出的脉冲个数，而是每个 PWM 中断都进行一次判断，判断是否需在下个中断时间内输出脉冲。优点是反应迅速，方法简单，且能够输出均匀的脉冲；缺点是，仅脉冲输出就会占用 CPU 较多的资源。</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><strong>上一个时间 1s 计算好在下一个时间 1s 需要打出的脉冲个数，然后在下一个时间 1s 内，让 n 个脉冲，不断的改变脉冲的周期，但是保持占空比 50% 且始终均匀分布。</strong>每次需要发送脉冲时，重新设定 PWM 的参数，这边占空比可以固定为 50%，但周期需要更改，如脉冲变为 20， 则周期就设定为 50ms，这样的好处是操作起来简单灵活，每次需要发送脉冲时，直接修改 PWM 占空比，然后重启开启定时器，但存在问题是 PWM 设置和开启需要一定的时间，无法确保 1s 内一定能够把脉冲输出完毕。当然我们可以通过进一步缩短周期时间，如需要产生 20 个脉冲，我们可以将周期设置为 45ms，这样在 900ms 内一定可以将脉冲输出完毕。这样缺失算是基本上解决这类问题了，但如果你的系统对时间进度要求较高的话，你的 PWM 定时器和程序执行的定时器很难做到同步。</p>
<p>这边提供另外一种思路，我们采用 PWM 定时器，来完成整个程序周期的调度，例如，我们设定 PWM 周期为 10ms ，然后通过 PWM 定时 100 个周期，进行一次主程序的扫描（1s），这样的话，主程序和脉冲输出就可以做到完全的同步了。以下两种方法，都是基于这种时钟基础做的操作。</p>
<a id="more"></a>
<h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p><strong>上一个时间 1s 计算好在下一个时间 1s 需要打出的脉冲个数，在下一个时间 1s 内，打出固定频率的脉冲，为了保持均匀，将脉冲分为几段输出。</strong>首先我们确定了 PWM 周期是 10ms，我们可以将 1s 这个时间片进一步划分，分成 20 个 50ms，在这 50ms 中，让每次打出一定数量的脉冲个数，例如，80个脉冲，则每个 50ms 需要输出 4 个脉冲，因为 PWM 周期是 10ms，所以这边输出的 4 个脉冲会占据 50ms 的前 40ms，这样看起来也基本算是分散的比较均匀了。进行这种处理时，需要注意的是余数，如 99 这个的余数，我们需要认为的通过算法，讲余数均匀的插入到，每个点后面。这种方法，同样是存在某些缺点的，缺点是需要把时间片分的比较细，如果你将 1s 分成 5 份的话，在输出 10 个波形时，会发现虽然整体上看 PWM 波还算是均匀，但每个时间片中，PWM 波是紧挨着的，具体如下：<code>110000000000000000001100000000000000000011...</code> 显而易见， 1 的分配在大时间 1s 中是均匀的，但小时间 200ms 中是紧挨着的。但如果分配的比较细致，如上面所示分成 20 个时间片的话，无疑又会增加主程序扫描和判定的次数。</p>
<h3 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h3><p><strong>上一个时间 1s 计算好在下一个时间 1s 需要打出的脉冲个数，在下一个时间 1s 内，打出固定频率的脉冲，但为了让脉冲更加均匀均匀，采用查表的方式，将脉冲均匀的分布在各个时间段。</strong>采用查表的方式，有时看似最简单的方式，往往说不定是最有效的，由于这边需要输出的脉冲情况数并不是太多（100种情况），我们可以将这 100 种情况下的每个 PWM 周期（也是 100 个状态）全部列出来，用 100*100bit 来保存你的数据，100bit 可以用 13kbyte 保存，这样差不多占用 1.3k 的代码段。然后我们每次进入 PWM 中断，判断下一个 PWM 周期是否需要开启 PWM 信号。这样可以更加精准地控制 PWM 输出，且减少计算量，但相应的，我们至少额外的 13kbyte 的 flash 空间来存储我们的数据，这也算是一种典型的时间换空间的方法。如果通过查表的方法来输出 PWM ，我们需要手动写一个计算程序来生成这样的表格。这边提供一个思路：如果输出 12 个 PWM 波，我们可以通过计算 (100-12)/12 得出每个 1 后面需要加入的 0 个数，然后通过 (100-12)%12 得到余数，从前往后，每个 1 后面再补 1 个 0 ，值到没有余数全部补完。</p>
<h3 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h3><p>提供另一种思路，如果 1s 内的 n 个脉冲可以通过其他方式获取的话，也就是说不是一次性获取 1s n 个脉冲，而是可以在 1/100 s 内每次判断是否有一个脉冲。将 1s 分为 100 份，判断下一个 10ms 是否需要发射脉冲，每 10ms 采用一个中断进行判断该次是否需要发射脉冲。这种方式灵活的更高方法更简单，但同时需要在中断中执行大量的判定和功能，很可能会影响其他功能的执行。</p>
<p>以上几种方法各有利弊，具体看你系统的需要而定。</p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）人类有三个大脑？——“脑的三位一体”理论 ]]></title>
      <url>http://noparkinghere.top/2017/03/08/2017/2017-03-08-%EF%BC%88%E8%BD%AC%EF%BC%89%E4%BA%BA%E7%B1%BB%E6%9C%89%E4%B8%89%E4%B8%AA%E5%A4%A7%E8%84%91%EF%BC%9F%E2%80%94%E2%80%94%E2%80%9C%E8%84%91%E7%9A%84%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93%E2%80%9D%E7%90%86%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p><em>本文是转载文章，可以参考<a href="http://blog.sina.com.cn/s/blog_663d9a1f0101f4gs.html" target="_blank" rel="external">原文链接</a></em></p>
<p>保罗.麦克里恩提出的“脑的三位一体”假设</p>
<ul>
<li>爬行动物脑</li>
<li>边缘系统（古哺乳动物脑）</li>
<li>新皮质（新哺乳动物脑）</li>
</ul>
<p>神经学专家保罗.麦克里恩提出假设，设想人类颅腔内的脑并非只有一个，而是三个。这三个脑作为人类进化不同阶段的产物，按照出现顺序依次覆盖在已有的脑层之上，如同考古遗址一样，保罗称其为“人脑的三位一体”构造。麦克里恩现在是位于美国马里兰州浦尔斯维的“脑进化与行为”实验室的主管，他说这三个脑的运行机制就像“三台互联的生物电脑，各自拥有独立的智能、主体性、时空感与记忆”。他将这三个脑分别称作新皮质或新哺乳动物脑，边缘系统或古哺乳动物脑，以及爬行动物脑，即脑干和小脑（见上图）。每个脑通过神经与其他两个相连，但各自作为独立的系统分别运行，各司其职。</p>
<a id="more"></a>
<p>该假设已经成为了一个颇具影响力的脑研究范式，催生了对人脑功能机制的从新思考。在此之前，研究者们认为新皮质作为人脑的最高层，控制着其他的低端脑层。麦克里恩否定了这一说法，指出，控制情感的边缘系统，虽然生理上位于新皮质之下，但在必要的时候能够干扰甚至阻止新皮质高阶精神功能的实现。</p>
<p>有趣的是，许多带有神秘色彩、年代久远的灵性修行团体也宣扬过与此类似的观点，比如“意识的三种境界”，甚至同样有人提出过“三个不同的大脑”一说。例如葛吉夫，他曾经称人类是“有三个大脑的生物”，他们分别掌控着人的意识、灵魂和身体。卡巴拉教、柏拉图主义，以及其他一些地方也可以见到类似的观点，他们基本上都提出了“意识—脑袋（真实的大脑）”、“灵魂—心脏”、“身体—腹腔”这类功能与器官的对应关系。我们不由想到了脉轮范式（chakra，音译为：查克拉），它与以上那些说法一脉相承且更加细化，认为人类的身体或脊椎一侧依次分布着若干个穴位，分别与不同的意识节点相对应。</p>
<p>爬行动物脑.  旧皮质，又称原始（爬行动物）脑或“基础脑”，包括脑干和小脑，是最先出现的脑成分，麦克里恩称其为“R-复合区”。它由脑干—延髓、脑桥、小脑、中脑，以及最古老的基底核——苍白球与嗅球组成。对于爬行动物来说，脑干和小脑对物种行为起着控制作用，出于这个原因，人们把旧皮质称为“爬行动物脑”。在爬行动物脑操控下，人与蛇、蜥蜴有着相同的行为模式：呆板、偏执、冲动、一成不变、多疑妄想，如同“在记忆里烙下了祖先们在蛮荒时代的生存印记”。无休止地复制着相同的行为方式，从不会从以前的错误中学习教训（与室利．阿罗频多所说的机械心灵相对应）。这个大脑控制着身体的肌肉、平衡与自动机能，诸如呼吸与心跳。大脑的这个部分一直保持活跃状态，即使在深度睡眠中也不会休息。</p>
<p>边缘系统（古哺乳动物脑）.  1952年麦克里恩第一次创造了“边缘系统”这个词，用来指代大脑中间的部分，这部分同样可以称作旧大脑皮层或中间脑（古哺乳动物脑），与大部分尤其是进化早期的哺乳动物脑相对应。位于边缘系统的古哺乳动物脑，与情感、直觉、哺育、搏斗、逃避、以及性行为紧密相关。如麦克里恩所察，情感系统一向是爱恨分明的，一件事物要么“宜人”要么“不宜”，没有中间状态。在恶劣的环境中，正是依赖这种简单的“趋利避害”原则，生存才得到保证。</p>
<p>当这部分大脑受到弱电流的刺激，多种情绪（恐惧、欢乐、愤怒、愉悦、痛苦等等）便会滋生。虽然各类情绪在特定位置存留的时间很短暂，但整个边缘系统却似乎是孕育情绪、注意力以及情感（情绪主导）记忆的主要温床。从生理上看，边缘系统包括下丘脑、海马体以及杏仁核。它帮助人类判断事物的基本价值（例如，你对某物是持肯定还是否定态度，佛教称此为vedena—“感”）和特别之处（例如，什么吸引了你的注意力），还有助于人类感知不确定性因素，进行创造性活动。边缘系统与新皮质有着千丝万缕的深入连接，二者联合操控着脑功能的发挥，任何一方都无法独立垄断人脑运行。<br>麦克里恩提出，教条化与偏执狂、自卑感、对欲望的合理化等行为倾向都可以在边缘系统中找到生物学基础。他认为边缘系统中蕴含的力量如果全部爆发，危险性实在不容小觑。按照他的理解，发出价值判断指令的指挥室，往往不是处于更高进化阶段的新皮质，而是边缘系统中相对低阶的古哺乳动物脑。前者产生的想法好不好，正确与否，都由后者来加以判断。</p>
<p>新皮质，大脑、脑皮质，或者换个词：新皮层，就是我们所知道的高级脑或理性脑，它几乎将左右脑半球（由一种进化较新的皮质类型组成，称为新皮质）全部囊括在内，还包括了一些皮层下的神经元组群。脑皮质对应的是灵长类哺乳动物脑，人类当然包括在内。正是脑皮质中所具有的高阶认知功能，令人类从动物群体中脱颖而出，麦克里恩将脑皮质称作是“发明创造之母，抽象思维之父”。人类大脑中，新皮质占据了整个脑容量的三分之二，而其他动物种类虽然也有新皮质，但是相对来说很小，少有甚至没有褶皱（意味着新皮质的表面积、复杂度与发达程度）。老鼠失去了脑皮质，仍然可以正常活动（至少从表面上看是如此），而人类一旦失去脑皮质，那他将与蔬菜无异。</p>
<p>脑皮质分为左右两个半球，就是为人们所熟知的的左右脑。左侧的脑皮质控制着身体的右侧，右侧的脑皮质控制着身体的左侧。并且，右脑更多地决定了人的空间感、抽象思维、音乐感与艺术性，而左脑则更多控制着人的线性逻辑，理性思考与言语能力。</p>
<p>鱼脑不重，但鱼类和比它低等的无脊椎动物都有一条脊索或脊髓。原始的鱼类在脊髓前端有一个小小的隆起，这就是鱼脑。较高级的鱼类的隆起变得更大些，但仍然不重于 1克或2克。这个隆起相当于高等动物的后脑，或脑干以及中脑部分。现代鱼类的脑多半为中脑，前脑极小。现代两栖类和爬虫类的脑则恰恰相反（见图5）。最原始脊椎动物的头骨化石内模显示，现代脑的主要部分（如后脑、中脑和前脑）业已形成。五亿年前，在原始沧海里邀游着一种鱼类动物，名叫甲胄鱼（Ostracoderms）和盾皮鱼（Placoderms）。现在仍可以辨认出来，这种动物脑的主要部分与现代脑是相似的。但它们的相应体积、各部组成意义及其早期功能肯定与现代的脑截然不同。有关脑后来进化最引人注目的见解，就是叙述覆盖在脊髓、后脑和中脑上面的另外三层连续堆积及其功能的特化。脑的每一步进化都保留着原有部分，但其功能必须被新层控制，同时具有新功能的新层又增殖出来。国立精神保健研究所脑进化和脑行为研究室主任麦克莱恩（PauIMaclean）是当代这一论点的主要阐述者。麦克莱恩著作的特点之一是包罗万象。他研究了从蜥蜴到鼠猴多种动物；另一个特点是，他和同事们仔细研究了这些动物的社会行为和其他行为，以便扩大成果，弄清脑的哪些部位控制着哪种行为。</p>
<p>带着粗鲁面部表情的鼠猴却有一种礼仪，这种礼仪常常表现在它们相互致意的时候。雄猴龇牙咧嘴、喀啦喀啦摇晃笼子铁杆，发出令人毛骨悚然的尖叫，翘起腿，裸露出勃起的阴茎。这种行为在现代人公共场合里彼视为极端野蛮的行为，而在鼠猴群落中，却是一种相当精细的行为，并用于表明其占有优势的等级地位。</p>
<p>麦克莱恩发现，鼠猴的一小部脑损伤能制止这种行为出现。与此同时，大量的他种行为包括性和好斗行为则不受任何影响。损伤中所涉及到的部分是前脑的最古老部分，是人和其他灵长目、哺乳类和爬虫类祖先所共有的部分。非灵长目哺乳类和爬虫类动物类似的定型行为似乎都控制在脑的这一相同部位。如爬虫这一组成部分受到损伤，除这种定型行为外，象行走或奔跑等自动型行为都可能减弱。</p>
<p>经常发现灵长目动物性的行为同所处的支配地位有关。在日本的猕猴中还保留着社会等级。日常的交配活动又在不断地加固这一等级差异，地位低卑的雄猴对动情期的雌猴表现出谦卑而又富有性的柔情，并有礼貌地让身份较高的雄猴首先交配。这种交配活动是常见的，但却又是敷衍了事的。似乎没有什么性的内容，只是作为一种表明在这一复杂的社会集群中各自所处不同地位的通俗象征。</p>
<p>当研究鼠猴行为时，我们考察了名叫卡斯珀的雄猴。它在这个集群中占支配地位，又是最活跃的表现者。尽管它表现在生殖方面的求偶夸耀行为要占整个集群此种行为的三分之二，但它主要是在雄性成猴面前显耀自己。从未见过卡斯珀与雌猴的交配行为。事实表明，它的主要动机是建树支配地位，对它来说寻求性欲满足的动机是无足轻重的。事实也说明，当两种功能活动可能涉及到同一器官系统时，它们却是完全独立的。研究这一集群的科学家们断定：就组群等级而论，生殖表现被看成是最有成效的社会标志，并已被定型化了，好象具有“我是主”的含意。这很可能源于性活动，但主要用于社会交往，与单纯的生殖活动是有所区别的。换而言之，生殖上的求偶夸耀行为是一种来源于性行为，但用于社会目的而不是生殖意图的定型行为。在1976年的电视谈话中，节目的主持人询问一名职业足球队员，如果你们队员在更衣室内都赤身裸体，是否感到难为情？他马上回答：“不，个别队员和打水的人除外，我们都很坦然，一点也不觉得难为情，正如平常我们相互在说，‘伙计，让我们看看你穿了些什么’时一样轻松自如。”</p>
<p>各种研究证实了性、攻击和支配地位之间存在着行为与神经解剖结构的联系。狮虎和其他动物交配定型行为在早期是很难跟打仗行动区分开来的。驯养的狮虎有时呜呜吼叫，用其爪慢慢地搜索着室内物品或轻轻地抚摸着人的皮肤，这些都是屡见不鲜的事。用性来建树和保持支配地位时常明显地见于同性恋和异性恋常例中（当然不是此类惯例中的唯一因素），同时也表现在许多猥亵的言词里。攻击这个动词在英语和其他语言中是最常见的。动物往往把攻击行为看作是非凡的愉快。在考察“Agression”这个动词的来源时，发现它的英语形式可能来自德语和中古荷兰语动词“Fokken”，意为攻击。这个词在其他方面的费解用法可以理解为猕猴象征语言的等同动词，只是句首的主语“我”字没有说出来，但双方还是理解的，这种做法和其他许多类似的表达方式好象同原始人的交媾定型行为一样。但据我们看，原始人的这种行为可能比猴出现得更早，这要倒回几亿年的地理时间。</p>
<p>根据鼠猴试验，麦克莱恩发展了被他称之为三位一体脑结构和脑进化的具有脸力的脑模式。他说，我们是通过三种完全不同的智力观点来观察我们自己和周围世界的。脑的三分之二是没有语言能力的。麦克莱恩认为，人脑就象三台有内在联系的生物电子计算机。每台计算机都有自己的特殊智力、自己的主观性、时间空间概念、自己的记忆、发电机和其他功能。脑的每一部分都能适应单独较大范围的进化。据说脑的三个组成部分在神经结构和功能上都是有区别的，它们的神经化学递质多巴胺和胆碱酯酶的含量完全不一样。最远古时人脑组成部分是脊髓、构成后脑的髓质和脑桥以及中脑。麦克莱恩把脊髓、后脑和中脑统称为神经框架。它含有生殖和自身保护的基本神经结构，包括心脏调节、血液循环和呼吸等结构，鱼和两栖动物的脑基本如此。如果按麦克莱恩的观点去解释，那么丧失了前脑的爬虫动物或较高等动物，就象一辆无人驾驶的车辆，没有方向目标，也无法开动。</p>
<p>我认为癫痫大发作，实质上可以看成是由于脑内电暴丧失了脑认识功能的驾驶者造成的。此时患者除神经框架外完全处于瞬息无效状态。这种损伤使受残者暂时又回到几亿年前的状态。我们至今还使用古希腊人对疾病的命名，古希腊人认识到了疾病的深奥特性，但他们却把疾病说成是上帝给予的惩罚。</p>
<p>麦克莱恩对三种神经框架的驾驶者进行了分门归类。它们之中的最古老部分都围绕着中脑（中脑主要由神经解剖学家称为的嗅觉沟回、层状体和苍白球等三部分组成）。中脑是我们同哺乳类和爬虫类共有的，它很可能是从几亿年前进化来的，麦克莱恩把它称之为爬虫复合体（R-complex，相当于蚯蚓部——译注）。围绕着爬虫复合体的是边缘系统，之所以这样命名是日为它毗邻在大脑皮层下（我们的臂和腿称作四肢，四肢对机体其余部分来说是边缘）。边缘系统是我们同哺乳动物共有的，也是我们同爬虫类共有的，但不那么完善精细，这大约进化了一亿多年或五千万年以上。最后就是覆盖在脑的其余部分上的显然是最新进化的堆积物——新皮质，同高级动物和灵长目动物一样，人的新皮质相当大。越发达的哺乳动物其新皮质增长越大，新皮质进化得最出色的是人（还有海豚、鲸鱼），这大概已有几千万年的进化史了。可当人出现后的近几百万年大大加快了这一进化速度。图6展示的是人脑示意图，三种当代哺乳动物的边缘系统和新皮质的对比在图5中已展示过。三位一体脑的观点同上章研究过的脑重与体重比率而得出的结论显然是一致的。哺乳动物、灵长目动物（特别是人）的出现总要伴随着脑在进化上的大范围飞跃。</p>
<p>很难通过改变脑的深层组织结构达到进化。深层的任何变化可能都是致命的，但是通过在旧系统上面增殖新系统可以达到根本的变化。这使人想起了十九世纪德国解剖学家黑克尔（Ernst Hacckel）称之为重演的学说。这个学说经历了不同时期学术上的肯定或否定。黑克尔认为，在胚胎发展中动物趋向于重复或重演我们祖先在进化中所遵循的程序。确实胎儿在子宫内发育中，在尚未呈现出人形之前, 经历了同鱼、爬虫动物和非灵长目哺乳动物非常相似的阶段。胎儿在鱼的阶段时还存有鳃裂。鳃裂对于依靠脐带得到滋养的胚胎来说是绝对无用的。在人的胚胎学中，脐带是完全必要的。既然鳃裂对我们的祖先是必不可少的，在变成人时胎儿经历了鳃裂阶段。胎儿的脑也是由内向外发展的，并大致经过下列顺序：神经框架，爬虫复合体，边缘系统和新皮质（见图29人脑的胚胎发育）。</p>
<p>重演的原因可理解为：自然选择对个体起作用，对种不产生影响，更不能影响受精卵和胎儿，这样一来新的进化变异都要出现在产后。胎儿可能具有象哺乳动物鳃裂这样的特性。鳃裂在胎儿出生后是完全无用的。由于它对胎儿没有什么严重影响，而且在出生前就消失了，所以鳃裂在胎儿时期保存下来是无关紧要的。人的胎儿鳃裂不是古代鱼的遗迹，而是鱼胚胎的遗迹。许多器官系统不是通过增加或保存的方式，而是通过变更旧的系统进展的。例如，把翅变成腿，腿变成鳍状肢或翅膀，或脚变成手、再变成脚，皮脂腺变成乳腺，鳃弓变成耳骨，鲨鱼鳞变成鱼牙等等。引起这种增殖和保留原有结构功能的原因有两个：一是由于新旧功能的同时需要：二是因为无法把符合幸存者的旧系统保留下去。</p>
<p>阐明这种进化本质的例子是很多的，几乎是随手可取。现在让我们再举一个例子吧。比如说考究一下植物为什么是绿色？绿色植物的光合作用利用太阳光谱中的红光紫光来分解水，生成糖类和植物体中的其他物质。太阳辐射的光谱中，黄光和绿光要多于红光和紫光。但以叶绿素为光合作用色素的植物排斥了最为丰富的光线黄光和绿光。许多植物看来“注意”到了这点，但是已经为时过迟了，因为它们已经进行了恰如其分的适应变化。现在已有了反射红光吸收黄绿光的其他色素，如类胡萝卜素，藻胆色素，真是尽善尽美，应有尽有！但是否有了新的光合色素植物就抛弃了叶绿素呢？图8展示了红藻的光合作用，植物的条纹结构里含有叶绿素，紧贴着这些条纹的小球含贮着使红藻呈现红色的藻胆色素。这些植物一成不变地把从绿光黄光中获取的能量传给叶绿色素，叶绿色素尽管不能吸收光，但它能在所有植物的光合作用中起到沟通光和化学过程之间的间隙作用。这样大自然就不可能抛弃叶绿素而再用更好的色素取代之。叶绿素已经纵横织成了生命之帛。具有附加色素的植物确实是多种多样的，附加色素更有效用，但叶绿素还是起作用。尽管它的可信赖性有所降低，它仍是光合过程中的核心。我想脑的进化也是如此进行的。脑的深层和古老部分仍然在起作用。</p>
<h4 id="爬虫复合体"><a href="#爬虫复合体" class="headerlink" title="爬虫复合体"></a>爬虫复合体</h4><p>如果上述观点是正确的，我们就应想到人脑的爬虫复合体在某种意义上还执行着恐龙的功能，人脑的边缘皮质还存在着美洲狮和树獭的思想活动。毫无疑问，脑每进化一步都伴随着脑的原有组成部分的生理学变化。在中脑等部位一定能见到爬虫复合体的进化。我们还知道，脑的多种功能控制在脑的不同部位。假如新皮质下的脑组成部分没有相当大的扩延，仍执行远古祖先头脑的功能，我们就会为此而感到惊慌失措。</p>
<p>麦克莱恩指出，爬虫复合体在攻击行为、保卫领域、礼仪和建立社会等级差异中起着重要作用。尽管偶尔也表现出更高的功能，但在我看来上述作用恰恰是现代人在官场中多种政治行为的特征。当然这并不否认新皮质在美国参议两院政治会议中所起的作用。不管怎么说，礼仪上的大量交往都是通过语言进行的，因而最终还要归结于新皮质的功能。究竟有多少区别于我们所说所想的实际行为可用爬虫的术语描述，这是引人入胜的。我们平时经常谈到“冷血”动物，就是指爬虫而言。</p>
<p>美国哲学家兰格（Susanne Langer）风趣地描述了这种思想部分的超前作用，写道：“人生是充满礼仪的，渗透着动物习俗的。生命是理智和礼仪、知识和宗教、散文和诗歌、事实和幻想的综合体。礼仪象艺术一样，它是人日常经验抽象的总结。礼仪不是在脑的古老部分，而是在皮质内产生的，一旦新皮质发育成人的状态，这种礼仪就成了皮质的基本功能了。”从各种资料来看，爬虫复合体是脑的原始部分，这看来已是无可非议的事实了。我想进一步了解爬虫动物的脑对人行为影响这一论点的社会含意。假如官僚政治的行为彻底地受爬虫复合体控制，这是否就意味着人的未来是没有希望了呢？人的新皮质约占脑重的85％，同脑干、爬虫复合体和边缘系统相比，这确实是一个重要特征。神经解剖学、政治历史和内省，这一切都提供了证据，证实人类完全能够抵制沉溺于爬虫脑的每个冲动的强烈欲望。如美国“人权法案”不可能不经大脑思考，而只是靠爬虫复合体记录构想出来的。我们人能抵制那种一味盲从地遵循遗传学上的既定行为，这正是我们高于他种动物的不同之处，也恰恰是我们的可塑性和漫长童年的特点。如果把三位一体脑看成是人类如何正确活动的楷模，然而却忽略人的本质组成部分，尤其是忽略我们人的礼仪和等级制度行为，那是没有什么益处的。相反，这种模式应能帮助我们理解人是怎么回事（我不敢断言，许多精神病，即青春期痴呆的精神分裂症的礼仪行为是否是由于爬虫复合体内的某些中枢活动过度的结果，或是由于起抑制爬虫复合体功能的大脑新皮质部位障碍造成的。同样我也不知道青少年常见的礼仪行为是否是因其新皮质还不完全发达的结果）。</p>
<p>在一次奇妙的旅行中，切斯特顿（Chesterton）写道：“你可以摆脱外国的法律约束，但你逃脱不了事物本身的自然法则。不要尽做那种振奋人心的三角越狱。如果三角形超越了它的三条边，那它就要有个悲惨的结局。但不是所有的三角形都是等边的。调整三位一体脑的每个组成部分的相关作用，这完全是我们能够办到的。”</p>
<h4 id="边缘系统"><a href="#边缘系统" class="headerlink" title="边缘系统"></a>边缘系统</h4><p>边缘系统看来是产生激情，即特别激动的情感部位。这使人立即想起关于爬虫复合体的另一种看法：它的特点并不表现于极为矛盾的强烈感情，而是对受其基因和脑支配的某些行为表现出顺从平静的默许。</p>
<p>边缘系统的电流放电有时能引起同精神病相似的症状或引起因服幻觉药而出现的类似症状。事实上许多治疗精神病药物都作用在边缘系统上。可能边缘系统能控制兴奋、恐惧以及多种人所特有的又往往是难以捉摸的感情。</p>
<p>垂体，这个影响其他腺体、控制人的内分泌系统的脑垂体是边缘区的本质部分。因内分泌不平衡造成情绪波动的特性给我们提供了有关边缘系统同思维状态联系的重要启示。在边缘系统里有一种很小的杏仁状的内含物，叫做杏仁体，它和攻击、恐惧行为息息相关。电刺激杏仁体可以激起温顺的家畜出现令人难以置信的恐惧和狂燥状态。当杏仁体切除后出现这样一种情况，猫发现小白鼠也要吓得发抖；反之，象山猫这种本性凶猛的动物倒变得温顺起来，容许人们喜爱抚摸。边缘系统机能失常的人可以产生无缘无故的狂怒、恐惧和脆弱感情。常态的过度刺激可以产生同样的后果：患这种病的机体出现不适当的莫名其妙的感觉，他们被看成疯痴。</p>
<p>至少象脑垂体、杏仁体和下丘脑这些边缘内分泌系统的一些确定感情作用是由小分子的激素蛋白质形成的。这种蛋白质由上述组织分泌出来，井影响脑的其他区域。大概人所共知的是脑垂体蛋白质——促肾上腺皮质激素（ACTH），它可直接影响到可见的象滞留、焦虑、注意力广度等多种神经功能。通过实验在脑第三室可测出某些小分子的下丘脑蛋白质。脑第三室是边缘系统的一个部位，它把下丘脑和视丘联系起来。</p>
<p>有充分理由可以认为利他主义的行为起源于边缘系统。的确，除极个别的例外（主要是社会领域），哺乳类和鸟类是唯一倾注全力照料幼雏的生物。这是一种通过条件允许的长期适应性，利用哺乳类和灵长目动物大脑的大量信息处理能力而进化发展的结果，似乎是哺乳动物首创了性爱* 。</p>
<p>强烈感情的逐渐形成主要表现在哺乳动物身上，鸟类的进化程度较小，许多动物的行为证实了这一见解。我想，家畜对人的依附性是毫无疑问的。众所周知，当拿走幼畜时，许多哺乳动物的母畜表现出明显的伤感。那么人们想知道这种感情效力究竟有多大？马是否也有少许的爱国热情？狗是否也有象人那样具有对宗教心醉神迷的感情？同我们没有交往的某些动物是否也有某种强烈费解的感情？</p>
<p>边缘系统的最原始部分是嗅觉皮质。它同嗅觉有关，它的萦回感情特性为大多数人所熟知。我们的记忆和回想能力的主要组成部分位于边缘系统内的一种结构——海马内（位于侧脑室下角底的中央部的曲形构造——译注），海马损害将引起严重的记忆减退已确切地证实了这一点。H·M（相当汉语中“某某”，因不便写出患者的姓名——译注）是一位有长期癫痫发作和惊厥史的病人，在他的海马附近的整个区域施行切除术，试图减少其癫痫发作次数和疾病的严重程度。手术后病人立刻变得健忘，但他仍保持良好的感觉功能，并能学会新的运动技能，也许还能进行某些感性学习，但几乎忘记了前几个小时所学到的一切。他本人的感觉是：“在我看来每天都是孤立存在的，无论什么样的愉快我都享有过，什么样的忧伤我都尝受了”。他把他的生活说成是一种辨认不出方向的迷惑感觉的继续扩大。应该说这种感觉也是我们许多人睡梦初醒时的共同感受，那时我们很难回忆起到底发生了什么事。确实，尽管这种损害严重，在海马切除后，其智商（IQ） （通过对给定的一些问题的口答来确定智力，这种智力测验结果用“智商”表示，智商就是用这种测定方法测出的“智力年龄”与“实际年龄”的比值——译注）有所改进。他能敏锐的分辨出不同的气味，但很难说出味源的名称，他对性活动已明显地失去了兴趣。</p>
<p>另一个病例是一个年轻的航空兵，他在同一个军人击剑决斗中，一块微薄的剑片飞入右鼻孔，刺穿了靠近上面的一小部分边缘系统，从而导致记忆的严重衰退，类似H·M病例，但不如H·M病情那么严重。他的感性知识和智力能力并没受什么明显的影响，但在语言材料方面的记忆减退特别明显。事故似乎使他变得对疼痛反应迟钝，他赤脚在巡洋舰炽热的金属甲板上踱来踱去，同他一起的乘客吵嚷说有一种烧焦皮肤的难闻气味之后，他才意识到他的脚已被烧伤。作为他本人即不知疼痛，也嗅不到烧焦的气味。</p>
<p>从这样的病例中不难看出，象哺乳动物这种复杂性活动是受三位一体脑的三个组成部分——爬虫复合体、边缘系统和新皮质同时控制的（我们已提到有关爬虫复合体和边缘系统在性活动中的复杂情况，同牵连到新皮质的复杂情况很容易通过内省获得证实）。</p>
<p>旧边缘系统的一段是专门用于口述和手势功能的。它的另一段用于性功能。性和嗅觉在很早以前就有关联，昆虫高度发展了性和嗅觉的联系，但这一情况也使我们远古的祖先透彻理解到依赖嗅觉的重要性，同时也看出了其不利方面。</p>
<p>我曾目睹一个试验，在试验中，用一条细金属丝将绿蝇头部联到一个示波器上，此示波器能以一种图形方式显示出由绿蝇嗅觉系统产生的任何电冲动（为了有机会观察到嗅觉设备，将绿蝇头部截断，由于刚截断不久，因而其头脑还能具有许多功能作用）。</p>
<p>试验者在绿蝇前面散发各种气味，包括令人讨厌不快的、但又没有明显影响的气体，如氨。这时在示波器萤光屏上留下的图线是水平伸展的，接着在断头的绿蝇前飘放微量的由这种雌性绿蝇放出的性引诱气味，此时在屏上呈现出垂直的尖峰脉冲。撤掉此种雌性引诱气味，绿蝇几乎嗅不到任何气味，绿蝇的嗅觉对此种性引诱分子非常敏感。</p>
<p>这种嗅觉功能的特化对昆虫来说是常见的。假如每秒钟仅有大约40个雌性引诱分子碰到蚕蛾轻软的触觉，它也会觉察出来。每个雌性蚕蛾每秒钟仅需释放出百分之一毫克的性引诱物，就足够引诱大约一立方英里范围内的每个雄蚕，这是蚕虫之所以幸存的原囚。</p>
<p>最奇妙的还是用气味寻求配偶和传种。例如，冬天在地下打洞的南非甲虫，当春回大地时，甲虫钻出地面，但雄性甲虫比雌性甲虫早几个星期从地里踉踉跄跄地爬出。在南非的同一地区，业已演变的兰花放出一种同雌性甲虫性引诱物相同的香味，事实上，兰花放出的气味产生了与雌性甲虫性引诱物功能基本相同的分子。加之雄性甲虫长期在地下视力很差，而兰花花瓣的构形又发生了演变，这对辨认能力缺乏的甲虫来说，兰花花瓣在性感官形态上又很象雌性甲虫。几周中雄性甲虫在兰花丛中恣意狂欢，心醉神迷。最后雌性甲虫从地里钻出，我们可以想象出雌性甲虫因身心受到伤害会产生多大的义愤。与此同时兰花却已通过多情的雄性甲虫进行了传粉，雄性甲虫窘迫不堪但又尽力传延本种后代，这样雄雌性甲虫都得以幸存了（顺便说一句，如兰花的迷惑力不是很强，这对兰花本身是有益的；但反过来说，如没有甲虫的自身繁殖的性活动，兰花因无媒介传粉也会陷入绝境）。这样一来，我们就发现了一条纯属嗅觉性刺激的界限。还有另外一条界限，那就是，既然每只雌性甲虫产生相同的性引诱物，雄性甲虫就不易同它心目中的雌性甲虫产生性交往。当雄性昆虫可能竭力表现自己去诱引雌性，或者同无异性伴侣的甲虫为竞争雌性而展开相互衔咬下颌骨搏斗，雌性引诱物在交配时的中心作用似乎减少了昆虫性选择的范围。</p>
<p>寻求配偶的另外方法已被爬虫动物、鸟类和哺乳动物所发展。但性同嗅觉的联系，在高等动物神经解剖结构上以及在人经历的轶事中都很明显地证实了这一点。我有时想知道除臭剂，尤其是女性除臭剂是否试图有意识地刺激人们联想起其他别的事情。</p>
<h4 id="新皮质"><a href="#新皮质" class="headerlink" title="新皮质"></a>新皮质</h4><p>假如鱼的前脑遭到损害，这将导致它丧失原有的主动谨慎的特性。对于高等动物来说，这种较复杂的特性似乎就位于新皮质内，这也是人的多种典型的感性认识功能部位。我们通常将其划分四个主要区或者说是四个叶来进行探究的。这四个叶是额叶、顶叶、颞叶和枕叶。新皮质中各个部位彼此相通，据现在所知它同脑下皮质的神经联系还是不少的，但这决不能说新皮质的各个部分是实际的功能单位。每个叶肯定具有许多不同功能，某些功能可能是几个叶或两个叶共有的。在其他功能中额叶好象是同深思熟虑和行动调节有关；顶叶同空间感觉以及大脑同身体其余部分问的信息交换有关；颞叶与各种复杂的感性认识有联系；枕叶同视觉、同人与其他灵长日动物占优势的感官有关系。</p>
<p>几十年来风行一时的神经生理学家认为，前脑后面的额叶是典型的预感和部署未来的功能部位。但近来的著作表明，情况并非如此简单。马萨诸塞州理工学院美国神经生理学家托伊伯（Hans Lukas Teuber）调查研究了大量额叶损残（在战争中受伤或击伤）的病例。他发现不少额叶损伤几乎对行为没有明显影响。不过在严重损残额叶的病理学中，“病人并不完全缺乏预料事件过程的能力，但不能在同那些事件关系中把自己设想成潜在动因”。托伊伯强调指出额叶可能同运动原和认识的预感，尤其是同随意运动造成的影响有关。额叶也似乎同视觉以及双足直立行走有关。这种额叶因执行人的特殊功能可能以两种途径进化。如果说额叶能控制预料未来的功能，那它也必然是产生关心和焦虑的情感部位。这就是为什么切断额叶能减少焦虑的原因。前额叶切开术必定会使患者大大减低人特有的能力。我们为预知未来所付出的代价就是对未来的忧虑，因而预测灾难不可能是一件令人宽慰的事。遇事总是过分乐观的人要比凶事预言者幸福的多。自然界预言凶事对幸存者来说是必需的。控制展现未来的学说起源于伦理学、魔法、科学和法典，预见灾祸的好处就在于能采取措施去防范它，牺牲眼前暂短利益换得未来长远好处是这种预见的结果。在物质丰富的社会里才能形成对社会和技术发明所必需的空闲时间。</p>
<p>可猜测出额叶的其他重要功能就是使人类双足直立行走。在额叶没有进化之前，人的直立姿势不可能出现。有关这一点详见以后章节。双足直立行走解放了双手，以便用双手操作，从而导致人类文化和哲学特性的较大增长，困此如果很客观他讲，文明可能就是额叶的产物。</p>
<p>来自眼睛的视觉信息传到人脑后主要在头的后部枕叶里定位，听觉印象定位于太阳穴内颞叶上部。据一些不完全的证据表明，盲人、聋哑人的新皮质的上述部位很不发达。枕叶损残，如枪伤经常引起视觉障碍，受残者可能在其他方面正常无疾，但只能用外围视力观察。在正常视觉中枢里觉察到暗点实点隐隐浮现在他的眼前，在其他病例中伴随而来的是离奇古怪的知觉，其中包括几何学上的视界内正规草写浮动障碍和“视力发作”，当发作时，患者会把在其右下方地板上的物体误认为在其左上方空中浮动的图象，物象在患者眼里颠转了180度。通过对称计算因各种枕叶损伤而造成的视力障碍，可以详尽地用图表示出枕叶的哪些部分负责执行哪种视力功能。青年人的脑好象能自身修复，并圆满地将这一功能活动转送到邻近区域，永久性的视力减弱似乎很少发生在青年人身上。</p>
<p>联系听觉和视觉刺激的能力定位于颞叶。颞叶损伤可以产生失语症，即不能意识所说的言语。值得注意的是脑损伤的病人可以完全胜任口语，但不能全部胜任书写文字；反过来也是如此，他们可能会写、但不能阅读；能读数字，但读不了字母；能准确叫出事物的名称，但不能识别颜色。新皮质有着惊人的功能分类，这种分工与阅读、书写或认字、识数等这些常识性见解相反，但活动是完全相似的。到目前为止，还有些未经证实的脑损伤报告。这种损伤仅仅引起不能理解被动语态或介词词组，或所有格结构。（虚拟语气的部位总有一天会找到的。是否拉丁人将变得格外富有天资，而说英语的民族在脑解剖结构的较小部分上将大大地缺乏变化？）各种抽象概念包括语法学的语言部分似乎惊人地同脑的特殊区域毗连相通。</p>
<p>在一个病例中，颞叶损残可引起患者辨认面目的严重障碍，甚至患者不能认出其直系亲属的面貌。图11中所描绘的面目图，患者说，人脸“可能”是个苹果。他并请求让他证实这种解释是合理的。他把口说成是苹果上的切口，把鼻子看作是在表面上凸起的苹果把，把眼睛认为是虫眼。相同的病人能完美的认出素描的房子以及其他非生物。广泛的试验表明，右颞叶损害可形成典型性的语言记忆丧失，我们具有阅读、绘画、在立体的三个方向标定自己以及恰当使用符号等能力，所有这些能力如果不是同语言的使用有关，大概就是同语言的发展有关。这些能力又会因近于头脑顶部的顶叶损残而遭到严重减弱。一位军人在战时其顶叶很大一部分被子弹穿通，他整整一年不能判断他的脚是否穿上了拖鞋，而且很难辨认出他所在医院、病室和病床。尽管如此，最后他还是痊愈了。</p>
<p>顶叶内新皮质角回（顶下叶的一个脑回——译注）的损害引起失读证，不能辨认印刷单词。顶叶看来与人的符号语言有关。在所有脑损伤中，顶叶损残造成智力极大衰退，这可以通过日常生活活动测试出来。</p>
<p>新皮质抽象概念中主要还是人的符号语言，尤其是读、写和计算。这些看来需要颞叶、顶叶、额叶，也许还需有枕叶的协调活动。但不是所有的符号语言都属于新皮质的。蜜蜂（没有一点新皮质）具有精美的舞蹈语言，用以在获得食物方向和距离方面彼此传递信息。澳大利亚昆虫学家弗里希（Karl von Frisch）首先发现了这一点。这是一种夸大的手势语言，实际上是蜜蜂找到食物时动作的模拟。这点有时同我们人的动作相似，如我们向电冰箱走了儿步，腹部冲着电冰箱，一下擦痛肚皮，那时我们就会伸舌摇头表示遗憾。应该说舞蹈语言的词汇量是极其有限的，可能仅有几十个单词。年轻人在童年时期所经历的学习几乎都是新皮质的功能活动。</p>
<p>大部分嗅觉过程是在边缘系统内进行的，与此同时也有一些发生在新皮质内。相同功能的划分似乎也适用于记忆。边缘系统的主要部分除嗅觉皮质外，正如我们所说的那样，都是海马皮质。当嗅觉皮质得到训练时，尽管效力很低，动物还能嗅到。这是脑功能多余信息的又一例证。还有一些证据表明，现代人嗅觉的短期记忆存储在海马里。海马的原功能可能是专管嗅觉的短期记忆，这对追逐捕食动物或寻找异性是有用的。但如人的两侧海马损残，正如H·M病例一样，引起各种短期记忆的极度减弱。这种病的患者不能连续不断地逐字记忆，很明显，海马和额叶都与人的短期记忆有关。</p>
<p>这方面的多种有趣结论之一，就是脑的长短期记忆大量储存在脑的不同部位。标准的条件作用——巴甫洛夫试验狗当听到铃响时分泌唾液的能力似乎就位于边缘系统。这是一种长期记忆，但却是极其有限的。很有经验的人其长期记忆都存储在新皮质内，这与他深思熟虑的性格是一致的，当我们逐渐衰老时，我们能回忆起童年时生动琐碎的往事，却会忘记人们刚对我们所讲的一切。这种现象是由于我们在长期和短期记忆上都出现些障碍。问题就出在这两者之间的联系上。我们很难把新材料存送到长期记忆里去。彭菲尔德认为，这种存贮能力的丧失是由于动脉硬化或其他体内功能失调而引起的老年人海马供血不足的结果。</p>
<p>这样，老年人（或不太老的人）在存贮短期记忆上可能严重衰退，但在其他方面他们却是相当机灵，在智力上也是敏捷的*。</p>
<p>这种现象表明，在脑的不同部分定位的长短期记忆之间是有着明显区别的。快餐馆的女服务员所能记住的信息量是令人佩服的。她能准确无误地将这些信息传告厨师，但一小时后这些信息就完全消失。这是什么原因呢？这个原因是女服务员仅把信息存储在短期记忆里了，而没有再努力把这种信息进一步存贮到长期记忆中。</p>
<p>回忆机制大概是很复杂的。一种共同的感觉就是在我们长期记忆里记住一些东西，如一个单词、一个名字、一副面孔、一种体会，我们发觉这些东西不能马上被回想起来。尽管我们如何冥思苦想，仍不能回忆起来。如果我们从侧面想想，回想某些稍有关联的周围事项，便常常能自动回忆出来。（这方面与人的视力也有些相似。当我们直接观察一个模糊不清的物体时，比如说星星，我们常用视网膜中央小窝，这个具有最敏锐的、细胞密度最大的、称作圆锥细胞的视网膜部分。当我们稍微转移视力，象我们说话时斜视一下物体时那样，我们就发挥了视网膜杆状细胞的作用，这种细胞对朦胧的光照很敏感，这样就能看出昏暗的星光。）为什么歪着头思考就能促进记忆的恢复呢？要了解这个问题是件颇有趣味的事。这只能认为是使用不同的神经途径来联想记忆痕迹的结果，但这说明不了脑的操纵管理因此就格外有效了。</p>
<p>我们都做过那种栩栩如生、毛骨悚然、寓意深远的梦，或相反有过一些清晰难忘的梦境；我们也都有过从梦中醒悟的感受。如果你默默自语“清晨时我一定能记住这个梦”，次日连个梦影都记不起来，顶多不过是一种印象模糊不清的痕迹而已。另一方面，如果我们对做的梦感受很深，捅醒身边的妻子，告诉她所梦到的一切，这样一来，次日清晨就能不费吹灰之力独立回想起梦情。同样，如果不嫌麻烦，爬起来把梦情写下来，次日早晨醒来时，无需参照记录就能清清楚楚地回想起梦情。记电话号码也是同样道理，如果别人告诉我号码，我只想着这一点，那我很可能忘记号码或数位串换，如果高声重复几遍或把号码记下来，那就能清清楚楚地回忆起来，这确实意味着大脑里有个特定部位专门记忆声音和影象，但并不记忆思想。远古时代首先存储在人脑里的记忆并不是一些富有哲理的思想，而是那些爬虫动物的嘶嘶叫声以及骤然俯冲下来扑食的鹰的影象。我不知道是否那种对于声音影象的记忆出现在我们所产生的许多想法之前。</p>
<h3 id="关于人的本质"><a href="#关于人的本质" class="headerlink" title="关于人的本质"></a>关于人的本质</h3><p>不管三位一体脑模式的功能定位如何引人入胜，但我要再次强调，如一味坚持认为脑功能的完全分工也是过分简单化。人的仪式，情感行为一定受新皮质的抽象推理的强烈影响。现已对纯属宗教信仰的真实性进行了分析论证，证明等级行为在哲理上也是正当无咎的，正如霍贝斯（ThomasHobbes）论证国王神圣权利那样。同样，人以外的动物，有的动物甚至连灵长目都不是，但却能表现出少许的分析能力。自然对于海豚我也有同样的印象，正如在我的著作《宇宙联系》中所阐述的那样。</p>
<p>然而，只要我们头脑里还存有要求停止某些行为的禁锢时，我们就把生活中礼仪、等级领域看成是受爬虫复合体的强烈影响，并认为是与我们的爬虫动物祖先共有的；我们认为生活中的利他主义、感情和宗教领域在相当大的程度上位于边缘系统，并与我们非灵长目的哺乳动物（可能还有鸟类）祖先共有，认为理性是新皮质的一种功能，并在某种程度上同高级灵长目动物以及象海豚鲸鱼这种鲸目动物所共有。当礼仪、感情和推理是我们人本质的重要领域时，抽象的联想力和推理能力几乎是人独有的特征。好奇心和解决问题的迫切愿望就是我们人类感情的标志。数学、科学、技术、音乐、艺术——这些比通常包括在“人文学科”范围更广泛一点的学科都是人所特有的活动。就“人文学科”这个词的通常用法来说，它好象是研究人的观察力，但这肯定是一种特别狭义的理解，实际上数学既是诗歌也是人文学，鲸鱼和海豚同人一样具有“人道”。</p>
<p>三位一体的脑模式来源于有关比较神经解剖学和行为的研究。但对人种来说，直诚的内省不是不可知的。如果三位一体的脑模式是正确的话，我希望在人类自我认识的历史中，对这一模式能得到某些启示。弗洛伊德（Sismund Freud）把人的精神状态划分为三种：“本我”（id）、自我”（ego)、“超我”（Superego)。这又使人们联想起广泛周知的三位一体脑的假说。爬虫复合体的攻击和性的行为同弗洛伊德描述的“以德”是完全一致的（在拉丁词中是“it”，即人的兽性）。但据我所知，弗洛伊德在描述“以德”时，并没强调爬虫复合体的礼仪和社会等级范畴。他把感情说成是“自我”功能。尤其是“无边无际的灵性感受”，对弗洛伊德来说，这是宗教神灵的等同词，但是“超我”却根本没有被说成是抽象推理部分，而是内在的社会和亲本结构。我们可以设想这一部分在三位一体的脑中具有较多的爬虫复合体的功能。这样一来，我只能勉强地根据三位一体的脑模式来描述人的三种心理状态。</p>
<p>可能较恰当的隐喻是弗洛伊德的思维划分法，他将思维分为有意识的、前意识的和无意识的三种。前意识是潜在的、但能发掘的功能；无意识是被抑制或是没有显示出来的功能；这是存在于各个心理组成部分中的张力。弗洛伊德在谈到人时，他认为人的神经官能症的能力是其文化发展能力的相对应面。他将无意识功能称为“原始过程”。</p>
<p>在《柏拉图对话集》的《费德鲁斯》（Phaedrus）一节中，可以得出有关人心理隐喻的一种论点。苏格拉底把人的灵魂同双轮马拉战车联系起来。这辆战车由黑白两匹马向不同方向牵拉着，而驾车人却无力地驾驭着。这个隐喻同麦克莱恩的神经框架的比喻是极其相似的。两匹马喻比爬虫复合体和边缘系统，歪歪斜斜疾驰的双马战车的驾驭者意指新皮质。可在另一个隐喻中，弗洛伊德把自我功能说成是一匹难驾驭马的骑乘者。弗洛伊德和柏拉图的隐喻都强调了心理组成部分之间的张力，各组成部分相当大的独立性，以及表征人的状态的观点，这点我以后还要讲到的。由于三个组成部分之间存有神经解剖联系，三位一体脑本身必定象费德鲁斯的双轮马车一样是个隐喻而已，但这可能将被证实，这是一个用处很大、含义极深的隐喻。</p>
<h3 id="人脑揭秘"><a href="#人脑揭秘" class="headerlink" title="人脑揭秘"></a>人脑揭秘</h3><p>您所能想到的每种动物都有脑，无论是哺乳类、鸟类、爬行类、鱼类，还是两栖类。但人脑是独一无二的，它让我们能够思考、计划、说话、想象……脑真是一个奇妙的器官。</p>
<p>脑的作用有很多：<br>控制体温、血压、心率和呼吸。<br>接受由您的感官（视觉、嗅觉、听觉、味觉等）感受到的大量外界信息。<br>控制行走、说话、站立或坐等身体运动。<br>使您能够思考、做梦、推理和体验感情。<br>所有这些活动都是由一小颗花耶菜大小的器官来协调、控制和调节的，这个器官就是：脑。<br>人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论<br>人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论</p>
<p>人脑揭秘<br>人类有三个大脑？——“脑的三位一体”理论<br>人类有三个大脑？——“脑的三位一体”理论    人类有三个大脑？——“脑的三位一体”理论<br>人体的脑、脊髓以及周围神经构成了一个精密复杂的综合信息处理及控制系统。研究脑和神经系统的学科叫做神经科学或神经生物学。由于神经科学涉及的领域较广，加之脑和神经系统比较复杂，因此本文将从基本知识入手，为您概述这一奇妙的器官。<br>在本文中，我们将了解脑的结构及其各组成部分的功能。通过大致地了解人脑，您将能够理解运动控制、视觉信号处理、听觉信号处理、感知、学习、记忆、情感等概念，我们将在以后的章节中详细阐述这些概念。<br>神经元结构<br>脑由大约1000亿个称为神经元的神经细胞组成。神经元有强大的电化学信号采集和传送能力——这恰好类似于计算机中的电路和电线。神经元细胞有着和其他细胞一样的特征和结构, 但其电化学特征使其能够远距离（可达几米）相互传递信号。<br>神经元的基本组成部分有三个：<br>细胞体——这个主要组成部分含有细胞必需的所有成分，如细胞核（含DNA）、内质网和核糖体（用于合成蛋白）、线粒体（用于生成能量）。如果细胞体死亡，神经元就会死亡。<br>轴突——神经细胞的长索状突出部分，沿着细胞传递电化学信息（神经冲动或动作电位）。<br>根据神经元种类，轴突可能覆盖着一层薄膜，即髓鞘，就像是绝缘电线。髓鞘由脂肪组成，可加快神经冲动沿轴突传播。有髓鞘的神经元主要位于周围神经（感觉和运动神经元）中，而无髓鞘的神经元则位于脑和脊髓中。<br>树突或神经末梢——神经细胞的树枝状细小突出，可与其他细胞连接，实现神经元之间的信息传递并感知环境。树突可以位于细胞的一端或两端。</p>
<p>基本神经元结构<br>神经元大小各异。例如，手指中的单个感觉神经元的轴突会延伸至整个手臂，而脑中的神经元可能只延伸几毫米。神经元依据功能的不同，其形状也各有不同。控制肌肉收缩的运动神经元，一端是细胞体，中间是长轴突，另一端则是树突；而感觉神经元两端都有树突，中间由长轴突连接，轴突上还连接着细胞体。</p>
<p>几种类型的神经元：运动神经元、感觉神经元、皮质锥体细胞<br>几种类型的神经元：运动神经元、感觉神经元、皮质锥体细胞</p>
<p>神经元的功能也各有不同：<br>感觉神经元将外部机体（末梢）信号传递到中枢神经系统。<br>运动神经元将中枢神经系统的信号传递到外部机体（肌肉、皮肤、腺体）。<br>感受器感知环境信号（化学物质、光线、声音、触碰），并将这些信息进行编码，转换成可由运动神经元传导的电化学信号。<br>中间神经元连接脑和脊髓中的各种神经元。<br>最简单的神经通路是单突触（单联接）反射通路，如膝跳反射。医生用叩诊锤敲击膝盖的特定部位时，感受器通过感觉神经元将信号传送到脊髓；感觉神经元再将信息传递给控制腿部肌肉的运动神经元；神经冲动沿运动神经元传递并刺激对应肌肉进行收缩。该反应是一种肌肉反射，过程十分快速，并不涉及脑。人类有很多类似的基本（hard-wired）反射，但随着任务越来越复杂，反射通路的“线路”也更错综复杂并且需要用到脑。<br>最简单的生物神经系统可能仅仅由反射通路构成。例如，叶状软体蜗虫和无脊椎动物都没有集中式脑，它们仅有由松散连接的神经元组成的简单反射通路。叶状软体蜗虫拥有一种单个神经元相互联系形成、遍布全身的神经网。<br>多数无脊椎动物（如龙虾）拥有多个简单“脑”，即由神经细胞聚集组成神经节。每个神经节都通过反射通路控制其对应节段的感觉和运动功能，同时神经节之间相互连接形成简单的神经系统。随着神经系统的进化，神经节链进化为更集中的简单脑。</p>
<p>脑的主要分区<br>脊髓<br>脑干<br>小脑<br>前脑<br>间脑——丘脑、下丘脑<br>脑皮质<br>脑由无脊椎动物的神经节进化而来。无论是何种动物，脑都可分为以下几个部分：</p>
<p>脑干——脑干由髓质（上端脊髓的膨大部分）、脑桥和中脑组成（低等动物只有髓质）。脑干控制反射、自动功能（如心率，血压）、肢体运动和内脏功能（消化、排尿）。<br>小脑——小脑整合来自前庭系统的位置和运动信息，并用这些信息协调肢体运动。<br>下丘脑和脑垂体——控制内脏功能、体温，以及进食、饮水、性反应、攻击及愉悦等行为反应。<br>大脑（也叫做脑皮质或简称皮质）——大脑由皮质、大纤维束（胼胝体）和一些深部结构（基底神经节、杏仁核、海马）组成。它整合来自所有感觉器官的信息、激发运动功能、控制情感、保存记忆和思维过程（情感表达和思考在高等动物中更为普遍）。</p>
<p>脑部对比图形</p>
<p>从鱼类到人类，您会发现皮质越来越大，所占比例也越来越大，并且出现褶皱。增大的皮质负责更高等级的功能，例如信息处理、语言、思维和记忆。另外，叫做丘脑的部分将来自脑干和脊髓的信息传递到脑皮质。<br>人体内的“鱼脑”？<br>低等动物（鱼类、两栖类、爬行类、鸟类）的“思维活动”很少，它们更关心觅食、进食、饮水、睡眠、繁殖和自我保护等日常活动。因此，它们的脑主要由控制这些功能的区域组成。我们也可以完成这些功能，所以我们的体内也有一个“爬行动物”的脑。</p>
<p>脑的下部是脑干和颅神经。<br>脑的下部是脑干和颅神经。</p>
<p>低等动物的脑</p>
<p>低级脑的基本组成部分包括脊髓、脑干和间脑（小脑和皮质同样存在，但在稍后部分讨论）。每个结构中都有名为髓核的神经细胞中枢，它们均有特定功能（呼吸、调节心率、睡眠）。</p>
<p>脊髓<br>脊髓可以看作是与脑分离的器官，或者仅是脑干向下的延伸部分。它含有来自于身体的感觉和运动反射通路，以及脑的上行和下行通路。脊髓中含有不依赖于脑的反射通路，如膝跳反射中的那样。</p>
<p>髓质——包含用于调节血压和呼吸的髓核，还包含用于传递由感觉器官发出的、源自颅神经的信息的髓核。<br>脑桥——脑桥含有将来自小脑的运动位置信息传递至皮质的髓核，也有与呼吸、味觉、睡眠相关的髓核。<br>中脑——中脑的髓核联系脑中与运动功能（小脑、基底神经节、大脑皮质）、眼部运动、听力控制有关的各个部分。其中一部分叫做黑质，与自主运动有关。当其功能丧失时就会发生帕金森氏病的震颤性运动。<br>丘脑——丘脑将外来的感觉通路传递到大脑皮质的相应区域，决定哪些感觉信息传导到意识以及哪些信号参与小脑、基底神经节、皮质之间的运动信息交换。<br>脑垂体——脑垂体含有控制脑垂体分泌激素的髓核。这些中枢支配有性繁殖、进食、饮水、生长、母性行为（如哺乳动物泌乳）。脑垂体还参与绝大多数行为，包括与日夜循环相关的生物“钟”（昼夜节律）。</p>
<p>低级脑的内部视图<br>低级脑的内部视图</p>
<p>小脑位于脑桥的后上方，并褶皱形成许多叶。它接收来自脊髓的感觉神经信息、来自皮质和基底神经节的运动信息，以及来自前庭系统的位置信息。然后小脑将这些信息进行整合并影响从脑出发的输出运动通路，以协调运动。为说明这一点，请伸手触摸身前的某一点，如计算机显示器——手会完成一个顺滑的动作。如果小脑受损，这个动作将变得非常僵硬，因为皮质会发出一系列导向目标点的肌肉微缩信号。小脑也会参与语言表达（控制唇部和喉部肌肉的细微收缩），以及其他认知功能。</p>
<p>人脑主要内部结构<br>高等动物的脑</p>
<p>大脑是人脑中最大的组成部分。皮质内包含有所有接受和处理感觉信号、触发运动、分析信息、推理和表达情感的中枢。分管这些功能的中枢位于皮质的不同区域。了解皮质各区域的功能前，让我们先了解一下各区域的分布。<br>大脑皮质的主要部分<br>皮质占据了人脑外表面的主要部分。脑的表面积约为1500到2000平方厘米，相当于一到两页报纸。将这么大的表面积装进颅骨时，皮质会发生折叠，形成褶（脑回）和沟（脑沟）。几条大的脑沟将皮质分为下述几叶：前叶、顶叶、枕叶和颞叶，每种叶均有不同功能。</p>
<p>将鼠标移到人脑各部分的标签上，可以看到其在人脑中对应的位置。<br>从上往下看时，一条大脑沟（大脑纵裂）将人脑分为左右两个半球。左右半球通过一束称为胼胝体的白质纤维结构进行信息交流。同时，两侧颞叶还通过靠近脑后部另一束称为前连合的纤维进行交流。</p>
<p>人脑主要内部结构-</p>
<p>如果能看到大脑的切面图，就可以发现一条脑沟将胼胝体以上的皮质区分为两半，这条脑沟称为扣带沟。扣带沟和胼胝体之间的区域叫做扣带回，又称为边缘系统或边缘叶。大脑内部是基底神经节、杏仁核和海马。<br>硬线连接：大脑之间的连接</p>
<p>大脑之间的连接是“硬线连接”，正如高楼或飞机用电线进行硬线连接一样。在脑中，所有连接均由神经元构成，通过皮质各叶中的中枢连接感受传入通路和运动传出通路，这些皮质中枢与人脑的其他区域之间也有连接。<br>大脑的某些区域具有特定功能：<br>顶叶——顶叶负责接收和处理所有的躯体感觉信号（触觉、痛觉）。<br>由脊髓分出的纤维，经过丘脑分配，到达顶叶各区域。<br>这些连接在顶叶内构成了一幅机体表面的“地图”，称为脑投射图。<br>脑投射图看起来有些奇怪，因为每个区域在图中按照感觉神经元连接的数目显示，与该区域的实际大小无关。（有关是什么决定了脑投射图的详细信息，请参见What Does Your “Homunculus” Look Like?Mapping Your Brain）</p>
<p>脑投射图，一幅机体的感受“地图”。脑投射图看起来有些奇怪，因为每个区域在图中按照感觉神经元连接的数目显示，与该区域的实际大小无关。<br>脑投射图，一幅机体的感受“地图”。脑投射图看起来有些奇怪，因为每个区域在图中按照感觉神经元连接的数目显示，与该区域的实际大小无关。</p>
<ul>
<li>顶叶后部（靠近颞叶的区域）有一块称为韦尼克氏区的区域，该区域对于理解与语言相关的感觉（听觉和视觉）信息非常重要。这块区域的损伤会造成“感觉性失语”，即患者不能理解语言的内容，但是可以发出声音。</li>
<li>额叶——额叶与运动（包括语言）和认知功能有关。</li>
<li>脑部的运动中枢（中央前回）位于额叶尾部、顶叶前方。它接收顶叶躯体感觉的连接信号，处理、触发运动功能。和顶叶中的脑投射图一样，中央前回也有运动区域的投射图（有关详细信息，请参见A Science Odyssey:You Try It - Probe the Brain Activity）。</li>
<li>额叶左侧有块区域，称为布罗卡氏区，控制用于发出声音的肌肉（嘴、唇和喉）。这块区域的损伤会造成“运动性失语”，即患者可以理解语言的内容，但只能发出无意义或模糊的声音。</li>
<li>额叶其他区域与联想功能（思维、学习和记忆）。</li>
</ul>
<p>脑功能区域模式图</p>
<ul>
<li>枕叶——枕叶负责接收和处理从眼睛直接传送过来的视觉信息，并将这些信息与顶叶（韦尼克氏区）和运动- 皮质（额叶）相关联。其功能之一在于处理从眼睛晶状体角膜投射到视网膜上的倒置图像。</li>
<li>颞叶——颞叶处理来自耳朵的听觉信息，并将之与顶叶的韦尼克氏区、额叶的运动皮质相关联。</li>
<li>脑岛——脑岛影响脑干的自动功能。比如，屏住呼吸时，脑岛的神经冲动会抑制髓质的呼吸中枢，脑岛同时还处理味觉信息。</li>
<li>海马——海马位于颞叶内，对短时记忆非常重要。</li>
<li>杏仁核——杏仁核位于颞叶内，控制社会行为、性行为以及其他情绪。</li>
<li>基底神经节——基底神经节与小脑共同协作，调控精细运动，例如指尖动作。</li>
<li>边缘系统——边缘系统控制情绪性行为和内脏肌肉（消化道和体腔器官的肌肉）的运动。<br>脑里面的水分</li>
</ul>
<p>脑和脊髓包裹着一系列坚韧的脑脊膜，可保护这些器官，避免其受到颅骨和脊柱的擦伤。同时，脑和脊髓还漂浮在颅骨和脊柱内的脑脊液中，以增强保护。这种缓冲液体由脑中的脉络丛组织产生，流经一系列腔室（脑室），最后，从脑部流出，沿脊髓流下。脑脊液与供血之间由血脑屏障隔开。</p>
<p>脑室系统<br>脑室系统</p>
<p>正如您所见，人脑是一个复杂精密、高度分化的器官，它控制机体的一切行为。在您了解了人脑的解剖结构之后，可以参阅其他文章，以了解其特定功能。</p>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[影评--阿修罗]]></title>
      <url>http://noparkinghere.top/2017/03/06/2017/2017-03-06-%E5%BD%B1%E8%AF%84-%E9%98%BF%E4%BF%AE%E7%BD%97/</url>
      <content type="html"><![CDATA[<p>简书笔友 @见月酱 美女的一篇文章让我知道了这部争议较大的电影，由于个人对这些新奇题材有着特殊的偏好，几乎各种受争议的禁片，限制级片，小众剧情片等，都会特地去看一遍。</p>
<p>首先看这部片子可谓是一波三折，最初也是简友推荐 B 站可以在线观影，然后去看了下，看一点点，发现一直无法显示人物配音，但背景声音很大，虽然画质和背景都不错，但没配音显然看不下去，于是尝试着去找片源，找了多个资源网站，奈何叫<strong>阿修罗</strong>这个名字的片子实在太多，不知道下载哪个，于是通过咨询等多次尝试终于刷新页面可以播放有配音的视频了。但天色不早该休息了，结果第二天尝试打开又没有声音了，之后试过多次，各种原因，反正最后在第 5 天（也就是昨天）才将该电影在手机上面看完的。</p>
<p>言归正传，这边说下该电影的观后感吧，该电影给人的留下了算是比较深刻的印象：画质出众，内容写实，寓意深刻。</p>
<h3 id="画质出众"><a href="#画质出众" class="headerlink" title="画质出众"></a>画质出众</h3><p>作为一部日本动漫来讲，出色的画质，配音可以说已经是司空见惯了，但并不是每部电影都能够将主题与画质相融合的，这部电影，就画质，配乐，配音等而言，都算是很出彩的，人物设计整体偏灰暗，当然中间部分场景特意渲染的唯美，但也是为了凸显这种反差，日本声优配音等都可以甩开国漫好几条街，这部电影的配音也很到位，尤其是片头的一段。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-06-影评-阿修罗/1.png" alt=""></p>
<a id="more"></a>
<h3 id="内容写实"><a href="#内容写实" class="headerlink" title="内容写实"></a>内容写实</h3><p>电影《阿修罗》是由1970年的漫画改编而来的电影，在2012年上映。时隔四十多年才被动画化，但上映之后仍是引起了巨大的争议。内容写实，主要体现在题材过于血腥，将卖女儿，食人肉，食子等有背现代社会价值观的内容搬上大银幕，这些题材出现让很多观众无法接收。就这方面题材表现而言这部动画，还是比较到位的，不似某些误导人的国内作品（男女主角牵个手就怀孕了，女英雄大吼一声就把敌人撕了）虽然说动画拍摄部分，已经有意的将这些镜头给过滤掉了，仅仅通过血或者他人的话语来表现这些情节，但这边我个人认为剧情内的表现都还算完整，可以接收。</p>
<h3 id="寓意深刻"><a href="#寓意深刻" class="headerlink" title="寓意深刻"></a>寓意深刻</h3><p>同一部作品，见仁见智。个人认为这部作品的寓意深刻，可以多多方面多个人物进行探讨：</p>
<ul>
<li>阿修罗的母亲，首先可以看出是一个充满母性的人物，但由于日久的极度饥饿，丧失了理智，对自己的孩子（阿修罗）下手了。前后反差之大不禁让人唏嘘，这边我们可以探讨下，该母亲在面对突发状况时，如遇到恶犬等袭击自己的孩子，可以冒着危险，去抵挡。有一点点食物时，虽然自己也吃不饱，但仍然会给自己孩子喂奶。然而当数日，日积月累的饥饿已经让自己丧失了思考能力的时候，不得不说人饥饿的本性也会掩盖其他所有的一切，尤其是当这种侵蚀并非一撮而就的时候。我们通过前面可以发现，有理由相信该母亲是爱孩子，为了孩子可以不惜生命，但当饥饿到已经没有力气去思考的时候，又会如何呢？</li>
<li>若狭是个善良漂亮的女孩子，看似善良温婉的背后却看出一颗坚强的内心。最初应该是表现在他待阿修罗，白天需要干农活，傍晚或者夜间需要背着阿修罗给他弄吃的等等，这种体力劳动并不轻松。第二次表现在她和对象约会，约会的过程被阿修罗撞见了，然后为了保护她的对象，毅然决然的赶走了阿修罗，这种艰难取舍的心理并不容易做到，首先她自己清楚什么最重要，能够立下决定可见她是个果断坚定的人。最后一点表现在若狭的死，蝼蚁尚且偷生，但有原则的人恰逢乱世一般都容易短命，通过若狭这个人物我们可以看到现代教育的影子，若狭如果生活在现在一定会是家长眼中的好孩子，领导眼里的好下属，但也仅此而已，高尚的教育+坚定的原则在特殊时候也许反而会毁了一个人；若狭的死同时可以让我们看出，对于自己不想活的人，即便他人在努力也无法挽救你，阿修罗的眼泪恰是这段结局最好的证明。</li>
<li>阿修罗这个人物是里面刻画最简单的人物，他唯一的目标就是吃掉活物，让自己生存。而恰恰是这种目标同人类社会的价值观相违背，引发出了一堆的事端。当人们日子丰衣足食的时候，所有人都鄙视指责破坏者（阿修罗吃人肉），而当天灾人怨颗粒无收时，这种为了几斗米折腰（卖女儿，沦为鹰犬，偷东西，吃人头等）却还要带着虚伪面具的行为无疑在影片结尾极具讽刺。人生而杀生，食肉，让自己活下来是人性（动物）的本能，阿修罗从小经历了人生的疾苦，同时也见到了若狭恪守人性的光辉，最终入世出世遁入佛门。</li>
</ul>
<hr>
<p>写作时间：21:30-22:33</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[关闭朋友圈，你将获得什么？]]></title>
      <url>http://noparkinghere.top/2017/03/06/2017/2017-03-06-%E5%85%B3%E9%97%AD%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%8C%E4%BD%A0%E5%B0%86%E8%8E%B7%E5%BE%97%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>偶然看到<a href="http://www.jianshu.com/p/409982e5ecb1" target="_blank" rel="external">关掉朋友圈的一年，我用手机记录了什么（春夏篇）</a>文章，突然想起来自己关闭微信朋友圈这个功能也有很长一段时间了（实在想不起来是什么时候关闭的），于是萌生了写这篇文章的兴趣，谈论这个问题前，我们先讨论一个问题：<strong>开通朋友圈，你获得了什么？</strong></p>
<h3 id="开通朋友圈，你获得了什么？"><a href="#开通朋友圈，你获得了什么？" class="headerlink" title="开通朋友圈，你获得了什么？"></a>开通朋友圈，你获得了什么？</h3><p>很多人每天花大量的时间刷朋友圈，有人是经常自己发朋友圈，而有的人却是默默的只看别人发布的内容。那么又有多少人考虑过朋友圈给你带来了什么呢？</p>
<ul>
<li>刷存在感（秀恩爱，晒美食，炫富，旅游，晒娃，等），经常发布朋友圈内容的人，往往需要博取别人的关注，来满足自己的虚荣心。</li>
<li>无聊的人打发时间，经常可以刷朋友圈，看看别人美好的生活，然后再自己意淫一下。</li>
<li>看别人分享的文章内容，增长自己的见识，关注热点。</li>
<li>靠朋友圈赚钱，发广告等。</li>
<li>获取最新的广告咨询，没准哪家店铺又出了新活动呢！</li>
<li>通过朋友圈别人的分享，学习新知识技能。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-06-关闭朋友圈，你将获得什么？/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="你确认你获得的不是假象？"><a href="#你确认你获得的不是假象？" class="headerlink" title="你确认你获得的不是假象？"></a>你确认你获得的不是假象？</h3><p>然而以上六点只能作为还在逛朋友圈的你安慰自己又浪费了半个小时的借口，当然，如果你最不缺的就是时间，可以当我没说。如果还有耐心看完此文，我们从以上 6 点一个个的进行分析。</p>
<h4 id="刷存在感"><a href="#刷存在感" class="headerlink" title="刷存在感"></a>刷存在感</h4><p>刷存在感，确实对于某些人来说可以得到心灵上面的满足，让自己成为朋友圈中的焦点（虽然舞台不大，但同样当了回明星）。但对于现代社会来说未必是好事，通过一些技术手段，有心之人很容易获取你的个人信息，包括并不仅限于照片，电话，地理位置，爱好，作息等。没准你的照片早已被挂上了多个交友网站了呢，或者被别人冒名使用了。部分人连身份证等信息也轻易泄露，网络可以搜出来身份证扫描件号码，都已被绑定了 5 个以上的微信号，除此之外，你的用户数据也会被各大商家（包括并不限于腾讯）拿去做了数据挖掘和分析，因此无论是腾讯推送给你的朋友圈广告，还是你经常收到的房产电话，都不仅是偶然。</p>
<h4 id="打发时间"><a href="#打发时间" class="headerlink" title="打发时间"></a>打发时间</h4><p>对于这种爱好的话，我也没有什么好说的，但觉得长此以往不利于个人的身心健康，回归现实世界，多出去走走，你会发现生活更美好。</p>
<h4 id="和时代接轨"><a href="#和时代接轨" class="headerlink" title="和时代接轨"></a>和时代接轨</h4><p>首先，你的朋友未必就在事发现场，你的朋友圈未必都是记者和狗仔，我相信大多数人的朋友圈对时事热点的更新远远没有新闻或者微博来的即时。每天花点时间去看看新闻也许你会发现你获得信息会更多，而不必时不时地担心又读到了一篇谣言。</p>
<h4 id="广告赚钱"><a href="#广告赚钱" class="headerlink" title="广告赚钱"></a>广告赚钱</h4><p>毕竟不是做这一行的，不清楚靠在朋友圈发广告到底可以引来多少关注和收益，但我清楚的了解，绝大多数人对朋友圈的广告都是很厌烦的。如果你的广告确确实实可以带给别人价值，那么建议可以去开通一个微信公共账号，发一些高品质的广告，而不是在朋友圈时时刻刻广告刷屏。</p>
<h4 id="获取广告"><a href="#获取广告" class="headerlink" title="获取广告"></a>获取广告</h4><p>O2O 时代，使用微信线下做生意，线上提供最新的咨询，这种模式还是广受欢迎的，因此许多人也许确实需要获取一些店家咨询和信息，但靠朋友圈发广告信息，用户看到的几率有多大？就目前我知道的线上信息一般有是那种都比朋友圈更加高效主流，其一是建立微信群，定期发通知；其二，公共账号发布消息；其三，群发消息。</p>
<h4 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h4><p>姑且不谈朋友圈的谣言有多少，我们讨论下朋友圈的信息对你有用的究竟有多少，微信定位是代替手机通讯录，因此，微信的好友可以说全是你的社交上面认识的人。而现代社会分工很详细明确，社交好友在工作，技能，生活阶层等方方面面可以说都和你有着千差万别，即便你有部分具备你需求技能的朋友，但可能他们未必会发朋友圈或者很少发朋友圈，因此通过朋友圈来学习东西现在是最不环保的。如果有学习的需求，可以去各种在线教育平台，了解一些问题可以去知乎，认识更多志同道合的朋友也可以通过社交媒体，微信公共账号可是个可以获得最新咨询和观点的绝佳平台。</p>
<h3 id="关闭朋友圈，你将获得什么？"><a href="#关闭朋友圈，你将获得什么？" class="headerlink" title="关闭朋友圈，你将获得什么？"></a>关闭朋友圈，你将获得什么？</h3><p>听说朋友圈已经去掉了小红点功能，没去考察过，不知道是不是真的。关闭了朋友圈，你能够获得的好处多多，最显而易见的两点就是：专注和时间。</p>
<p>朋友圈虽然占用的时间并不多，但一些人可能有刷朋友圈的强迫症，即便没有你什么事情，你也会一拿起手机就习惯性地刷新下朋友圈。长此以往不利于你注意力的集中，且会断断续续的浪费你很多可以完成别的事情的时间。</p>
<p>往其他方面讲，关闭朋友圈后，你再也不必看到某些人天天自恋晒照了，再也不会刷到一条条广告，以及看到腾讯广告中其他好友各种装逼言论了，毋容置疑，你的世界会清静下来很多。</p>
<p>最后这边再补充一点，朋友圈某好友，经常会发布自己的美照，但某次聊天意外发现其实她朋友圈一般都是关闭的，只是在想要晒照的时候会手动开启下朋友圈发张图。这件事告诉我们，大家的时间都很金贵，你在刷着别人的朋友圈时，没准别人其实并没有关注你们，她的分享也许只是 APP 自动生成，或者一键转载，她发的照片或者只是为了花一分钟过把自拍瘾。当你在忙着刷着别人朋友圈内容时，别人或许早已关闭了朋友圈，让自己全身心地投入到工作生活中去了。</p>
<hr>
<p>写作时间：21:10-22:27</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力lab--运动]]></title>
      <url>http://noparkinghere.top/2017/03/05/2017/2017-03-05-%E8%87%AA%E6%8E%A7%E5%8A%9Blab-%E8%BF%90%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>随着最近十多年来经济的发展和人民生活物质越来越充足，如何提高生活品质开始成为越来越多人所追求的目标。人民不再需要多吃养起肉来才可以抵挡随时可能到来的饥寒，相反越来越多的人因为食物的充足而暴饮暴食，他们的体重从起走上了不归路。健康饮食，锻炼身体成了最近几年全民关注的话题。</p>
<p>最近加入了运动训练营，主要目的是培养自己的运动习惯，改掉一些不良的毛病，这几年下来，由于个人从事电脑方面的工作，一天到晚坐着盯着电脑（从早到晚），下班后，甚至还会玩玩游戏，看看视频，或者再盯着电脑学点东西。虽然早就意识到这样的习惯肯定有问题，但奈何自己之前也没什么运动习惯/爱好。想跑步锻炼身体，但找不到合适的场景和氛围，之前做了几次，后来也就没下文了。其他的一些运动项目，貌似也需要的条件过多，自己并不能满足。思来想去，最终加入了这个训练营，也期望借此可以养成每天运动的小目标。</p>
<h3 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h3><p>截止写本文开始，已经完成该运动训练营三天，这边说下感受，参加之前对此次训练可以说是零认识，不知道锻炼什么，也不知道锻炼多久等等。加入三天后，目前是以 seven 作为每日必备的锻炼目标，其他内容根据个人喜好而选择不做强求。</p>
<p>经过三天的训练，我发现 seven 确实可以算是一个优秀的 APP ，之前虽然下载过不少这种软件，但没怎么用过，首先 seven 设定每次的锻炼时长为 7 分多钟，这个时长让大多数人都可以接收，毕竟也就上个厕所，喝杯茶的时间，如果是十多分钟或者二十分钟的话，每次完成运动就需要算好自己是否有连续的这么长时间可以利用。此外，seven 的一次训练多组动作，动作难度也不大，一般人都能够完成，且动作之间有数秒休息，动作的不断切换让人可以感觉到这种节奏感和活力，往往更加能够激发人去运动。</p>
<p>由于太长时间没有运动，这几天做完一组 seven 还是会感觉全身酸痛，但精神状态很不错。就目前我的状态而言，这款软件还是很适合我的，每天花费少量的时间并且能够培养运动习惯。</p>
<p>说完运动类 APP 再来说下队友，一个锻炼注定的乏味无聊的，在小组中，给自己找了个队友，两人一起互相监督，坚持运动会好很多。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-05-自控力lab-运动/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="计划安排"><a href="#计划安排" class="headerlink" title="计划安排"></a>计划安排</h3><ul>
<li>每天一组 seven 运动。</li>
<li>快走+慢跑，具体里程根据身体情况而定，天晴时，一周至少两次，一次 0.5h 以内。</li>
<li>不跑步时，锻炼哑铃，每周至少两次，一次 0.5h 以内。</li>
</ul>
<h3 id="运动军令状"><a href="#运动军令状" class="headerlink" title="运动军令状"></a>运动军令状</h3><p>本人在此郑重承诺，在第五期运动训练营期间，本人将全力以赴，永不放弃，确保在此期间达到以下目标：每日坚持锻炼，完成上述计划安排，养成良好的运动习惯。</p>
<p>如有未达到目标，就破费请队友吃一顿大餐以做惩罚。如达到目标，将让队友请我吃一顿大餐已做奖励。百分百对自己的承诺负责，绝不食言！**</p>
<p>兑现日：2017/05/10 请 201705F029紫荆~魔都 监督。</p>
<p>本人签字：damon</p>
<p><strong>军令如山，势必达成！</strong></p>
<p>_加油！加油！加油！</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力周总结]]></title>
      <url>http://noparkinghere.top/2017/03/04/2017/2017-03-04-%E8%87%AA%E6%8E%A7%E5%8A%9B%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>参加<strong>自控力lab</strong>的训练营有了一周的时间，且写作这边也完成了 6 篇，运动训练进行了 3 天。这篇文章算是一篇周总结吧。</p>
<p>应该来说这周的进展还是比较混乱或者失败的，首先是作息时间并没能够有效的改善，反而因为写作/运动任务等导致时间更加不够了，晚上也更忙了。可以看出计划的安排略显不合理，或者个人精力不够新动力欠缺。</p>
<h3 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h3><p>下面讲详细叙述下情况目前一段时间的时间表：</p>
<ul>
<li>工作日 17:00 后开始上英语课</li>
<li>17:30 之后阅读推荐书籍</li>
<li>看完书后一般在 18:10-18:30 去吃晚餐，晚餐加散步在 1h 左右</li>
<li>一般 19:30 左右才开始写文章，写作时间不固定，技术类文章 2h 大概完成个初稿，随笔类文章一般在 1h 左右</li>
<li>由于刚开始参加自控力lab，且报了多个训练营，第一周连续多日网上直播课程或者上课，且一般都需要一个多小时，约从 20:30-21:30/22:00 中间这一段时间也忙不了别的事情（即便写作效率也很低）</li>
<li>课程结束后，群聊或者私聊等又会占用部分时间，不知不觉，下一个任务就得在 22:30 之后才可以开始执行了</li>
<li>22:30 开始学英语单词等内容，一般占用 1h </li>
<li>运动 seven 的时间 10 分钟左右</li>
<li>洗漱等杂务，最终基本上也在 00:00 以后了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-04-自控力周总结/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h3><ul>
<li>训练营课程内容所花费的时间是绝对可以优化的，可以其他时间采用回放等方式获取信息。</li>
<li>目前需要插入运动时间（跑步等内容），初期设想是 20:30 之后，这段时间可以课程时间进行错开，跑完步后花时间回听课程会更好</li>
<li>学习时间，除了以上安排的内容外，个人设想是晚上还要有 2h 左右的学习时间。</li>
<li>英语的学习内容较多，算是长期打卡的一个任务了，但占用时间未免过多，且都拖拉到睡觉前，一方面不利于休息，另外一方面效率不高，后续可以安排到早上完成任务。</li>
<li>起床时间过晚，一直恶有性循环显然是不明智的，下一阶段，最主围绕早睡早起为主，只有这个实现了，其他目标才有可能达成。</li>
<li>每日写作学习时间需要更专注些，切勿在聊天时写作，在看视频时背单词等等，专注至少可以让效率提升一倍。</li>
<li>每天的写作时间可以控制在 1.5h 小于这个时间的话，可以为第二天写作做准备，合理控制时间，不超过这个时间。</li>
</ul>
<hr>
<p>写作时间：21:15-22:00</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[搜索资源必备网站]]></title>
      <url>http://noparkinghere.top/2017/03/03/2017/2017-03-03-%E6%90%9C%E7%B4%A2%E8%B5%84%E6%BA%90%E5%BF%85%E5%A4%87%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>又是一个周末，今天的文章准备总结一下个人的在搜索资源上面的一些技巧，作为一个网龄超过 10 年的用户，我也算是经历了互联网的几个发展阶段，多年上网的经历也让我对互联网查找资源颇有一番心得。</p>
<p>其实查找资源并非一件容易的事情，尤其是对如今这个版权至上的年代而言，要想找一些自己想要的电影资源，学习视频，小说书籍等已经变得很不容易了。如果你觉得麻烦，又土豪的话花钱去观看那些阉割版的视频当然也没有问题。</p>
<h3 id="历史回顾"><a href="#历史回顾" class="headerlink" title="历史回顾"></a>历史回顾</h3><p>互联网找资源也算是分为多个发展阶段，这边我只从我开始接触互联网的时候谈起。起初互联网可以说是缺乏监管甚至是没有监管的，那时候各种网站随便上，银行也没有自己的网站，淘宝，优酷等网站也起步没多久。</p>
<p>那时候找资源可以通过百度去直接搜索，想要什么东西，基本都可以通过迅雷或者网际快车下载到，一些种子资源也可以通过电驴进行直接搜索。起初的 VeryCD 上面有不少的教程电影等等，几乎互联网上面见得了光的资源都可以在 VeryCD 上面下载到。百度可以搜索盗版软件等也很多，随便一搜就可以搜到不少的破解软件，访问国外的网站也都是可以，只是可能速度不会太快。后来随着视频网站等的崛起，慢慢的人们更加喜欢看在线视频了，但画质不高，不少提供资源的网站仍然可以下载高清的片源。</p>
<p>然而，事情不可能总是一如既往的美好，随着监管力量的进入，一条条壁垒被架设起来，最出名的当然属于 GFW ，这边不详细讨论。随着这两年对互联网监管力量的加大，只是偶然找找资源的小伙伴们也发现，很多资源过去能够搜到，现在基本上搜不出来了，或者搜出来无法访问。百度网盘中的内容不能再查看了，360云盘等多家网盘相继倒闭了。很多人一时无所适从，不知道能够去哪儿找资源了，因为他们只会用百度，然而百度作为业界最良心的一家公司，搜娱乐八卦还有广告的技术绝对登峰造极。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-03-搜索资源必备网站/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h3><p>好了，言归正传，这边推荐一些搜索资源比较给力的搜索引擎或网站:</p>
<ul>
<li><a href="http://www.loldytt.com/" target="_blank" rel="external">LOL电影天堂</a>：一个搜索电影资源的好网站，片源不算太多，但重要的是更新比较的及时，弹出广告也相对较少。</li>
<li><a href="http://www.lbldy.com/" target="_blank" rel="external">龙部落</a>：也是一个视频搜索网站，专注于最新电视剧，电影等。</li>
<li><a href="http://www.verycd.com/sto/datum/" target="_blank" rel="external">VeryCD</a>：老牌的搜索网站了，网站经过多次波折，多次整改，最终算是幸存了下来，但相关资料资源没有提供版权出处的话均被不提供下载，这边又不得不提它的克隆网站<a href="http://www.xuexi111.com/" target="_blank" rel="external">学习库</a>，你可以认为该网站就是 VeryCD 的完整版。</li>
<li><a href="http://www.panduoduo.net/" target="_blank" rel="external">盘多多</a>：一个比较出众的网盘搜索工具，主要收录的视频教程较多，通过该网站可以找到绝大多数公开的视频教程。</li>
<li><a href="http://pan.ape8.cn/" target="_blank" rel="external">百度网盘搜索引擎</a>：主要是针对百度网盘进行资源的检索，搜索到资源的几率还行。</li>
<li><a href="http://www.xilinjie.com/" target="_blank" rel="external">西林街</a>：同样是一个搜索资源的工具，不同的是，该网站主要是捕捉其他网站的搜索结果，然后讲内容呈现出来，基本上不被和谐的资源，绝大多数在该网站是能够被找到的，查找一些老电影等还是比较给力的。</li>
<li><a href="http://www.zoudupai.com/" target="_blank" rel="external">走读派</a>:可以用来搜索一些电子书记，资源不多，但还算可以</li>
<li><a href="http://www.kindlepush.com/main" target="_blank" rel="external">kindle推</a>：爱阅读的小伙伴十之八九都有个 kindle ，这个网站主要就是提供 kindle 书籍的资源，按照教程可以将书记直接推送到 kindle 上。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>暂时就只介绍这么多，知道以上这么多网站差不多已经可以检索到国内互联网的大多数教程，书籍，影片了。这边不准备推荐种子搜索的网站（大多数不正规，非法，随时无法访问），或者国外的网站，毕竟大多数人无法访问。补充说明下，如果你需要检索学术工作相关的文档之类的，建议还是科学上网，使用<a href="http://www.Google.com" target="_blank" rel="external">谷歌</a>，你会惊奇的发现，百度找了几天都找不到，甚至要付费的文档，谷歌一搜就出现在第一个。</p>
<hr>
<p>写作时间：21:30-22:52</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[70天读写计划安排]]></title>
      <url>http://noparkinghere.top/2017/03/01/2017/2017-03-01-70%E5%A4%A9%E5%86%99%E4%BD%9C%E8%AE%A1%E5%88%92%E5%AE%89%E6%8E%92/</url>
      <content type="html"><![CDATA[<p>报名参加<strong>自控力读写训练营</strong>，主要目的是：希望提高写作技巧，效率和养成写作习惯，以及认识更多有趣的朋友，希望 70 天后能够达成我所设想的目标。</p>
<p><em>下面详细说下读和写的安排计划：</em></p>
<h3 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-01-70天写作计划安排/1.jpg" alt=""></p>
<a id="more"></a>
<p>随话说，没有输入就没有输出，婴儿在学会说之前也都会有较长一段时间的沉默期，因为他们只有将输入（大人说的话）转换为自己的认知才可能创造输出（说话）。几乎任何人都不可能凭空创造出与这个世界完全不同的东西，当今几乎社会所有的创新都是站在了前人的肩膀上。</p>
<p>个人认为相比于看视频，听广播而言，阅读是更好的一种输入方式，因为它可以给你更多的想象和思考。想要有好的输入，选择阅读的书籍至关重要，下面列出我选择的书单：</p>
<ul>
<li>《自控力 》：1-10周，每周按后面练习完成相关计划</li>
<li>《月亮和六便士》：1-10周，慢慢阅读</li>
<li>《写出我心：普通人如何通过写作表达自己》：1-2周阅读</li>
<li>《微习惯》：3-4周阅读</li>
<li>《哈弗虚拟写作课：怎样讲一个好故事》：5-6周阅读</li>
<li>《超级阅读术》：7-8周阅读</li>
</ul>
<p>预留两周时间，总结思考之前阅读的内容。</p>
<h3 id="写作计划"><a href="#写作计划" class="headerlink" title="写作计划"></a>写作计划</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-03-01-70天写作计划安排/2.png" alt=""></p>
<p>输出和输入同样重要，通常我们输入的目的就是为了更好的输出，而输出又可以反作用于输入，能够更好的总结自己创造新的价值。这边来说说个人的读写安排吧，参加这个集训营之前写过大半年的文章，最开始的设想是想要将去年准备写的一些文章给整理写完，去年一共大概有超过 80 篇文章，但真正整理写完的估计 1/2 都不到，之前个人写文一般都还是集中在自学学习和研究的计算机领域，因此文章的题材也多是技术类，这类文章的特点就是需要不断查找翻阅大量的资料，然后实验验证排查，最终将自己的理解总结出来。</p>
<h3 id="主要写作"><a href="#主要写作" class="headerlink" title="主要写作"></a>主要写作</h3><p>上面已经描述过，个人的状况，因此 70 的集训营个人读写会以补全之前的技术博客文章为主，涉及：编程，操作系统，软件安装，软件教程等等。</p>
<h3 id="辅助写作"><a href="#辅助写作" class="headerlink" title="辅助写作"></a>辅助写作</h3><p>辅助写作的文章题材可以各式各样，为了锻炼自己的写作能力，也会去尝试不同的题材，大致有：</p>
<ul>
<li>书籍读后感</li>
<li>电视，电影观后感</li>
<li>电子产品吐槽</li>
<li>当前一些实事的看法</li>
<li>过往学习经验的总结</li>
</ul>
<hr>
<h3 id="今日小结："><a href="#今日小结：" class="headerlink" title="今日小结："></a>今日小结：</h3><p>中途看了好几条微信消息，虽然今天完成文章较快不到 1h，但毕竟内容不多，这样的文章全神贯注，应该可以控制在半小时之内的，还有提高的空间。</p>
<p>写作时间：19:39-20:25</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）程序的内存分配方式 for c/c++]]></title>
      <url>http://noparkinghere.top/2017/03/01/2017/2017-03-01-%EF%BC%88%E8%BD%AC%EF%BC%89%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-for-c-c/</url>
      <content type="html"><![CDATA[<p>本篇文转载文章，博主只进行了简单的排版和少量的修改，可以查看<a href="http://lib.csdn.net/article/c/41000" target="_blank" rel="external">原文出处</a>，另外文章的内容仍然不是阐述的很清晰，关于 C 和内存的关系也查看过很多资料很多内容描述的都不太一样，暂时认为本文写的还算详细可取，因此转载过来。</p>
<h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><p>内存分配方式有三种：</p>
<ul>
<li>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</li>
<li>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</li>
</ul>
<a id="more"></a>
<h3 id="程序的内存空间"><a href="#程序的内存空间" class="headerlink" title="程序的内存空间"></a>程序的内存空间</h3><p>一个程序将操作系统分配给其运行的内存块分为4个区域，下面为<strong>程序内存空间</strong>:</p>
<ul>
<li>代码区(code area)    </li>
<li>全局数据区(data area)</li>
<li>堆区(heap area)</li>
<li>栈区(stack area)</li>
</ul>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分:</p>
<ul>
<li>栈区（stack）：由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。</li>
<li>堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。</li>
<li>全局区（静态区）（static）：存放全局变量、静态数据、常量。程序结束后由系统释放。</li>
<li>文字常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放。</li>
<li>程序代码区：存放函数体（类成员函数和全局函数）的二进制代码。</li>
</ul>
<p>下面给出例子程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></div><div class="line">	<span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> b; <span class="comment">//栈</span></div><div class="line">	<span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈</span></div><div class="line">	<span class="keyword">char</span> *p2; <span class="comment">//栈</span></div><div class="line">	<span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456在常量区，p3在栈上。</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></div><div class="line">	p1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</div><div class="line">	p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</div><div class="line">	<span class="comment">//分配得来得和字节的区域就在堆区。</span></div><div class="line">	<span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="堆与栈的比较"><a href="#堆与栈的比较" class="headerlink" title="堆与栈的比较"></a>堆与栈的比较</h3><h4 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h4><ul>
<li>stack: 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间。</li>
<li>heap: 需要程序员自己申请，并指明大小，在C中malloc函数，C++中是new运算符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); p1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</div><div class="line">如p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</div><div class="line">但是注意p1、p2本身是在栈中的。</div></pre></td></tr></table></figure>
<h4 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h4><ul>
<li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li>
</ul>
<p>对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。</p>
<p>由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h4 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h4><ul>
<li>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。</li>
<li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li>
</ul>
<h4 id="申请效率的比较"><a href="#申请效率的比较" class="headerlink" title="申请效率的比较"></a>申请效率的比较</h4><ul>
<li>栈由系统自动分配，速度较快。但程序员是无法控制的。</li>
<li>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</li>
</ul>
<p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是栈，而是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。</p>
<h4 id="堆和栈中的存储内容"><a href="#堆和栈中的存储内容" class="headerlink" title="堆和栈中的存储内容"></a>堆和栈中的存储内容</h4><ul>
<li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li>
<li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li>
</ul>
<h4 id="存取效率的比较"><a href="#存取效率的比较" class="headerlink" title="存取效率的比较"></a>存取效率的比较</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char <span class="built_in">s1</span>[] = <span class="string">"a"</span><span class="comment">;</span></div><div class="line">char *<span class="built_in">s2</span> = <span class="string">"b"</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<p>a是在运行时刻赋值的；而b是在编译时就确定的；但是，在以后的存取中，<strong>在栈上的数组比指针所指向的字符串(例如堆)快。</strong> 比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>　<span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> a = <span class="number">1</span>;</div><div class="line">	<span class="keyword">char</span> c[] = <span class="string">"1234567890"</span>;</div><div class="line">	<span class="keyword">char</span> *p =<span class="string">"1234567890"</span>;</div><div class="line">	a = c[<span class="number">1</span>];</div><div class="line">	a = p[<span class="number">1</span>];</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的汇编代码:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>: a = c[<span class="number">1</span>];</div><div class="line"><span class="symbol">00401067 </span><span class="number">8</span>A <span class="number">4D</span> F1 mov cl,byte ptr [ebp-<span class="number">0</span>Fh]</div><div class="line"><span class="number">0040106</span>A <span class="number">88</span> <span class="number">4D</span> FC mov byte ptr [ebp-<span class="number">4</span>],cl</div><div class="line"><span class="number">11</span>: a = p[<span class="number">1</span>];</div><div class="line"><span class="number">0040106D</span> <span class="number">8</span>B <span class="number">55</span> EC mov edx,dword ptr [ebp-<span class="number">14</span>h]</div><div class="line"><span class="symbol">00401070 </span><span class="number">8</span>A <span class="number">42</span> <span class="number">01</span> mov al,byte ptr [edx+<span class="number">1</span>]</div><div class="line"><span class="symbol">00401073 </span><span class="number">88</span> <span class="number">45</span> FC mov byte ptr [ebp-<span class="number">4</span>],al</div></pre></td></tr></table></figure></p>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>堆和栈的主要区别有以下几点：</p>
<ul>
<li>管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</li>
<li>空间大小不同：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。</li>
<li>碎片问题不同：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构。</li>
<li>生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</li>
<li>分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li>
<li>分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</li>
</ul>
<p>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址， EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p>
<p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。</p>
<h3 id="new-delete与malloc-free比较"><a href="#new-delete与malloc-free比较" class="headerlink" title="new/delete与malloc/free比较"></a>new/delete与malloc/free比较</h3><p>从C++角度上说，使用new分配堆空间可以调用类的构造函数，而malloc()函数仅仅是一个函数调用，它不会调用构造函数，它所接受的参数是一个unsigned long类型。同样，delete在释放堆空间之前会调用析构函数，而free函数则不会。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="built_in">Time</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="built_in">Time</span>(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">string</span>);</div><div class="line">		~<span class="built_in">Time</span>()</div><div class="line">		&#123;</div><div class="line">			cout&lt;&lt;<span class="string">"call Time's destructor by:"</span>&lt;&lt;name&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">	　　<span class="built_in">int</span> <span class="built_in">hour</span>;</div><div class="line">	　　<span class="built_in">int</span> min;</div><div class="line">	　　<span class="built_in">int</span> sec;</div><div class="line">	　　<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Time</span>::<span class="built_in">Time</span>(<span class="built_in">int</span> h,<span class="built_in">int</span> m,<span class="built_in">int</span> s,<span class="built_in">string</span> n)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">hour</span>=h;</div><div class="line">	min=m;</div><div class="line">	sec=s;</div><div class="line">	name=n;</div><div class="line">	cout&lt;&lt;<span class="string">"call Time's constructor by:"</span>&lt;&lt;name&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="built_in">Time</span> *t1;</div><div class="line">	t1=(<span class="built_in">Time</span>*)malloc(sizeof(<span class="built_in">Time</span>));</div><div class="line">	free(t1);</div><div class="line">	<span class="built_in">Time</span> *t2;</div><div class="line">	t2=<span class="keyword">new</span> <span class="built_in">Time</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">"t2"</span>);</div><div class="line">	delete t2;</div><div class="line">	system(<span class="string">"PAUSE"</span>);</div><div class="line">	return EXIT_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　call Time<span class="string">'s constructor by:t2</span></div><div class="line">　　call Time's <span class="function"><span class="keyword">destructor</span> <span class="title">by</span>:</span>t2</div></pre></td></tr></table></figure></p>
<p>从结果可以看出，使用new/delete可以调用对象的构造函数与析构函数，并且示例中调用的是一个非默认构造函数。但在堆上分配对象数组时，只能调用默认构造函数，不能调用其他任何构造函数。</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/u010070526/article/details/41748043" target="_blank" rel="external">http://blog.csdn.net/u010070526/article/details/41748043</a><br><a href="http://lib.csdn.net/article/c/41000" target="_blank" rel="external">http://lib.csdn.net/article/c/41000</a><br><a href="http://blog.csdn.net/wellhead/article/details/4506180" target="_blank" rel="external">http://blog.csdn.net/wellhead/article/details/4506180</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wget下载整个网站]]></title>
      <url>http://noparkinghere.top/2017/03/01/2017/2017-03-01-wget%E4%B8%8B%E8%BD%BD%E6%95%B4%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>当我们看到一个优秀的网站，但上网却不是太方便的时候，往往将网页保存下来，然后离线浏览是最佳选择，但是对于一些教程，因为目录下的文章较多，有的动辄上百篇文章，无疑一个个保存网页肯定效率低下不现实。这边我们推荐使用 wget 这个工具来获取保存整个网站/目录下的内容。</p>
<p>需要下载某个目录下面的所有文件。命令如下</p>
<p><code>wget -c -r -np -k -L -p www.xxx.org/pub/path/</code></p>
<p>在下载时。有用到外部域名的图片或连接。如果需要同时下载就要用-H参数。</p>
<p>例如： <code>wget -c -r -np -k -L -p http://akaedu.github.io/book/</code></p>
<a id="more"></a>
<p>或者也可以使用如下方式：</p>
<p>wget –no-check-certificate –recursive –no-clobber –domains website.org –no-parent www.website.org/xxx</p>
<p>–recursive 现在整个网站</p>
<p>–domains 指定下载的域，将不会下载其它域的文件</p>
<p>​–no-parent 不下载父链接的内容，很重要，能减少不必要的循环</p>
<p>–no-clobber 不重复下载一个文件​</p>
<p>​–no-check-certificate 不检查网站认证信息</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.sina.com.cn/s/blog_4ddef8f80102vtq2.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4ddef8f80102vtq2.html</a><br><a href="http://www.cnblogs.com/lidp/archive/2010/03/02/1696447.html" target="_blank" rel="external">http://www.cnblogs.com/lidp/archive/2010/03/02/1696447.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自控力学习日计划表]]></title>
      <url>http://noparkinghere.top/2017/02/28/2017/2017-02-28-%E8%87%AA%E6%8E%A7%E5%8A%9B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%A1%E5%88%92%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="70-天工作日计划表："><a href="#70-天工作日计划表：" class="headerlink" title="70 天工作日计划表："></a>70 天工作日计划表：</h3><ul>
<li>6:50左右 前起床</li>
<li>7:00-7:30 出门，散步，买早餐</li>
<li>7:30-8:00 扇贝单词，高效率 0.5h 完成，其他扇贝任务日碎片时间中完成。</li>
<li>8:00-8:15 在公司，整体桌面，打水，文章整理，制定日计划</li>
<li>8:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-17:20 在线英语学习</li>
<li>17:20-18:00/18:20 阅读推荐书籍</li>
<li>18:00/18:20-19:00 晚餐、散步时间</li>
<li>19:00-20:30 完成相关写作内容</li>
<li>20:30-21:00 运动时间</li>
<li>21:00-21:15 洗漱</li>
<li>21:15-22:45 自我学习时间，完成相应学习计划</li>
<li>22:45-23:15 休息娱乐，看一集美剧或动漫</li>
<li>23:20之前 入睡</li>
</ul>
<p>10 周阅读 6本书籍，&lt;自控力&gt;按章节计划内容执行，其他书籍两周阅读一本。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-02-28-自控力学习日计划表/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="当前现状"><a href="#当前现状" class="headerlink" title="当前现状"></a>当前现状</h3><p><em>以上内容，当然对于现在的我来说是不可能完成的，否则的话，我应该已经算是一个高自控力的达人了，上述内容算是 70 天的一个目标，计划是 8-9 周可以达成该目标，最后一周可以确切的执行该目标。</em></p>
<ul>
<li>07:50左右 前起床</li>
<li>08:00-08:15 吃早饭，去公司</li>
<li>08:15-12:00 上午工作时间</li>
<li>12:00-13:00 午饭，稍做休息</li>
<li>13:00-17:00 下午工作时间</li>
<li>17:00-17:20 在线英语学习</li>
<li>18:00-19:30 晚餐、散步和休息时间</li>
<li>19:30-22:30 学习或者娱乐</li>
<li>22:30-23:59 扇贝英语</li>
<li>00:30左右 入睡</li>
</ul>
<p>目前基本上可以保证英语的学习时间，其他时间不能固定，因为工作等原因，个人极度缺乏锻炼，因此后续锻炼身体将会作为重点提高项目。</p>
<h3 id="拟定计划"><a href="#拟定计划" class="headerlink" title="拟定计划"></a>拟定计划</h3><p>经过分析，暂时会分为 5 个阶梯步骤来完成，其中每两周作为一个阶段，循序渐进的接近最终的目标，涉及范围：作息，运动，自学，英语。</p>
<h4 id="第一阶段（02-28-03-05）"><a href="#第一阶段（02-28-03-05）" class="headerlink" title="第一阶段（02.28-03.05）"></a>第一阶段（02.28-03.05）</h4><ul>
<li>更改作息时间：7:30左右起床，23:50之前入睡</li>
<li>早晨完成部分英语单词的学习，剩余内容晚上完成</li>
<li>每天锻炼半小时</li>
<li>傍晚阅读推荐书籍半小时以上</li>
<li>每天一篇文章</li>
<li>其余时间暂时不做限定</li>
</ul>
<p>完成情况：作息时间未能按计划完成，每天完成了一组 seven 运动，阅读时间基本上满足要求，每天完成了一篇写作。</p>
<p>小结：仍然需要很多进行改进，但第一周作为摸索阶段，要求不宜过高。</p>
<h4 id="第二阶段（03-05-03-19）"><a href="#第二阶段（03-05-03-19）" class="headerlink" title="第二阶段（03.05-03.19）"></a>第二阶段（03.05-03.19）</h4><ul>
<li>修改作息时间，7:30左右起床</li>
<li>早晨完成一组 seven </li>
<li>17:00-18:20 上英语课和阅读</li>
<li>两个小时的学习时间</li>
<li>晚上 9:30 前完成 写作计划</li>
<li>完成当日写作内容</li>
<li>23:30左右入睡</li>
</ul>
<hr>
<p>待定…</p>
<h3 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h3><p>为了达成计划，需要不断的完善自己，充分利用各种技巧。</p>
<hr>
<p>写作时间：7:30-8:20，9:30-10:00，总时长超过一个半小时。<br>写作同时忙别的，不够专注，需要改正。</p>
<p>未完待续…</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何更好地用简书写作]]></title>
      <url>http://noparkinghere.top/2017/02/27/2017/2017-02-27-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%94%A8%E7%AE%80%E4%B9%A6%E5%86%99%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>出于个人想提高个人写作技巧和培养写作习惯的目的，所以加入了<strong>自控力lab</strong>的小组 70 天的计划。虽然在简书上面已经混迹多日，但却没能发现一个简书阅读写作的说明书。在加入这个写作计划前，个人开通了博客，且部分文章也发在了简书这个平台上面了。基于上述原因，个人准备写一个简书的写作使用说明，以供各位简书新人参考。</p>
<p><em>推荐各位如果有条件的话，最好采用网页版编辑文字，效率高，体验佳。</em></p>
<h3 id="Markdown-带来优质的写作体验"><a href="#Markdown-带来优质的写作体验" class="headerlink" title="Markdown 带来优质的写作体验"></a>Markdown 带来优质的写作体验</h3><p>之所以使用简书这个平台，很大一部分原因是简书拥有其他博客所不具备的良好的阅读和写作体验。简书之所以能够带来良好的写作体验是因为支持目前十分流行的 Markdown 语法。</p>
<p>默认简书使用的是富文本编辑方式，这种方式的特点是能够类似于 word 之类的软件，生成很多花哨的内容，但是书写起来极为复杂，如：<code>{\[rtf](http://baike.baidu.com/view/18817.htm)1\ansi\ansicpg936\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fmodern\fprq6\fcharset134 \&#39;cb\&#39;ce\&#39;cc\&#39;e5;}}{\*\generator Msftedit 5.41.21.2500;}\viewkind4\uc1\pard\lang2052\f0\fs20 Hello World!\par}</code> 很显然这样的书写方式一般只能借助工具进行排版，但是 Markdown解决了这样的问题。</p>
<p>Markdown 的优点就是文章所有排版都通过文字符号来完成，且一学就会，只要有一个 Markdown 解析器，就可以达到你的排版效果，跨平台，易移植，不需要依赖 word 等排版工具，同时 Markdown 写出来的文章也可以通过一些转换工具，直接转成 PDF 文档。</p>
<p>听起来 Markdown 好像很高端，但确实非常简单易学，这边再提供一个<a href="http://www.zealer.com/post/725.html" target="_blank" rel="external">Markdown体验视频</a>，视频仅供娱乐参考，介绍的不系统不详细，下面将会详细介绍下 Markdown 语法。为了让大伙儿学起来不困难，这边只会挑常用的一些语法进行陈述。</p>
<p>简书默认是上述提及的富文本编辑方式，如果使用 Markdown 语法的话，需要先设置下，在个人页面基础设置中选用 Markdown 即可，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img//2017-02-27-如何更好地用简书写作/1.png" alt="设置"></p>
<a id="more"></a>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>Markdown 通过 <code>#</code> 来表示标题的等级，具体如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line"></div><div class="line">## 二级标题</div><div class="line"></div><div class="line">### 三级标题</div><div class="line"></div><div class="line">。。。。。。</div></pre></td></tr></table></figure>
<p>这边建议大家从三级标题开始沿用，一级标题就是你文章的题目，已经被文章所占用，二级标题和一级标题样式大小区分不是太明显，且多个平台上面二级标题都会过大，产生一种很奇怪的布局效果。</p>
<h4 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h4><p>通过使用 <code>**加粗**</code> 这种样式，可以将一个一段文字进行加粗设置，学会了这个，你再也不需要每次选中文字，然后点工具栏的加粗工具了。</p>
<h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>有粗体的样式，自然就有斜体，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法，如：<code>*斜体*</code></p>
<p><strong>以上粗体和斜体，需要注意 <code>*</code> 前后切勿加入空格，否则可能会无法转换格式。</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>在 Markdown 下，列表的显示只需要在文字前加上 - 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。<strong>注意：一定要加空格。</strong></p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>现在码字写文章，一般都讲究图文并茂的书写，一个好的图片往往才是吸引别人点开你文章的要素，markdown 当然也具备载入图片的功能啦！具体格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">图片</span>](<span class="link">http://mat1.gtimg.com/www/images/qq2012/qqlogo_1x.png</span>)</div></pre></td></tr></table></figure>
<p>很长的一段是不是很吓人？其实就分三部分：</p>
<ul>
<li><code>!</code> 代表这边引用的是图片</li>
<li><code>[]</code> 中代表的是图片的名称，可以不填</li>
<li><code>()</code> 中才是真正图片的链接地址</li>
</ul>
<p>所以就是这种格式： <code>![](网上链接)</code>。</p>
<p>简书有个很好的特点就是，你所使用的外链图片在文章发表后会转存为简书的图片，能够完全不影响阅读体验，同时，你的文章再次编辑或者打包下载时，里面的外链原始地址不会更改。</p>
<p><em>以下为扩展内容，一般写作的话不一定用的上，不需要详细了解：</em></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>注意用 <code>|</code> 分隔符号隔开，<code>|</code> 前后可以加入或不加入空格，<code>-</code> 个数不限，第二行的内容不能少，下面是具体案例语法格式：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">学号 |<span class="string"> 姓名 </span>|<span class="string"> 分数</span></div><div class="line">- |<span class="string"> - </span>|<span class="string"> -</span></div><div class="line">小明 |<span class="string"> 男 </span>|<span class="string"> 75</span></div><div class="line">小红 |<span class="string"> 女 </span>|<span class="string"> 79</span></div><div class="line">小陆 |<span class="string"> 男 </span>|<span class="string"> 92</span></div></pre></td></tr></table></figure>
<p>实际呈现效果如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>分割线的语法只需要另起一行，连续输入三个星号 <em>*</em> 即可。</p>
<h4 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h4><p>插入链接与插入图片的语法很像，区别在一个 <code>!</code> 号，格式为：<code>[文字](网上链接)</code>。</p>
<h4 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h4><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 <code>把中间的代码包裹起来，如</code>code`，你可以使用 `` 将包括内容，特殊内容就不会自动转换格式了。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>如果你需要引用一小段别处的句子，那么就要用引用的格式：<code>&gt; 例如这样</code></p>
<p><code>只需要在文本前加入 &gt; 这种尖括号（大于号）即可。</code></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当然简书也并非尽善尽美，在 Markdown 的体验效果上面还是存在不少的缺陷的，比如：</p>
<ul>
<li>书写时无法对的标记符进行高亮突出</li>
<li>无法自动补充你下一个符号如：引用，列表等</li>
<li>缺少一键生成格式的快捷键</li>
<li>预览无法与文章做到实时同步，预览内容过长需要手动去上下拖动，无法跟随同步。</li>
<li>Markdown 实际生成的页面显示布局虽然还算不错，但仍然可以进一步提高。</li>
</ul>
<p>因此如果你对 Markdown 很偏爱的话，可以使用第三方的编辑工具编辑后再粘贴到简书，或者期待简书下一个版本的更新。多说无意，这边直接给出本文原稿的下载链接，有兴趣的朋友可以直接下载<a href="https://raw.githubusercontent.com/noparkinghere/blog.github.io/master/source/_posts/2017/2017-02-27-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E7%94%A8%E7%AE%80%E4%B9%A6%E5%86%99%E4%BD%9C.md" target="_blank" rel="external">本文原稿</a>，然后复制到简书的编辑器中预览编辑查看效果。</p>
<h3 id="分屏预览技巧"><a href="#分屏预览技巧" class="headerlink" title="分屏预览技巧"></a>分屏预览技巧</h3><p>码字时，通过点击简书右上角的一个预览按钮，即可完成分配预览，如下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-02-27-如何更好地用简书写作/2.png" alt=""></p>
<h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>不久前，也就是 2017 年开始，简书的经过了大改版，在原有体验的基础上面，增加了夜间模式，具体操作如下：点击你简书页面右上角的 Aa 图标（头像左边），点击第一个选项就可以设置为夜间模式。</p>
<h3 id="博客文章迁移"><a href="#博客文章迁移" class="headerlink" title="博客文章迁移"></a>博客文章迁移</h3><p>很多时候博客类网站由于经营不善等原因，都存在一定的可能面临关闭或者倒闭，知名案例请问<strong>度娘</strong>。简书的所提供的方式，是目前为止，我所见到的最简洁人性化的解决方案，<code>点击头像-&gt;设置-&gt;账号管理-&gt;打包下载文章</code> 。下载后文章是一个压缩文件，里面所有的内容，就是你码字的内容，如果你采用的是 markdown 语法，你们你可以讲文章直接上传到任何支持 markdown 语法的网站，即可完成博客迁移，无需进行重新排版等操作。</p>
<hr>
<p>以上内容，主要适合于初次接触简书的用户码字，对于简书的老司机来说应该已经算是家常便饭了吧。看完全文，如有不明白的话，可以参考最下方的教程链接，也可以私信我或者加我微信号（见我个人空间的微信二维码）。</p>
<p>统计写作初稿时间：8:30pm-10:30pm 时间消耗较长，写作能力急需提高。</p>
<blockquote>
<p>参考资料：<br><a href="http://sspai.com/25137" target="_blank" rel="external">http://sspai.com/25137</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[按键防抖]]></title>
      <url>http://noparkinghere.top/2017/02/21/2017/2017-02-21-%E6%8C%89%E9%94%AE%E9%98%B2%E6%8A%96/</url>
      <content type="html"><![CDATA[<p><em>目前市面上按键繁多，有传统的机械按键也有目前比较流行的电容式触摸按键，这边所讨论的按键是传统使用的机械按键，并非新型的触摸电容按键。</em></p>
<p>通常按键所用的开关都是机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上就稳定的接通，在断开时也不会一下子彻底断开，而是在闭合和断开的瞬间伴随了一连串的抖动，如下图所示：</p>
<blockquote>
<p>参考链接：<br><a href="http://c.biancheng.net/cpp/html/1901.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/1901.html</a><br><a href="http://www.amobbs.com/thread-543529-1-1.html" target="_blank" rel="external">http://www.amobbs.com/thread-543529-1-1.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux-shadowsocks全局代理]]></title>
      <url>http://noparkinghere.top/2017/01/25/2017/2017-01-25-ss-linux%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>windows 直接下载 ss 终端，稍加设置即可完成全局代理，linux 用户如果需要让某个软件可以使用 ss 一般都需要连接端口才行。例如本地 ss 配置为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"server_port"</span>:1800,</div><div class="line"><span class="string">"local_port"</span>:1080,</div></pre></td></tr></table></figure></p>
<h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><p>这边就相当于将本地的 127.0.0.1:1080 和 server_ip:1800 建立了连接关系。因此软件如果需要使用 vps 上面搭建的 ss 服务的话，则需要让该软件使用的协议连接到 127.0.0.1:1080 上。之前在 vps-shadowsocks 中介绍的 chrome 插件 SwitchyOmega 就是使用 SOCKS5 协议连接到 127.0.0.1:1080 上，让所有数据通过 SOCKS5 协议，然后从 127.0.0.1:1080 进行收发。</p>
<p>可以看出如果我们需要让其他软件也能够使用 ss 则需要让他们也能够使用 127.0.0.1:1080 代理服务器，然而不幸的是，大多数软件并不支持代理服务的功能， windows 平台下的软件很多可以通过设置 IE 代理让其他软件使用代理服务（原理是：大多数软件都会优先读取 IE 的代理设置，再访问网络）。</p>
<a id="more"></a>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>linux 下有个软件： proxychains 解决了我们的所有问题，该软件可以通过 <code>sudo apt-get install proxychains</code> 下载安装，一般为 3.1 版本。当然也可以去下载安装<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">源码</a>，源码安装版本较新，需要自行编译安装，一般为 4.x 版本。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>man proxychains 我们可以看到 proxychains 读取的配置文件地址，这边我们自定义 ~/.proxychains/proxychains.conf 文件，写入如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">ins.conf  VER 3.1</div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.</span></div><div class="line"><span class="comment">#   </span></div><div class="line"></div><div class="line"><span class="comment"># The option below identifies how the ProxyList is treated.</span></div><div class="line"><span class="comment"># only one option should be uncommented at time,</span></div><div class="line"><span class="comment"># otherwise the last appearing option will be accepted</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#dynamic_chain</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Dynamic - Each connection will be done via chained proxies</span></div><div class="line"><span class="comment"># all proxies chained in the order as they appear in the list</span></div><div class="line"><span class="comment"># at least one proxy must be online to play in chain</span></div><div class="line"><span class="comment"># (dead proxies are skipped)</span></div><div class="line"><span class="comment"># otherwise EINTR is returned to the app</span></div><div class="line"><span class="comment">#</span></div><div class="line">strict_chain</div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Strict - Each connection will be done via chained proxies</span></div><div class="line"><span class="comment"># all proxies chained in the order as they appear in the list</span></div><div class="line"><span class="comment"># all proxies must be online to play in chain</span></div><div class="line"><span class="comment"># otherwise EINTR is returned to the app</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#random_chain</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Random - Each connection will be done via random proxy</span></div><div class="line"><span class="comment"># (or proxy chain, see  chain_len) from the list.</span></div><div class="line"><span class="comment"># this option is good to test your IDS :)</span></div><div class="line"></div><div class="line"><span class="comment"># Make sense only if random_chain</span></div><div class="line"><span class="comment">#chain_len = 2</span></div><div class="line"></div><div class="line"><span class="comment"># Quiet mode (no output from library)</span></div><div class="line"><span class="comment">#quiet_mode</span></div><div class="line"></div><div class="line"><span class="comment"># Proxy DNS requests - no leak for DNS data</span></div><div class="line">proxy_dns </div><div class="line"></div><div class="line"><span class="comment"># Some timeouts in milliseconds</span></div><div class="line">tcp_read_time_out 15000</div><div class="line">tcp_connect_time_out 8000</div><div class="line"></div><div class="line"><span class="comment"># ProxyList format</span></div><div class="line"><span class="comment">#       type  host  port [user pass]</span></div><div class="line"><span class="comment">#       (values separated by 'tab' or 'blank')</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#        Examples:</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#               socks5192.168.67.781080lamersecret</span></div><div class="line"><span class="comment">#       http192.168.89.38080justuhidden</span></div><div class="line"><span class="comment">#       socks4192.168.1.491080</span></div><div class="line"><span class="comment">#           http192.168.39.938080</span></div><div class="line"><span class="comment">#       </span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#       proxy types: http, socks4, socks5</span></div><div class="line"><span class="comment">#        ( auth types supported: "basic"-http  "user/pass"-socks  )</span></div><div class="line"><span class="comment">#</span></div><div class="line">[ProxyList]</div><div class="line"><span class="comment"># add proxy here ...</span></div><div class="line"><span class="comment"># meanwile</span></div><div class="line"><span class="comment"># defaults set to "tor"</span></div><div class="line">socks5 127.0.0.1 1080</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>输入 <code>proxychains curl www.google.com</code> 命令，我们可以看到提示内容，如果一直等待或者无法访问则代表设置失败。这是一种方法通过 proxychains + 命令。</li>
</ul>
<p><strong>这边值得注意的是使用 <code>proxychains curl www.google.com</code> 命令，博主一开始使用的是  <code>proxychains ping www.google.com</code> 一直无法 ping 通，也一致认为自己配置的有问题，后来才发现： ping 命令本身不调用 http ，socks5 等协议，ping也属于一个通信协议，是 TCP/IP 协议的一部分。而诸如：  http ，socks5，ssh 等都是基于 TCP/IP 或者 UPD 之上的协议，所以验证的时候一定要当心注意了使用其他调用 socks5 协议的软件才可以验证。</strong></p>
<ul>
<li>输入 <code>proxychains bash</code> 我们可以建立一个新的 shell 基于这个 shell 运行的所有命令和软件都会通过 <code>127.0.0.1:1080</code> 转发数据。</li>
</ul>
<p><strong>通过 proxychains 打开的软件，在使用时都会有详细的网络连接信息。</strong></p>
<p>补充一个问题：如果使用时出现 <code>ERROR: ld.so: object &#39;libproxychains.so.3&#39; from LD_PRELOAD cannot be preloaded: ignored.</code> 原因是无法找到 libproxychains.so.3 文件，可以通过 <code>find /usr/lib/ -name libproxychains.so.3</code> 找到具体路径，然后 <code>export LD_PRELOAD=你找到的路径</code> 。</p>
<h3 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h3><p>基于 <code>proxychains bash</code> 开启的所有软件都可以通过 ss 来访问外网，而这个 terminal 可以相当于是全局代理的，当然如果你需要设置整个系统都全局代理的话，应该也是可以修改 linux 下面的源码的，让密码认证通过后，启用的 login-bash 采用 proxychains 方式启用。这边未做详细研究，理论上可能可行。</p>
<hr>
<p><em>个人对网络研究很欠缺，如有错误还望指正。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.tuicool.com/articles/rUNFF3" target="_blank" rel="external">http://www.tuicool.com/articles/rUNFF3</a><br><a href="http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded" target="_blank" rel="external">http://askubuntu.com/questions/293649/proxychains-ld-preload-cannot-be-preloaded</a><br><a href="http://blog.csdn.net/yusiguyuan/article/details/24269129" target="_blank" rel="external">http://blog.csdn.net/yusiguyuan/article/details/24269129</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）中文技术文档的写作规范]]></title>
      <url>http://noparkinghere.top/2017/01/05/2017/2017-01-05-%EF%BC%88%E8%BD%AC%EF%BC%89%E4%B8%AD%E6%96%87%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E7%9A%84%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>这篇文章转自<a href="https://github.com/noparkinghere/document-style-guide" target="_blank" rel="external">阮一峰老师的 github 项目</a>，写博客也有一段时间了，也不断地修改格式排版等内容，但始终缺乏一个规范标准，直到看到这篇文章。文章中写的内容个人觉得大都算是在情在理，很适合像我这样用 markdown 写博客的人去遵循。</p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>标题分为四级。</p>
<ul>
<li>一级标题：文章的标题</li>
<li>二级标题：文章主要部分的大标题</li>
<li>三级标题：二级标题下面一级的小标题</li>
<li>四级标题：三级标题下面某一方面的小标题</li>
</ul>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul>
<li>一级标题下，不能直接出现三级标题。</li>
<li>标题要避免孤立编号（即同级标题只有一个）。</li>
<li>下级标题不重复上一级标题的内容。</li>
<li>谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</li>
</ul>
<a id="more"></a>
<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h2 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h2><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：本文介绍如何快速启动Windows系统。</div><div class="line"></div><div class="line">正确：本文介绍如何快速启动 Windows 系统。</div></pre></td></tr></table></figure>
<p>全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">正确：<span class="number">2011</span>年<span class="number">5</span>月<span class="number">15</span>日，我订购了<span class="number">5</span>台笔记本电脑与<span class="number">10</span>台平板电脑。</div><div class="line"></div><div class="line">正确：<span class="number">2011</span> 年 <span class="number">5</span> 月 <span class="number">15</span> 日，我订购了 <span class="number">5</span> 台笔记本电脑与 <span class="number">10</span> 台平板电脑。</div></pre></td></tr></table></figure>
<p>半角的百分号，视同阿拉伯数字。</p>
<p>英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：一部容量为 <span class="number">16</span> GB 的智能手机</div><div class="line"></div><div class="line">正确：一部容量为 <span class="number">16</span>GB 的智能手机</div></pre></td></tr></table></figure>
<p>半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：他的电脑是 MacBook Air 。</div><div class="line"></div><div class="line">正确：他的电脑是 MacBook Air。</div></pre></td></tr></table></figure>
<h2 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h2><ul>
<li>避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。</li>
<li>尽量使用简单句和并列句，避免使用复合句。</li>
</ul>
<h2 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h2><p>尽量不使用被动语态，改为使用主动语态。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：假如此软件尚未被安装，</div><div class="line"></div><div class="line">正确：假如尚未安装这个软件，</div></pre></td></tr></table></figure>
<p>不使用非正式的语言风格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！</div><div class="line"></div><div class="line">正确：无法参加本次活动，我深感遗憾。</div></pre></td></tr></table></figure>
<p>用对“的”、“地”、“得”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">她露出了开心的笑容。</div><div class="line">（形容词＋的＋名词）</div><div class="line"></div><div class="line">她开心地笑了。</div><div class="line">（副词＋地＋动词）</div><div class="line"></div><div class="line">她笑得很开心。</div><div class="line">（动词＋得＋副词）</div></pre></td></tr></table></figure>
<p>使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：从管理系统可以监视中继系统和受其直接控制的分配系统。</div><div class="line"></div><div class="line">正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。</div></pre></td></tr></table></figure>
<p>名词前不要使用过多的形式词。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。</div><div class="line"></div><div class="line">正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。</div></pre></td></tr></table></figure>
<p>单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。</div><div class="line"></div><div class="line">正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。</div></pre></td></tr></table></figure>
<p>同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：请确认没有接通装置的电源。</div><div class="line"></div><div class="line">正确：请确认装置的电源已关闭。</div></pre></td></tr></table></figure>
<p>避免使用双重否定句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：没有删除权限的用户，不能删除此文件。</div><div class="line"></div><div class="line">正确：用户必须拥有删除权限，才能删除此文件。</div></pre></td></tr></table></figure>
<h2 id="英文处理"><a href="#英文处理" class="headerlink" title="英文处理"></a>英文处理</h2><p>英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">英文：⋯information stored <span class="keyword">in</span> random <span class="keyword">access</span> memory (RAMs)⋯</div><div class="line"></div><div class="line">中文：……存储在随机存取存储器（RAM）里的信息……</div></pre></td></tr></table></figure>
<p>外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">U<span class="selector-class">.S</span><span class="selector-class">.A</span>.</div><div class="line">Apple, Inc.</div></pre></td></tr></table></figure>
<p>表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">英文：<span class="number">5</span> minutes later⋯</div><div class="line"></div><div class="line">中文：<span class="number">5</span> 分钟过去了⋯⋯</div></pre></td></tr></table></figure>
<p>英文书名或电影名改用中文表达时，双引号应改为书名号。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">英文：<span class="keyword">He</span> published <span class="keyword">an</span> article entitled <span class="string">"The Future of the Aviation"</span>.</div><div class="line"></div><div class="line">中文：他发表了一篇名为《航空业的未来》的文章。</div></pre></td></tr></table></figure>
<p>第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。</div></pre></td></tr></table></figure>
<p>专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">“American Association <span class="keyword">of</span> Physicists <span class="keyword">in</span> Medicine”（美国医学物理学家协会）是专有名词，需要大写。</div><div class="line"></div><div class="line">“online <span class="keyword">transaction</span> processing”（在线事务处理）不是专有名词，不应大写。</div></pre></td></tr></table></figure>
<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><ul>
<li>一个段落只能有一个主题，或一个中心句子。</li>
<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>
<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>
<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>
<li>段落之间使用一个空行隔开。</li>
<li>段落开头不要留出空白字符。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用第三方内容时，应注明出处。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">One <span class="keyword">man</span>’s constant <span class="keyword">is</span> another <span class="keyword">man</span>’s variable. — Alan Perlis</div></pre></td></tr></table></figure>
<p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本文转载自 WikiQuote</div></pre></td></tr></table></figure>
<p>使用外部图片时，必须在图片下方或文末标明来源。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本文部分图片来自 Wikipedia</div></pre></td></tr></table></figure>
<h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="半角数字"><a href="#半角数字" class="headerlink" title="半角数字"></a>半角数字</h2><p>数字一律使用半角形式，不得使用全角形式。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误： 这件商品的价格是１０００元。</div><div class="line"></div><div class="line">正确： 这件商品的价格是 <span class="number">1000</span> 元。</div></pre></td></tr></table></figure>
<h2 id="千分号"><a href="#千分号" class="headerlink" title="千分号"></a>千分号</h2><p>数值为千位以上，应添加千分号（半角逗号）。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XXX 公司的实收资本为 RMB1,<span class="number">258</span>,<span class="number">000</span>。</div></pre></td></tr></table></figure>
<p>对于 4 ～ 6 位的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于7位及以上的数值，千分号是必须的。</p>
<p>多位小数要从小数点后从左向右添加千分号，比如<code>4.234,345</code>。</p>
<h2 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h2><p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$<span class="number">1</span>,<span class="number">000</span></div><div class="line"><span class="number">1</span>,<span class="number">000</span> 美元</div></pre></td></tr></table></figure>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>表示数值范围时，用<code>～</code>连接。参见《标点符号》一节的“连接号”部分。</p>
<p>带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正确：<span class="number">132</span>kg～<span class="number">234</span>kg</div><div class="line">错误：<span class="number">132</span>～<span class="number">234</span>kg</div><div class="line"></div><div class="line">正确：<span class="number">67</span>%～<span class="number">89</span>%</div><div class="line">错误：<span class="number">67</span>～<span class="number">89</span>%</div></pre></td></tr></table></figure>
<h2 id="变化程度的表示法"><a href="#变化程度的表示法" class="headerlink" title="变化程度的表示法"></a>变化程度的表示法</h2><p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">增加到过去的两倍</div><div class="line">（过去为一，现在为二）</div><div class="line"></div><div class="line">增加了两倍</div><div class="line">（过去为一，现在为三）</div></pre></td></tr></table></figure>
<p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">降低到百分之八十</div><div class="line">（定额是一百，现在是八十）</div><div class="line"></div><div class="line">降低了百分之八十</div><div class="line">（原来是一百，现在是二十）</div></pre></td></tr></table></figure>
<p>不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>
<h1 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h1><h2 id="原则-2"><a href="#原则-2" class="headerlink" title="原则"></a>原则</h2><ul>
<li>中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。</li>
<li>如果整句为英文，则该句使用英文/半角标点。</li>
<li>句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</li>
</ul>
<h2 id="句号"><a href="#句号" class="headerlink" title="句号"></a>句号</h2><p>中文语句中的结尾处应该用全角句号（<code>。</code>）。</p>
<p>句子末尾用括号加注时，句号应在括号之外。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：关于文件的输出，请参照第 <span class="number">1.3</span> 节（见第 <span class="number">26</span> 页。）</div><div class="line"></div><div class="line">正确：关于文件的输出，请参照第 <span class="number">1.3</span> 节（见第 <span class="number">26</span> 页）。</div></pre></td></tr></table></figure>
<h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><p>逗号<code>，</code>表示句子内部的一般性停顿。</p>
<p>注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>
<h2 id="顿号"><a href="#顿号" class="headerlink" title="顿号"></a>顿号</h2><p>句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。</div><div class="line"></div><div class="line">正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。</div></pre></td></tr></table></figure>
<p>英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook <span class="keyword">and</span> other components.</div></pre></td></tr></table></figure>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>分号<code>；</code>表示复句内部并列分句之间的停顿。</p>
<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：许多人都认为客户服务的核心是“友好”和“专业”。</div></pre></td></tr></table></figure>
<p>引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”</div></pre></td></tr></table></figure>
<h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>补充说明时，使用全角圆括号<code>（）</code>，括号前后不加空格。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：请确认所有的连接（电缆和接插件）均安装牢固。</div></pre></td></tr></table></figure>
<h2 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h2><p>全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。</div></pre></td></tr></table></figure>
<p>表示时间时，应使用半角冒号（<code>:</code>）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：早上 8<span class="selector-pseudo">:00</span></div></pre></td></tr></table></figure>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>省略号<code>……</code>表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>
<p>省略号不应与“等”这个词一起使用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。</div><div class="line"></div><div class="line">正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……</div><div class="line"></div><div class="line">正确：我们为会餐准备了香蕉、苹果、梨等各色水果。</div></pre></td></tr></table></figure>
<h2 id="感叹号"><a href="#感叹号" class="headerlink" title="感叹号"></a>感叹号</h2><p>应该使用平静的语气叙述，尽量避免使用感叹号<code>！</code>。</p>
<p>不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>
<h2 id="破折号"><a href="#破折号" class="headerlink" title="破折号"></a>破折号</h2><p>破折号<code>————</code>一般用于做进一步解释。破折号应占两个汉字的位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。</div></pre></td></tr></table></figure>
<h2 id="连接号"><a href="#连接号" class="headerlink" title="连接号"></a>连接号</h2><p>连接号用于连接两个类似的词。</p>
<p>以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>
<ul>
<li>两个名词的复合</li>
<li>图表编号</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">例句：氧化-还原反应</div><div class="line"></div><div class="line">例句：图 <span class="number">1</span><span class="number">-1</span></div></pre></td></tr></table></figure>
<p>以下场合应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>
<ul>
<li>数值范围（例如日期、时间或数字）</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：<span class="number">2009</span> 年～<span class="number">2011</span> 年</div></pre></td></tr></table></figure>
<p>注意，波浪连接号前后两个值都应该加上单位。</p>
<p>波浪连接号也可以用汉字“至”代替。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">例句：周围温度：<span class="number">-20</span>°C 至 <span class="number">-10</span>°C</div></pre></td></tr></table></figure>
<h1 id="章节结构"><a href="#章节结构" class="headerlink" title="章节结构"></a>章节结构</h1><p>软件手册是一部完整的书，建议采用下面的结构。</p>
<ul>
<li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li>
<li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li>
<li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul>
<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>
<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>
<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>
</ul>
</li>
<li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li>
<li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件API的逐一介绍</li>
<li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li>
<li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul>
<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>
<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>
<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>
<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>
<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>
</ul>
</li>
</ul>
<p><strong>范例</strong></p>
<ul>
<li><a href="http://redux.js.org/index.html" target="_blank" rel="external">Redux 手册</a></li>
<li><a href="http://flight-manual.atom.io/" target="_blank" rel="external">Atom 手册</a></li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p><a href="http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html" target="_blank" rel="external">产品手册中文写作规范</a>, by 华为<br><a href="http://docs.daocloud.io/write-docs/format" target="_blank" rel="external">写作规范和格式规范</a>, by DaoCloud<br><a href="http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf" target="_blank" rel="external">技术写作技巧在日汉翻译中的应用</a>, by 刘方<br><a href="https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf" target="_blank" rel="external">简体中文规范指南</a>，by lengoo<br><a href="https://open.leancloud.cn/copywriting-style-guide.html" target="_blank" rel="external">文档风格指南</a>, by LeanCloud<br><a href="https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit" target="_blank" rel="external">豌豆荚文案风格指南</a>, by 豌豆荚<br><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="external">中文文案排版指北</a>，by sparanoid<br><a href="http://w3c.github.io/clreq/" target="_blank" rel="external">中文排版需求</a>，by W3C  </p>
</blockquote>
<hr>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[别了，2016；你好，2017]]></title>
      <url>http://noparkinghere.top/2017/01/01/2017/2017-01-01-%E5%88%AB%E4%BA%86%EF%BC%8C2016%EF%BC%9B%E4%BD%A0%E5%A5%BD%EF%BC%8C2017/</url>
      <content type="html"><![CDATA[<p>这篇文章写的晚了，本来是想年前写得，结果一耽搁已经是2017了，过去得一年有太多值得说得，新的一年也有太多值得期待的，这篇文章中只会写有关学习工作上面的得失，个人生活不做涉及。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2017-01-01-别了，2016；你好，2017/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="别了，2016"><a href="#别了，2016" class="headerlink" title="别了，2016"></a>别了，2016</h3><h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><p>2016 对我来说也算是一个特殊的年份，但其实细想起来所有的得失也基本都集中在了下半年，其中最值得一提的可以分为如下几点：</p>
<ul>
<li>首先是加入了 github 这个家庭，虽然是 15 年就注册了 github 但一直没有研究和使用过，且那时对 git 也不够熟悉了解，有大半年的时间都没能开采这座金矿。</li>
<li>放弃了玩了多年的游戏（LOL），这中间也是是非曲中良多，朋友同学的互相指责，让单纯的游戏最后都不欢而散，之后转型玩了一段时间 dota2 ，网速不是太好，加上更新有问题，后来也就不玩了。也许已经不再是个孩子，再者本身从事电脑工作，是时候和电脑游戏说再见了。不玩游戏后也确实节省出了很多时间，也完成了接下来绝大多数的一些工作内容。</li>
<li>在 github 上搭建了个人博客，建立博客本身并不是难事，阅读教程按部就班就可以了，但最大的收获还是切实得整理总结了一些有内容的文章，对于高中语文一直不及格的我来说，能够写博客也是怪不可思议的。</li>
<li>基本掌握了 git 的使用，且也用于个人的一些项目上了。有关 git ，个人觉得还是比较复杂抽象的，也可能原因在于起初学习时，没看到什么较好的教程，现在学会了，却发现最近出来了不少通俗易懂的教程。</li>
<li>对 EFM32 的芯片有了一定的研究认识，虽然过程是十分艰难的，但目前而言，已经可以写一些常规的驱动了。</li>
<li>学了两次 Python，只能说基本掌握了 Python 的思想和语法。</li>
<li>尝试并体验了多家云服务器，买了国外一个分拆的 VPS 服务，体验来说良好，通过虚拟机和 VPS 也学习并且尝试了多个服务的搭建，简单的搭建并不困难，但要运营管理好，对现阶段的我来说还是有相当一段距离的。</li>
<li>使用 shanbay 学习了快两年了，阅读英文文档和网站已经基本可以胜任。</li>
</ul>
<h4 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h4><ul>
<li>学了两次 Python，说来还是比较失败的，两次都因为各种原因中断了，应该来说还是缺少一个项目历练或者学习全面的学习计划，两次都是学到某一阶段，后面不知道该做啥了，然后又因为某些原因中断了一段时间。</li>
<li>学习方法差，效率低，很多计划未能够完成，python 的书籍，还有 linux-c 的一本书籍都未能完成阅读</li>
<li>网络文档看多了或者其他原因，不能/未能静下心好好的看看书，学习一些东西，光靠互联网，走了不少歪路。</li>
<li>上半年浪费时间过多，收获不显著，早点不玩游戏，可能会收获更多。</li>
<li>shanbay 单词荒废过多，一整年都没能静下心来真正拼写背诵单词，虽有提高但不大，主要在于学习不够专注，对自己不够狠。</li>
<li>周末利用率不高，对于技术从业者来说，提高基本上靠业余时间，但一般也仅仅能够利用晚上，且效率比较低，总的来说还是不够专注。</li>
<li>linux 虽然用了也蛮久了，但还是需要重新系统的学习一次，命令的使用，思想的建立都不够完善。</li>
<li>blog 未能好好装修，计划的 H5 没能研究学习完。</li>
</ul>
<h3 id="你好，2017"><a href="#你好，2017" class="headerlink" title="你好，2017"></a>你好，2017</h3><p>2016 在学习工作上面不算成功，有不少欠缺之处，最主要还是表现两点：1.在工作学习不够专注，效率低。 2.业余时间尤其是周末利用率不高。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[MCU中的HardFault_Handler问题]]></title>
      <url>http://noparkinghere.top/2016/12/28/2016/2016-12-28-mcu%E4%B8%AD%E7%9A%84hardfault-handler%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用的工具 KDE-5.11 在调试目标芯片 EFM32 时出现问题，起初是调试铁电驱动，但在单步仿真时到某一步总会不再响应，或者结束仿真时 PC 跳转到了 HardFault_Handler 异常。为了解决这个问题，于是不断地缩减代码，之后发现程序从 startup 开始执行时，一进入 main 函数就会不响应或者跳转到 HardFault_Handler 中，一度怀疑自己的硬件 CMSIS 移植有问题。为了解决这个问题，尝试了多个办法，包括并不仅仅限于更换调试工具，断点调试，评估板代替测试，重新移植底层代码，查看 RAM 占用，修改静态区全局变量占用大小等等。下面总结一些遇到 HardFault_Handler 异常的解决方法。</p>
<a id="more"></a>
<h3 id="HardFault-Handler-分析"><a href="#HardFault-Handler-分析" class="headerlink" title="HardFault_Handler 分析"></a>HardFault_Handler 分析</h3><p>一般 HardFault_Handler 错误是指 PC 指向了一个无法访问的位置，主要可以分为两种：</p>
<ul>
<li>内存溢出或者访问越界。这个需要自己写程序的时候规范代码，遇到了需要慢慢排查。</li>
<li>堆栈溢出。增加堆栈的大小。</li>
</ul>
<p>仿真时，有时会出现 HardFault_Handler 这种错误，这种错误往往会涉及到一些编译运行时的深层次原理，但基本可以肯定的是一般都是 SP,LR,PC 这三个寄存器出了问题，下面介绍这三个寄存器：</p>
<ul>
<li><p>堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。</p>
</li>
<li><p>连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">（1）保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：</div><div class="line">            MOV PC, LR </div><div class="line">            BX LR</div><div class="line"></div><div class="line">	通常子程序这样写，保证了子程序中还可以调用子程序。</div><div class="line">             stmfd sp!, &#123;lr&#125;</div><div class="line">             ……</div><div class="line">             ldmfd sp!, &#123;pc&#125;</div><div class="line"></div><div class="line">（2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。</div></pre></td></tr></table></figure>
<ul>
<li>程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。</li>
</ul>
<p>需要研究到底寄存器、函数是如何跳转调用的，我们需要使用 KDE 中的两个仿真工具： Register 和 Call Stack+Locals。Register 中主要观察 SP,LR,PC 三个寄存器的数据，PC永远指向 CPU 正在执行工作的位置，LR 会保存你调用子函数之前的跳转地址，也就是说当子函数完成返回时，会回到 LR 值对应的地址继续执行下面的程序。我这边实验时，能够看出每次执行错误后， PC 会跳转到一个很大的错误地址。</p>
<h3 id="指针跑飞"><a href="#指针跑飞" class="headerlink" title="指针跑飞"></a>指针跑飞</h3><p>在 HardFault_Handler 中的 while(1) 设置断点，然后运行，给它触发 HardFault_Handler 的条件，然后到断点处之后，查看 watch 窗口中的 Call Stack+Locals，也就是堆栈以及局部变量，程序执行到哪一句发生的错误，以及当时各个压栈的函数的各个局部变量的值一目了然。一般而言最常出现的就是<strong>指针跑飞，数组越界</strong>，这两种其实可以看做一个情况，都是指针访问了无权限访问的空间，通过 Call Stack+Locals 窗口往往能够定位到该函数，然后可以采用单步执行，看到具体在哪一步触发了异常。</p>
<h3 id="RAM溢出"><a href="#RAM溢出" class="headerlink" title="RAM溢出"></a>RAM溢出</h3><p>这种情况也是我排查的一种情况，编译完成之后，全局变量已经占用了相应大小 RAM 中的静态存储区域，如果你的 MCU 本身不够大，例如我的只有 8K RAM空间，而 COM 的缓冲数组占用了过多的全局变量，这边就存在一定的可能 RAM 不够分配而越界。</p>
<h3 id="底层-CMSIS-问题"><a href="#底层-CMSIS-问题" class="headerlink" title="底层 CMSIS 问题"></a>底层 CMSIS 问题</h3><p>因为我的项目是在进入 main 函数一开始就出错了，所以为了排除是不是之前的跳转就有问题，所以重新移植 startup.s 文件</p>
<h3 id="Jlink"><a href="#Jlink" class="headerlink" title="Jlink"></a>Jlink</h3><p>不排除调试器存在缺陷，所以更换了调试器，将自己的程序移植到评估板上面运行，进一步验证，直接使用官方自带例程，在评估板上面运行。</p>
<h3 id="inline函数无法捕捉"><a href="#inline函数无法捕捉" class="headerlink" title="inline函数无法捕捉"></a>inline函数无法捕捉</h3><p>EFM32 芯片采用 JLINK V9 多次测试多款不同型号的芯片都无法单步执行，单步只能在 while(1) 中执行，一般从 startup 到 main 函数中就会发生错误，开始怀疑是调试工具的问题，通过增加断点部分解决了这个问题，经过评估板测试，查看 RAM 占用，静态区全局变量等查看不断排查，之后发现是共同规律是每次 inline 函数调用某一个普通函数时，单步执行到 return 时，无法找到真实的返回地址。</p>
<p>这边是我主要出现错误的情况，一般较为少见，根本原因在于 inline 函数是类似于宏定义，直接本地展开的，如果使用断点是无法捕捉到的，这边我的 inline 函数中又调用了一个普通函数，因为 inline 函数是原地展开，LR 没有载入它的地址，而每次普通函数在返回时，无法获取到 inline 函数的返回地址，然后就跳转了异常，这本身并不能算是一个问题，在 MCU 正常运行时不会产生任何影响，影响的仅是你的调试过程。另外我个人在调试 SPI 驱动时，因为也调用了固件库自带的 inline 函数，所以导致也没法单步执行这段程序。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然这边查出我的问题出现在内联函数上面，但是，以上的集中方法都可以作为常用排查 HardFault_Handler 异常的方法，且一般而言出现指针跑飞的可能性最高。</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/zyboy2000/article/details/7668331" target="_blank" rel="external">http://blog.csdn.net/zyboy2000/article/details/7668331</a><br><a href="http://www.51hei.com/bbs/dpj-39846-1.html" target="_blank" rel="external">http://www.51hei.com/bbs/dpj-39846-1.html</a><br><a href="http://blog.csdn.net/jimmy2013_1_1/article/details/9723461" target="_blank" rel="external">http://blog.csdn.net/jimmy2013_1_1/article/details/9723461</a><br><a href="http://blog.chinaunix.net/uid-26967414-id-3823606.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26967414-id-3823606.html</a><br><a href="http://blog.csdn.net/zhou1232006/article/details/6149548" target="_blank" rel="external">http://blog.csdn.net/zhou1232006/article/details/6149548</a><br><a href="http://blog.csdn.net/pony_maggie/article/details/5270501" target="_blank" rel="external">http://blog.csdn.net/pony_maggie/article/details/5270501</a><br><a href="http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view" target="_blank" rel="external">http://wenku.baidu.com/view/f7bf4ad6b14e852458fb576a.html?re=view</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh常规用法详解]]></title>
      <url>http://noparkinghere.top/2016/12/27/2016/2016-12-27-ssh%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>ssh 算是 linux 下最常用的工具之一，虽然用了很多次但对它并不是很了解，本文将查找一些资料并总结自己使用的 ssh ，希望能够通过这篇文章，帮助理解和使用 ssh。</em></p>
<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995 年，芬兰学者Tatu Ylonen设计了 ssh 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 linux 系统的标准配置。</p>
<p>ssh 是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用 ssh 协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。需要指出的是，ssh 只是一种协议，存在多种实现，既有商业实现，也有开源实现。</p>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>假定你要以用户名 user，登录远程主机 host，如：<code>ssh user@host</code>；SSH的默认端口是 22，也就是说，你的登录请求会送进远程主机的 22 端口。使用 p 参数，可以修改这个端口，如：<code>ssh -p 2222 user@host</code></p>
<p>ssh 登录同样可以使用密码登录，输入用户名后，输入密码即可完成登录，但一般我们不这么做，我们使用 ssh 的目的就是防止密码被截取，因此一般我们采用秘钥对的形式来验证本地主机和目标机是否可以配对。我们将公钥放在目标机器上，然后登录目标机器时，本地机器的私钥能够和目标机器的秘钥配对，则验证通过，否则验证失败。</p>
<p>值得注意的是，公钥并不需要特别在意，它往往是公开的，即便被别人获取也无法产生威胁，真正重要的是私钥。我们可以将公钥比作你的用户名，私钥则是你的密码。密码的重要性不言而喻，因此私钥一旦丢失往往会造成很严重的后果，我们往往需要更改私钥的存放位置，或者给私钥再设置一个使用密码。</p>
<h3 id="本地SSH配置"><a href="#本地SSH配置" class="headerlink" title="本地SSH配置"></a>本地SSH配置</h3><ul>
<li>首先我们需要检查你电脑上现有的 ssh key：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh 检查本机的ssh密钥</div></pre></td></tr></table></figure>
<p>如果提示：No such file or directory 说明你是第一次使用 git。</p>
<ul>
<li>生成新的SSH Key：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></div></pre></td></tr></table></figure>
<p><em>此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」</em></p>
<ul>
<li>然后系统会要你输入密码：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):&lt;输入加密串&gt;</div><div class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</div></pre></td></tr></table></figure>
<p><em>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，相当于二次的加密，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。个人嫌麻烦一般不会再设定密码，本身ssh的访问就属于本地自动加密认真，就比较安全，除非你秘钥丢失，否则一般不会出问题，</em></p>
<ul>
<li><p>看到这样的界面，就成功设置了本地的 ssh key了：</p>
</li>
<li><p>~/.ssh/id_rsa.pub 就是需要使用的公钥，将该公钥加入到其他系统上面或者支持ssh服务的软件上面即可实现访问。</p>
</li>
</ul>
<h3 id="将本地公钥上传到远程linux服务器"><a href="#将本地公钥上传到远程linux服务器" class="headerlink" title="将本地公钥上传到远程linux服务器"></a>将本地公钥上传到远程linux服务器</h3><p>不同的 Linux 之间 copy 文件常用有3种方法：</p>
<ul>
<li>第一种就是 ftp，也就是其中一台 Linux 安装 ftp Server，这样可以另外一台使用 ftp 的 client 程序来进行文件的 copy。</li>
<li>第二种方法就是采用 samba 服务，类似 Windows 文件 copy 的方式来操作，比较简洁方便。</li>
<li>第三种就是利用 scp 命令来进行文件复制。</li>
</ul>
<p><strong>scp 是有Security的文件 copy，基于 ssh 登录。操作起来比较方便，比如要把当前一个文件 copy 到远程另外一台主机上，可以如下命令。</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp /home/daisy/full.tar.gz root<span class="variable">@172</span>.<span class="number">19.2</span>.<span class="number">75</span><span class="symbol">:/home/root</span></div></pre></td></tr></table></figure>
<p>然后会提示你输入另外那台 172.19.2.75 主机的 root 用户的登录密码，接着就开始 copy 了。如果想反过来操作，把文件从远程主机 copy 到当前系统，也很简单。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp root<span class="variable">@172</span>.<span class="number">19.2</span>.<span class="number">75</span><span class="symbol">:/home/root/full</span>.tar.gz home/daisy/full.tar.gz</div></pre></td></tr></table></figure>
<p>scp 沿用了 ssh 的规则，默认一般是 22 端口，如果需要指定其他端口的话可以加上 -P [端口号]，如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -P <span class="number">2222</span> /home/daisy/full.tar.gz root<span class="variable">@172</span>.<span class="number">19.2</span>.<span class="number">75</span><span class="symbol">:/home/root</span></div></pre></td></tr></table></figure>
<ul>
<li>我们将原始机的公钥拷贝到目标服务器的 .ssh 目录下，且命名为 authorized_keys。</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp /home/git/.ssh/id_rsa.pub git<span class="variable">@ubuntu_server</span><span class="symbol">:/home/git/</span>.ssh/authorized_keys</div></pre></td></tr></table></figure>
<p><em>注意，ubuntu_server 为 ip 对应的名称，这边可以改成 ip 地址，git 为用户名。修改实体机(本地机而不是服务器)的 ip 配置文件 <code>/ect/hosts</code>，加入如下行：<code>192.168.18.202 ubuntu_server</code>， ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server,可以修改 /etc/hostname 中的名称。</em></p>
<p><strong>注意：ssh在使用时无法通过VPN，需要人为手动做一些修改，这边主要是通过将需要ssh访问的ip地址直接经过网卡而不经过vpn。详细内容参见<em>linux 下 ssh 通过VPN推送失败</em>文章。</strong></p>
<h3 id="windows-下使用-ssh"><a href="#windows-下使用-ssh" class="headerlink" title="windows 下使用 ssh"></a>windows 下使用 ssh</h3><p>windows 使用 ssh 一般可以通过 putty 或者 secureCRT，这两款软件都是自带 ssh 服务的，一般你安装他们后，windows 上就可以使用 ssh 了。如果需要秘钥登录的话，需要手动加载秘钥位置，如：secureCRT 的秘钥在 tools 下的 manage agents keys -&gt; add，具体的一些位置需要自己去查找，这边不再详细讨论。</p>
<p>windows 下除了 ssh 登录外，使用 git 时也会需要加载私钥，git 官方版回去默认位置找私钥，默认位置一般为当前用户目录下的 .ssh 文件夹下。对于 linux 就是 ~/.ssh/ 目录下，而 windows 则是 C:/users/当前登录用户/.ssh/ 目录下。</p>
<p>使用 WinSCP 时，也可以使用 scp 复制文件，注意该软件只能读 ppk 格式的秘钥，如果其采用的不是 openSSH 的秘钥，则需要通过工具转换以下，步骤为：</p>
<ul>
<li>工具-&gt;运行 PuTTYgen-&gt;load你的秘钥-&gt;save private key 保存转成 ppk 格式 （如果直接通过 WinSCP 生成秘钥对的话，可以在 PuTTYgen 中直接 点解 generate 生成新的秘钥对）</li>
<li>工具-&gt;运行pageant-&gt;add key 将刚刚生成的秘钥载入进来</li>
</ul>
<blockquote>
<p><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a><br><a href="http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html" target="_blank" rel="external">http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html</a><br><a href="http://blog.csdn.net/hunanchenxingyu/article/details/40544513" target="_blank" rel="external">http://blog.csdn.net/hunanchenxingyu/article/details/40544513</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[针对百度网盘限速的解决方案]]></title>
      <url>http://noparkinghere.top/2016/12/26/2016/2016-12-26-%E9%92%88%E5%AF%B9%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>虽然百度这家公司在道德水准上面没下限（卖假药，开赌场等），大多数产品做的也都比较烂（界面丑，体验差），但在搜索引擎和网盘这两个领域，因为国内种种众所周知的原因，还是只能用这家的产品。面对百度网盘下载速度越来越慢，收费越来越高，服务越来越差等特点，本文主要介绍一些方法，让我们能够更快地下载百度网盘中的资源。参考自<a href="http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D" target="_blank" rel="external">文章</a> 主要的方法可以分为两种，破解版的百度云管家和直链下载。</p>
<p>以下的一些方法随时可能会失效，详细可以<a href="http://www.runningcheese.com/baiduyun" target="_blank" rel="external">参考链接</a>，上面会持续更新。</p>
<a id="more"></a>
<h3 id="破解版百度云管家"><a href="#破解版百度云管家" class="headerlink" title="破解版百度云管家"></a>破解版百度云管家</h3><p>经常使用百度云的用户，无疑客户端是最佳的选择，破解版本的百度云管家是可以让你<strong>无限时的免费试用百度云管家</strong>。可以去<a href="http://www.52pojie.cn/" target="_blank" rel="external">吾爱破解</a>等论坛下载最新破解版本的百度云，但这边不推荐这种方法，主要原因是客户端破解版很容易失效。</p>
<h3 id="云直链下载"><a href="#云直链下载" class="headerlink" title="云直链下载"></a>云直链下载</h3><h4 id="网页嵌入脚本下载"><a href="#网页嵌入脚本下载" class="headerlink" title="网页嵌入脚本下载"></a>网页嵌入脚本下载</h4><ul>
<li>Chrome需要安装拓展 <a href="http://tampermonkey.net/" target="_blank" rel="external">Tampermonkey</a>，其他Chrome壳浏览器安装 Tampermonkey，在应用市场可以找到并下载安装。</li>
<li>打开<a href="https://greasyfork.org/zh-CN/scripts/23635-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B" target="_blank" rel="external">脚本地址</a>，并安装。</li>
<li>每次打开百度云资源后，脚本就会自动获取相关信息，加载，并可以获取直链了。</li>
</ul>
<p>但注意：将直连放到迅雷等软件中，下载速度依然很慢，时断时连，原因暂未明了，不排除我这边网络的问题。</p>
<h4 id="应用数据获取直链"><a href="#应用数据获取直链" class="headerlink" title="应用数据获取直链"></a>应用数据获取直链</h4><p>提供这种方法的应用较多，例如：<a href="http://bdbea3.duapp.com/baidu_pcs/index.php" target="_blank" rel="external">百度网盘直链系统V2.0</a>，授权打开后，会在百度云盘根目录下的我的应用数据中新建文件夹，讲需要下载的文件，放到该新增的文件夹中，直接下载可以获取直链，个人实验速度要稍微比上面的直链快些，但也仅有 600-700k 的样子，且也不适用于几个G的大文件，依然不是很满意。</p>
<p>百度云直连系统：<a href="http://www.139.sh/" target="_blank" rel="external">免费云存储-免费百度网盘直链平台-永久外链-139直链网盘</a>，同样也是一个直链系统，方法依然是将需要下载的文件放入我的应用数据文件夹中，然后打开该服务网址，就可以看到外链已经被解析出来了，直接复制下载即可。就我个人的网络网盘来说这个速度最快，使用 aria2 可以得到数兆每秒的下载速度，且大文件也没有问题。</p>
<hr>
<p>To be continued …</p>
<blockquote>
<p>参考链接：<br><a href="http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D" target="_blank" rel="external">http://www.runningcheese.com/baiduyun?from=singlemessage&amp;nsukey=%2FdzDPL5oNO1chDPgm3EdQmoQJUF%2BMIslSStmsD899bHiLizX7%2BbA5dJq5gbDAeFPwVxr%2BXSK2bx1X8578hc8gj2ZstvXGjsWoXdGDpR2KwqlaeJ3aLAZujniUz%2FMDo6YptCoB1k%2BDSc5wqLoCsrPlXfhWhx%2BfXdKnWRcDVfGQQw%3D</a><br><a href="https://www.zhihu.com/question/28333225" target="_blank" rel="external">https://www.zhihu.com/question/28333225</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux 系统瘦身]]></title>
      <url>http://noparkinghere.top/2016/12/20/2016/2016-12-20-linux-%E7%B3%BB%E7%BB%9F%E7%98%A6%E8%BA%AB/</url>
      <content type="html"><![CDATA[<p>目前 PC 市场中，硬盘内存等硬件设备越来越廉价不值钱，所以很多人不再考虑删减系统清除无用文件等来节省更多的空间。然而，很多不同的应用对存储空间运行空间等依然十分敏感，本文主要针对是在个人使用的 VPS 上，如何使用更少的资源运行更多的服务。</p>
<p>系统以 ubuntu/debian 为例，作为 VPS 普通服务器的操作系统来使用，进行优化，删除不会经常使用的工具，保留一些个人认为有用的功能。</p>
<h3 id="清理下载的缓存包"><a href="#清理下载的缓存包" class="headerlink" title="清理下载的缓存包"></a>清理下载的缓存包</h3><p>在 Ubuntu 中通过 sudo apt-get install 安装软件时，其下载的包都缓存在 /var/cache/apt/archives/ 目录中。如果要清理掉这些已下载的缓存包，那么可以执行命令：<br><code>sudo apt-get autoclean</code> 和 <code>sudo apt-get clean</code> 。</p>
<a id="more"></a>
<h3 id="清理不再需要的包"><a href="#清理不再需要的包" class="headerlink" title="清理不再需要的包"></a>清理不再需要的包</h3><p>在 Ubuntu 系统中安装软件时，该软件的依赖通常也会自动安装上。那么，在删除该软件后，其依赖可能需要我们手动删除之。可以运行 sudo apt-get autoremove 命令来解决这个问题。</p>
<h3 id="清除-update-库"><a href="#清除-update-库" class="headerlink" title="清除 update 库"></a>清除 update 库</h3><p>清除 apt-get update 过程中所下载的软件库列表： <code>rm -rf /var/lib/apt/lists/*</code> 。但注意每次执行 apt-get update 后还会重新更新这些文件，因此在仍然需要安装软件的 VPS 上这个用处不大，但是如果服务器已经配置成功了，可以接连使用  <code>rm -rf /var/lib/apt/lists/* &amp;&amp;  apt-get autoclean &amp;&amp; apt-get autoremove</code> 来清除空间。</p>
<h3 id="清理无用的语言文件"><a href="#清理无用的语言文件" class="headerlink" title="清理无用的语言文件"></a>清理无用的语言文件</h3><p>Ubuntu 与其他 Linux 发行版一样，是一个支持多语言界面的系统。其实，对使用自己母语的我们来说，通常保留中文即可，也可以保留自己所需要使用的语言，如英文。其他的语言文件则没有必要保留。为了清理这些无用的语言文件，需要在 Ubuntu 系统中安装一个名为 localepurge 的小工具，apt-get install localepurge。执行 localepurge，软件会提示你如何操作，服务器端建议只保留 en, en_US, en_US.UTF-8 。该软件分为两种界面，一种是直接按空格选择需要保留的包，另外一种是输入包序号选择保留包。</p>
<h3 id="清理-build-essential"><a href="#清理-build-essential" class="headerlink" title="清理 build-essential"></a>清理 build-essential</h3><p>查看该软件包的依赖关系，可以看到以下内容：<br>$ apt-cache depends build-essential</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">build-essential</div><div class="line">|依赖: libc6-dev</div><div class="line">依赖: &lt;libc-dev&gt;</div><div class="line">libc6-dev</div><div class="line">依赖: gcc</div><div class="line">依赖: g++</div><div class="line">依赖: make</div><div class="line">依赖: dpkg-dev</div></pre></td></tr></table></figure>
<p>也就是说，安装了该软件包，编译c/c++所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c++程序，需要安装该软件包就可以了， build-essential 里面包含了最常用的编译工具，编译程序有了这个软件包<br>它才知道头文件在哪，也才知道库函数在哪，还会下载其他依赖的软件包，最后才组成一个开发环境。</p>
<p>对于不开发 c/c++ 用的服务器来说，如果只是用安装包安装，不用源码编译的话，则可以卸载这个软件包。</p>
<h3 id="清除部分文档帮助文件"><a href="#清除部分文档帮助文件" class="headerlink" title="清除部分文档帮助文件"></a>清除部分文档帮助文件</h3><p>清除其中的一些帮助说明文档： <code>rm -rf /usr/share/{doc,man}</code> 。</p>
<h3 id="编辑器安装和卸载"><a href="#编辑器安装和卸载" class="headerlink" title="编辑器安装和卸载"></a>编辑器安装和卸载</h3><p>安装 vim，个人习惯只用 vim ，但 vim 的套件也会占用 20M 以上的空间，这边如果对编辑器没有特殊要求的可以安装使用 nano （约 2M 大小）。</p>
<hr>
<p>To be continued…</p>
<p>有关服务器的 linux 系统仍然在研究中，后续还会更新。</p>
<blockquote>
<p>参考链接：<br><a href="https://zhidao.baidu.com/question/2051702708087103867.html" target="_blank" rel="external">https://zhidao.baidu.com/question/2051702708087103867.html</a><br><a href="http://www.cnblogs.com/dolphi/p/3622570.html" target="_blank" rel="external">http://www.cnblogs.com/dolphi/p/3622570.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GithubPage+Hexo搭建博客]]></title>
      <url>http://noparkinghere.top/2016/12/14/2016/2016-12-14-GithubPage+Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>个人博客是使用 githubpage+jekyll 搭建的，且博客已经工作有半年了，但由于期初的模板没有找好，加上一些其他的问题，导致博客看起来比较凌乱，这边给出另外一个 GithubPage+Hexo 的博客搭建方法供大家参考，本文操作系统主要使用的是 ubuntu 16.04，使用其他 linux 发行版的用户，可以参考本文。附上最终效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-14-githubpage-hexo搭建博客/1.png" alt=""></p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-14-githubpage-hexo搭建博客/2.png" alt=""></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h4><p>Node.js 是一个开放源代码、跨平台的、可用于服务器端和网络应用的运行环境，该应用由 C++ 语言写成，在 Node.js 运行时运行。Node.js 提供事件驱动和非阻塞 I/O API，可优化应用程序的吞吐量和规模。这些技术通常被用于实时应用程序。并且它是采用 Google 的 V8 引擎来执行代码，它的大部分基本模块都是用 JavaScript 写成的，包含有一系列内置模块，使得程序可以作为独立服务器运行，从而脱离 Apache HTTP Server 或 IIS 运行。npm 也即 Node包管理器（Node Package Manager），它是一个以 Javascript 编写的软件包管理系统，默认环境为 Node.js 。</p>
<ul>
<li>安装 nodejs ： sudo apt-get install nodejs , 注意 ubuntu 16.04 使用：sudo apt install nodejs</li>
<li>安装 npm ： sudo apt-get install npm ， 注意 ubuntu 16.04 使用：sudo apt install npm</li>
</ul>
<p>需要安装 nrm ， nrm 是 npm 的资源管理器，借助各个工具可以方便快捷地对 npm 的源进行管理。另外，由于国内网络环境原因在使用 npm 默认下载源的时候不仅速度非常慢而且常常会超时，因此这里还手动指定了从淘宝源下载。<code>sudo npm install nrm -g --registry https://registry.npm.taobao.org</code>，<code>nrm use taobao</code>（如果出现无法找到 node 则执行： <code>sudo  ln -s /usr/bin/nodejs /usr/bin/node</code> ）</p>
<h4 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h4><p>这边步骤在多篇博文中都有详细描述，这边就不再累述了，可以直接搜索引擎搜索，或者在本博客的其他文章中找到。</p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。接下来我们开始使用 Hexo 搭建博客。</p>
<ul>
<li>sudo npm install hexo-cli -g 或者 sudo npm install -g hexo</li>
<li>如果以上命令遇到错误或者警告，则更新 npm 版本，<code>sudo npm i npm -g</code></li>
<li>创建并进入目录 Hexo ：<code>mkdir Hexo &amp;&amp; cd Hexo</code></li>
<li>使用 hexo 生成博客框架。依次执行如下命令(hexo init blog 过程可能会比较慢，需要耐心等待。)：<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ hexo init blog</div><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ npm install</div><div class="line">$ hexo generate (hexo generate 为我们生成了静态文件存储于 public 文件夹之下，并且在一开始默认情况下执行这句将会为我们生成一个 Hello World 的页面。)</div><div class="line">$ hexo server (通过 hexo server 运行起 hexo 内置的服务器。这时候就可以开始在本地访问了，默认地址为 localhost:4000 。)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：hexo 中的 generate, server, dpoly 等操作都可以简写为首字母，所以 hexo generate 等同于 hexo g ，hexo server 等同于 hexo s，。</p>
<h3 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h3><p>通过 tree | less 可以查看以下 blog 的目录结构，主要的几个文件和目录的作用分别如下：</p>
<ul>
<li><code>_config.yml</code> ：配置文件，可以修改网站的主题、标题、作者等信息。</li>
<li><code>public</code> ：由 hexo 根据 source 文件夹中的资源进行渲染生成的文件夹，里边存储着最终的静态网页文件。</li>
<li><code>scaffolds/</code> ：模板文件，当要给博客添加新文章的时候，将根据对应的模板进行创建。</li>
<li><code>source/</code> ：用于存储用户资源，比如文章与新页面等。其中以 _ 开头的文件夹中除了 <code>_posts</code> 文件夹中的 markdown 或 HTML 文件会在执行 generate 操作的时候被渲染添加到 public 文件夹中之外，其他均被忽略。而且在初始化博客的过程中 <code>_posts</code> 目录底会自带一个 hello-world.md 的文件。</li>
<li><code>themes/</code> ：主题文件，自带默认主题 landscape 。</li>
</ul>
<h3 id="操作指导"><a href="#操作指导" class="headerlink" title="操作指导"></a>操作指导</h3><h4 id="文章创建"><a href="#文章创建" class="headerlink" title="文章创建"></a>文章创建</h4><p><code>hexo new [layout] &lt;filename&gt;</code> 其中 layout 为可选参数，指定了新创建的文件布局，默认为 post 文件。 filename 为必填参数，指定了文件名，如果文件名中有空格则需要把文件名用引号”” 包裹起来。例如： 终端输入：  <code>hexo new &quot;我的第一篇文章&quot;</code> ，这时候我们发现 hexo 在 <code>source/_post</code> 目录之下创建了一个 我的第一篇文章.md 的文件。打开该文件进行编辑。我们也可以通过 atom 等常用的 markdown 编辑工具直接在 <code>source/_post</code> 目录下创建文章进行编辑即可。刷新浏览器就可以看到我们博客更新的内容了。</p>
<p>至此我们基本配置好了本地 hexo 服务，能够自己写点内容了。</p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><ul>
<li>在 hexo/source 目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为<code>https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/</code> 图片名称。 注意目录必须为 <code>hexo/source</code>，且图片文件夹为 img ，否则通过 hexo generate 可能无法生成目标图片。</li>
<li>也可以使用<a href="http://tc.ffsky.net/" target="_blank" rel="external">图床</a>外链来存储图片。</li>
</ul>
<h3 id="部署到-github-page"><a href="#部署到-github-page" class="headerlink" title="部署到 github page"></a>部署到 github page</h3><p>访问 github，创建库 <code>git账户名.github.io</code> ， 这一这个名字是固定的，一般的库没法修改跳转地址，只能显示为 github page 。</p>
<p>将远程库同步到本地，<code>git clone [你的仓库的 url]</code>，本地会多出一个 <code>git账户名.github.io</code> 的文件夹，然后把 public 文件目录下的博客文件都复制到你的本地仓库中，并将本地仓库 push 到 github 仓库上。这样当其他人访问你的博客链接的时候 github 将会自动将该仓库中的相应文件展示出来。</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>由于访问网页最终都是访问的 html 文件，因此这边需要通过本地 hexo generate 工具生成所需的 html 页面代码，然后每次将你的 html 页面覆盖到 github 的项目中去。</p>
<p>执行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">cp -R public/* [你的仓库名]</div><div class="line"><span class="built_in">cd</span> [你的仓库名]</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">'update blog'</span></div><div class="line">git push</div></pre></td></tr></table></figure></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>注意，实际上 github page 是可以自己按照 jekyll 的方式将源码生成 html 文件的，但是 对于 hexo 等其他源码，如果需要展示出来，则必须本地生成 html 代码，然后把生成的代码部署到服务器上面才行，这边我们可以使用如上面的方式（将 public 目录下面生成的 html 文件直接复制到服务器的根目录下）， hexo 提供了更加人性化的方式，通过 hexo deploy 可以一键完成部署（无需在通过 push 手动推送了），每次部署的步骤，可按以下两步：</p>
<ul>
<li>修改 该配置文件：vim <code>_config.yml</code>，执行如下命令才能使用 git 部署 <code>npm install hexo-deployer-git --save</code>:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repository: https://github.com/username/username.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p><em>注：type: git 老版本可能是 github，repository 后也可以采用 ssh 的地址，https 每次需要输入密码，而 ssh 需要配置好公钥私钥免密码。</em></p>
<ul>
<li>执行以下命令无需手动将代码 push 上去<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
</li>
</ul>
<p>以上步骤虽然看起来貌似繁琐，但实际可以写成 bash 脚本，这样每次就会自动生成 public 自动复制以及上传了。</p>
<h4 id="CNAME-配置"><a href="#CNAME-配置" class="headerlink" title="CNAME 配置"></a>CNAME 配置</h4><p>github page 可以使用上面提供的网址也可以让每次访问时跳转自己的域名地址，一般 github page 需要在根目录下新建一个 CNAME 文件，其中写下你的域名地址如：<code>www.google.com</code>。</p>
<p>因为 hexo 每次需要生成好文件再上传，这边将 CNAME 文件放入 source 目录下，每次 hexo g &amp;&amp; hexo generate 后则会上传 CNAME 到 github page了。</p>
<h3 id="扩展补充"><a href="#扩展补充" class="headerlink" title="扩展补充"></a>扩展补充</h3><p>上述虽然配置完成了 hexo 博客，但博客功能过于简单，使用起来不方便，可以添加图片，摘要，标签页与分类页等内容。</p>
<h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>下载并解压缩 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT 主题</a></p>
<p><code>wget http://labfile.oss.aliyuncs.com/courses/700/next.zip &amp;&amp; unzip next.zip</code></p>
<p>需要将主题文件放入 Hexo/blog/themes 下，打开 <code>../blog/_config.yml</code> 修改 theme 后的内容就可以更改主题了。这会博客就套上了我们的新模板了。但是我们发现博客菜单上的文字是英文的于是我们还要重新配置以下，让主题以中文的方式显示。再次编辑 <code>_config.yml</code> 文件，将 language 项设置为 zh-Hans 。</p>
<p>注意更改主题后每次需要重启 <code>hexo server</code> 服务才可以刷新网页。</p>
<p><em>到 github 上面搜索，可以找到更多出色的主题，这儿给出一个<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">主题汇总</a>。</em></p>
<h3 id="hexo-小结"><a href="#hexo-小结" class="headerlink" title="hexo 小结"></a>hexo 小结</h3><p>hexo 比 jekyll 布局更简单，更加容易操作，但每次需要本地生成 html 然后上传同步，虽然这不是问题，可以用脚本实现，但对于图片等内容，需要依赖第三方图床就显得很是无奈了。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用 Hexo 部署了数月，今天出现了新问题，今天又出现了新问题，hexo 部署无法推送到 github 上，疑似该问题出现了有一段时间了，<code>npm install hexo-deployer-git --save</code> 的插件读取了 <code>_config.yml</code> 文件的内容，但是上传到 github 时，出现错误，本来应该上传 public 内容，但是这边会上传文件夹中的全部内容。</p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/" target="_blank" rel="external">http://behappyli.cn/2015/12/05/hexo%E6%95%99%E7%A8%8B/</a><br><a href="http://www.runoob.com/w3cnote/git-guide.html" target="_blank" rel="external">http://www.runoob.com/w3cnote/git-guide.html</a><br><a href="http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</a><br><a href="http://blog.csdn.net/u012307002/article/details/51298705" target="_blank" rel="external">http://blog.csdn.net/u012307002/article/details/51298705</a><br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">https://www.zhihu.com/question/24422335</a><br><a href="http://www.jianshu.com/p/1d427e888dda" target="_blank" rel="external">http://www.jianshu.com/p/1d427e888dda</a><br><a href="http://www.jianshu.com/p/f4dce0e76886" target="_blank" rel="external">http://www.jianshu.com/p/f4dce0e76886</a><br><a href="http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</a><br><a href="http://www.jianshu.com/p/2b9f202c13fd" target="_blank" rel="external">http://www.jianshu.com/p/2b9f202c13fd</a><br><a href="http://c4fun.cn/blog/2014/03/03/use-hexo-blog/" target="_blank" rel="external">http://c4fun.cn/blog/2014/03/03/use-hexo-blog/</a><br><a href="http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[TeamViewer 远程控制]]></title>
      <url>http://noparkinghere.top/2016/12/12/2016/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>TeamViewer 是一款最流行的远程桌面连接工具，特点：连接稳定，功能强大，跨平台，对网络稳定性要求低等等，几乎集成了市面上大多数远程工具的优点，实时性很强，且资源消耗低，这些都远不是 qq 等国内软件的远程服务可以比拟的。本篇文章就是 windows 远程连接 Ubuntu 桌面编辑完成的。</p>
<p>本文主要介绍如何在局域网内使用 TeamViewer 完成远程桌面的设置。</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>这边给出<a href="https://www.teamviewer.com/zhcn/download/linux/" target="_blank" rel="external">官方下载地址</a>，可以看到官方提供了目前主流移动端和 PC 端的各个版本的软件。这边根据你自己的平台下载需要的版本。因为平台需要这边我下载的是 windows 版本和 Ubuntu 版本。需要注意的是：下载版本为完整版，而不是缩减版（缩减版中需要联网登录，且不直接存在登录远程功能），图示如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/1.jpg" alt=""></p>
<a id="more"></a>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="广域网连接"><a href="#广域网连接" class="headerlink" title="广域网连接"></a>广域网连接</h4><p>通过ID+密码连接，首先，输入对方的 ID 地址，然后选择下方的远程控制后点击连接到小伙伴，最后输入对方的密码即可完成远程控制。比较诡异的是远程链接到对方的 windows 后，背景图会变成黑色，但这无须担心，退出连接后，会恢复原来主题。另外如果实在看的不舒服，登录后点击“查看”，然后把“删除墙纸”勾掉就可以了。</p>
<h4 id="局域网连接"><a href="#局域网连接" class="headerlink" title="局域网连接"></a>局域网连接</h4><p>局域网下的 teamviewer 的使用，可以类似于 windows 下的远程登录，虽然原理不尽相同，但通 teamviewer 我们可以图形化的实现跨平台操作，也就是说 windows 下可以远程操作 linux 的图形化界面，实现功能类似于我之前的一篇文章 “putty-xming-远程使用-linux-gui” 。“putty-xming-远程使用-linux-gui” 采用的是 ssh 加密，转发，登录的是一个新的账号，对网络的要求特别高，刷新速度慢；而 teamviewer 对比 ssh 转发的效果更好，速度更快，网络要求也更低，刷新快，操作流畅，即便浏览网页问题也不大，但和 windows 远程桌面登录相比在体验上还是有差距的。</p>
<ul>
<li>使用局域网链接，需要先配置下本机设置，找开软件后，先要设置允许接入lan（或者叫允许局域网连接），那样的话，ID的地方就显示内网的IP了。如果你的 ID 不能显示自己的 IP 地址，重新启动软件即可。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/2.jpg" alt=""></p>
<ul>
<li>局域网内同样需要两边都先打开软件，然后使用 IP 代替伙伴ID输入，后续操作和上面类似，直接点远程控制，输入密码即可。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-12-teamviewer-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/3.jpg" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TeamViewer 的链接方式稳定，带宽占用资源小，高质量模式下，也仅有 200kb/s 的传输速度，操作也很及时，附带的录屏文件传输等功能强大。但 TeamViewer 并非完全免费的软件，一些附带功能和商业用途需要付费支持，另外 TeamViewer 只能用于远程图形化界面的使用的话，说白了就是只能一个人使用，不能类似于 ssh 可以多人使用登录。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.wuji8.com/meta/864411156.html" target="_blank" rel="external">http://www.wuji8.com/meta/864411156.html</a><br><a href="https://zhidao.baidu.com/question/497787316.html" target="_blank" rel="external">https://zhidao.baidu.com/question/497787316.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[LAMP 环境搭建]]></title>
      <url>http://noparkinghere.top/2016/12/09/2016-12-09-lamp-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>之前写过一些服务器的配置文章，但当时都只是按部就班，对于相关服务的理解很欠缺。由于很多的博客系统，网站都依赖于：操作系统，服务器软件，数据库，后台编程语言等，本质上他们都存在很大的共性，细心品尝里面的门道其实不可谓不多，这边重新梳理 LAMP 环境的搭建，帮助学习和理解。</p>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[efm32开发板+FAQ]]></title>
      <url>http://noparkinghere.top/2016/12/08/2016/2016-12-08-efm32%E5%BC%80%E5%8F%91%E6%9D%BF+FAQ/</url>
      <content type="html"><![CDATA[<p>silabs 的 EFM 系列芯片历来以低能耗，可信的加密而文明，比较遗憾的是，国内用的较少，且基本上没有什么中文参考资料，刚刚开办没多久的官方中文论坛贴出来的资料也大都是英文版，且论坛在 GFW 下访问相当困难。因为项目需求，这边我入手了两个系列的 EFM 开发板，但都出了大大小小的问题。</p>
<p>个人总结：1.因为前期缺少相关指导，且官方指导手册仅告诉要如何做，却没指示相关工具的位置和使用。2.该芯片配备专有 IDE 且还分好几个版本，无疑增加了摸索的难度。3.个人经验不足，之前上手的都是开发板，没接触过这种官方自带的评估板。</p>
<p>其实上手这个评估板并不困难，困难的是没有一个详尽完整的指导手册，不知道如何用评估板去烧录上面的 MCU ，如何用评估板烧录自己产品的 MCU等。</p>
<p>相比国内的开发板学习板而言，EFM 开发板大都是官方的评估板，并且大都是英文原版说明文档。最主要的一点，在购买 EFM 开发板时，官方是不会将开发板资料打包给你的，取而代之的是让你安装官方的软件 simplicity studio ，软件中会将你芯片的相关文档程序等进行罗列。虽然看起来更加人性化了，然而问题也出在这边，simplicity studio offline 罗列出来的文档/程序不全，部分你芯片的资料已经被装在电脑中了，但 simplicity studio 却没有将呈现给你，一般你还得自己手动在电脑中检索，或者去官网搜索。</p>
<h3 id="评估板简介："><a href="#评估板简介：" class="headerlink" title="评估板简介："></a>评估板简介：</h3><p>EFM32 配套评估板 上 Jlink 是从Segger授权的, 功能上应该没有缩减。因此价格也较贵，原价 $69 现价 $29 ，一般网购的价格在 ￥200 左右，这个价位对于国内 STM32 满地跑，部分 STM32 开发板价格甚至在 100 左右来说的话，还是较贵的，最关键的是淘宝购买的厂家不承担售后服务之类的，出问题只能自己解决。</p>
<p>另外，EFM32 官方配套软件很强大，将编码，烧录，仿真，能耗监控，文档，样例等等都集成在了一起，很多资料都需要去这个 IDE 中查找，对英语不好或者不善于摸索的人来说也是一道门槛。</p>
<p>评估板的功能：</p>
<ul>
<li>根据你的版型，不同的板子有不同的功能，一般都会有显示器，按键，led等基本功能</li>
<li>能耗检测模块</li>
<li>板载 Jlink ：可以烧录板载 MCU，也可以烧录外置芯片。</li>
<li>可以使用外置 Jlink 来烧录板载的 MCU。</li>
<li>大多数引脚引出，且预留焊盘，另外还有 EXP 扩展口（注意 debug-out 是小灯，而不是指 EXP 扩展口）。</li>
</ul>
<a id="more"></a>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>评估板的 debug 主要分为 in,out,mcu,off 等选项，这几个选项至关重要，我们可以不使用 simplicity studio 这个 IDE，但如果需要使用这个评估板，就必须得弄清楚如何设置评估板的 debug 模式。</p>
<p>这边我使用 simplicity v3 版本，设置 debug 模式，需要通过一个 commander 的软件，该软件在 simplicity v3 安装包中可以检索到，如果需要在 simplicity studio 中打开，则安装时需要安装无线模块套件（如果不安装这个套件，软件中无法打开这个 commander 工具，因此建议新手安装完整版的 simplicity v3 而不是只安装你所需要的芯片组建），打开 simplicity IDE 然后在 file 中打开 simplicity commander。</p>
<p>每次使用评估板要进行相关操作时，都需要使用 commander 进行设置，详细配置说明：</p>
<ul>
<li>debug-in ： 烧录评估板上面的 jlink 固件，注意烧录的是 jlink 而不是评估板的 EFM芯片。</li>
<li>debug-out : 使用评估板作为 jlink 烧录其他板子上面的外置芯片。mcu 资料中可以读出外置芯片具体信息，另外评估板有个 debug-out 灯会亮起。</li>
<li>debug-mcu : 烧录评估板上面自带的 EFM 芯片。mcu 资料中可以读出板载芯片具体信息。</li>
</ul>
<p><strong>评估板作为 jlink 是官方正版授权的，烧录程序一般没有问题，但如果需要打多个断点进行仿真，则可能会仿真失败，应该是和 jink 采用的芯片有关系。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-08-efm32开发板+FAQ/1.png" alt=""></p>
<h3 id="固件烧录"><a href="#固件烧录" class="headerlink" title="固件烧录"></a>固件烧录</h3><p>普通升级，官方推荐使用 Kit Manager 打开后会自动判断固件是否需要升级，事实上 Kit Manager 和 simplicity commander 功能基本相同，但 Kit Manager 更显得傻瓜式，而且也会经常出现无法打开，无法连接芯片等问题，如果遇到了这些问题，建议还是使用 simplicity commander 进行所有操作。</p>
<p>如果无法找到 commander 工具，这边推荐给出两个该工具的下载地址：</p>
<p>固件烧录失败后，如何重新烧录固件，步骤差不多如下：</p>
<ul>
<li>将评估板的 bootloader 接地（bootloader 位置各个开发板不尽相同，可以参照原理图，或者查看下面给出的参考连接），接下来连接电脑，打开 simplicity commander ，如果 bootloader 接地成功则会显示 j-link device 信息，否则读取不到信息。</li>
<li>设置 debug mode:in 烧录 jlink 芯片，找到固件包，安装包（包为 .emz 格式，在 simplicity 安装目录中，可以电脑自行检索包路径）。</li>
</ul>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>这边附上一个中文版的问题总结，比较难得的一版中文资料， <a href="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-08-efm32开发板+FAQ/EFM32 系列微控制器 FAQ.pdf" target="_blank" rel="external">EFM32 系列微控制器 FAQ</a></p>
<h4 id="根据-CMU-的时钟树，在使用其他低频时钟源操作-LEA-LEB-时无需配置-CMU-HFCORECLKEN0，但实际操作必须配置-CMU-HFCORECLKEN0-才可以正常工作。"><a href="#根据-CMU-的时钟树，在使用其他低频时钟源操作-LEA-LEB-时无需配置-CMU-HFCORECLKEN0，但实际操作必须配置-CMU-HFCORECLKEN0-才可以正常工作。" class="headerlink" title="根据 CMU 的时钟树，在使用其他低频时钟源操作 LEA/LEB 时无需配置 CMU_HFCORECLKEN0，但实际操作必须配置 CMU_HFCORECLKEN0 才可以正常工作。"></a>根据 CMU 的时钟树，在使用其他低频时钟源操作 LEA/LEB 时无需配置 CMU_HFCORECLKEN0，但实际操作必须配置 CMU_HFCORECLKEN0 才可以正常工作。</h4><p>查看 RTC/LEUART 可以看到 To use this module, the LE interface clock must be enabled in CMU_HFCORECLKEN0, in addition to the module clock. 时钟树没能将具体的成都呈现出来，实际工作时，查看相关外设的使用说明，会有使用方法。</p>
<h4 id="EFM32-如何给芯片加密解密？"><a href="#EFM32-如何给芯片加密解密？" class="headerlink" title="EFM32 如何给芯片加密解密？"></a>EFM32 如何给芯片加密解密？</h4><p>这边提供一个比较老的中文文档<a href="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-08-efm32开发板+FAQ/EFM32 加密-解锁流程.pdf" target="_blank" rel="external">EFM32 加密-解锁流程](FAQ</a>，仅供参考。需要注意的是，似乎只有 EFM32Gxxx 系列可以加密锁定，其他芯片是不可以的。</p>
<blockquote>
<p>参考链接：<br><a href="http://m.blog.csdn.net/article/details?id=41648431" target="_blank" rel="external">http://m.blog.csdn.net/article/details?id=41648431</a><br><a href="http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142" target="_blank" rel="external">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Recover-EFM32-or-EFM8-kit-that-was-bricked-during-firmware/ta-p/122142</a><br><a href="http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776" target="_blank" rel="external">http://community.silabs.com/t5/32-bit-MCU-Knowledge-Base/Unlock-a-Bricked-EFM32/ta-p/122776</a><br><a href="http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view" target="_blank" rel="external">http://wenku.baidu.com/view/ee891f3a5a8102d276a22ffc.html?re=view</a><br><a href="http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227" target="_blank" rel="external">http://community.silabs.com/t5/ChineseForum/%E7%96%91%E4%BC%BC%E8%8A%AF%E7%89%87%E6%98%AF%E5%90%A6%E7%83%A7%E5%9D%8F%E4%BA%86/m-p/184134/highlight/false#M1227</a><br><a href="http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx" target="_blank" rel="external">http://www.silabs.com/products/mcu/32-bit/efm32-gecko/pages/efm32-gecko.aspx</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PuTTY + Xming 远程使用 Linux GUI]]></title>
      <url>http://noparkinghere.top/2016/12/01/2016/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/</url>
      <content type="html"><![CDATA[<p>就目前而言，将 linux 作为个人电脑操作系统使用的人还比较少，而 linux 也一直以来因为其占用资源少，系统稳定，强大的 CLI 而闻名于世。因此显而易见，广大用户一般都是通过 ssh 等方式登录连接 linux ，然后使用 CLI 完成需要的操作，而使用 linux GUI 用户较少，甚至可以被忽略，但出于个人的需要，本人需要通过 windows 远程登录 linux 然后通过 chrome 等</p>
<h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3><ul>
<li>windows 7 x64 中文旗舰版</li>
<li>ubuntu 16.04 </li>
</ul>
<a id="more"></a>
<h3 id="软件配置："><a href="#软件配置：" class="headerlink" title="软件配置："></a>软件配置：</h3><h4 id="Xming-："><a href="#Xming-：" class="headerlink" title="Xming ："></a>Xming ：</h4><p>Xming是一个在 Microsoft Windows 操作系统上运行 X Window System 的自由软件。其主要功能是通过在Linux平台上通过交叉编译的方法，实现了跨越操作系统对X GUI的表现。</p>
<p>正常安装该软件：这边使用过的是： Xming-6-9-0-31-setup.exe 的版本，正常安装过，一般都没有问题，设置按照下图选择不安装 ssh client。 Display 设置按照个人习惯进行设置，如果仅是打开个别 GUI 窗口的话，建议采用 Multiple windows ，可以讲所有的 GUI 窗口作为一个个应用进行打开。接下来按照默认设置进行下一步即可，另外最后一步可以保存当前设置作为一个快捷方式，下次直接打开即可。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/1.png" alt=""></p>
<h4 id="putty"><a href="#putty" class="headerlink" title="putty :"></a>putty :</h4><p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。自带SSH Forwarding的功能，包括X11 Forwarding。</p>
<ul>
<li>输入需要拨号的地址（这边注意本机和目标机器在同一个网段）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/2.png" alt=""></p>
<ul>
<li>设置拨号的账户名，方便下次登录</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/3.png" alt=""></p>
<ul>
<li>一定要打开 X11 转发模式，可以让 ssh 图形化转发给 Xming 进行工作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-12-01-putty-xming-%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8-linux-gui/4.png" alt=""></p>
<h4 id="SecureCRT-方式（可以跳过）"><a href="#SecureCRT-方式（可以跳过）" class="headerlink" title="SecureCRT 方式（可以跳过）"></a>SecureCRT 方式（可以跳过）</h4><p>这边补充 SecureCRT 这个软件的方式，原理和 putty 类似，得益于 SecureCRT 在用户界面上面更加友好方便，常常用作远程管理使用，如果已经使用了 putty 的这边可以跳过，两种方式选其一即可。</p>
<p>SecureCRT 同 putty 类似，设置时，需要在 session options -&gt; connection -&gt; port forwarding -&gt; remote/x11 中勾选 x11 forwarding 下面的 forward x11 packets 和 enforce x11 authentication 。注意：不需要添加 remotely forwarded connections 中的内容。</p>
<h4 id="linux端设置"><a href="#linux端设置" class="headerlink" title="linux端设置"></a>linux端设置</h4><ul>
<li>要允许Linux主机上的SSH X转发，查看 /etc/ssh/sshd_config 文件，加入以下一行，<code>X11Forwrding yes</code> 至此配置完成。</li>
<li>保证 linux 端至少要有多个可以访问的用户。</li>
</ul>
<h4 id="工作运行"><a href="#工作运行" class="headerlink" title="工作运行"></a>工作运行</h4><ul>
<li>上述部分 putty 设置完成后，开始登录，注意使用不同于 linux 上已经登录图形界面的账户登录 putty 。</li>
<li>在 windows 上使用 PuTTY 连接到 linux ，输入 xclock &amp; ，可以看到一个图形化时钟出现了，说明图形化转发已经成功了。</li>
<li>输入 <code>google-chrome</code> 则可以在 xming 中打开 chrome 浏览器进行需要的操作了。</li>
<li>输入 <code>gnome-session</code> 则可以远程打开 GUI 交互环境。</li>
</ul>
<p><strong>这边要注意的是：如果 putty 和 linux GUI 登录了同一个账号，则输入相关命令可能会无法打开相关 GUI，检查发现事实上，你要打开的窗口在 linux 主机上面被打开了，因此最好的办法是登录一个新的账号，进行相关的图形化操作。</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过步骤可以发现，PuTTY + Xming 或 SecureCRT + Xming 的配置较为简单，但效率较低，即便传输速率达到 4mb/s 图像依然刷新较慢，体验效果很差。可能是 ssh 的直接访问方式，没有对视频等多媒体进行过优化，推荐可以采用其他方式进行远程桌面连接，这边可以参考博客中另外一篇文章 <em>TeamViewer 远程控制</em>。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html" target="_blank" rel="external">http://www.zw1840.com/blog/zw1840/2008/10/putty-xming-linux-gui.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[vps-docker]]></title>
      <url>http://noparkinghere.top/2016/11/28/2016-11-28-vps-docker/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">https://www.gitbook.com/book/yeasy/docker_practice/details</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[检测VPS虚拟化技术]]></title>
      <url>http://noparkinghere.top/2016/11/26/2016/2016-11-26-%E6%A3%80%E6%B5%8BVPS%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>很多时候，我们需要知道自己的 VPS 是通过什么软件进行分配的，这是可以使用如下的几种方式：</p>
<h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>使用如下命令运行</p>
<p><code>wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/code/master/vm_check.sh &amp;&amp; bash vm_check.sh</code></p>
<p>代码运行结束就会在最后一行显示虚拟化技术：kvm还是openv或者是xen一目了然。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line">make[1]: Leaving directory `/root/virt-what-1.12<span class="string">'</span></div><div class="line">openvz</div><div class="line">kvm</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上述内容，看末尾显示如果是：openvz 和 kvm 表示经过了 openvz 和 kvm 两层虚拟化最后构建了你所用的 VPS 。</p>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>这种方法是后来看到的，方法更为简单:</p>
<ul>
<li>apt-get install virt-what</li>
<li>直接执行 virt-what 这个脚本，就会报告结果，例如：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@a118:~<span class="comment"># virt-what </span></div><div class="line">openvz</div><div class="line">kvm</div></pre></td></tr></table></figure>
<blockquote>
<p>参考地址：<br><a href="https://www.91yun.org/zh/archives/836" target="_blank" rel="external">https://www.91yun.org/zh/archives/836</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS : shadowsocks]]></title>
      <url>http://noparkinghere.top/2016/11/25/2016/2016-11-25-vps-shadowsocks/</url>
      <content type="html"><![CDATA[<p>日常生活中，由于 GFW 的强大，很多学习资料等内容我们无法获取或者检索，因此科学上网往往相当重要，本文章使用 VPS 搭建 shadowsocks 服务让安全的科学上网成为可能，需要注意的是 VPS 必须是境外服务器，推荐 vultr 搬瓦工等廉价 VPS。另外你也可以访问<a href="https://shadowsocks.org/en/index.html" target="_blank" rel="external">shadowsocks 官网</a>查看详细的教程和下载软件。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>这边可以参考<a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="external">原文博客</a>，以下只是简单罗列一些原理：</strong></p>
<ul>
<li>早期互联网用户访问网站时，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户： </li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss1.png" alt=""></p>
<ul>
<li>GFW 出现后，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss2.png" alt=""></p>
<ul>
<li>为了绕过GFW的过滤（包含了各种HTTP代理服务、Socks服务、VPN服务等等），以 ssh tunnel 的方法为例：1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道 2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求 4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss3.png" alt=""></p>
<p><strong>由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh 存在被定向进行干扰的问题</strong></p>
<ul>
<li>shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似:1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题 2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密 3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/ss4.png" alt=""></p>
<ul>
<li>GFW 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 Connection Reset 这样的响应内容，而无法接收到正常的内容 </li>
</ul>
<h3 id="软件简介："><a href="#软件简介：" class="headerlink" title="软件简介："></a>软件简介：</h3><h4 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks:"></a>shadowsocks:</h4><p><a href="https://shadowsocks.org/en/index.html" target="_blank" rel="external">shadowsocks：A secure socks5 proxy,designed to protect your Internet traffic.</a>。</p>
<p>Shadowsocks（中文名称：影梭）是使用Python、C++、C#等语言开发的、基于Apache许可证的开放源代码软件，用于保护网络流量、加密数据传输。Shadowsocks使用Socks5代理方式。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。在中国大陆，本工具也被广泛用于突破防火长城（GFW），以浏览被封锁、屏蔽或干扰的内容。在2015年8月22日，Shadowsocks原作者Clowwindy称受到了中国政府的压力，宣布停止维护此项目并移除其用户页面所载的源代码。</p>
<p>Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。</p>
<ul>
<li>Shadowsocks使用自行设计的协议进行加密通信。[4]加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。</li>
<li>所有的流量都经过算法加密，允许自行选择算法，所以比较安全。</li>
<li>Shadowsocks通过异步I/O和事件驱动程序运行，响应速度快。</li>
<li>客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器（OpenWrt）等[5]。</li>
<li>专为移动设备和无线网络优化。</li>
</ul>
<h4 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor:"></a>supervisor:</h4><p>Linux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p>
<h3 id="VPS-安装及配置："><a href="#VPS-安装及配置：" class="headerlink" title="VPS 安装及配置："></a>VPS 安装及配置：</h3><h4 id="软件列表："><a href="#软件列表：" class="headerlink" title="软件列表："></a>软件列表：</h4><ul>
<li>vps（Debian GNU/Linux 7 ），这边采用 Debian 系列linux，ubuntu 应该步骤类似，如果使用 redhat 系列，部分指令需要自行更改，这边不做累述。</li>
<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>
<li>supervisor ： 用于Linux后台进程管理的利器</li>
</ul>
<a id="more"></a>
<h4 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul>
<li>安装软件，终端输入：<code>apt-get install python-pip &amp;&amp; pip install shadowsocks</code>。</li>
<li>写 shadowsocks 配置文件： vim /etc/shadowsocks.json ， 具体内容如下：</li>
<li>如果无法安装成功，请<a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="external">访问</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line">    <span class="string">"server_port"</span>:50003,</div><div class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="string">"local_port"</span>:1080,</div><div class="line">    <span class="string">"password"</span>:<span class="string">"123456"</span>,</div><div class="line">    <span class="string">"timeout"</span>:300,</div><div class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,</div><div class="line">    <span class="string">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">说明： </div><div class="line">server 你 vps 的 IP</div><div class="line">servier_port 服务端的端口</div><div class="line">local_port 本地端口，一般默认1080</div><div class="line">password 服务端设置的密码</div><div class="line">timeout 超时设置</div><div class="line">method 加密方法</div><div class="line"></div><div class="line">如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码:</div><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="string">"local_port"</span>:1080,</div><div class="line">    <span class="string">"timeout"</span>: 600,</div><div class="line">    <span class="string">"method"</span>: <span class="string">"aes-256-cfb"</span>,</div><div class="line">    <span class="string">"port_password"</span>:</div><div class="line">    &#123;</div><div class="line">        <span class="string">"10001"</span>: <span class="string">"password1"</span>,</div><div class="line">        <span class="string">"10002"</span>: <span class="string">"password2"</span>,</div><div class="line">        <span class="string">"10003"</span>: <span class="string">"password3"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"_comment"</span>:</div><div class="line">    &#123;</div><div class="line">        <span class="string">"10001"</span>: <span class="string">"xiaoming"</span>,</div><div class="line">        <span class="string">"10002"</span>: <span class="string">"lilei"</span>,</div><div class="line">        <span class="string">"10003"</span>: <span class="string">"mike"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这边 server 的地址可以通过 ifconfig 获取本机地址，如果是一些多层虚拟出来的机器，如果无法获得本机IP，则输入0.0.0.0即可。</p>
<ul>
<li>安装 supervisor： apt-get install supervisor</li>
<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisord.conf 在末尾加入如下内容：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[program:shadowsocks]</div><div class="line"><span class="built_in">command</span>=ssserver -c /etc/shadowsocks.json</div><div class="line">autostart=<span class="literal">true</span></div><div class="line">autorestart=<span class="literal">true</span></div><div class="line">user=root</div><div class="line">log_stderr=<span class="literal">true</span></div><div class="line">logfile=/var/<span class="built_in">log</span>/shadowsocks.log</div></pre></td></tr></table></figure>
<ul>
<li>最后让 supervisor 开机自启动：在 <code>vim /etc/rc.local</code> 空白行加入 <code>service supervisor restart</code> (事实上这一步可以不用加，supervisor 本身就会开机自启动，在 <code>/etc/rc2.d/</code> 下 我们可以看到 <code>lrwxrwxrwx 1 root root  20 Nov 25 11:56 S01supervisor -&gt; ../init.d/supervisor</code> ，当然如果你的系统没能自动开启 supervisor 守护进程，则需要手动完成上述操作)，重启服务器查看是否配置成功。</li>
</ul>
<p><em>采用 supervisor 的原因很大程度上是：将 <code>ssserver -c /etc/shadowsocks.json</code> 放入/etc/rc.local中没法开启自启该服务，另外 supervisor 会保护 ss 进程服务，当被终止后，会重启启动。</em></p>
<p><strong>以上内容均为个人总结转述，如果可以访问外网，请参考<a href="https://shadowsocks.org/en/download/servers.html" target="_blank" rel="external">官网</a>给出的更加详细的配置步骤。以下为客户端配置，注意只有在完成了服务器端配置或者你已经有一个可以使用的 shadowsocks 服务器，才能够在本地搭建以下服务。</strong></p>
<p>注意：如果你运行： ssserver -c /etc/shadowsocks.json 无法成功的话，则推荐去仔细阅读官网说明文档。</p>
<p><strong>设置完成后，root 重启 VPS。</strong></p>
<h3 id="本地-linux-下的安装配置"><a href="#本地-linux-下的安装配置" class="headerlink" title="本地 linux 下的安装配置"></a>本地 linux 下的安装配置</h3><h4 id="软件列表：-1"><a href="#软件列表：-1" class="headerlink" title="软件列表："></a>软件列表：</h4><ul>
<li>linux PC端： shadowsocks ， 本地操作系统 ubuntu 16.04 , 。</li>
<li>shadowsocks-severs： 注意安装 shadowsocks 的 severs 版本</li>
<li>supervisor ： 用于Linux后台进程管理的利器</li>
<li>chrome 插件 SwitchyOmega ：</li>
</ul>
<h4 id="详细步骤：-1"><a href="#详细步骤：-1" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul>
<li>安装 shadowsocks （我们这边不采用 GUI 软件而直接使用 shadowsocks 命令工具连接 shadowsocks 服务器。）步骤如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install python-pip</div><div class="line">sudo apt-get install python-setuptools m2crypto</div><div class="line">pip install shadowsocks</div><div class="line"></div><div class="line">注意： 如果是 ubuntu 16.04 的版本执行完以上命令后可能仍然无法执行 sslocal 命令，需要手动执行 `sudo apt install shadowsocks` （ubuntu16.04 直接可以直接用apt 而不用 apt-get 这是一项改进）。</div></pre></td></tr></table></figure>
<ul>
<li>配置 Shadowsocks ：同服务器类似， 也是配置 shadowsocks.json 这个文件，可以在你想要指定的目录下新建这个文件如：~/.config/shadowsocks.json ， 编辑该文件：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"server"</span>:<span class="string">"www.baidu.com"</span>,</div><div class="line">    <span class="string">"server_port"</span>:50003,</div><div class="line">    <span class="string">"local_port"</span>:1080,</div><div class="line">    <span class="string">"password"</span>:<span class="string">"123456"</span>,</div><div class="line">    <span class="string">"timeout"</span>:600,</div><div class="line">    <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">说明：</div><div class="line">server 后面填写你需要链接的服务器地址</div><div class="line">server_port 后面填写你 Shadowsocks 服务器配置的 server_port 端口</div><div class="line">local_port 无需修改</div><div class="line">password 需要和 Shadowsocks 服务器保持一致</div></pre></td></tr></table></figure>
<ul>
<li>完成以下步骤后，你的浏览器仍然不能浏览网页，Shadowsocks 仅提供了转发服务，而你本地的端口发送的数据还无法和server_port进行链接，这时候，你可以采用全局代理的软件让所有数据帮转发，这边推荐chrome的 SwitchyOmega 插件。可以从Github上直接下载最新版 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="external">SwitchyOmega</a> （这个是chrome的）然后浏览器地址打开chrome://extensions/，将下载的插件托进去安装。安装好之后下面开始设置代理，如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/3.png" alt=""></p>
<p>上图步骤中注意类型条件中勾选<strong>规则列表规则</strong>， 规则地址： <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 填入其中。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/4.png" alt=""></p>
<p>点击 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。</p>
<p>如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。</p>
<ul>
<li>安装 supervisor： sudo apt-get install supervisor</li>
<li>将 shadowsocks 加入到 supervisor 中进行管理：vim /etc/supervisor/supervisor.conf 在末尾加入如下内容，或者在 /etc/supervisor/conf.d 下新建新的文件增加如下内容（注意 shadowsocks.json 文件路径写对）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[program:shadowsocks]</div><div class="line"><span class="built_in">command</span>=sslocal -c /home/username/.config/shadowsocks.json</div><div class="line">autostart=<span class="literal">true</span></div><div class="line">autorestart=<span class="literal">true</span></div><div class="line">user=root</div><div class="line">log_stderr=<span class="literal">true</span></div><div class="line">logfile=/var/<span class="built_in">log</span>/shadowsocks.log</div></pre></td></tr></table></figure>
<ul>
<li>最后让 supervisor 开机自启动：在 <code>sudo vim /etc/rc.local</code> 空白行加入 <code>sudo service supervisor restart</code>。<em>不知出于什么原因这边 supervisor 必须手动写入 /etc/rc.local 中才会开机自启动</em> 查看是否配置成功可以重启电脑。</li>
</ul>
<p><em>如果需要让 linux 下其他软件也都可以使用 ss 服务，可以参考我的另外一篇文章：linux-shadowsocks全局代理。</em></p>
<h3 id="本地-windows-下安装配置"><a href="#本地-windows-下安装配置" class="headerlink" title="本地 windows 下安装配置"></a>本地 windows 下安装配置</h3><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/3.3.5/Shadowsocks-3.3.5.zip" target="_blank" rel="external">下载客户端</a>，作为一个开源软件 GUI 客户端分为多个版本，这边提供了 win 版本，需要安装 微软的库，打开后如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/5.png" alt=""></p>
<p>这边的服务器 IP 同上面 linux 的类似，填写你的域名或者 IP 即可，密码也要和服务器的 shadowsocks 服务保持一致。值得一提的是 windows 下面的客户端直接可以设置全局代理，右击任务栏的小图标可以设置相关选项。</p>
<p><strong>配置成功后，重启本地电脑，或者 kill 本地 ssslocal 进程，supervisor 会重新重启 ss 服务，加载新的配置。</strong></p>
<h3 id="本地-安卓手机端-安装配置"><a href="#本地-安卓手机端-安装配置" class="headerlink" title="本地 安卓手机端 安装配置"></a>本地 安卓手机端 安装配置</h3><p>安卓用户这边推荐使用腾讯自家的应用宝，直接搜索 shadowsocks 会看到中文名“影梭”的这个软件(<em>注意应用宝中的软件版本较老，为 2.8.3 目前最新版本为 3.2.7。</em>)，设置基本和 windows 的类似，设置完毕后，点击右上角的开启按钮。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-25-vps-shadowsocks/6.png" alt=""></p>
<p>其中安卓和苹果的<a href="https://shadowsocks.org/en/index.html" target="_blank" rel="external">shadowsocks 官网</a>给出地址都是应用商城地址，用户可以直接去 github 去查找 shadowsocks 库，在 releases 中下载最新的版本。</p>
<blockquote>
<p>参考链接：<br><a href="http://vc2tea.com/whats-shadowsocks/" target="_blank" rel="external">http://vc2tea.com/whats-shadowsocks/</a><br><a href="https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html" target="_blank" rel="external">https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html</a><br><a href="https://aitanlu.com/linux-ubuntu-install-shadowsocks.html" target="_blank" rel="external">https://aitanlu.com/linux-ubuntu-install-shadowsocks.html</a><br><a href="https://php-rmcr7.rhcloud.com/shadowsocks-server/" target="_blank" rel="external">https://php-rmcr7.rhcloud.com/shadowsocks-server/</a><br><a href="http://blog.chinaunix.net/uid-25530360-id-5595974.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-25530360-id-5595974.html</a><br><a href="http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000" target="_blank" rel="external">http://www.liaoxuefeng.com/article/0013738926914703df5e93589a14c19807f0e285194fe84000</a><br><a href="https://zh.wikipedia.org/zh-hans/Shadowsocks" target="_blank" rel="external">https://zh.wikipedia.org/zh-hans/Shadowsocks</a><br><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="external">https://github.com/shadowsocks/shadowsocks/tree/master</a><br><a href="http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:http://everet.org/shadowsocks.html</a><br><a href="https://wiki.archlinux.org/index.php/Shadowsocks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Shadowsocks_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87</a>)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[(转)虚拟主机、VPS和云主机]]></title>
      <url>http://noparkinghere.top/2016/11/23/2016/2016-11-23-%E8%BD%AC-%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E3%80%81vps%E5%92%8C%E4%BA%91%E4%B8%BB%E6%9C%BA/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转载链接：<a href="http://www.chinaz.com/prime/2012/1021/279069.shtml" target="_blank" rel="external">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>
</blockquote>
<p>云计算时代，云主机其可扩展性、价格便宜、安全可靠的特性深受企业和开发者欢迎，但目前有些IDC企业，新瓶装旧酒，将虚拟主机、VPS进行包装推出所谓的云主机服务，为了帮助用户更好的辨别和挑选云主机，下文详细介绍虚拟主机、VPS和云主机产品的特点以及差异性。</p>
<h3 id="一、虚拟主机、VPS和云主机"><a href="#一、虚拟主机、VPS和云主机" class="headerlink" title="一、虚拟主机、VPS和云主机"></a>一、虚拟主机、VPS和云主机</h3><p>共享主机也称虚拟主机，从互联网诞生至今，大部分站长都是从”共享主机”(shared hosting)开始学习建站的。所谓”共享主机”，就是一台服务器上有许多网站，大家共享这台服务器的硬件和带宽。如果它发生故障，那么上面的所有网站都无法访问。</p>
<p>VPS主机(Virtual Private Server 虚拟专用服务器)，将一部服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、独立超大空间、独立内存、独立CPU资源、独立执行程序和独立系统配置等。用户除了可以分配多个虚拟主机及无限企业邮箱外，更具有独立服务器功能，可自行安装程序，单独重启服务器。</p>
<p>”云主机”(Cloud hosting)可以看成是新一代的共享主机。</p>
<p>首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。</p>
<p>比如，假设你要把本机的文件备份到网上，你可以使用共享主机，把文件传到某一台服务器上;也可以使用云主机，通过某种形式的接口，把它们传到云里。也就是说，共享主机用户直接面对特定的服务器，而云主机用户直接面对网络接口，看不到服务器内部。</p>
<p>一个通俗的比喻是，你可以向银行租一个编号为”8888″的保险箱(共享主机)，也可以把贵重物品直接交给保管公司，听任他们保管。</p>
<p>诸如Gmail、FaceBook、Twitter、Flickr这样的产品，都可以看作是基于”云主机”的服务。</p>
<p>云主机能真正获得root权限，用户可以重装和升级操作系统，而VPS主机用户没有root权限，无法重装和升级操作系统。</p>
<a id="more"></a>
<h3 id="二、虚拟主机、VPS、云主机的区别"><a href="#二、虚拟主机、VPS、云主机的区别" class="headerlink" title="二、虚拟主机、VPS、云主机的区别"></a>二、虚拟主机、VPS、云主机的区别</h3><h4 id="供应和部署时间"><a href="#供应和部署时间" class="headerlink" title="供应和部署时间"></a>供应和部署时间</h4><p>虚拟主机——数天至数周</p>
<p>VPS———即时，无需安装操作系统</p>
<p>云主机——即时，几分钟即可完成，可一键部署、也可自主安装操作系统</p>
<h4 id="安全可靠性"><a href="#安全可靠性" class="headerlink" title="安全可靠性"></a>安全可靠性</h4><p>虚拟主机——一般：租用白牌服务器故障率高、基本无ARP、木马和DDOS防范能力、基本无备机和数据备份服务</p>
<p>VPS———差：同一台物理服务器上其他VPS上安装的程序缺陷、ARP欺骗、病毒、资源挤占等会严重影响到自身;基本无ARP、木马和DDOS防范能力</p>
<p>云主机——高：内置ARP防范，规模化提升DDOS防攻击能力;分享品牌企业级服务器和硬件虚拟化的性能和可靠性，内置HA;提供备机、快照、数据备份等多种快速恢复措施</p>
<h4 id="性能及保障"><a href="#性能及保障" class="headerlink" title="性能及保障"></a>性能及保障</h4><p>虚拟主机——好且有保障</p>
<p>VPS———差：性能一般，只适用于小规模并发访问;性能无保障，易遭受同一台物理服务器上其他VPS的挤压</p>
<p>云主机——好且有保障：同物理服务器</p>
<h4 id="弹性和扩展性"><a href="#弹性和扩展性" class="headerlink" title="弹性和扩展性"></a>弹性和扩展性</h4><p>虚拟主机——扩容需要重新租用新服务器、还需为原有租用资源付费</p>
<p>VPS———扩容快，受制于单台服务器配置</p>
<p>云主机——即时供应、按需扩展 ，无需为原有租用资源付费</p>
<h4 id="拥有成本"><a href="#拥有成本" class="headerlink" title="拥有成本"></a>拥有成本</h4><p>虚拟主机——季付年付成本高、需要为服务商转嫁CapEx支出支付押金;需要自己维护租用的服务器导致Opex较高</p>
<p>VPS———低配置的VPS租用价格最低;但低安全可靠性和无保障的性能导致服务质量无保障，运营成本难控制且偏高</p>
<p>云主机——综合成本最低：月付无押金、按需使用按需付费、基本零维护 ，还可分享规模化、绿色节能、最佳IT实践带来的成本优势</p>
<h4 id="易用、易管理性"><a href="#易用、易管理性" class="headerlink" title="易用、易管理性"></a>易用、易管理性</h4><p>虚拟主机——需要远程控制卡且只有租用品牌机才有可能，无法实现集中统一管理</p>
<p>VPS———提供单一的单机管理界面，无root或超级管理员操作系统权限，管理灵活性受制于管理界面</p>
<p>云主机——内置KVM、客户通过自服务系统可以集中统一管理分布在各地的云主机;完全拥有root或超级管理员操作系统权限</p>
<h3 id="三、云主机的优点"><a href="#三、云主机的优点" class="headerlink" title="三、云主机的优点"></a>三、云主机的优点</h3><p>云主机主要有三大优点。</p>
<ul>
<li><p>便宜:因为服务可以分散到多台服务器，因此能够充分利用资源，这样就降低了硬件、电力和维护成本。而且，云主机是根据使用量计费的，多用多付，少用少付，所以对小网站特别有利。</p>
</li>
<li><p>可靠:因为服务分布在多台服务器、甚至多个机房，所以不容易彻底宕机，抗灾容错能力强，可以保证长时间在线。</p>
</li>
<li><p>可扩展性好(scalability):云主机的基本特点就是分布式架构，所以可以轻而易举地增加服务器，成倍扩展服务能力。</p>
</li>
</ul>
<h3 id="四、云主机的缺点"><a href="#四、云主机的缺点" class="headerlink" title="四、云主机的缺点"></a>四、云主机的缺点</h3><p>一些客户担心云主机的安全问题，感到对服务缺乏控制。</p>
<p>因为云主机只是提供网络接口，所以客户的数据必然全部服从云服务公司的安排，完全在后者控制之下。数据是否安全保密，取决于后者的职业道德和保护能力。</p>
<p>但是，这其实是一个”伪问题”，因为绝大多数情况下，云服务公司会比客户更在乎、也更善于保护数据。Paul Graham在《黑客与画家》一书中，就谈过这一点：</p>
<p>”反对者往往觉得我们的产品不安全，如果员工可以很容易地登录，那么坏人也可以很容易地登录。一些大公司觉得不能把客户的信用卡资料交给我们，而是放在自己的服务器上更安全。……但是事实上，他们的服务器就是没我们的安全，我们对数据的保护几乎肯定比他们好。</p>
<p>想想看，谁能雇到更高水平的网络安全专家，是一个所有业务就是管理服务器的技术型创业公司，还是一家服装零售商？……而且我们比他们更关心数据的安全。如果一家服装零售商的服务器被入侵，最多只影响到这家公司本身，这件事也很可能在公司内部被掩盖起来，最严重的情况下可能还会有一个员工被解雇。但是，如果我们的服务器被入侵，就有成千上万家公司可能受到影响，这件事也许还会被当作新闻，发表在业内网站上面，使得我们生意做不下去，不得不关门歇业。</p>
<p>如果你想把钱藏在安全的地方，请问你是选择家中床垫下面，还是选择银行？这个比喻对服务器管理的方方面面都适用，不仅是安全性，还包括正常运行时间、带宽、负载管理、备份等等，都是我们占优。”</p>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git submodule 详解]]></title>
      <url>http://noparkinghere.top/2016/11/23/2016-11-23-git-submodule-%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>使用 git 也有一段时间，但不得不说 git 的功能相当强大和复杂，需要你不断的去摸索学习。这边介绍一个 git 很强大的功能：git submodule 。起初发现这个文件是在我本人 fork 了一个 awesome 的配置文件，用了也蛮久，但最近由于总是出现连接错误，然后手动去更改了一些文件，但意外发现更改的文件无法提交， status 中竟然没有这些文件的信息，另外通过其他官方文档 gitignore 中的几个 ignore 中仔细查看，很确定项目中并没有忽略这些文件，通过排查最后才发现是 .gitmodules 这个文件捣的鬼。仔细研究发现git-submodule是一个十分强大的功能，值得去学习研究。</p>
<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="external">http://www.kafeitu.me/git/2012/03/27/git-submodule.html</a><br><a href="https://git-scm.com/docs/git-submodule" target="_blank" rel="external">https://git-scm.com/docs/git-submodule</a><br><a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">https://git-scm.com/docs/git-config</a><br><a href="https://git-scm.com/docs/gitignore" target="_blank" rel="external">https://git-scm.com/docs/gitignore</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CRC校验]]></title>
      <url>http://noparkinghere.top/2016/11/22/2016-11-22-crc%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="原理规则"><a href="#原理规则" class="headerlink" title="原理规则"></a>原理规则</h3><a id="more"></a>
<h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK" target="_blank" rel="external">http://wenku.baidu.com/link?url=FLbB1d-cPj5uuxsaORgTaLYDUcEwziU4VFE3dHzIxv_2UNwvBiBAo4_n5D2n9zbmgM3kJMJHKOptYbd6bJd21sHtDIOLysViDIHcHN5UpgK</a><br><a href="http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS" target="_blank" rel="external">http://wenku.baidu.com/link?url=_jgyTFPUC5EdnDykoVR-hbtutdNnZjgOhlbHaJ0Ipcy04SZiLHCaUY2zTyiZjn4WpNPxQZUDtBXJD5Z1K56EUffQ7nk3qM5lxH0ux9Qz7OS</a><br><a href="http://blog.csdn.net/husion01/article/details/17440333" target="_blank" rel="external">http://blog.csdn.net/husion01/article/details/17440333</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim学习]]></title>
      <url>http://noparkinghere.top/2016/11/21/2016/2016-11-21-vim%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>vim 和 emacs 一个号称编辑器之神，一个被称为神的编辑器。打开 vim 执行命令：vimtutor 则可以查看官方说明教程，vimtutor是vim使用入门教程。老实说，自从接触vim到现在也有好多年了，但一直没有强迫自己使用，以及它的难定制性，让我至今都还无法像那些大神一样，完全脱离鼠标和IDE，本文只对 vim 最基础和常用的部分进行详细讲解，不涉及定制和插件等部分内容。</p>
<p>普通模式的操作： [数字] command motion，数字代表了后面实际操作执行的次数；command 是执行命令，如：复制，粘贴，剪切等；motion 是操作符，代表了执行命令的操作范围就是定位命令如：i,j,k,l,G等等。</p>
<p>普通模式是任何模式的中继，虽然普通模式下你只能通过一些命令进行简单的操作，但如果你想从某个模式进入另外一个模式都必须要先进入普通模式，如：从插入模式进入可视模式，必须先按 esc 进入普通模式，然后按 v 进入可视模式。</p>
<p>ex 命令都是以 : 开头的字符</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>在普通模式下，可以用键盘实现光标的移动，h j k l 分别代表光标的 左 下 上 右 的移动。请按 esc 键(这是为了确保您处在正常模式)。</p>
<ul>
<li>h 的键位于左边，每次按下就会向左移动。</li>
<li>l 的键位于右边，每次按下就会向右移动。</li>
<li>j 键看起来很象一支尖端方向朝下的箭头。</li>
<li>k 朝上移动。</li>
<li>gg 跳到首行</li>
<li>G 跳到末行</li>
</ul>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>在命令模式下，在普通模式中，输入冒号则进入命令行模式：</p>
<ul>
<li>输入 w 则保存</li>
<li>输入 q 则退出该软件</li>
<li>输入 wq 保存并退出</li>
<li>输入 q! 强制退出。</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在<strong>普通模式下</strong>，删除单一字符可以使用 x 命令，如果删除更多字符则可以使用 d 命令：<code>d motion</code>。</p>
<p>motion 表示操作范围的指令，一下内容再次出现的 motion 都参见这边的表格：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>将光标定位到行首位置</td>
</tr>
<tr>
<td>$</td>
<td>光标定位到行尾位置</td>
</tr>
<tr>
<td>b</td>
<td>将光标定位到光标所在单词的起始处</td>
</tr>
<tr>
<td>e</td>
<td>将光标定位到光标所在单词的结尾处</td>
</tr>
<tr>
<td>w</td>
<td>将光标定位到下一个单词的起始处</td>
</tr>
<tr>
<td>gg</td>
<td>将光标定位到文件开头</td>
</tr>
<tr>
<td>G</td>
<td>将光标定位到文件结尾</td>
</tr>
</tbody>
</table>
<p>如果删除更多字符则可以使用 c 命令：<code>c motion</code>，和 d 命令类似，区别是删除后，进入插入模式。</p>
<p><strong>vim 中所有的删除都相当于剪切，并不是真正意义上的删除，所以一旦粘贴的话往往会是你所删除的那些内容。</strong></p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>在<strong>普通模式下</strong>，可以使用 y 命令：<code>y [数字] motion</code>。复制的操作和删除类似，学习 vim 时尤其需要注意这些共性。</p>
<p>vim有12个粘贴板，分别是 <code>0、1、2、...、9、a、&quot;、+</code> 用 :reg 命令可以查看各个粘贴板里的内容。下面讲一下vim的粘贴板的基础知识：</p>
<ul>
<li>+号粘贴板是系统粘贴板，用 “+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用 Ctrl＋C 或右键复制的内容复制到 vim 中，需要在正常模式下按 “+p 。</li>
<li>“ 号粘贴板（临时粘贴板）比较特殊，直接按 y 就复制到这个粘贴板中了，直接按 p 就粘贴这个粘贴板中的内容；</li>
<li>要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按”Np，其中N为粘贴板号，如上所述，可以按”5p将5号粘贴板里的内容粘贴进来，也可以按”+p将系统全局粘贴板里的内容粘贴进来。</li>
</ul>
<h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>p 将最后一次剪切或者复制的内容，粘贴到<strong>光标之后</strong>；P 将最后一次剪切或者复制的内容，粘贴到<strong>光标之前</strong>。</p>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>在<strong>普通模式下</strong>，u 表示撤销最后一次修改，U 撤销整行的修改，ctrl+r 恢复撤销的内容。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在普通模式下进入插入模式，可以使用以下指令：</p>
<ul>
<li>i：光标前插入</li>
<li>I ：行首插入</li>
<li>a：光标后插入</li>
<li>A：行尾插入</li>
</ul>
<h3 id="可视"><a href="#可视" class="headerlink" title="可视"></a>可视</h3><p>出了插入，普通，命令模式外，还有可视模式，通过 v 和 V 进入该模式。</p>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>跳转到指定行：</p>
<ul>
<li>普通模式下输入：行号+G</li>
<li>进入命令行模式：<code>:行号</code></li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>查找光标所指向的单词，直接 <code>shift+*</code> 即可高亮。</p>
<p>输入/内容，则会匹配所有相关内容，按 n 搜索下一个匹配， 按 N 搜索上一个匹配。</p>
<p>搜索诸如：<code>. * [ ] ^ % / ? ~ $</code> 等，需要在前面加上 \ 转义字符。</p>
<p>取消搜索的高亮，则可以输入：<code>nohl</code>（nohighlight的缩写）。</p>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul>
<li>:s/原内容/替换 ： 光标后找到第一匹配内容并替换</li>
<li>:%s/原内容/替换 ： 请示替换内容</li>
<li>:1,10s/原内容/替换/g ： 1-10 行的所有内容进行替换</li>
</ul>
<h3 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h3><p>打开 vim 时，输入 vim -o a b c 可以并排打开三个文件，使用 ctrl + w + w 切换到下个窗口，也可以使用 ctrl + w + 方向按键进行切换。</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>zz 代替 :wq<br>:map 宏定义<br>. ：代表当前行，$代表最后行，1代表第一行<br>:! ：输入 shell 命令 ； :r 文件名； :r! ： 插入 shell 命令输出结果<br>:e ：切换编辑新文件，无需退出<br>:e!<br>s<br>cc/S<br>cw<br>de<br>deep<br>ddp<br>. 操作<br>~ ： 改变大小写<br>:co<br>:m</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/nkguohao/article/details/8937695" target="_blank" rel="external">http://blog.csdn.net/nkguohao/article/details/8937695</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS 简介]]></title>
      <url>http://noparkinghere.top/2016/11/19/2016/2016-11-19-vps-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>起初对云服务很好奇，完全不知所云，无从下手的感觉，但经过一段时间的摸索研究，也基本能够搭建一些自己想要的服务了，这边根据一些网络资料和自己的学习研究，对这阶段进行一个总结，希望对那些刚刚开始尝试搭建云服务的网友有所帮助。</p>
<h3 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h3><p>利用虚拟话技术在一台物理服务器上面创建多个相互隔离的虚拟化私有主机(“Virtual Private Server – VPS”)，可以看出原理和 PC 上面用虚拟机自己虚拟出来的系统并没有什么本质区别，只不过 VPS 是虚拟化之后放到网络上面使用的而已。对用户和应用程序来说，每个 VPS 平台的运行和管理都与一台独立主机完全相同，每个 VPS 均可以独立进行重启并且拥有 root 访问权限，用户，IP地址，内存，进程，文件，应用程序，系统函数库以及配置文件等。</p>
<p>目前一般 VPS 结构是这样的：最底层为 Host Hardware 硬件， 然后是 Host Operating System 宿主机/真实系统，再然后是真实系统上面运行的虚拟化软件，最后是虚拟机软件内部运行的操作系统 Guest OS 访客系统（这边看上去和我们个人电脑 PC 上面跑的虚拟机中的虚拟操作系统并没啥区别）。</p>
<p>随着云技术的不断成熟，现在的 VPS 也有了很大的改进，例如国内的腾讯，阿里等都给自己的 VPS 起了新名字，什么弹性云服务，无虚拟机，云服务器等等，从用户角度来看和 VPS 没有区别，但技术层面一般现在都会将 Host Hardware 硬件通过集群技术搭建，几百上千台主机共建一个硬件平台，然后分配资源建立 VPS，这边一般可以看作是 cloud VPS，可以做到弹性扩展，无缝对接，无需在需要时再去更新硬件资源。</p>
<p>能够使用 linux VPS 完成的优先使用 linux。</p>
<p>这边如果对 VPS 服务器等还有疑惑可以参考本博客的另外一篇文章<strong>虚拟主机、VPS和云主机</strong>。</p>
<a id="more"></a>
<h4 id="桌面用户："><a href="#桌面用户：" class="headerlink" title="桌面用户："></a>桌面用户：</h4><p>vmware，virtualbox，virutalPC等，vmware，virtualbox都是支持多个操作系统的跨平台软件功能强大，用的也比较多。</p>
<h4 id="服务器用户："><a href="#服务器用户：" class="headerlink" title="服务器用户："></a>服务器用户：</h4><ul>
<li>Hyper-V：微软自带的虚拟化技术，只能在 windows 上运行，买 windows vps 很可能是 Hype-V 虚拟的</li>
<li>vmware：专业做虚拟话技术的公司，产品覆盖很广，个人企业都有，功能强大，可运行在各个平台，虚拟出各种操作系统。</li>
<li>OpenVZ：很老的一款软件，只能运行在 linux 上，也只能虚拟出 linux 操作系统，国内很多在拆分的时候没有很好的维护以及滥用超售，不能运行需要编译内核的应用。</li>
<li>Xen：版虚拟化技术，性能有一定损失，可以升级内核等</li>
<li>KVM：最近两年刚流行的，是一个开源系统虚拟化模块，KVM 目前已经成为学术界主流的虚拟机监控器之一，目前因为硬件虚拟化技术等都比较成熟，KVM 性能优势等相当明显。</li>
</ul>
<p>对于 VPS 的免费软件选择： KVM &gt; XEN &gt; OpenVZ。</p>
<h4 id="用途分析："><a href="#用途分析：" class="headerlink" title="用途分析："></a>用途分析：</h4><ul>
<li>搭建网站平台</li>
<li>不熟企业信息化系统，中小型企业不存在机房，使用 VPS 会节约成本。</li>
<li>挂 PT 数据传输分享</li>
<li>加密数据访问，科学上网</li>
<li>多人协作开发，代码托管</li>
<li>私有云存储空间</li>
<li>等等</li>
</ul>
<h4 id="VPS-选择"><a href="#VPS-选择" class="headerlink" title="VPS 选择"></a>VPS 选择</h4><ul>
<li>优先选择 linux VPS ，软件多，性能稳定，占用资源少，价格便宜等等。</li>
<li>选择国内 VPS （阿里云/腾讯云）：面向群体为国内用户，需要 ICP 备案，时间较长；另外支持备案的域名较少，使用国内 VPS 时，购买域名需要慎重。</li>
<li>选择国外 VPS （vultr，digitalocean, 搬瓦工）：客户是国外用户或者不用于商业用途，价格为国内一半以下，带宽充足。</li>
</ul>
<h4 id="选择虚拟技术"><a href="#选择虚拟技术" class="headerlink" title="选择虚拟技术"></a>选择虚拟技术</h4><p>优先选择 KVM， 其次 XEN 或 vmware，最后 OpenVZ。</p>
<h4 id="硬件资源选择"><a href="#硬件资源选择" class="headerlink" title="硬件资源选择"></a>硬件资源选择</h4><p>一般 VPS 会提供多种方案或者自由搭配组合，主要根据自己的实际需求选择硬件资源。</p>
<ul>
<li>应用要求高，则选择内存大的，CPU 强劲的方案，例如游戏服务器等</li>
<li>网络应用，主要分享文件视频等，选择流量大的</li>
<li>主要用于存储数据的，选择较大的硬盘空间。</li>
</ul>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=Hs-er4JwHc8" target="_blank" rel="external">https://www.youtube.com/watch?v=Hs-er4JwHc8</a><br><a href="http://www.chinaz.com/prime/2012/1021/279069.shtml" target="_blank" rel="external">http://www.chinaz.com/prime/2012/1021/279069.shtml</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[keil工程的代码优化]]></title>
      <url>http://noparkinghere.top/2016/11/16/2016/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="C项目的工程优化"><a href="#C项目的工程优化" class="headerlink" title="C项目的工程优化"></a>C项目的工程优化</h3><p>这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。</p>
<h3 id="keil"><a href="#keil" class="headerlink" title="keil"></a>keil</h3><p>keil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。</p>
<p>每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。</p>
<p><strong>Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM &gt; Code + RO Data + RW Data  ， 而 RAM &gt; RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png" alt=""></p>
<a id="more"></a>
<p>KDE 生成的 .map 文件分析：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">Product: MDK-ARM Standard 5.10</div><div class="line">Component: ARM Compiler 5.04 update 1 (build 49)</div><div class="line">Tool: armlink [5040049]</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Section Cross References</div><div class="line"></div><div class="line">    main.o(i.AdjustTask) refers to memseta.o(.text) <span class="keyword">for</span> __aeabi_memclr4</div><div class="line">    main.o(i.AdjustTask) refers to analogin.o(i.AnalogInConvert) <span class="keyword">for</span> AnalogInConvert</div><div class="line">	...</div><div class="line">	</div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Removing Unused input sections from the image.</div><div class="line"></div><div class="line">    Removing main.o(.data), (1 bytes).</div><div class="line">    Removing main.o(.data), (4 bytes).</div><div class="line">	...</div><div class="line"></div><div class="line">329 unused section(s) (total 12428 bytes) removed from the image.</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Image Symbol Table</div><div class="line"></div><div class="line">    Local Symbols</div><div class="line"></div><div class="line">    Symbol Name                              Value     Ov Type        Size  Object(Section)</div><div class="line"></div><div class="line">    ../clib/../cmprslib/zerorunl2.c          0x00000000   Number         0  __dczerorl2.o ABSOLUTE</div><div class="line">    ../clib/microlib/division.c              0x00000000   Number         0  uldiv.o ABSOLUTE</div><div class="line">	...</div><div class="line">	</div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Memory Map of the image</div><div class="line"></div><div class="line">  Image Entry point : 0x08000131</div><div class="line"></div><div class="line">  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x0001c0c8, Max: 0x00080000, ABSOLUTE, COMPRESSED[0x0001bc94])</div><div class="line"></div><div class="line">    Execution Region ER_IROM1 (Base: 0x08000000, Size: 0x0001baa0, Max: 0x00080000, ABSOLUTE)</div><div class="line"></div><div class="line">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class="line"></div><div class="line">    0x08000000   0x00000130   Data   RO         4967    RESET               startup_stm32f10x_hd.o</div><div class="line">    0x08000130   0x00000000   Code   RO         5008  * .ARM.Collect$$$<span class="variable">$00000000</span>  mc_w.l(entry.o)</div><div class="line">    0x08000130   0x00000004   Code   RO         5086    .ARM.Collect$$$<span class="variable">$00000001</span>  mc_w.l(entry2.o)</div><div class="line">	...</div><div class="line">	</div><div class="line">    Execution Region RW_IRAM1 (Base: 0x20000000, Size: 0x0000f050, Max: 0x00010000, ABSOLUTE, COMPRESSED[0x000001f4])</div><div class="line"></div><div class="line">    Base Addr    Size         Type   Attr      Idx    E Section Name        Object</div><div class="line"></div><div class="line">    0x20000000   0x00000038   Data   RW           27    .data               main.o</div><div class="line">    0x20000038   0x00000005   Data   RW          422    .data               analogin.o</div><div class="line">	...</div><div class="line">	</div><div class="line">==============================================================================</div><div class="line"></div><div class="line">Image component sizes</div><div class="line"></div><div class="line"></div><div class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name</div><div class="line"></div><div class="line">      1252        138          0          5        200       3550   analogin.o</div><div class="line">       704         74         12         24          0       5534   analogout.o</div><div class="line">	...</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line"></div><div class="line">      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   </div><div class="line"></div><div class="line">     80732       6214      32580       1576      59944     659393   Grand Totals</div><div class="line">     80732       6214      32580        500      59944     659393   ELF Image Totals (compressed)</div><div class="line">     80732       6214      32580        500          0          0   ROM Totals</div><div class="line"></div><div class="line">==============================================================================</div><div class="line"></div><div class="line">    Total RO  Size (Code + RO Data)               113312 ( 110.66kB)</div><div class="line">    Total RW  Size (RW Data + ZI Data)             61520 (  60.08kB)</div><div class="line">    Total ROM Size (Code + RO Data + RW Data)     113812 ( 111.14kB)</div><div class="line"></div><div class="line">==============================================================================</div></pre></td></tr></table></figure>
<p>优化步骤如下：</p>
<ul>
<li>project &gt;&gt; Option for Target “**” 打开如图 2界面。选择“target”，勾选上“Use MicroLIB”再编译。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/2.png" alt=""></p>
<p><strong>分析：microLIB是缺省的C库，而且microLIB进行了高度优化。如果不勾选“Use MicroLIB”，keil会连接标准C库。所以勾选“Use MicroLIB”会减小code大小。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/3.png" alt=""></p>
<ul>
<li>project &gt;&gt; Option for Target “**” 打开如界面。选择“C/C++”，勾选上“One ELF Section per Functin”再编译。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/4.png" alt=""></p>
<p><strong>分析：“One ELF Section per Functin”就是将每个函数都生成一个ELF文件，最会将需要的函数链接成一个大的ELF文件。但是如果没有勾选“One ELF Section per Functin”。Keil将每个文件编译成一个ELF文件（即使文件中用未被使用的函数），最会链接成一个ELF文件。所以勾选“One ELF Section per Functin”会使code变小。</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/5.png" alt=""></p>
<hr>
<p>Keil 这个 IDE 作为一个编辑器来说功能比较弱，但调试功能较强，关于这个软件可定制的功能较少，目前也还没有看到详细介绍如何用 keil 进行更好优化的文章，后续发现新的技巧仍然会进一步补充。</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/abclixu123/article/details/46923725" target="_blank" rel="external">http://blog.csdn.net/abclixu123/article/details/46923725</a><br><a href="http://blog.csdn.net/gasbi/article/details/6186312" target="_blank" rel="external">http://blog.csdn.net/gasbi/article/details/6186312</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[notepad++和MinGW]]></title>
      <url>http://noparkinghere.top/2016/11/15/2016/2016-11-15-notepad-%E5%92%8Cmingw/</url>
      <content type="html"><![CDATA[<p>今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。</p>
<h3 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h3><p>Windows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><a href="https://pan.baidu.com/s/1slNDMtn" target="_blank" rel="external">notepad++</a>只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了<a href="https://pan.baidu.com/s/1bFK8TC" target="_blank" rel="external">MinGW-5.1.6</a>离线包，安装步骤很简单，这边不具体阐述。</p>
<a id="more"></a>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><h4 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h4><p>环境变量，简而言之就是在终端中直接输入名称，系统能够识别，且运行的一些可执行文件名称。在（我的电脑右击－－&gt;系统属性－－&gt;高级－－&gt;环境变量－－&gt;系统变量 中）（以下目录都根据自己的电脑MinGW所在位置不同而改变）在PATH的值中加入“D:\MinGW\bin”（如果没有就新建一个PATH）。如果PATH中还有其他内容，需要用英文状态下使用分号进行分割。这是寻找gcc编译器的路径。（这一步中PATH的值根据你的MinGW安装的路径设定，要能够访问的gcc编译器，也就是MInGW安装目录里面的bin文件夹）</p>
<p>下面两步作为可选步骤，如果有确切需求可以添加：新建LIBRARY_PATH变量，在其值中加入“D:\MinGW\lib”。这是标准库存放的路径。新建C_INCLUDE_PATH变量，在其值中加入“D:\MinGW\include”。这是Include查找头文件的路径。</p>
<p>设置结束之后，在cmd控制台窗口下面，输入gcc -v。若已经成功安装好，会显示gcc的版本信息。比如说我的：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-15-notepad-%E5%92%8Cmingw/2.png" alt=""></p>
<p>测试一下：<br>随便找个c文件，你也可以自己写个。使用命令提示符cd到c文件保存的目录，然后：输入<code>gcc -o test.exe (你的c文件名).c</code>如果有提示语法错误或者在当前目录生成了test.exe那说明gcc可用了，如果提示 ‘gcc’ 不是内部或外部命令，也不是可运行的程序或批处理文件。说明环境MinGW的环境变量未设置成功。</p>
<h4 id="notepad"><a href="#notepad" class="headerlink" title="notepad++"></a>notepad++</h4><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-15-notepad-%E5%92%8Cmingw/1.png" alt=""></p>
<p>如上图，选用自己喜欢的风格模式，对里面的一些背景参数适当的设置，将行号等常用的功能打开，可以隐藏一些不需要的工具栏，菜单中列出了可以执行的一些操作，适当借用于快捷键可以更快的编写代码。</p>
<p>由于这边主要是让notepad++可以一键编译c程序，所以为其加上编译，运行。</p>
<ul>
<li>编译：按F5输入<code>cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT</code> 点保存，设置快捷键为F9</li>
<li>运行：按F5输入<code>cmd /k &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F9</li>
</ul>
<p>上述两步，环境搭建完成，当你用N++编写程序时，先保存再按F9可编译，然后再按Ctrl+F9开看到运行结果。</p>
<p>熟练习惯后，可以将编译运行一起使用：<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; cmd /k &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>或者<code>cmd /k gcc -std=c99 -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; pause &amp; &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot;&amp; PAUSE &amp; EXIT</code>保存，设置快捷键为Ctrl+F5。</p>
<p><strong>关键字说明：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">引号的使用是为了适用于文件名或者路径中带有空格的情况，一定不能省略。</div><div class="line">&amp; PAUSE 含义是命令运行后暂停等待键盘操作</div><div class="line">&amp; EXIT 含义是完成后退出运行窗口，回到notepad++</div><div class="line">$(NAME_PART) 代表当前正操作的文件的文件名，不含后缀；</div><div class="line">$(FULL_CURRENT_PATH) 代表当前正操作的文件的完整路径，包括盘符、路径、文件名、后缀；</div><div class="line">$(CURRENT_DIRECTORY) 代表当前文件所在的目录路径；</div><div class="line">通过以上三个环境变量可以很容易的理解上面一段指令的含义。</div><div class="line">至于gcc，-o参数就是将一个c文件编译成exe文件。gcc的bin目录已经之前在系统环境变量中进行过设定，否则需要补全gcc命令的绝对路径。(很简单，将<span class="string">"g++.exe"</span>换成<span class="string">"D:\MinGW\bin\g++.exe"</span>,还是要参照你安装的路径）</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html" target="_blank" rel="external">http://jingyan.baidu.com/article/9989c7461dc55ff648ecfe12.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[美国总统诞生了]]></title>
      <url>http://noparkinghere.top/2016/11/10/2016/2016-11-10-%E7%BE%8E%E5%9B%BD%E6%80%BB%E7%BB%9F%E8%AF%9E%E7%94%9F%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。</p>
<p>就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。</p>
<p>其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。</p>
<p>其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。</p>
<p>当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。</p>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言工程组建]]></title>
      <url>http://noparkinghere.top/2016/11/10/2016-11-10-c%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E7%BB%84%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。</p>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何看待蓝绿大厂问鼎中国]]></title>
      <url>http://noparkinghere.top/2016/11/03/2016/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/</url>
      <content type="html"><![CDATA[<p>根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。</p>
<hr>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg" alt=""></p>
<h3 id="差强人意"><a href="#差强人意" class="headerlink" title="差强人意"></a>差强人意</h3><p>就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。</p>
<p>在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。</p>
<p>音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。</p>
<p>快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。</p>
<p>在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。</p>
<p>软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。</p>
<p>说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。</p>
<p>举个例子：OV两家的CPU &lt; 荣耀6的CPU，OV两家的CPU &lt; MI4的CPU；OV两家的GPU &gt; 荣耀6的GPU，OV两家的GPU &lt; MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。</p>
<p>因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。</p>
<p>对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。</p>
<p>综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg" alt=""></p>
<a id="more"></a>
<h3 id="信息轰炸"><a href="#信息轰炸" class="headerlink" title="信息轰炸"></a>信息轰炸</h3><p>这个时代是改革开放来最差的时代，因为经济增长缓慢，民营实业入不敷出，房价虚高，资本的寒冬；但这个时代缺失娱乐业最好的时代，各种综艺节目，电视电影，网剧直播等层出不穷，一个全民娱乐的时代。OV两家恰恰是这个时代最大的受益者之一，在娱乐圈，电视台，广告界磨辊打趴了这么多年，积累了深厚的资源和用户，动辄数亿的广告，但却往往能够找准最佳的商机，带来丰厚的回报。细数OV两家的广告可以遍布你身边的一切，从最初的湖南卫视到浙江卫视，从多个热门综艺节目到热门电视剧，从微博到微信。无论你是做哪一行的，逃到哪儿都可以看到这两家的广告。</p>
<p>绝大多数用户的心理都是从众的，OV两家前几年在小米混的风生水起的时候，只能通过电视广告来发展自己偏远地区的业务，那时候两家主要的购买群体一般是三四线城市或者农村，因为网络物流不发达，用户主要获取信息途径通过电视，所以来自这些地方的用户大都购买这两款手机。OV两家那时候属于闷声赚钱，相比于“中酷联”这三家，既不用面对激烈的竞争，也还能谋取较高的利润，但市场占有率不算高，算是小日子过得还不错。</p>
<p>仔细研究OV两家的进程，颇有点“农村包围城市”的韵味，OV两家最近的之所以能够逆袭，不是得益于自身手机的发展，恰恰是整个行业的不发展，苹果两年一大步今年都已经干脆不走了。早从13年的同质化开始，整个行业已经陷入了僵局，各个产品几乎不存在差异化，或者只是微差异化。OV两家只要跟着谷歌走，产品做的不是实在太烂，在有一定知名度的前提下，就可以掌握更多用户。如果说早期的OV两家是牢牢把控了小城市和农村，那现在就是“农村包围城市”，这两家很大成都就是说服了互联网，一二线城市中的原有苹果用户，老旧安卓机转型过来的用户以及追星的用户来购买他们的产品而实现销量增长的。老苹果用户在更新手机的时候想体验其他平台或者因为预算选择稍微便宜的手机，OV两家一般都会是他们的首选，原因有两点：1.广告效应，论知名度，两家无出其右，其他国产机都具备屌丝标签。2.OV两家刻意模仿苹果，用户体验各方面几乎可以和苹果无缝对接了，连图标都做的一致。老旧安卓机用户的原因可以分为两点：1.耳熟能详的知名度。2.更好的外观和体验。</p>
<p>综上可以看出，不断地信息轰炸，建立自己的品牌影响力，让观众普遍认为你手机还不错，这点很重要。在苹果和三星占有率再创新低时，OV两家的信息轰炸还是很有效果的。</p>
<h3 id="低调专注"><a href="#低调专注" class="headerlink" title="低调专注"></a>低调专注</h3><p><strong>低调专注算是一个褒义词，这边我们只就事论事</strong>，众所周知，做任何事情专注最为重要，OV两家的成功决不能排除专注这一点，当别人都在迫于小米荣耀等线上角逐的势头，而不得不做互联网营销时，这两家却反其道而行之，专注于线下（因为他们也知道自己的手机那时在智能机时代确实毫无竞争力可言），构建更加完善的线下渠道，在更多传统媒体上面布满广告，给予经销商高回报率等，这些都奠定了它成功的基础。我们来重新回顾思考这些事情，当初其实OV在做大规模营销和扩大线下建设时，其实大多数人都认为，这已经是个信息化社会了，线下终将被淘汰，减少中间商环节才是未来数码3C的大势所趋。但事实证明，大多数人的观点并不正确，中国的城市化进程，网络物流的推广覆盖远不是坐在高层写字楼办公的金领白领可以看清的，中国仍然有6亿的农村人口，即便他们可以使用网络但却没有物流，小型城市人口也仍然在中国占了很大的比重，他们虽然可以使用网络，但未必人人都会完全融入信息化社会。可以看出OV两家的“农村包围城市”的战略还是很明智的，这些地盘往往是被忽视了的金库。</p>
<p>各家在网络上面都会进行营销。锤子小米华为等，微博，贴吧上粉黑水军争吵不断。当提及OV两家，不得不说一个有趣的现象，几乎所有这些互联网品牌的手机用户的都看不上OV两家，谁和它比都不屑。这也导致，市面上几乎就找不到OV两家手机的测评，一些测评花了几分钟说了下外观和界面，然后说“这手机就这样也没什么好说的”，但这两家公司历来低调，对这些评论从来都不进行任何回复，也就是说直接无视你们，因为他们知道这些人不是他们的用户群，把事情闹大，万一大家都知道你手机不好，那咋办？另一个低调表现在对高通和谷歌的顺从，当其某厂家发声质疑高通的垄断时而期望获取更多话语权的时候，OV两家义无反顾地积极配合响应高通等公司，这主要取决于他们知道自身的定位，缺乏核心技术，软件研发调优能力弱，同时也不具备芯片等研发能力，所以业务重点更能定为清晰，只做产品的整装与宣传。可见<strong>在商言商</strong>，专注低调赚钱往往更能够成功！</p>
<h3 id="外观精良"><a href="#外观精良" class="headerlink" title="外观精良"></a>外观精良</h3><p>外观这边用不美这个词，还是很讲究的，在我看来精美这个词只能用于“在一定的时期，能够满足社会上8,9成数用户的审美标准，那才可以称得上是精美”，iphone 4刚出来的时候是可以算上精美的，而iphone 6的机身和背面惊人的白带，还是离精美差的较远的。精致的话，一般用在工业制造上面极为考究的产品，如小米的工业陶瓷机身，所以这边考虑到这两家做外观虽然都能看到很多苹果的影子，但还算是用料不错，品质有保证。</p>
<p>就OV的外观而言，国产手机中，也就只有魅族可以和它一起争夺女性用户了。</p>
<p>国内小米和华为在外观上面都有着浓厚的工科生或中年人审美情怀，OPPO，VIVO，魅族的外观类似苹果材质和颜色看起来也更加清新和明快，虽然不能如galaxy edge系类满足绝大多数人审美，但往往更讨年轻人和女性用户的喜欢。这一点尤为重要，上述提到过，当今社会，手机早已同质化严重，创新疲乏，所以试问普通用户除了外观还有啥可以追求？！换句话说，即便各家仍然有软件体验，应用等创新层出不穷，但毕竟这是个看脸的社会，有多少人会喜欢小米正面左上方的LOGO？举个例子：亲身经历，身边有50岁大妈，之前用手机只打电话，所以一直用的红米之类的千元机，现在周围人都用微信，所以入手一智能机，本来是去看华为的手机，结果转了一圈，都嫌太丑，最后买了VIVO的一款主打机型。连三星都将国行版正面LOGO给去掉了，可见对于国人来说，颜值是多么重要！</p>
<p>综上，OV虽然未必美观漂亮，但最起码有明星加持，有苹果的影子，用户不会觉得像其他国产机一样丑，智能手机已经快走过了10个年头，如果它寿命还没有结束的话，未来的竞争恐怕也只有外观的竞争了吧。</p>
<h3 id="高回报率"><a href="#高回报率" class="headerlink" title="高回报率"></a>高回报率</h3><p>再好的策略都离不开优秀的执行者，OV两家的成功离不开线下销售人员的三寸不烂之舌，如何让调用手机销售的积极性，让他们都来卖你的手机，而不是卖其他品牌的呢？大家如果有去电脑城战JS的经理的话，都会知道，JS推荐笔记本或者品牌机都是有选择性的，贵的他不一定推荐给你，便宜的也不一定推荐给你，他们会选择自己赚的最多的推荐给你，举例子说：他们会极力诱导你放弃购买6000的电脑（他只能赚800），而去买4200的电脑（因为他能赚1500）。OV两家同样是如此，在高提成高回报率的前提下，很多销售甚至会阻止你购买其他机型，而大力诱导你买这两家的手机。</p>
<h3 id="稳步求变"><a href="#稳步求变" class="headerlink" title="稳步求变"></a>稳步求变</h3><p>OV在广告领域可谓早有心得，但近期可以看到在微博微信流媒体视频都可以看到OV两家的身影，要想一直繁荣，就必须有增长，只是市场经济不变的法则。OV两家也是看到早已坐实了线下渠道，通过种种手段完成了资本的原始积累，所以从今年开始攻占线上渠道，也就是说等线上销售基本已经定型，各家玩不出什么花样的时候，他们直接拿过来照搬，再加上线下和主流媒体渠道实现全范围的对大家进行轰炸，最终这两个季度用户数量激增，拿下了市场冠亚军的宝座。</p>
<p>总结：虽然黑了OV两家这么多年，但也不得不承认他们确确实实有自身的可取之处。写了这么多，我们可以看出，OV两家成功的主要原因：自始至终大力投资广告，一点点增加自己的品牌影响和曝光度；早期依靠线下在智能机行业站稳脚跟，达到原始资本的积累；后期为了再增长，主打外观，将广告进一步做大，做广，最终在国内手机行业登顶。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>存在即为合理，我们不能否认最近两年来OV两家在市场拓展上面的成功，就如当年小米开创互联网营销模式一样，OV用同样利用全民娱乐，线上线下互补，手机制造门槛降低等打出了一手好牌。但如果一味的模仿抄袭，产品无特色体验差等，最终当消费者觉醒时，依然会被市场所抛弃。我们有理由相信好的产品真金不怕火炼，最终才会经得起消费者检验；但同时，手段和策略能更快地给我们带来更多的资金和市场也同样至关重要。一个公司要想能够持续性发展，势必需要将资金反馈到自己的产品中才行，否则<em>挂羊头卖狗肉</em>的事最终会被揭露出来。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 手机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[uart/spi/iic的比较]]></title>
      <url>http://noparkinghere.top/2016/10/30/2016-10-30-uart-spi-iic%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大端和小端]]></title>
      <url>http://noparkinghere.top/2016/10/30/2016/2016-10-30-%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/</url>
      <content type="html"><![CDATA[<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>
<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。</p>
<p><strong>端模式(Byte Endian)</strong> 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。</p>
<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>
<p>注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。</p>
<h3 id="端模式-Byte-Endian-简述"><a href="#端模式-Byte-Endian-简述" class="headerlink" title="端模式(Byte Endian)简述"></a>端模式(Byte Endian)简述</h3><ul>
<li><p>大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01-&gt;1000，0x23-&gt;1001，0x45-&gt;1002，0x67-&gt;1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。</p>
</li>
<li><p>小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67-&gt;1000，0x45-&gt;1001，0x23-&gt;1002，0x01-&gt;1003这种顺序存储。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。</p>
</li>
</ul>
<p>除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。</p>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。</p>
<p>描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：</p>
<ul>
<li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 同 0x789A6B 次序一致，这种更加符合人的阅读习惯。大端更加符合人的阅读习惯，自左往右的依次增高的阅读习惯。</li>
<li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 看起来并不容易阅读。小端比较符合人的一般思维逻辑（注意仅仅符合思维逻辑，并不符合阅读习惯）。</li>
</ul>
<p>这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实没有一个统一的标准，串口传输数据时一般都满足原则：<strong>先传输字符的低位，后传输字符的高位</strong>；然而在某些通信协议中却刚好相反，如 SPI 中，就是<strong>先传输字符的高位，后传输字符的低位</strong>的方式。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-30-大端和小端/1.png" alt=""></p>
<ul>
<li><em>以下内容引用自阮一峰老师的博客：</em>  </li>
</ul>
<blockquote>
<p>首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。<br>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
</blockquote>
<p>个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。</p>
<h3 id="记忆方法"><a href="#记忆方法" class="headerlink" title="记忆方法"></a>记忆方法</h3><blockquote>
<p>在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。</p>
</blockquote>
<p>这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。</p>
<h3 id="测试大小端参考代码："><a href="#测试大小端参考代码：" class="headerlink" title="测试大小端参考代码："></a>测试大小端参考代码：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">方法1：</div><div class="line">typedef unsigned char u8;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	unsigned long int a = 0x01020304;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (u8 i = 0; i &lt; 4; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, *((u8 *)&amp;a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果结果为：4321则为小端模式，而1234为大端模式。</div><div class="line"></div><div class="line">方法2：</div><div class="line"></div><div class="line">typedef union</div><div class="line">&#123;</div><div class="line">	unsigned short int a;</div><div class="line">	unsigned char b;</div><div class="line">&#125;Union;</div><div class="line"></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	Union u1;</div><div class="line">	u1.a = 0x0201;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (u1.b == 0x01)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"little endian\n"</span>);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (u1.b == 0x02)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/vvzaixian/article/details/7067221" target="_blank" rel="external">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href="http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml" target="_blank" rel="external">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href="https://my.oschina.net/chaenomeles/blog/673091" target="_blank" rel="external">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href="http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字节对齐]]></title>
      <url>http://noparkinghere.top/2016/10/30/2016/2016-10-30-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
      <content type="html"><![CDATA[<p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>
<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</p>
<h3 id="字节对齐（Byte-Alignment）"><a href="#字节对齐（Byte-Alignment）" class="headerlink" title="字节对齐（Byte Alignment）"></a>字节对齐（Byte Alignment）</h3><p>我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。</p>
<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 <em> 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。<strong>基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数</strong>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<em>*为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</em></em>。</p>
<p>举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>
<p>结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然<strong>结构体变量首地址必须是4字节对齐的</strong>，但是<strong>结构体的每个成员有各自默认的对齐方式</strong>，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且<strong>第一个成员的首地址等于整个结构体变量的首地址</strong>。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">char(1字节)，1字节对齐</div><div class="line">short(2字节)，2字节对齐</div><div class="line">int(4字节)，4字节对齐</div><div class="line"><span class="built_in">float</span>(4字节)，4字节对齐</div><div class="line">double(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。</div><div class="line">*不同CPU的对其规则可能不同, 请参考手册。*</div></pre></td></tr></table></figure>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>
<a id="more"></a>
<h3 id="对齐的算法："><a href="#对齐的算法：" class="headerlink" title="对齐的算法："></a>对齐的算法：</h3><p>由于各个平台和编译器的不同，现以 gcc 3.4.5 编译器（x64平台）为例，来讨论编译器对 struct 数据结构中的各成员如何进行对齐的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">测试程序如下：</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	long int a;</div><div class="line">	char b;</div><div class="line">	short c;</div><div class="line">&#125;STRU_A;</div><div class="line"></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	long int a;</div><div class="line">	short c;</div><div class="line">&#125;STRU_B;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, sizeof (STRU_A), sizeof (STRU_B));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构体 A 中包含了 4 字节长度的 int 1个，1 字节长度的 char 1个和 2 字节长度的 short 型数据1个。所以 A 用到的空间应该是 7 字节。但是因为编译器要对数据成员在空间上进行对齐。所以使用 sizeof(STRU_A)值为 8。现在把该结构体调整成员变量的顺序。这时候同样是总共 7 个字节的变量，但是 sizeof(STRU_B)的值却是 12。</p>
<p>程序编译器对结构存储的特殊处理确实提高了CPU的存储变量速度，但有时候也会带来一些麻烦，这边我们使用#pragma pack (value)来屏蔽掉变量默认的对齐方式。下面我们使用预编译指令#pragma pack (value)来告诉编译器，使用我们指定的对齐值来取代缺省的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">进一步我们修改代码：</div><div class="line"></div><div class="line"><span class="comment">#pragma pack (2) /*指定按 2 字节对齐*/</span></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	long int a;</div><div class="line">	short c;</div><div class="line">&#125;STRU1;</div><div class="line"><span class="comment">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span></div><div class="line"></div><div class="line"><span class="comment">#pragma pack (1) /*指定按 1 字节对齐*/</span></div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	long int a;</div><div class="line">	short c;</div><div class="line">&#125;STRU2;</div><div class="line"><span class="comment">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, sizeof (STRU1), sizeof (STRU2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeof(STRU1)值为 7。对于 char 型数据，其自身对齐值为 1，对于 short 型为 2，对于 int,float,double类型，其自身对齐值为 4，单位字节。</p>
<p>这里面有四个概念值：</p>
<ul>
<li>数据类型自身的对齐值：就是上面交代的基本数据类型的自身对齐值。</li>
<li>指定对齐值：#pragma pack (value)时的指定对齐值 value。</li>
<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>
</ul>
<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值 N 是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是 表示“对齐在 N 上”，也就是说该数据的”存放起始地址%N=0”.而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数 倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">例子分析：</div><div class="line">分析例子 B；</div><div class="line">struct B</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	int a;</div><div class="line">	short c;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节,sizeof(struct B)=12;同理,分析上面例子C：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pragma pack (2) /*指定按 2 字节对齐*/</span></div><div class="line">struct C</div><div class="line">&#123;</div><div class="line">	char b;</div><div class="line">	int a;</div><div class="line">	short c;</div><div class="line">&#125;;</div><div class="line"><span class="comment">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span></div></pre></td></tr></table></figure>
<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。</p>
<p>下面是一个有char，int，short三种类型，4个成员组成的结构体，该结构体在还未编译之前是大小占8个字节。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct AlignData</div><div class="line">&#123;</div><div class="line">	char a;</div><div class="line">	short b;</div><div class="line">	int c;</div><div class="line">	char d;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译之后，为了保持结构体中的每个成员都是按照各自的对齐，编译器会在一些成员之间插入一些padding，因此编译后得到如下的结构体：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct AlignData </div><div class="line">&#123;</div><div class="line">	char a;</div><div class="line">	char Padding0[1];</div><div class="line">	short b;</div><div class="line">	int c;</div><div class="line">	char d;</div><div class="line">	char Padding1[3];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译后该结构体的大小为12个字节，<strong>最后一个成员d后面填充的字节数要使该结构体的总大小是其成员类型中拥有最大字节数的倍数</strong>(int拥有最大字节数)，因此d后面要填充3个字节。</p>
<p>通过以上的详细分析，我们可以总结编译器在自动分配结构体类型对齐时，<strong>一般是以第一个数据为基准值，然后往后累加地址查找，最终确保将每个需要分配的数据分配到sizeof(data)整数倍的地址上面。至于那些在查找过程中不满足要求的存储空间就空出。</strong>一般主要满足以下规则：</p>
<ul>
<li>单个字节(char)能对齐到任意地址</li>
<li>2字节(short)以2字节边界对齐</li>
<li>4字节(int, long)以4字节边界对齐</li>
</ul>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/vvzaixian/article/details/7067221" target="_blank" rel="external">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href="http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml" target="_blank" rel="external">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href="https://my.oschina.net/chaenomeles/blog/673091" target="_blank" rel="external">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href="http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SPI通信详解]]></title>
      <url>http://noparkinghere.top/2016/10/29/2016/2016-10-29-spi%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>SPI 相比其他协议算是比较简单的，本来是去年要总结的一篇文章，但由于偷懒只把部分参考链接放出来了，隔了很长时间，才下定决心将内容整理出来，之前写过 uart 还有其他一些内容，要完整的表述出来，还是相当占用篇幅的。</em></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>SPI, Serial Perripheral Interface, 串行外围设备接口, 是 Motorola 公司推出的一种同步串行接口技术. SPI 总线在物理上是通过接在外围设备微控制器(PICmicro) 上面的微处理控制单元 (MCU) 上叫作同步串行端口(Synchronous Serial Port) 的模块(Module)来实现的, 它允许 MCU 以全双工的同步串行方式, 与各种外围设备进行高速数据通信.SPI最大的特点是由主设备时钟信号的出现与否来确定主／从设备间的通信。一旦检测到主设备的时钟信号，数据开始传输。SPI 是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为 PCB 的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如 AT91RM9200，stm32，efm32等等。</p>
<p>SPI 主要应用在 EEPROM, Flash, 实时时钟(RTC), 数模转换器(ADC), 数字信号处理器(DSP) 以及数字信号解码器之间. 它在芯片中只占用四根管脚 (Pin) 用来控制以及数据传输, 节约了芯片的 pin 数目, 同时为 PCB 在布局上节省了空间. 正是出于这种简单易用的特性, 现在越来越多的芯片上都集成了 SPI技术.</p>
<h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（单向传输时）。也是所有基于SPI的设备共有的，它们是SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）。</p>
<ul>
<li>SDO/MOSI：主设备数据输出，从设备数据输入</li>
<li>SDI/MISO：主设备数据输入，从设备数据输出</li>
<li>SCLK：时钟信号，由主设备产生（除非需要指定频率如： uart ，其他通讯一些一般都会配上一个时钟总线）</li>
<li>CS：从设备使能信号，由主设备控制，主设备可以通过 CS 来选择究竟读写哪个从设备</li>
</ul>
<p>CS: 其中CS是控制芯片是否被选中的，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），对此芯片的操作才有效，这就允许在同一总线上连接多个SPI设备成为可能。</p>
<p>SDI/SDO/SCLK: 通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCK时钟线存在的原因，由SCK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。这样，在至少8次时钟信号的改变（上沿和下沿为一次），就可以完成8位数据的传输。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="采用主-从模式-Master-Slave-的控制方式"><a href="#采用主-从模式-Master-Slave-的控制方式" class="headerlink" title="采用主-从模式(Master-Slave) 的控制方式"></a>采用主-从模式(Master-Slave) 的控制方式</h4><p>SPI 规定了两个 SPI 设备之间通信必须由主设备 (Master) 来控制次设备 (Slave). 一个 Master 设备可以通过提供 Clock 以及对 Slave 设备进行片选 (Slave Select) 来控制多个 Slave 设备, SPI 协议还规定 Slave 设备的 Clock 由 Master 设备通过 SCK 管脚提供给 Slave 设备, Slave 设备本身不能产生或控制 Clock, 没有 Clock 则 Slave 设备不能正常工作。</p>
<h4 id="采用同步方式-Synchronous-传输数据"><a href="#采用同步方式-Synchronous-传输数据" class="headerlink" title="采用同步方式(Synchronous)传输数据"></a>采用同步方式(Synchronous)传输数据</h4><p>Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse), 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过时钟极性 (CPOL) 和 时钟相位 (CPHA) 控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的。</p>
<h4 id="数据交换-Data-Exchanges"><a href="#数据交换-Data-Exchanges" class="headerlink" title="数据交换(Data Exchanges)"></a>数据交换(Data Exchanges)</h4><p>SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个 “发送者(Transmitter)” 或者 “接收者(Receiver)”. 在每个 Clock 周期内, SPI 设备都会发送并接收一个 bit 大小的数据, 相当于该设备有一个 bit 大小的数据被交换了。</p>
<p>一个 Slave 设备要想能够接收到 Master 发过来的控制信号, 必须在此之前能够被 Master 设备进行访问 (Access)。 所以, Master 设备必须首先通过 SS/CS pin 对 Slave 设备进行片选, 把想要访问的 Slave 设备选上。</p>
<a id="more"></a>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="四种时钟"><a href="#四种时钟" class="headerlink" title="四种时钟"></a>四种时钟</h4><p>spi四种模式SPI的相位(CPHA)和极性(CPOL)分别可以为0或1，对应的4种组合构成了SPI的4种模式(mode)</p>
<p>Mode 0 CPOL=0, CPHA=0<br>Mode 1 CPOL=0, CPHA=1<br>Mode 2 CPOL=1, CPHA=0<br>Mode 3 CPOL=1, CPHA=1</p>
<p>spi 没有直接规定是从上升沿还是下降沿采集，但规定了从第几个边沿开始采集和空闲时的电平状态。<br>时钟极性CPOL: 即 SPI 空闲时，时钟信号 SCLK 的电平（1:空闲时高电平; 0:空闲时低电平）<br>时钟相位CPHA: 即 SPI 在 SCLK 第几个边沿开始采样（0:第一个边沿开始; 1:第二个边沿开始）</p>
<p>具体使用哪个模式，并不固定，需要根据具体芯片手册开发 spi 的驱动，sd 卡的 spi 常用的是 mode 0 和 mode 3，这两种模式的相同的地方是都在时钟上升沿采样传输数据，区别这两种方式的简单方法就是看空闲时，时钟的电平状态，低电平为 mode 0 ，高电平为 mode 3。</p>
<h4 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h4><p>spi slave 是从模式，是被控制的一方，接收时钟、片选和写的数据；并发送回复的读数据；<br>spi master 是主模式，来控制从模式，发送时钟、片选和写的数据，并接受读的数据；<br>带有 SPI 功能的 MCU 往往需要选择主从模式。</p>
<h4 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h4><p>使用片上 SPI 资源或者模拟 SPI 时还需要注意一个字节的数据是高位优先传输还是低位优先传输，不同于 I2C，一般情况下 SPI 会采用 MSB （高位优先传输）。</p>
<h4 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h4><h3 id="模拟-SPI"><a href="#模拟-SPI" class="headerlink" title="模拟 SPI"></a>模拟 SPI</h3><p>SPI 并非芯片必须集成的功能，很多过去的芯片都没有集成该功能，但我们依然可以通过控制 IO 高低电平/输入输出，来模拟出芯片手册上面要求的信号，下面我以 FM25W256-G 为例做个简单说明。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 以下程序临时改写，未经过实验验证 */</span></div><div class="line"></div><div class="line"><span class="comment">/* SPI端口初始化 */</span>  </div><div class="line"><span class="keyword">void</span> spi_init()  </div><div class="line">&#123;  </div><div class="line">    set_gpio_direction(SS, OUTP);  </div><div class="line">    set_gpio_direction(SCLK, OUTP);  </div><div class="line">    set_gpio_direction(MOSI, OUTP);  </div><div class="line">    set_gpio_direction(MISO, INP);  </div><div class="line">    set_gpio_value(SCLK, <span class="number">0</span>);     <span class="comment">//CPOL=0  </span></div><div class="line">    set_gpio_value(MOSI, <span class="number">0</span>);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line">从设备使能 enable：为1时，使能信号有效，SS低电平为0时，使能信号无效，SS高电平</div><div class="line">*/  </div><div class="line"><span class="keyword">void</span> ss_enable(<span class="keyword">int</span> enable)  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">if</span> (enable)  </div><div class="line">        set_gpio_value(SS, <span class="number">0</span>);     <span class="comment">//SS低电平，从设备使能有效  </span></div><div class="line">    <span class="built_in">else</span>  </div><div class="line">        set_gpio_value(SS, <span class="number">1</span>);     <span class="comment">//SS高电平，从设备使能无效  </span></div><div class="line">&#125;  </div><div class="line"> <span class="comment">/* SPI字节写 */</span>  </div><div class="line"><span class="keyword">void</span> spi_write_byte(<span class="keyword">unsigned</span> <span class="keyword">char</span> b)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="built_in">for</span> (i=<span class="number">7</span>; i&gt;=<span class="number">0</span>; i--) &#123;  </div><div class="line">        set_gpio_value(SCLK, <span class="number">0</span>);  </div><div class="line">        set_gpio_value(MOSI, b&amp;(<span class="number">1</span>&lt;&lt;i));   <span class="comment">//从高位7到低位0进行串行写入  </span></div><div class="line">        <span class="built_in">delay</span>();       <span class="comment">//延时  </span></div><div class="line">        set_gpio_value(SCLK, <span class="number">1</span>);    <span class="comment">// CPHA=1，在时钟的第一个跳变沿采样  </span></div><div class="line">        <span class="built_in">delay</span>();   </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/* SPI字节读 */</span>  </div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> spi_read_byte(<span class="keyword">void</span>)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r = <span class="number">0</span>;  </div><div class="line">    <span class="built_in">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;  </div><div class="line">        set_gpio_value(SCLK, <span class="number">0</span>);  </div><div class="line">        <span class="built_in">delay</span>();       <span class="comment">//延时  </span></div><div class="line">        set_gpio_value(SCLK, <span class="number">1</span>);    <span class="comment">// CPHA=1，在时钟的第一个跳变沿采样  </span></div><div class="line">        r = (r &lt;&lt;<span class="number">1</span>) | get_gpio_value(MISO);   <span class="comment">//从高位7到低位0进行串行读出  </span></div><div class="line">        <span class="built_in">delay</span>();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> SPI写操作  buf：写缓冲区  len：写入字节的长度 </div><div class="line">*/  </div><div class="line"><span class="keyword">void</span> spi_write (<span class="keyword">unsigned</span> <span class="keyword">int</span> add, <span class="keyword">unsigned</span> <span class="keyword">char</span> date)  </div><div class="line">&#123;  </div><div class="line">    spi_init();       <span class="comment">//初始化GPIO接口  </span></div><div class="line">    ss_enable(<span class="number">1</span>);       <span class="comment">//从设备使能有效，通信开始  </span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    spi_write_byte(<span class="number">0x06</span>);  	<span class="comment">// 写使能指令</span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    ss_enable(<span class="number">0</span>);       </div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">	</div><div class="line">    ss_enable(<span class="number">1</span>);       <span class="comment">//从设备使能有效，通信开始  </span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    spi_write_byte(<span class="number">0x02</span>);  	<span class="comment">// 写指令</span></div><div class="line">    spi_write_byte((add&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>);  	<span class="comment">// 写高地址</span></div><div class="line">    spi_write_byte(add&amp;<span class="number">0xff</span>);  	<span class="comment">// 写低地址</span></div><div class="line">    spi_write_byte(date);  <span class="comment">// 写数据</span></div><div class="line">    <span class="built_in">delay</span>();  </div><div class="line">    ss_enable(<span class="number">0</span>);       <span class="comment">//从设备使能无效，通信结束  </span></div><div class="line">&#125;  </div><div class="line"><span class="comment">/* </span></div><div class="line">SPI读操作 buf：读缓冲区 len：读入字节的长度 </div><div class="line">*/  </div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> spi_read(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len)  </div><div class="line">&#123;  </div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> res;</div><div class="line">    spi_init();       <span class="comment">//初始化GPIO接口  </span></div><div class="line">    ss_enable(<span class="number">1</span>);       <span class="comment">//从设备使能有效，通信开始  </span></div><div class="line">    <span class="built_in">delay</span>();        <span class="comment">//延时  </span></div><div class="line">    spi_write_byte(<span class="number">0x03</span>);  	<span class="comment">// 写指令</span></div><div class="line">    spi_write_byte((add&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>);  	<span class="comment">// 写高地址</span></div><div class="line">    spi_write_byte(add&amp;<span class="number">0xff</span>);  	<span class="comment">// 写低地址</span></div><div class="line">    res = spi_read_byte();  <span class="comment">// 写数据</span></div><div class="line">    <span class="built_in">delay</span>();  </div><div class="line">    ss_enable(<span class="number">0</span>);       <span class="comment">//从设备使能无效，通信结束  </span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = <span class="number">0</span>;</div><div class="line">	spi_init();</div><div class="line">	spi_write_byte(<span class="number">0xaa</span>, <span class="number">0x22</span>);</div><div class="line">	tmp = spi_read_byte(<span class="number">0xaa</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上述代码我们不难发现，在使用模拟 SPI 时，可以方便我们移植，且不会增加特定寄存器的配置难度，但同时也以为着会增加代码量，且时钟要控制的比较精准才可以读取成功。</p>
<h3 id="寄存器操作-SPI"><a href="#寄存器操作-SPI" class="headerlink" title="寄存器操作 SPI"></a>寄存器操作 SPI</h3><p>使用寄存器配置 SPI，每个芯片厂家都不尽相同，会有自己的独家配置，这边为了文章的完整性，以 stm32 为例举个简答的例子。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>相比 IIC 等其他协议而言，SPI 操作比较简单，但会占用更多的资源。同任何其他协议一样，在使用 SPI 进行通信时，也需要仔细阅读芯片手册，以下介绍一些可以会引起读写失败，容易忽视的问题：</p>
<h4 id="时钟生效"><a href="#时钟生效" class="headerlink" title="时钟生效"></a>时钟生效</h4><p>在看芯片手册时，往往不同的 SPI 通讯设备，会存在不同的时钟周期，有效，如上面 FM25W256-G 就是在上升沿时有效，而少数芯片却可能会是下降沿有效，在使用 SPI 控制芯片时首先第一步就是该仔细看时钟周期，如果你在配置寄存器时，忽略了这点往往会读写失败。</p>
<h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>同样芯片手册会详细指定是 MSB 还是 LSB 这点也要仔细阅读，不然容易造成数据错误。</p>
<h4 id="指令操作顺序"><a href="#指令操作顺序" class="headerlink" title="指令操作顺序"></a>指令操作顺序</h4><p>操作指令的顺序很重要，FM25W256-G 这款芯片就仅指定了每次写时需要先使能，我们需要仔细阅读手册的时序图，查看使能时是否作为一个完整的执行周期。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SPI 是计算机通讯中，最常见的几种协议之一，其具备：协议简单，所需资源不算太多，成本不高，通讯速度较快等特点，因此虽然经历了很多的发展，但仍然没有被淘汰，至今仍然活跃在工业领域的各种数字传感器中，因此能够根据芯片手册开发相关的 SPI 驱动对嵌入式程序员来说是相当重要的。</p>
<hr>
<p>写作时间：20:30-22:30</p>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://baike.baidu.com/item/SPI" target="_blank" rel="external">http://baike.baidu.com/item/SPI</a><br><a href="https://my.oschina.net/freeblues/blog/67400" target="_blank" rel="external">https://my.oschina.net/freeblues/blog/67400</a><br><a href="http://www.cnblogs.com/hello2mhb/p/3518974.html" target="_blank" rel="external">http://www.cnblogs.com/hello2mhb/p/3518974.html</a><br><a href="http://www.cnblogs.com/aaronLinux/p/6219146.html" target="_blank" rel="external">http://www.cnblogs.com/aaronLinux/p/6219146.html</a><br><a href="http://blog.csdn.net/special_lin/article/details/12835863" target="_blank" rel="external">http://blog.csdn.net/special_lin/article/details/12835863</a><br><a href="http://blog.csdn.net/zyboy2000/article/details/11861329" target="_blank" rel="external">http://blog.csdn.net/zyboy2000/article/details/11861329</a><br><a href="https://blog.csdn.net/yihui8/article/details/54316888" target="_blank" rel="external">https://blog.csdn.net/yihui8/article/details/54316888</a><br><a href="https://blog.csdn.net/lyj19960106/article/details/77718930" target="_blank" rel="external">https://blog.csdn.net/lyj19960106/article/details/77718930</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MSB 和 LSB]]></title>
      <url>http://noparkinghere.top/2016/10/29/2016/2016-10-29-msb-%E5%92%8C-lsb/</url>
      <content type="html"><![CDATA[<p>MSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：</p>
<ul>
<li>MSB ： Most Significant Bit，LSB ： Least Significant Bit</li>
<li>MSB ： Most Significant Byte，LSB ： Least Significant Byte</li>
</ul>
<p>但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。</p>
<h3 id="高低位"><a href="#高低位" class="headerlink" title="高低位"></a>高低位</h3><p>MSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。</p>
<p>一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是<strong>重要位（Most Significant Bit</strong>，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明<strong>Data is written MSB first</strong>。</p>
<p>但值得注意的是，uart 通讯中全部采用<strong>Data is written LSB first</strong>，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。</p>
<h3 id="高低字节"><a href="#高低字节" class="headerlink" title="高低字节"></a>高低字节</h3><p>MSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。</p>
<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>
<p>计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。</p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux分区问题]]></title>
      <url>http://noparkinghere.top/2016/10/28/2016/2016-10-28-linux%E5%88%86%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>分区功能是个使用系统时候的必备功能，但却不特别常用，所以每次使用时难免会因为不记得指令或者错误使用指令而导致一些没必要的错误发生，建议如果不是经常分区，对步骤不是记得太清楚的话，在分区前还是搜索一下详细步骤，免得出了问题仍然不自知。笔者之所以写这篇文章就是潜意识中觉得分区步骤简单，然后出了问题，还不知道问题出在哪儿。</p>
<h3 id="简述分区步骤："><a href="#简述分区步骤：" class="headerlink" title="简述分区步骤："></a>简述分区步骤：</h3><ul>
<li>df:可以查看下当前系统<strong>挂载了的分区</strong>，如下图所示</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Filesystem     1K-blocks     Used Available Use% Mounted on</div><div class="line">udev             4044748        0   4044748   0% /dev</div><div class="line">tmpfs             812844     9744    803100   2% /run</div><div class="line">/dev/sda2       47930248 11323396  34149048  25% /</div><div class="line">tmpfs            4064220   349608   3714612   9% /dev/shm</div><div class="line">tmpfs               5120        4      5116   1% /run/lock</div><div class="line">tmpfs            4064220        0   4064220   0% /sys/fs/cgroup</div><div class="line">/dev/sda1         497696     3668    494028   1% /boot/efi</div><div class="line">/dev/sda3       95990540 70935460  20155908  78% /home</div><div class="line">tmpfs             812844       12    812832   1% /run/user/1000</div><div class="line">/dev/sda5      142794248 34011608 101506060  26% /home/demon/Space</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>也可以使用sudo fdisk -l 看当前系统存在的分区信息</li>
<li>下面开始分区，使用sudo fdisk /dev/sda，这边要对sda设备进行分区，主要看你要对哪块盘进行分区，如果有第二块盘，则是sdb。执行完这个指令后，会有帮助提示，跟着提示走，会很简单。</li>
<li>这边我们新建分区，输入：n，选择分区码，起始扇区，结尾扇区。最后输入w写入分区表。这边出现警告：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The partition table has been altered.</div><div class="line">Calling ioctl() to re-read partition table.</div><div class="line">Re-reading the partition table failed.: Device or resource busy</div><div class="line"></div><div class="line">The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8).</div></pre></td></tr></table></figure>
<p>起初一直在纠结这个问题，后来通过网上查看发现仅仅是个警告，并非错误，而虽然完成但事实上这边没有格式化，值得注意的是，fdisk虽然选择了分区类型，但并没有格式化分区，而这边的分区类型仅仅是将分区类型的内容写入了MBR中，真正格式化还得手动执行。</p>
<ul>
<li>使用 <code>sudo fdisk -l</code> 已经可以查看到分区列表了</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Device         Start        End    Sectors   Size Type</div><div class="line">/dev/sda1       2048     999423     997376   487M EFI System</div><div class="line">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class="line">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class="line">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class="line">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class="line">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>
<ul>
<li>下面真正格式化分区，格式化分区需要选择格式化类型，上面通过 fdisk 已经选定了分区为 linux filesystem 了，这边就要将其格式化为其对应的文件系统。<code>sudo mkfs.ext4 /dev/sda6</code>，再看分区 <code>sudo fdisk -l</code>。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Device         Start        End    Sectors   Size Type</div><div class="line">/dev/sda1       2048     999423     997376   487M EFI System</div><div class="line">/dev/sda2     999424   98656255   97656832  46.6G Linux filesystem</div><div class="line">/dev/sda3   98656256  293967871  195311616  93.1G Linux filesystem</div><div class="line">/dev/sda4  293967872  309592063   15624192   7.5G Linux swap</div><div class="line">/dev/sda5  309592064  600000000  290407937 138.5G Linux filesystem</div><div class="line">/dev/sda6  600000512 1953525134 1353524623 645.4G Linux filesystem</div></pre></td></tr></table></figure>
<ul>
<li>最后一步就是挂载分区了，使用sudo mount /dev/sda6 ~/Extern 将sda6新分出来的分区挂载到当前用户目录下的Extern分区中即可。</li>
<li>df再次查看可以发现，分区已经被挂载成功了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Aria2详解]]></title>
      <url>http://noparkinghere.top/2016/10/27/2016/2016-10-27-aria2%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Aria2应该来说是最流行的免费下载工具之一，因为它的轻量级以及支持各种协议而被广为使用。</p>
<p><em>这个东西折腾了很长时间，终于配好了，老实说仅仅是配置使用的话应该是相当简单的，但由于一开始参考了mac下配置的那篇文章，虽然更改了路径等内容，但每次启动aria2的时候总是经常启动不起来，或者启动后自动被kill了，反复往返，看了很多教程官方文档说明等，一直查不出问题所在，最后没办法，直接自己写配置文件，终于可以使用了。</em></p>
<h3 id="aria2配置"><a href="#aria2配置" class="headerlink" title="aria2配置"></a>aria2配置</h3><p>根据man文档aria2的默认配置在$HOME/.aria2/aria2.conf中，你也可以在每次加载的过程中人为修改位置如：<code>aria2c --conf-path=/etc/.aria2/aria2.conf</code>。</p>
<p>配置如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#保存路径，注意这边必须写完整路径</span></div><div class="line">dir=/home/demon/Downloads</div><div class="line"><span class="comment">#允许rpc</span></div><div class="line"><span class="built_in">enable</span>-rpc=<span class="literal">true</span></div><div class="line"><span class="comment">#允许所有来源, web界面跨域权限需要</span></div><div class="line">rpc-allow-origin-all=<span class="literal">true</span></div><div class="line"><span class="comment">##允许非外部访问</span></div><div class="line">rpc-listen-all=<span class="literal">true</span></div><div class="line"><span class="comment">#RPC端口, 仅当默认端口被占用时修改</span></div><div class="line">rpc-listen-port=6800</div><div class="line"><span class="comment">#disable-ipv6=true</span></div><div class="line"><span class="comment">#最大同时下载数(任务数), 路由建议值: 3</span></div><div class="line">max-concurrent-downloads=10</div><div class="line"><span class="comment">#断点续传</span></div><div class="line"><span class="built_in">continue</span>=<span class="literal">true</span></div><div class="line"><span class="comment">#同服务器连接数</span></div><div class="line">max-connection-per-server=10</div><div class="line"><span class="comment">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span></div><div class="line">min-split-size=10M</div><div class="line"><span class="comment">#单文件最大线程数, 路由建议值: 5</span></div><div class="line">split=10</div><div class="line"><span class="comment">#下载速度限制</span></div><div class="line">max-overall-download-limit=0</div><div class="line"><span class="comment">#单文件速度限制</span></div><div class="line">max-download-limit=0</div><div class="line"><span class="comment">#上传速度限制</span></div><div class="line">max-overall-upload-limit=0</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="aria2c命令"><a href="#aria2c命令" class="headerlink" title="aria2c命令"></a>aria2c命令</h3><p>基本使用</p>
<ul>
<li>下载一个文件（Download a file）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aria2c http://host/image.iso</div><div class="line">说明：1.10.0以后的版本默认对每个 host 使用 1 个连接，你可以使用 –max-connection-per-server 或者 -x 选项进行改变。</div></pre></td></tr></table></figure>
<ul>
<li>用每个 host 两个连接从一个 host 下载一个文件（To download a file using 2 connections from single host）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aria2c -x2 http://host/image.iso</div><div class="line">说明：想要停止下载，可以按Ctrl-C。想要恢复下载，可以在同一个文件夹中执行相同的下载命令。只要URI指向同一个文件，URIs是可以被改变的。</div></pre></td></tr></table></figure>
<ul>
<li>同时使用两个连接下载同一文件（Download a file using 2 connections）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c <span class="_">-s</span>2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso</div><div class="line"></div><div class="line">说明：你可以指定URIs的数量多余 <span class="_">-s</span> 选项设定的数。在这个例子中，前两个URL会被用于下载，而第三个URL作为备用（如果前面两个有个挂了，第三个顶上）。</div></pre></td></tr></table></figure>
<ul>
<li>同时从FTP和HTTP源下载一个文件（Download a file from HTTP and FTP servers）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">aria2c http://host1/file.zip ftp://host2/file.zip</div></pre></td></tr></table></figure>
<ul>
<li>并行下载任意数目的URI, metalink, torrent（Parallel downloads of arbitrary number of URI, metalink, torrent）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c -Z http://host/file1 file2.torrent file3.metalink</div><div class="line">说明：如果你只是下载 torrent 和 metalink 的文件，那么选项 -Z 将不是必须的。所以你可以使用以下这个命令同时下载bt文件。</div><div class="line">aria2c file1.torrent file2.torrent</div></pre></td></tr></table></figure>
<ul>
<li>并发下载一个文件中的URI（Download files listed in a file concurrently）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c -ifiles.txt -j5</div><div class="line">说明：选项 -j 用于指定同时下载的文件的数量。你可以在文件中指定本地的 torrent 和 metalink 文件。</div><div class="line">说明：你可以指定一些 选项 在下载文件（input list file）中。</div></pre></td></tr></table></figure>
<ul>
<li>在退出时保存错误/未完成的下载（Save error/unfinished downloads on exit）：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aria2c -ifiles.txt --save-session=out.txt</div><div class="line">当你按下Ctrl-C或者 aria2 退出时，所有的错误（error）/未完成（unfinished）下载将会保存到 out.txt 文件中。注意通过 XML-RPC 方式(aria2.addTorrent and aria2.addMetalink)添加的下载不会被保存！你可以使用这个文件作为一个输入文件列表（input file list）来重新开始下载。</div><div class="line">aria2c -iout.txt</div></pre></td></tr></table></figure>
<h3 id="uget"><a href="#uget" class="headerlink" title="uget"></a>uget</h3><p>uget可以说相当于一个图形化界面的下载器，这个下载器的优点是可以调用curl和aria2等工具，在设置–插件中选择aria2即可，具体的使用类似迅雷等一些下载器类似。一单设置选择了aria2的话，uget就会自动运行aria2这个进程，其他程序就无法调用aria2的部分功能了。这个软件占用资源较小，如果使用的linux操作系统，简单易用，基本上不需要配置，重点推荐。</p>
<h3 id="web软件"><a href="#web软件" class="headerlink" title="web软件"></a>web软件</h3><p>aria2c有几个比较出名的web软件可以选择：<a href="http://ziahamza.github.io/webui-aria2/" target="_blank" rel="external">webui-aria2</a>，<a href="https://binux.github.io/yaaw/" target="_blank" rel="external">yaaw</a>。</p>
<p>注意在使用这些UI工具时，实际仍然是调用aria2s命令，因此需要实现开启aria2的守护进程：<code>aria2c -D</code>，然后在浏览器上面可以执行相关操作。</p>
<p>我个人在使用这两个工具时，研究了很久但一直不能使用，疑似无法读取本地的配置文件，极少情况能够加载成功，进行下载。<strong>待解决</strong></p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://aria2c.com/usage.html" target="_blank" rel="external">http://aria2c.com/usage.html</a><br><a href="https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay" target="_blank" rel="external">https://medium.com/@Justin___Smith/aria2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B-mac%E5%92%8Cwindows-b31d0f64bd4e#.n6bvy48ay</a><br><a href="http://yalv.me/aria2/" target="_blank" rel="external">http://yalv.me/aria2/</a><br><a href="https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/20563721?columnSlug=ChanTalk</a><br><a href="http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727" target="_blank" rel="external">http://wenku.baidu.com/link?url=bKJCYvk24K--RuZ7DuCzg_0TADnrIMt7aT8fSjTcElI57nOenrWsmKVmWuuHD0SKOt-0OrbvltqOSzXX8Ryj0qEJzhCegBN65X1_dNAA727</a><br><a href="http://www.cnblogs.com/RhinoC/p/aria2.html" target="_blank" rel="external">http://www.cnblogs.com/RhinoC/p/aria2.html</a><br><a href="https://aria2.github.io/" target="_blank" rel="external">https://aria2.github.io/</a><br><a href="http://sydi.org/posts/linux/aria2c-usage-sample-cns.html" target="_blank" rel="external">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a><br><a href="http://chanjh.com/post/software/0012" target="_blank" rel="external">http://chanjh.com/post/software/0012</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux免密码命令]]></title>
      <url>http://noparkinghere.top/2016/10/24/2016/2016-10-24-linux%E5%85%8D%E5%AF%86%E7%A0%81%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>在使用ubuntu的过程中，部分命令必须要具备root权限才可以执行，然后root权限需要输入密码，很多常用的命令如:reboot等，甚至需要每次输入密码，部分用户也许会很不满意。另外当如果在写脚本时也会出现这种问题，脚本中可能会包含一些sudo指令，但用户不想每次都输入密码。这边介绍几种方法以供参考。</p>
<a id="more"></a>
<h3 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h3><p>将免密码文件写入到 /etc/sudoers 配置文件中，书写格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">假设你的用户名是user，host是host则可以将以下命令加入到 /etc/sudoers 中:</div><div class="line"></div><div class="line">user host = (root) NOPASSWD: /sbin/shutdown</div><div class="line">user host = (root) NOPASSWD: /sbin/reboot</div><div class="line">user host = (root) NOPASSWD: /home/user/program/startup.sh (注意：startup.up需要设定为可执行)</div><div class="line"></div><div class="line">可以看到通过以上方法写入到sudoers中可以让程序或者脚本中即便需要root权限，也可以免密码自动执行。</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password" target="_blank" rel="external">http://askubuntu.com/questions/159007/how-do-i-run-specific-sudo-commands-without-a-password</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[I2C通信详解]]></title>
      <url>http://noparkinghere.top/2016/10/20/2016/2016-10-20-I2C%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>在使用单片机的过程中，I2C 通信可以说是最被广泛使用和采纳的协议之一，采用 I2C 协议可以占用更少的资源，链接多台设备，因此它和 SPI 一样，在数字传感器中备受偏爱。</p>
<p>I²C（Inter-Integrated Circuit）字面上的意思是集成电路之间，它其实是 I²C Bus 简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。I²C 的正确读法为“I平方C”（”I-squared-C”），而“I二C”（”I-two-C”）则是另一种错误但被广泛使用的读法。自2006年11月1日起，使用I²C协议已经不需要支付专利费，但制造商仍然需要付费以获取I²C从属设备地址。</p>
<p>I2C 主要用于电压、温度监控，EEPROM数据的读写，光模块的管理等。该总线只有两根线，SCL 和 SDA，SCL 即 Serial Clock，串行参考时钟，SDA 即 Serial Data，串行数据。</p>
<a id="more"></a>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="IO口"><a href="#IO口" class="headerlink" title="IO口"></a>IO口</h4><p>注意使用其他通讯协议时，你可能不需要特别注意 IO 的模式，但如果你使用的是模拟 I2C 的话，则最好关注下 IO 口模式设置。在 I2C 总线中有 2 个口线，SDA 和 SCL。这两个口线对为 OC 输出。</p>
<p>OC就是开漏输出(Open Collector)的简称，有时候也叫OD输出（Open-Drain），OD是对mos管而言，OC是对双极型管而言，在用法上没啥区别。相对于OC输出，另一种输出叫推挽输出(Push-Pull)，一般的MCU管脚输出可以设置这两种模式。这里分别介绍下这两种输出的不同点。</p>
<ul>
<li>推挽输出 : 可以输出高、低电平连接数字器件，推挽结构一般是指两个三极管分别受两互补信号的控制，总是在一个三极管导通的时候另一个截止.</li>
<li>开漏输出 : 输出端相当于三极管的集电极未接任何电平， 要得到高电平状态需要上拉电阻才行，适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)。</li>
</ul>
<p>对于MCU的开发者来讲，简单的这样理解就可以了。如果管脚设置成推挽输出模式，输出高时，IO口相当于VCC, 输出低时IO口相当于接地。如果管脚设置成开漏输出模式，输出高时，IO口的电平会和与其相连的口线进行与操作，如果都为高，才会被上拉拉成高电平，输出为低时，也相当于接地。</p>
<p>在网上我们看到很多的例程代码都是直接设置IO口的高低电平，这样做其实是不太合理的。因为我们只满足了 I2C 总线在自己这端的时序要求。而没有考虑到连接在总线上的其他器件。如果总线上其他器件的电平和MCU输出的电平一致，这样做是没问题的，如果两边的电平不一致时，这样做就有一定风险造成IO的损坏。当你输出高时，相当于IO口连接到VCC，如果对方这是恰好输出的是低电平，那就相当于短路了。因为 I2C 总线要实现线与的功能，所以 SDA 和 SCL 口线都必须设置为开漏输出模式，这种方式也是最安全的模式。我们使用 MCU 的硬件 I2C 接口时，口线会被自动设置成开漏。但有时候我们会使用 IO 口来模拟 I2C 总线，这个时候我们如何设置口线呢?</p>
<p>因为 I2C 的总线是开漏输出的，总线上接上上拉电阻后，SCL 和 SDA 就变成了高电平，这个时候挂接在总线上的任意一个 I2C 主机口可以把 SDA 拉低，即产生了一个 START 信号，挂接在总线上的其他 I2C 主机检测到这个信号后就不能去操作 I2C 总线了，否则会发生冲突。直到检测到一个 STOP 信号为止。STOP 的信号是在 SCL 口线为高时，SDA 产生一个上升沿。STOP 信号之后，I2C总线恢复到初始状态。</p>
<p>这里要分两种情况，如果MCU的口线支持开漏输出模式，则可以直接把 SDA 和 SCL 设置成开漏输出。例如 Silicon 的 C8051 系列 MCU，它的口线就支持开漏和推挽输出。如果 MCU 不支持开漏输出，例如 MSP430。当然如果软件做的合理，是可以避免这样的事情的，但总线上的很多器件都不是由你能控制的，如何设计出更合理的软件来避免这样的问题发生呢？对于不支持开漏输出MCU，我们最合理的做法是，当设置口线电平为高时，我们把口线设置成输入状态，然后利用口线上的上拉电阻来把口线拉高。这样即使是两边电平不一致时，也不会造成IO口的损坏。</p>
<h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>常见的I²C总线依传输速率的不同而有不同的模式：标准模式（100 Kbit/s）、低速模式（10 Kbit/s），但时钟频率可被允许下降至零，这代表可以暂停通信。而新一代的I²C总线可以和更多的节点（支持10比特长度的地址空间）以更快的速率通信：快速模式（400 Kbit/s）、高速模式（3.4 Mbit/s）。</p>
<h4 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h4><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/1.png" alt=""></p>
<p>如上图所示，I2C 是 OC 或 OD 输出结构，使用时必须在芯片外部进行上拉，上拉电阻R的取值根据 I2C 总线上所挂器件数量及 I2C 总线的速率有关，一般是标准模式下 R 选择 10kohm，快速模式下 R 选取 1kohm，I2C 总线上挂的 I2C 器件越多，就要求 I2C 的驱动能力越强，R 的取值就要越小，实际设计中，一般是先选取 4.7kohm 上拉电阻，然后在调试的时候根据实测的 I2C 波形再调整 R 的值。</p>
<p>I²C 只有两根通讯线：数据线 SDA 和时钟 SCL，可发送和接收数据。I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：</p>
<ul>
<li>开始信号： SCL 为高电平时， SDA 由高电平向低电平跳变，开始传送数据。</li>
<li>结束信号： SCL 为高电平时， SDA 由低电平向高电平跳变，结束传送数据。</li>
<li>应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲，表示已收到数据。 CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号， CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。</li>
</ul>
<p>具体时序如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/2.png" alt=""></p>
<p>I2C总线的主要时序参数有：开始建立时间 t(SUSTA)，开始保持时间 t(HDSTA)，数据建立时间 t(SUDAT)，数据保持时间 t(SUDAT) ，结束建立时间 t(SUSTO) 。</p>
<ul>
<li>开始建立时间：SCL 上升至幅度的90%与SDA下降至幅度的90%之间的时间间隔；</li>
<li>开始保持时间：SDA下降至幅度的10%与SCL下降至幅度的10%之间的时间间隔；</li>
<li>数据建立时间：SDA上升至幅度的90%或SDA下降至幅度的10%与SCL上升至幅度的10%之间的时间间隔；</li>
<li>数据保持时间：SCL下降至幅度的10%与SDA上升至幅度的10%或SDA下降至幅度的90%之间的时间间隔；</li>
<li><p>结束建立时间：SCL上升至幅度的90%与SDA上升至幅度的90%之间的时间间隔；</p>
</li>
<li><p>数据接收方收到传输的一个字节数据后，需要给出响应，此时处在第九个时钟，发送端释放SDA线控制权，将SDA电平拉高，由接收方控制。若希望继续，则给出“应答（ACK）”信号，即SDA为低电平；反之给出“非应答（NACK）”信号，即SDA为高电平。I2C总线传输的特点：I2C总线按字节传输，即每次传输8bits二进制数据，传输完毕后等待接收端的应答信号ACK，收到应答信号后再传输下一字节。等不到ACK信号后，传输终止。空闲情况下，SCL和SDA都处于高电平状态。</p>
</li>
</ul>
<p>每个字节后会跟随一个ACK信号。ACK bit使得接收者通知发送者已经成功接收数据并准备接收下一个数据。所有的时钟脉冲包括ACK信号对应的时钟脉冲都是由master产生的。</p>
<p>ACK信号：发送者在ACK时钟脉冲期间释放SDA线，接收者可以将SDA拉低并在时钟信号为高时保持低电平。</p>
<p>NACK信号：当在第9个时钟脉冲的时候SDA线保持高电平，就被定义为NACK信号。Master要么产生STOP条件来放弃这次传输，或者重复START条件来发起一个新的开始。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/3.png" alt=""></p>
<ul>
<li>判断一次传输的开始：如上图所示，I2C总线传输开始的标志是：SCL信号处于高电平期间，SDA信号出现一个由高电平向低电平的跳变。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/4.png" alt=""></p>
<ul>
<li>判断一次传输的结束:如上图所示，I2C总线传输结束的标志是：SCL信号处于高电平期间，SDA信号出现一个由低电平向高电平的跳变。跟开始标识正好相反。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/5.png" alt=""></p>
<ul>
<li>有效数据:在SCL处于高电平期间，SDA保持状态稳定的数据才是有效数据，只有在SCL处于低电平状态时，SDA才允许状态切换。前面已经讲过了，SCL高电平期间，SDA状态发生改变，是传输开始/.结束的标志。</li>
</ul>
<h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-20-I2C通信详解/7.png" alt=""></p>
<p>如上图所示，I2C开始传输时，第一个字节的前7bit是地址信息(7位地址器件)，第8bit是操作标识，为“0”时表示写操作，为“1”时表示读操作，第9个时钟周期是应答信号ACK，低有效，高电平表示无应答，传输终止。在上图中还可以看出，正常情况下，写操作是I2C主设备方发起终止操作的，而读操作时，I2C主控制器在接收完最后一个数据后，不对从设备进行应答，传输终止。</p>
<p>I2C数据总线SDA是在时钟为高时有效，在时钟SCL为高期间，SDA如果发生了电平变化就会终止或重启I2C中线，所以我们在数据传输过程中，要在SCL为低的时候去更改SDA的电平。</p>
<h4 id="总线信号时序"><a href="#总线信号时序" class="headerlink" title="总线信号时序"></a>总线信号时序</h4><p>再次总结下总线的各种时序状态：</p>
<ul>
<li>总线空闲状态：SDA 和 SCL 两条信号线都处于高电平，即总线上所有的器件都释放总线，两条信号线各自的上拉电阻把电平拉高；</li>
<li>启动信号 START：信号 SCL 保持高电平，数据信号SDA的电平被拉低(即负跳变)。启动信号必须是跳变信号，而且在建立该信号前必修保证总线处于空闲状态；</li>
<li>停止信号 STOP：时钟信号SCL保持高电平，数据线被释放，使得SDA返回高电平(即正跳变)，停止信号也必须是跳变信号。</li>
<li>数据传送：SCL 线呈现高电平期间，SDA 线上的电平必须保持稳定，低电平表示 0 (此时的线电压为地电压)，高电平表示1(此时的电压由元器件的VDD决定)。只有在 SCL 线为低电平期间，SDA 上的电平允许变化。</li>
<li>应答信号 ACK：I2C 总线的数据都是以字节( 8 位)的方式传送的，发送器件每发送一个字节之后，在时钟的第9个脉冲期间释放数据总线，由接收器发送一个ACK(把数据总线的电平拉低)来表示数据成功接收。</li>
<li>无应答信号 NACK：在时钟的第 9 个脉冲期间发送器释放数据总线，接收器不拉低数据总线表示一个 NACK，NACK 有两种用途:<br>a. 一般表示接收器未成功接收数据字节；<br>b. 当接收器是主控器时，它收到最后一个字节后，应发送一个 NACK 信号，以通知被控发送器结束数据发送，并释放总线，以便主控接收器发送一个停止信号 STOP。</li>
</ul>
<p><em>起始信号是必需的，结束信号和应答信号，都可以不要。</em></p>
<h3 id="模拟-I2C"><a href="#模拟-I2C" class="headerlink" title="模拟 I2C"></a>模拟 I2C</h3><p>目前大部分 MCU 都带有 I2C 总线接口，但是芯片自带的 I2C 也有两个问题，一个是移植性较差不够通用，另外部分 MCU 不带 I2C 还是得要模拟的方式，以及一些芯片设计的 I2C 据说是存在问题的，如： stm32 的 I2C 不够稳定，efm32 的 I2C 不够节能等等。这边建议，在权衡 I2C 占用的 CPU 资源是否可以承受后，再做选择。</p>
<h4 id="IIC-选用-IO-模式"><a href="#IIC-选用-IO-模式" class="headerlink" title="IIC 选用 IO 模式"></a>IIC 选用 IO 模式</h4><p>通过上面可以知道，IIC 在通信过程中，主设备SCL始终是保持发送状态，因此这边我们可以将 SCL 设置为推挽或者开漏输出。推挽的输出能力较强，开漏输出则需要加上拉电阻，而一般 IIC 的推荐电路就是需要人为增加了上拉电阻的，因此在考虑功耗等一些情况下，可能开漏输出更好。</p>
<p><strong>而问题的关键是 SDA 到底设置为什么模式？</strong></p>
<p>网上参考资料众说纷纭，这边以我自己做实验的亲身感受为例，我推荐在作为输出时将这个脚配置为开漏输出模式；在 MCU 需要接收信号的时候，如果 MCU 本身没有限制，或者不需要精简代码的话，则将其设置为输入模式。详解：</p>
<p>将 SDA 直接设置为开漏模式：</p>
<p>这种方法一般用于之前程序的很多单片机中，开漏因为需要接上拉电阻才能改变电平，且具有线与的特性，通过读 IO 口的状态，即便是设置成了开漏输出，但仍然可以读取IO的数据状态，可以说一劳永逸，一种模式两种用途，虽然目前试过大多数MCU通过这种方式也都可以读取，但毕竟是输出模式，万一以后的设计更改了，无法读取了，则有潜在性的问题。</p>
<p>将 SDA 设置位推挽输出模式进行输出，需要读取数据时转换成输入模式：</p>
<p>最近在不少地方看到用这种方式来对 IIC 器件进行读取，感觉较为灵活，之前也将开漏转换成了这种模式。但最近实验过程中发现了不少问题，在 SDA 发送数据结束后，等待应答的这个过程中，使用推挽模式，有明显的短路风险。这段时间虽然时间很短，且接下来会立即将推挽切换为输入模式，但在单步执行测试的过程中,实际会出现很高的电流，疑似推挽的高电平输出引起了断路，用这种模式必须较为谨慎，注意各种延时时间，千万不能让器件断路烧坏。<em>在使用一个 IIC 通信的 AD 芯片过程中，一段时间后出现测量值不准，疑似可能是这种原因引起的。</em></p>
<p>SCL 使用开漏输出模式，SDA 使用开漏输出+输入模式：</p>
<p>通过上面的讨论，最终个人认为 IIC 通信过程中：SCL 使用开漏输出模式，SDA 使用开漏输出发送数据，使用输入模式读取数据，这种方法较为合理。值得注意：SDA 需要模式切换，IIC 的延迟时间无需过长，否则影响效率，这些根据手册中的标准执行。</p>
<p>以下以 EFM32 为例，给出参考代码，这边的代码只需要修改部分宏定义，就可以直接移植到 STM32 等其他单片机上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* iic相关引脚定义 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_PORT      gpioPortA  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_PIN        0  </span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_PORT      gpioPortA  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_PIN        1</span></div><div class="line"></div><div class="line"><span class="comment">/* iic相关功能函数定义 */</span></div><div class="line"><span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=1;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_HIGH()      GPIO_PinOutSet(IIC_SDA_PORT, IIC_SDA_PIN)  </span></div><div class="line"><span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_HIGH()      GPIO_PinOutSet(IIC_SCL_PORT, IIC_SCL_PIN)</span></div><div class="line"><span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=0;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_LOW()      GPIO_PinOutClear(IIC_SDA_PORT, IIC_SDA_PIN)</span></div><div class="line"><span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_LOW()      GPIO_PinOutClear(IIC_SCL_PORT, IIC_SCL_PIN)</span></div><div class="line"><span class="comment">//设置SDA为输入</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_DISABLE()  GPIO_PinModeSet(IIC_SDA_PORT, IIC_SDA_PIN, gpioModeDisabled, 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_DISABLE()  GPIO_PinModeSet(IIC_SCL_PORT, IIC_SCL_PIN, gpioModeDisabled, 0)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SCL_SET_OUT()    GPIO_PinModeSet(IIC_SCL_PORT, IIC_SCL_PIN, gpioModePushPull, 0)</span></div><div class="line"></div><div class="line"><span class="comment">//设置为推挽输出模式</span></div><div class="line"><span class="comment">//#define IIC_SDA_SET_OUT()    GPIO_PinModeSet(IIC_SDA_PORT, IIC_SDA_PIN, gpioModePushPull, 0)</span></div><div class="line"><span class="comment">//设置为推开漏出模式</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_SET_OUT()    GPIO_PinModeSet(IIC_SDA_PORT, IIC_SDA_PIN, gpioModeWiredAndDrive, 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_SET_IN()    GPIO_PinModeSet(IIC_SDA_PORT, IIC_SDA_PIN, gpioModeInput, 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IIC_SDA_INPUT()      GPIO_PinInGet(IIC_SDA_PORT, IIC_SDA_PIN)</span></div><div class="line"></div><div class="line"><span class="comment">/* 初始化IIC */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//设置为推挽输出模式</span></div><div class="line">  IIC_SDA_SET_OUT();  </div><div class="line">  IIC_SCL_SET_OUT();    </div><div class="line"></div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=1;</span></div><div class="line">  IIC_SDA_HIGH();</div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">  IIC_SCL_HIGH();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* 产生IIC起始信号 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  u8 i;</div><div class="line">  <span class="comment">//IIC_SDA设置为推挽输出</span></div><div class="line">  IIC_SDA_SET_OUT();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=1;</span></div><div class="line">  IIC_SDA_HIGH();</div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">  IIC_SCL_HIGH();</div><div class="line"></div><div class="line">  i = <span class="number">5</span>;</div><div class="line">  <span class="keyword">while</span>(i--);                               <span class="comment">//setup time for stop 4us</span></div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=0;</span></div><div class="line">  IIC_SDA_LOW();</div><div class="line">  </div><div class="line">  i = <span class="number">5</span>;</div><div class="line">  <span class="keyword">while</span>(i--);                               <span class="comment">//setup time for stop 4us</span></div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//产生IIC停止信号</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  u8 i;</div><div class="line">  <span class="comment">//IIC_SDA设置为推挽输出</span></div><div class="line">  IIC_SDA_SET_OUT();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();</div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=0;</span></div><div class="line">  IIC_SDA_LOW();</div><div class="line">    </div><div class="line">  i = <span class="number">5</span>;</div><div class="line">  <span class="keyword">while</span>(i--);                               <span class="comment">//setup time for stop 4us</span></div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">  IIC_SCL_HIGH();</div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=1;</span></div><div class="line">  IIC_SDA_HIGH();</div><div class="line"></div><div class="line">  i = <span class="number">5</span>;</div><div class="line">  <span class="keyword">while</span>(i--);                               <span class="comment">//setup time for stop 4us                 </span></div><div class="line">&#125;</div><div class="line"><span class="comment">//主机接收从机应答信号</span></div><div class="line"><span class="comment">//等待应答信号到来</span></div><div class="line"><span class="comment">//返回值：1，接收应答失败</span></div><div class="line"><span class="comment">//        0，接收应答成功</span></div><div class="line"><span class="function">u8 <span class="title">IIC_Wait_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  u8 ucErrTime=<span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//SDA设置为输入</span></div><div class="line">  IIC_SDA_SET_IN();</div><div class="line"></div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=1;</span></div><div class="line">  IIC_SDA_HIGH();</div><div class="line">  </div><div class="line">  __nop();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">  IIC_SCL_HIGH();</div><div class="line">  </div><div class="line">  __nop();</div><div class="line">  <span class="keyword">while</span>(IIC_SDA_INPUT())</div><div class="line">  &#123;</div><div class="line">    ucErrTime++;</div><div class="line">    <span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</div><div class="line">    &#123;</div><div class="line">      IIC_Stop();</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//主机发送给从机应答信号</span></div><div class="line"><span class="comment">//产生ACK应答</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();  </div><div class="line">  <span class="comment">//IIC_SDA设置为推挽输出</span></div><div class="line">  IIC_SDA_SET_OUT();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=0;</span></div><div class="line">  IIC_SDA_LOW();</div><div class="line">  __nop();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">  IIC_SCL_HIGH();</div><div class="line">  __nop();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//主机发送给从机应答信号</span></div><div class="line"><span class="comment">//不产生ACK应答        </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_NAck</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();</div><div class="line">  <span class="comment">//IIC_SDA设置为推挽输出</span></div><div class="line">  IIC_SDA_SET_OUT();  </div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA=1;</span></div><div class="line">  IIC_SDA_HIGH();</div><div class="line">  __nop();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">  IIC_SCL_HIGH();</div><div class="line">  </div><div class="line">  __nop();</div><div class="line">  </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();</div><div class="line">&#125;                        </div><div class="line"><span class="comment">//IIC发送一个字节</span></div><div class="line"><span class="comment">//返回从机有无应答</span></div><div class="line"><span class="comment">//1，有应答</span></div><div class="line"><span class="comment">//0，无应答        </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span></div><div class="line">&#123;                        </div><div class="line">    u8 t;   </div><div class="line">  </div><div class="line">  <span class="comment">//IIC_SDA设置为推挽输出</span></div><div class="line">  IIC_SDA_SET_OUT();  </div><div class="line">     </div><div class="line">  <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">  IIC_SCL_LOW();</div><div class="line">  </div><div class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</div><div class="line">    &#123;              </div><div class="line">    <span class="comment">//I2C_SDA PC0 --&gt; IIC_SDA输出数据</span></div><div class="line">        <span class="keyword">if</span> (((txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>) &amp; <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">      IIC_SDA_HIGH();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">      IIC_SDA_LOW();  </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        txd&lt;&lt;=<span class="number">1</span>;     </div><div class="line">    __nop();   <span class="comment">//对TEA5767这三个延时都是必须的</span></div><div class="line">    </div><div class="line">    <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">    IIC_SCL_HIGH();</div><div class="line">    __nop(); </div><div class="line">    </div><div class="line">    <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">    IIC_SCL_LOW();</div><div class="line">    __nop();</div><div class="line">    &#125;</div><div class="line">&#125;       </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   </span></div><div class="line"><span class="function">u8 <span class="title">IIC_Read_Byte</span><span class="params">(u8 ack)</span></span></div><div class="line">&#123;</div><div class="line">  u8 i, receive=<span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//SDA设置为输入</span></div><div class="line">  IIC_SDA_SET_IN();</div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=0;</span></div><div class="line">    IIC_SCL_LOW();</div><div class="line">    __nop();</div><div class="line">    <span class="comment">//I2C_SCL PC1 --&gt; IIC_SCL=1;</span></div><div class="line">    IIC_SCL_HIGH();</div><div class="line">        receive &lt;&lt;= <span class="number">1</span>;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span>(IIC_SDA_INPUT())</div><div class="line">      receive++;   </div><div class="line">      </div><div class="line">    __nop(); </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  __nop(); </div><div class="line"></div><div class="line">  ack ? IIC_Ack() : IIC_NAck();</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> receive;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自带-I2C"><a href="#自带-I2C" class="headerlink" title="自带 I2C"></a>自带 I2C</h3><p>这边仅以 stm32 平台通过 I2C 总线读取 EEPROM 为例，说明下如何通过芯片自带 I2C 功能来通信。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define  EEP_Firstpage      0x00</span></div><div class="line"></div><div class="line">u8 I2c_Buf_Write[256];</div><div class="line">u8 I2c_Buf_Read[256];</div><div class="line"></div><div class="line">static void I2C_GPIO_Config(void)</div><div class="line">&#123;</div><div class="line">  GPIO_InitTypeDef  GPIO_InitStructure; </div><div class="line"></div><div class="line">  /* 使能与 I2C1 有关的时钟 */</div><div class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</div><div class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);  </div><div class="line">    </div><div class="line">  /* PB6-I2C1_SCL、PB7-I2C1_SDA*/</div><div class="line">  GPIO_InitStructure.GPIO_P<span class="keyword">in</span> =  GPIO_Pin_6 | GPIO_Pin_7;</div><div class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</div><div class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;	       // 开漏输出</div><div class="line">  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void I2C_Mode_Configu(void)</div><div class="line">&#123;</div><div class="line">  I2C_InitTypeDef  I2C_InitStructure; </div><div class="line"></div><div class="line">  /* I2C 配置 */</div><div class="line">  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</div><div class="line">  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</div><div class="line">  I2C_InitStructure.I2C_OwnAddress1 =I2C1_OWN_ADDRESS7; </div><div class="line">  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable ;</div><div class="line">  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</div><div class="line">  I2C_InitStructure.I2C_ClockSpeed = I2C_Speed;</div><div class="line">  </div><div class="line">  /* 使能 I2C1 */</div><div class="line">  I2C_Cmd(I2C1, ENABLE);</div><div class="line"></div><div class="line">  /* I2C1 初始化 */</div><div class="line">  I2C_Init(I2C1, &amp;I2C_InitStructure);   </div><div class="line">&#125;</div><div class="line"></div><div class="line">void I2C_EE_Init(void)</div><div class="line">&#123;</div><div class="line"></div><div class="line">  I2C_GPIO_Config(); </div><div class="line"> </div><div class="line">  I2C_Mode_Configu();</div><div class="line"></div><div class="line">  /* 选择 EEPROM Block0 来写入 */</div><div class="line">  EEPROM_ADDRESS = EEPROM_Block0_ADDRESS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void I2C_EE_BufferWrite(u8* pBuffer, u8 WriteAddr, u16 NumByteToWrite)</div><div class="line">&#123;</div><div class="line">  u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;</div><div class="line"></div><div class="line">  Addr = WriteAddr % I2C_PageSize;</div><div class="line">  count = I2C_PageSize - Addr;</div><div class="line">  NumOfPage =  NumByteToWrite / I2C_PageSize;</div><div class="line">  NumOfSingle = NumByteToWrite % I2C_PageSize;</div><div class="line"></div><div class="line">  I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);</div><div class="line">  I2C_EE_WaitEepromStandbyState();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void I2C_EE_PageWrite(u8* pBuffer, u8 WriteAddr, u8 NumByteToWrite)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); // Added by Najoua 27/08/2008</div><div class="line">    </div><div class="line">  /* Send START condition */</div><div class="line">  I2C_GenerateSTART(I2C1, ENABLE);</div><div class="line">  </div><div class="line">  /* Test on EV5 and clear it */</div><div class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); </div><div class="line">  </div><div class="line">  /* Send EEPROM address <span class="keyword">for</span> write */</div><div class="line">  I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);</div><div class="line">  </div><div class="line">  /* Test on EV6 and clear it */</div><div class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));  </div><div class="line"></div><div class="line">  /* Send the EEPROM<span class="string">'s internal address to write to */    </span></div><div class="line">  I2C_SendData(I2C1, WriteAddr);  </div><div class="line"></div><div class="line">  /* Test on EV8 and clear it */</div><div class="line">  while(! I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</div><div class="line"></div><div class="line">  /* While there is data to be written */</div><div class="line">  while(NumByteToWrite--)  </div><div class="line">  &#123;</div><div class="line">    /* Send the current byte */</div><div class="line">    I2C_SendData(I2C1, *pBuffer); </div><div class="line"></div><div class="line">    /* Point to the next byte to be written */</div><div class="line">    pBuffer++; </div><div class="line">  </div><div class="line">    /* Test on EV8 and clear it */</div><div class="line">    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /* Send STOP condition */</div><div class="line">  I2C_GenerateSTOP(I2C1, ENABLE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void I2C_EE_WaitEepromStandbyState(void)      </div><div class="line">&#123;</div><div class="line">  vu16 SR1_Tmp = 0;</div><div class="line"></div><div class="line">  do</div><div class="line">  &#123;</div><div class="line">    /* Send START condition */</div><div class="line">    I2C_GenerateSTART(I2C1, ENABLE);</div><div class="line">    /* Read I2C1 SR1 register */</div><div class="line">    SR1_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);</div><div class="line">    /* Send EEPROM address for write */</div><div class="line">    I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);</div><div class="line">  &#125;while(!(I2C_ReadRegister(I2C1, I2C_Register_SR1) &amp; 0x0002));</div><div class="line">  </div><div class="line">  /* Clear AF flag */</div><div class="line">  I2C_ClearFlag(I2C1, I2C_FLAG_AF);</div><div class="line">  /* STOP condition */    </div><div class="line">  I2C_GenerateSTOP(I2C1, ENABLE); </div><div class="line">&#125;</div><div class="line"></div><div class="line">void I2C_EE_BufferRead(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)</div><div class="line">&#123;  </div><div class="line">  //*((u8 *)0x4001080c) |=0x80; </div><div class="line">    while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); // Added by Najoua 27/08/2008</div><div class="line">    </div><div class="line">    </div><div class="line">  /* Send START condition */</div><div class="line">  I2C_GenerateSTART(I2C1, ENABLE);</div><div class="line">  //*((u8 *)0x4001080c) &amp;=~0x80;</div><div class="line">  </div><div class="line">  /* Test on EV5 and clear it */</div><div class="line">  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));</div><div class="line"></div><div class="line">  /* Send EEPROM address for write */</div><div class="line">  I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);</div><div class="line"></div><div class="line">  /* Test on EV6 and clear it */</div><div class="line">  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));</div><div class="line">  </div><div class="line">  /* Clear EV6 by setting again the PE bit */</div><div class="line">  I2C_Cmd(I2C1, ENABLE);</div><div class="line"></div><div class="line">  /* Send the EEPROM's internal address to write to */</div><div class="line">  I2C_SendData(I2C1, ReadAddr);  </div><div class="line"></div><div class="line">  /* Test on EV8 and clear it */</div><div class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</div><div class="line">  </div><div class="line">  /* Send STRAT condition a second time */  </div><div class="line">  I2C_GenerateSTART(I2C1, ENABLE);</div><div class="line">  </div><div class="line">  /* Test on EV5 and clear it */</div><div class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));</div><div class="line">  </div><div class="line">  /* Send EEPROM address <span class="keyword">for</span> <span class="built_in">read</span> */</div><div class="line">  I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Receiver);</div><div class="line">  </div><div class="line">  /* Test on EV6 and clear it */</div><div class="line">  <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));</div><div class="line">  </div><div class="line">  /* While there is data to be <span class="built_in">read</span> */</div><div class="line">  <span class="keyword">while</span>(NumByteToRead)  </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span>(NumByteToRead == 1)</div><div class="line">    &#123;</div><div class="line">      /* Disable Acknowledgement */</div><div class="line">      I2C_AcknowledgeConfig(I2C1, DISABLE);</div><div class="line">      </div><div class="line">      /* Send STOP Condition */</div><div class="line">      I2C_GenerateSTOP(I2C1, ENABLE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Test on EV7 and clear it */</div><div class="line">    <span class="keyword">if</span>(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))  </div><div class="line">    &#123;      </div><div class="line">      /* Read a byte from the EEPROM */</div><div class="line">      *pBuffer = I2C_ReceiveData(I2C1);</div><div class="line"></div><div class="line">      /* Point to the next location <span class="built_in">where</span> the byte <span class="built_in">read</span> will be saved */</div><div class="line">      pBuffer++; </div><div class="line">      </div><div class="line">      /* Decrement the <span class="built_in">read</span> bytes counter */</div><div class="line">      NumByteToRead--;        </div><div class="line">    &#125;   </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /* Enable Acknowledgement to be ready <span class="keyword">for</span> another reception */</div><div class="line">  I2C_AcknowledgeConfig(I2C1, ENABLE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void I2C_Test(void)</div><div class="line">&#123;</div><div class="line">  u16 i;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"写入的数据\n\r"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> ( i=0; i&lt;=255; i++ ) //填充缓冲</div><div class="line">  &#123;   </div><div class="line">    I2c_Buf_Write[i] = i;  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //将I2c_Buf_Write中顺序递增的数据写入EERPOM中 </div><div class="line">  I2C_EE_BufferWrite(I2c_Buf_Write, EEP_Firstpage, 256);	 </div><div class="line"></div><div class="line">  //将EEPROM读出数据顺序保持到I2c_Buf_Read中 </div><div class="line">  I2C_EE_BufferRead(I2c_Buf_Read, EEP_Firstpage, 256); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们在根据芯片手册来写 I2C 驱动时，尤其需要注意以下几点：</p>
<ul>
<li>传输数据的大小端模式，这边的大小端是位大小端而不是字节。</li>
<li>时钟周期，如果通讯出现问题，试着用示波器看 CLK 波形得出通讯速度，以及看下通讯设备能够支持的速度。</li>
<li>看下应答信号是否设置成功。</li>
</ul>
<blockquote>
<p>参考链接：<br><a href="https://blog.csdn.net/luckywang1103/article/details/17549739" target="_blank" rel="external">https://blog.csdn.net/luckywang1103/article/details/17549739</a><br><a href="https://zhuanlan.zhihu.com/p/26579936" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/26579936</a><br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://blog.csdn.net/zmq5411/article/details/6085740" target="_blank" rel="external">http://blog.csdn.net/zmq5411/article/details/6085740</a><br><a href="https://zh.wikipedia.org/wiki/I%C2%B2C" target="_blank" rel="external">https://zh.wikipedia.org/wiki/I%C2%B2C</a><br><a href="http://blog.sina.com.cn/s/blog_626998030102vfjx.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_626998030102vfjx.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[usb转串口]]></title>
      <url>http://noparkinghere.top/2016/10/19/2016/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>使用单片机，对硬件编程的时候，可以说串口是最常用的交互方式，毕竟要安装一个显示器，显示屏等设备需要额外的开销，大量增加代码量，且很多场景并非必备外设。这篇文章将会详细的介绍单片机中最常使用的串口通信功能，这边通过<strong>多篇文章</strong>以51单片机和stm32为例，对串口（以ttl电平，232，485等）进行详细的论述。</p>
<p>在实验调试单片机时，串口相当重要以及常用，而现在电脑却一般仅有usb口（考虑到串口非专业人士不再使用）。因此我们在使用单片机读取串口数据时，往往需要<strong>将相应的串口转换为usb口</strong>。由于串口这边根据串口的不同，主要介绍常见的几种转接方式。</p>
<h3 id="串口ttl转usb"><a href="#串口ttl转usb" class="headerlink" title="串口ttl转usb"></a>串口ttl转usb</h3><p>常规调试过程中，我们可以将单片机ttl电平的串口信号TX和RX，通过转换芯片变成usb总线的信号。<strong>注意该过程既不是RS232也不是RS485，而是ttl的串口信号，该信号一般仅仅用来测试和下载，仅仅是方便使用而已。</strong></p>
<p>通常我们用来讲ttl串口信号转换为usb信号的芯片可以分为三种：FT232,CH340,PL2303，价位由高到低。这边我仅仅使用过CH340,PL2303这两款芯片的模块，对比后缺失PL2303误码率较高（当然不排除厂家因素）。一般情况我们使用CH340较多，相对稳定且价格便宜。实现的原理如下，其他集中芯片也大体一致：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/1.png" alt=""></p>
<p>建议大家使用CH340的模块，价格也很便宜，这边给出完整的电路原理图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/2.jpg" alt=""></p>
<a id="more"></a>
<h3 id="RS232串口转usb"><a href="#RS232串口转usb" class="headerlink" title="RS232串口转usb"></a>RS232串口转usb</h3><p>实际上是先将RS232转换为ttl电平，然后在通过上述方式转为usb通讯。下面详细介绍下RS232如何转换为ttl电平。</p>
<p>一般我们通过使用max232或者max3232将RS232电平（逻辑1(MARK)=-3V～-15V，逻辑0(SPACE)=+3～+15V）转换为ttl电平（5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列）。</p>
<ul>
<li>max232 供电电压5v，耗电5mA，外接4个1uF电容，传统5v供电单片机常用。</li>
<li>max3232 供电电压5v或3.3V，耗电0.3mA，外接4个0.1uF电容其他特性都一样，价格略有差别。现在更为常用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-usb%E8%BD%AC%E4%B8%B2%E5%8F%A3/3.png" alt=""></p>
<p>也就是说如果RS232串口想要和单片机链接通讯中间必须要有max232或者max3232这样的转换芯片，而如果RS232串口想要通过usb链接电脑，则必须先通过max232或者max3232转换成ttl信号，然后在通过CH340转换为usb通讯。</p>
<h3 id="RS485串口转usb"><a href="#RS485串口转usb" class="headerlink" title="RS485串口转usb"></a>RS485串口转usb</h3><p>RS485的转换就更为丰富了，包括以下几种：RS485&lt;-&gt;RS232，RS485&lt;-&gt;ttl，RS485&lt;-&gt;usb。网上基本也有各种转接头可以购买，这边仅做简要阐述。</p>
<ul>
<li>RS485&lt;-&gt;ttl：选用芯片MAX485(5V)或MAX3485(3.3V)类似上面提到的max232和max3232。</li>
<li>RS485&lt;-&gt;RS232：一般核心采用MAX232+MAX485共同设计电路，但设计细节差异较大，可以参加文末给出的链接</li>
<li>RS485&lt;-&gt;usb：分为两种方式：1.同RS232串口转usb类似，可以通过接MAX485转成ttl电平然后通过CH340转成usb通讯，2.将RS485转成RS232，然后再将RS232转成usb。</li>
</ul>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://tieba.baidu.com/p/3263424064" target="_blank" rel="external">http://tieba.baidu.com/p/3263424064</a><br><a href="http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO" target="_blank" rel="external">http://wenku.baidu.com/link?url=_l22igEh5jeC75_3TLzsRkLGv6s08EbKd2VFO_ZfDEUzjN45DeXM5wljNK8_B1Jn0ptTP9es6JNRw-iveGSyWK3WI2jQx8qj9QxkATRjFnO</a><br><a href="http://www.elecfans.com/article/88/131/189/2015/20150929385089.html" target="_blank" rel="external">http://www.elecfans.com/article/88/131/189/2015/20150929385089.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[串口RS232通信详解]]></title>
      <url>http://noparkinghere.top/2016/10/19/2016/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>
<p>波特率：单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。（有单独文章详解）</p>
<p>数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。当然，一般8位为一个字节，通常都喜欢设置为8位数据位传输。</p>
<p>停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。</p>
<p>奇偶校验位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。</p>
<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>
<p>注意：<strong>串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。</strong></p>
<a id="more"></a>
<h3 id="串口通讯—全双工和半双工方式"><a href="#串口通讯—全双工和半双工方式" class="headerlink" title="串口通讯—全双工和半双工方式"></a>串口通讯—全双工和半双工方式</h3><h4 id="全双工方式-full-duplex-："><a href="#全双工方式-full-duplex-：" class="headerlink" title="全双工方式(full duplex)："></a>全双工方式(full duplex)：</h4><p>当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工制。在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送。全双工方式无需进行方向的切换，因此，没有切换操作所产生的时间延迟，这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利。这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线传送数据信号。(可能还需要控制线和状态线，以及地线)。比如，计算机主机用串行接口连接显示终端，而显示终端带有键盘。这样，一方面键盘上输入的字符送到主机内存;另一方面，主机内存的信息可以送到屏幕显示。通常，往键盘上打入1个字符以后，先不显示，计算机主机收到字符后，立即回送到终端，然后终端再把这个字符显示出来。这样，前一个字符的回送过程和后一个字符的输入过程是同时进行的，即工作于全双工方式。</p>
<h4 id="半双工方式-half-duplex"><a href="#半双工方式-half-duplex" class="headerlink" title="半双工方式(half duplex):"></a>半双工方式(half duplex):</h4><p>若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据，这样的传送方式就是半双工制。采用半双工方式时，通信系统每一端的发送器和接收器，通过收/发开关转接到通信线上，进行方向的切换，因此，会产生时间延迟。收/发开关实际上是由软件控制的电子开关。当计算机主机用串行接口连接显示终端时，在半双工方式中，输入过程和输出过程使用同一通路。有些计算机和显示终端之间采用半双工方式工作，这时，从键盘打入的字符在发送到主机的同时就被送到终端上显示出来，而不是用回送的办法，所以避免了接收过程和发送过程同时进行的情况。</p>
<p>目前多数终端和串行接口都为半双工方式提供了换向能力，也为全双工方式提供了两条独立的引脚。在实际使用时，一般并不需要通信双方同时既发送又接收，像打印机这类的单向传送设备，半双工甚至单工就能胜任，也无需倒向。</p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>首先需要明白两个概念，就是DTE和DCE。DTE是指数据终端设备，典型的DTE就是计算机和单片机。DCE是指数据通信设备，典型的DCE就是MODEM。RS232串口标准中的RXD和TXD都是站在DTE立场上的，而不是DCE。明白了这一点，再讲下面的接线方法，就很好理解了。</p>
<p>单片机与计算机进行串口通信时，单片机的RXD接计算机的TXD，单片机的TXD接计算机的RXD。主要是在使用串口时，TXD和RXD都是成对的，因此值得注意的是如果都是标准串口链接方式，往往不能直接连接，必须要错开链接，而这常常有两种方式，一种是让其中一个端口的RXD和TXD对调（故意错开），然后导线直通；另外一种是两个端口都采用标准端口，但导线部分RXD和TXD对调（交叉线）。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>
<p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>
<p>即便串口拥有同步功能，一般也是作为uart（通用异步收发传输器）使用，在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。事实上目前一般我们所说的串口通信就是指通用异步收发，极少采用同步通讯的方式。</p>
<h3 id="硬件接口以及连线"><a href="#硬件接口以及连线" class="headerlink" title="硬件接口以及连线"></a>硬件接口以及连线</h3><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口。</p>
<p>RXD接TXD，TXD接RXD，无论是单片机和单片机相连还是计算机和单片机相连都是如此，发射部分TXD永远同RXD链接配对。具体连接见下图：</p>
<ul>
<li>使用串口直通线。设计电路时，单片机的RXD连接电路板DB9的TXD，单片机的TXD连接电路板DB9的RXD，具体实现可在232电平转换芯片处反接。</li>
<li>使用串口交叉线。设计电路时，因为串口线已做交叉，单片机的RXD连接电路板DB9的RXD，单片机的TXD连接电路板DB9的TXD，均直连即可。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/5.jpg" alt=""></p>
<p>除非专门说明，否则所有引脚线序都是指串口外侧的线序，RS232串口的端口示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg" alt=""></p>
<p>如果是作为RS-232C接口，则各引脚定义如表所示。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg" alt=""></p>
<p>值得注意的是：<strong>公头和母头的RS232口在所有引脚的定义上面都是一致的，因此在购买选链接线的时候会分很多种：公对公23交叉，公对公直通，母对母直通，母对母23交叉，公对母23交叉，公对母直通。如果不能确定是什么线，万用表测量串口线一端的引脚2与另一端的引脚2是否短接，是则是直连串口线，否则是交叉串口线。</strong></p>
<p>各引脚的电气特性为：在TxD和RxD上，逻辑“1”为-3V~-15V； 逻辑“0”为+3V~+15V。在RTS、CTS、DSR、DTR和DCD等控制线上，信号有效为+3V~+15V；信号无效为-3V~-15V。对于数据信号，逻辑“1”为低于-3V，逻辑“0”为高于+3V；对于控制信号，接通ON为低于-3V；断开OFF为高于+3V；-3V~+3V、低于-15V、高于+15V都表示电压无意义。</p>
<p><strong>串口异步传输在空闲状态时都必须是高电平。</strong></p>
<h3 id="特征简述"><a href="#特征简述" class="headerlink" title="特征简述"></a>特征简述</h3><ul>
<li>RS-232串口通信最远距离是50英尺，约为15m，可见232的距离传输并不是很远，由于正负逻辑电平的差量有限，232的抗干扰能力较弱。</li>
<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps（传统情况下232的传输速度有限一般就是在19200以下）</li>
<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （使用过程中尤其需要注意232的电平，不能直接将单片机同RS-232C口中RX，TX直连，中间需要有相应的转换芯片才可）</li>
</ul>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>既然要详细介绍RS232的使用和通讯，这边肯定要附上常见的硬件设计电路和原理图的。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/72.png" alt=""></p>
<h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><p>串口因为作为最常用的一个功能，有关串口的协议一般已经被迁入到了目前市面上几乎所有主流的芯片中了，目前绝大多数芯片本身自带串口相关功能，用户无需按照协议来模拟出高低电平和时间周期来发送码元，相关功能已经作为芯片自带功能嵌入到了相关寄存器中，用户仅仅需要根据参考文档，完成usart相关寄存器的配置和调用，即可实现串口的发送和接收了。</p>
<h4 id="IO口模拟uart实现"><a href="#IO口模拟uart实现" class="headerlink" title="IO口模拟uart实现"></a>IO口模拟uart实现</h4><p>IO口模拟uart能够帮助我们更加深入了理解uart的相关协议，知道整个uart通信过程中，是如何工作，对一切细节特性都可以了如指掌，对于我们深入的研究学习串口通信还是比较有帮助的，且IO模拟出来的通信协议一般都更具兼容性，可以很方便的进行不同芯片的移植，而无需关注芯片本身寄存器和底层结构。</p>
<p>众所周知数字电路实现的最主要功能就是输入输出，高低电平。所谓的协议虽然复杂但都是可以通过输入输出和高低电频给模拟出来的。下面主要以stm32芯片为例，使用IO口模拟出串口通讯，这边只附上主要程序片段，详细工程见链接。</p>
<p>首先，必须要知道串口通讯时数据是怎样传输的？这里以异步传输字符为例子，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS232%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/6.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>串口异步传输在空闲状态时都必须是高电平</li>
<li>起始位是低电平，发完后有一个等待时间</li>
<li>中间数据位个数以及是否有校验位需要和接收端保持一致，发完后有一个等待时间</li>
<li>停止位为高电平</li>
<li>每次发完后的等待时间由波特率所决定，停止位之后需要有一定的空闲时间，这个时间是超过等待时间的。</li>
</ul>
<p>以下为模拟串口接收发送的主要代码，<strong>仅仅是一个粗稿，实验使用，具体的工程项目存在较大的缺陷，还要进一步完善。</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">/* IO口设置，这边不详细写出，IO配置成LED灯的模式即可 */</div><div class="line"></div><div class="line">***以下为模拟uart的TX口发送数据***</div><div class="line"></div><div class="line">/*主要的打印字符串函数*/</div><div class="line">void my_printf(char * str, ...)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span> (*str != <span class="string">'\0'</span>)</div><div class="line">	&#123;</div><div class="line">		UART_SendData((u8)*str++);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*串口发送每个数据包*/</div><div class="line">void UART_SendData(u8 data)</div><div class="line">&#123;</div><div class="line">	TX_LOW();</div><div class="line">	UART_DELAY();</div><div class="line"></div><div class="line">	//传输字节的过程中是从字节的低位开始发送的。</div><div class="line">    <span class="keyword">for</span> (u8 i = 0; i &lt; 8; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (data &amp; 0x01)</div><div class="line">		&#123;</div><div class="line">			TX_HIGH();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> </div><div class="line">		&#123;</div><div class="line">			TX_LOW();</div><div class="line">		&#125;</div><div class="line">		data &gt;&gt;= 1;</div><div class="line">		</div><div class="line">		UART_DELAY();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	TX_HIGH();</div><div class="line">	</div><div class="line">	// 值得注意的是在发送完毕后</div><div class="line">	UART_DELAY();</div><div class="line">	UART_DELAY();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*使用systick定时器精准制定波特率115200*/</div><div class="line"><span class="comment">#define	UART_DELAY()	delay_com()</span></div><div class="line"></div><div class="line">void delay_com(void)</div><div class="line">&#123;		</div><div class="line">	u32 temp;	    	 </div><div class="line">	SysTick-&gt;LOAD =  SystemCoreClock / 8 / 115200; //时间加载	  		 </div><div class="line">	SysTick-&gt;VAL = 0x00;        //清空计数器</div><div class="line">	SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk ;          //开始倒数	 </div><div class="line">	<span class="keyword">do</span></div><div class="line">	&#123;</div><div class="line">		temp = SysTick-&gt;CTRL;</div><div class="line">	&#125;<span class="keyword">while</span>(temp &amp; 0x01 &amp;&amp; !(temp&amp;(1&lt;&lt;16)));//等待时间到达   </div><div class="line">	SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;       //关闭计数器</div><div class="line">	SysTick-&gt;VAL = 0X00;       //清空计数器	 </div><div class="line">&#125;</div><div class="line"></div><div class="line">***以下为模拟uart的RX接收数据***</div><div class="line"></div><div class="line">这边内容较多，不做详细的累述，仅大致提供下思路，详细内容可以参见代码。</div><div class="line"></div><div class="line"></div><div class="line">/* 串口完整接收一个字节的数据 */</div><div class="line">u8 UART_GetByte(void)</div><div class="line">&#123;</div><div class="line">	u8 Data = 0;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (u8 i = 0; i &lt; USART_DATA_LEN; i++)</div><div class="line">	&#123;</div><div class="line">		UART_DELAY();</div><div class="line">		Data |= RX1_READ()&lt;&lt;i;	</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span> Data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 终端捕捉信号 */</div><div class="line">void EXTI15_10_IRQHandler(void) /* bit &amp; add */</div><div class="line">&#123;</div><div class="line">	/* about key2 bit*/</div><div class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(RX1_EXTI_LINE) != RESET)</div><div class="line">    &#123;</div><div class="line">		/* 每次有数据接受时，开启定时器用来计量数据采集的时间 */</div><div class="line">		TIM3-&gt;CNT = 0;</div><div class="line">		TIM_Cmd(TIMER_NUM[TIMER3], ENABLE); //使能定时器3</div><div class="line"></div><div class="line">		TIM3_Init_Ctrl(ENABLE);</div><div class="line"></div><div class="line">		g_TimeOut = 0;</div><div class="line">		</div><div class="line">		g_byStore[point++] = UART_GetByte();</div><div class="line"></div><div class="line">        /* 清除中断挂起标志位，否则会被认为中断没有被处理而循环再次进入中断 */</div><div class="line">      	EXTI_ClearITPendingBit(RX1_EXTI_LINE);</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">**这边的难点在于如何判断数据发送完毕**</div><div class="line">- 设置RX口为外部终端触发，当接收到第一个下降沿时，进入中断函数</div><div class="line">- 中断函数逐一执行接收数据的采集和捕捉</div><div class="line">- 我们通过采用一个定时器来每次收到外部中断时，完成一次计时，当计时超过一次数据接收的时间，则认为接收完毕</div></pre></td></tr></table></figure>
<p> 一般字符传输都采用：1位起始位，8位数据位，1位停止位，没有校验位 的形式传输，其他形式的这里不讲。<strong>串口异步传输在空闲状态时都必须是高电平</strong>。第一位传输的是起始位，<strong>起始位会将原来空闲时的高电平拉成低电平</strong>，起始位用来来标识数据开始传输，提示接收方准备开始接收数据；当接收方第一次检测到一个下降沿时，就表示接收到了起始位。起始位后就是8位的数据位，接收方在接收每一位数据的时候会采集几十次，如果结果都是低电平，则接收到的数据位0，如果结果都是高电平，则接受到的数据位是1。1位停止位会将电平拉成高电平，为接收下一个数据做准备。</p>
<h4 id="芯片自带uart实现"><a href="#芯片自带uart实现" class="headerlink" title="芯片自带uart实现"></a>芯片自带uart实现</h4><p>既然IO口也能够模拟出uart通信功能，为何众多芯片厂商还要费尽心思的将uart做入芯片里面呢？就我个人理解而言，IO虽然可以模拟出通信协议，但毕竟是IO口的操作，在能耗，速度还有计算资源占用上面都会是一个很大的开销。尤其对功耗而言，将这些做入芯片内部，可以最完美的匹配这些协议，降低能耗，另外虽然牺牲了一定的移植性，但模拟这些通讯协议可以减少代码复杂度，降低程序员编写代码的门槛，无需彻底的理解弄清这些协议，即可完成相关功能，这现在也被大家广泛接受，毕竟如：IIC，SPI等通信协议书完全用IO模拟写起来并不是太简单。这边主要以stm32中自带的串口驱动为例，本事例不具备普遍应用性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/jason-lu/articles/3171870.html" target="_blank" rel="external">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href="http://book.51cto.com/art/201308/408900.htm" target="_blank" rel="external">http://book.51cto.com/art/201308/408900.htm</a><br><a href="http://blog.csdn.net/sdwuyulunbi/article/details/6632382" target="_blank" rel="external">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href="http://blog.csdn.net/skyflying2012/article/details/49274313" target="_blank" rel="external">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href="http://blog.csdn.net/gszhy/article/details/8594433" target="_blank" rel="external">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href="http://blog.csdn.net/bytxl/article/details/49147915" target="_blank" rel="external">http://blog.csdn.net/bytxl/article/details/49147915</a><br><a href="http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">http://www.baike.com/wiki/51+IO%E5%8F%A3%E6%A8%A1%E6%8B%9F%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AFC%E6%BA%90%E7%A8%8B%E5%BA%8F</a><br><a href="http://ziye334.blog.163.com/blog/static/224306191201452833850647" target="_blank" rel="external">http://ziye334.blog.163.com/blog/static/224306191201452833850647</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[串口RS485通信详解]]></title>
      <url>http://noparkinghere.top/2016/10/19/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><strong>注意：串口发送数据是按位逐个发送的，且在传输字节的过程中是从字节的低位开始发送的。串口的一些内容不再逐一介绍说明，可以参加之前的usb转串口及RS232通信等文章</strong></p>
<h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><p>485（一般称作 RS485/EIA-485）是隶属于 OSI 模型物理层的电气特性规定为 2 线，半双工，多点通信的标准。它的电气特性和 RS-232 大不一样。用缆线两端的电压差值来表示传递信号。值得注意的是：RS485 仅仅规定了接受端和发送端的电气特性，它没有规定或推荐任何数据协议。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/1.jpg" alt=""></p>
<p>RS485接口可以只使用两根线进行通讯（其他串口通讯至少需要三根线，一根为地线作为参考电平），通过差分电平（利用两个信号的差值来判断信息，使用差分信号来传输的，也就是一根线传同相信号，一根线传反相，这样差值最大，抗干扰能力强。）来确定信号是0还是1，也正因为这个原因，所以RS485每次有且仅有一根线能够传输数据，另外一根线作为比对信号，因此RS485是半双工的通讯方式。主要特点如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/2.jpg" alt=""></p>
<ul>
<li>接口电平低，不易损坏芯片。 RS485 的电气特性：逻辑“ 1”以两线间的电压差为+(2~6)V<br>表示；逻辑“ 0”以两线间的电压差为-(2~6)V 表示。接口信号电平比 RS232 降低了，<br>不易损坏接口电路的芯片，且该电平与 TTL 电平兼容，可方便与 TTL 电路连接。</li>
<li>传输速率高。 10 米时， RS485 的数据最高传输速率可达 35Mbps，在 1200m 时，传输<br>速度可达 100Kbps。</li>
<li>抗干扰能力强。 RS485 接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力<br>增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485 总线最长可以传输 1200m<br>以上（速率≤100Kbps）</li>
<li>一般最大支持 32 个节点，如果使用特制的 485 芯片，可以达到 128 个或者 256 个节点，<br>最大的可以支持到 400 个节点。</li>
</ul>
<a id="more"></a>
<h3 id="类比RS232"><a href="#类比RS232" class="headerlink" title="类比RS232"></a>类比RS232</h3><p>实际上232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>
<p>因为都是采用串口通信协议，所以软件端几乎可以直接使用，且RS485具备耗材少，抗干扰强等特点，在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>
<ul>
<li>从接线上，RS232是三线制，RS485是两线制</li>
<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>
<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>
<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>
</ul>
<p>RS232的接线：<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/3.jpg" alt="">)</p>
<p>RS485的接线<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-19-%E4%B8%B2%E5%8F%A3RS485%E9%80%9A%E4%BF%A1%E8%AF%A6%E8%A7%A3/4.jpg" alt=""></p>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/jason-lu/articles/3171870.html" target="_blank" rel="external">http://www.cnblogs.com/jason-lu/articles/3171870.html</a><br><a href="http://book.51cto.com/art/201308/408900.htm" target="_blank" rel="external">http://book.51cto.com/art/201308/408900.htm</a><br><a href="http://blog.csdn.net/sdwuyulunbi/article/details/6632382" target="_blank" rel="external">http://blog.csdn.net/sdwuyulunbi/article/details/6632382</a><br><a href="http://blog.csdn.net/skyflying2012/article/details/49274313" target="_blank" rel="external">http://blog.csdn.net/skyflying2012/article/details/49274313</a><br><a href="http://blog.csdn.net/gszhy/article/details/8594433" target="_blank" rel="external">http://blog.csdn.net/gszhy/article/details/8594433</a><br><a href="http://blog.csdn.net/bytxl/article/details/49147915" target="_blank" rel="external">http://blog.csdn.net/bytxl/article/details/49147915</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu关闭笔记本触摸板]]></title>
      <url>http://noparkinghere.top/2016/10/18/2016/2016-10-18-ubuntu%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%A7%A6%E6%91%B8%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p><em>ubuntu 16.04的版本中，试过多个笔记本都可以通过键盘的快捷按键关闭触摸板的使用，但仍然显得不够智能，因为缺乏相关的程序和驱动，无法做到自动选择触摸板和鼠标。另外虽然我用的是ubuntu的系统但因为没有使用它的WM所以触摸板无法直接禁用，必须通过手动的方式才可以实现。</em></p>
<p>本文搜集了一些比较通用的触摸板禁用方式，另外后续如果找到更好的方法，还会补充上来。以下在dell的超极本和msi的游戏本上面实现过，且实验环境是ubuntu 16.04，其他系统和笔记本不能确保一定可以实现。</p>
<h3 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><ul>
<li>sudo rmmod psmouse    这个是禁用触摸板</li>
<li>sudo modprobe psmouse 这个是启用触摸板</li>
</ul>
<p>方式简单快捷，但是会将触点和触板都禁用了，一般还是希望保持触点是启用的，且仅有启用和禁用的两个功能，每次需要指令才可以实现，无法做到智能识别鼠标自动启用禁用。</p>
<a id="more"></a>
<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>在软件中心中搜索”pointing-device”安装，图形化界面操作简单方便。</p>
<p>但新问题出现了：禁用之后，如果敲击键盘的话，那么触板又会启用。这个问题当时很头大啊。经测试发现，只要将系统自带的管理器中“敲击键盘时禁用触摸板”这一项的勾去掉。那么就不会出问题了。<br>小结：以上就是对在Ubuntu系统下关闭触摸板很有用的两种方法，这两种方法使得以后再出现这样的情况时就可以采用的哦！</p>
<p><em>该方法我并没有尝试过，因为较少使用ubuntu自带的软件中心，有兴趣的朋友可以尝试下。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.285868.com/a/xtjc/5798.html" target="_blank" rel="external">http://www.285868.com/a/xtjc/5798.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机中的通信简介]]></title>
      <url>http://noparkinghere.top/2016/10/18/2016/2016-10-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>计算机从最初发展到现在已经有半个多世纪的历史，众所周知其实计算机就是一堆电路的组成，传统最为通用的计算功能仅仅是控制高低电平，输入输出（0和1）。而计算机中的CPU和其他设备如内存，硬盘，主板的其他电路连接过程中，控制的过程就是通过相关的通信协议，让一堆的高低电平输入输出最终可以转化为我们我们工作需要的内容，而赋予这些0,1实际意义的就是通信协议。计算机中有着众多的通信协议，有些协议已经逐渐被淘汰，而另外一些经过这么多年的发展仍然在各行各业经久不衰，一些更新更稳定更满足这个时代需求的协议也正在被越来越多的智能设备移动设备所采纳。本文仅仅是简要的叙述计算机嵌入式中最常用的一些协议。</p>
<p>这边如果对码元，波特率等还不是恨清除的可以参考<strong>传输速率</strong>这篇文章。</p>
<p><em>在了解通信协议和传输前，得先弄明白：总线和协议，串行传输和并行传输，同步通信和异步通信，全双工和半双工等基本概念，至于具体的通信方式和协议，这边仅作简述，有单独文章进行具体阐述。</em></p>
<h3 id="总线和协议"><a href="#总线和协议" class="headerlink" title="总线和协议"></a>总线和协议</h3><p>在展开讲解之前，先来区分两个概念：总线和协议。</p>
<p><strong>总线</strong>是一组信号线的集合，它定义了各引线的信号、电机、机械特性，使计算机内部各组成部分之间以及不同的计算机之间建立信号联系，进行信息传送和通信，按照作用范围简单来分可以分为内部总线和外部总线。内部总线：就是计算机内部功能模板之间进行通信的总线，它是构成完整的计算机系统的内部信息枢纽，但按功能仍要分为数据总线DB，地址总线AB，控制总线CB，电源总线PB。外部总线是计算机与计算机之间或计算机与其他智能设备之间进行通信的连接。但随着嵌入式不断的发展，现在在两者的区分已经不是那么严格，USB的传输可以认作是外部串行传输方式，而传统所认为是内部穿行传输方式的IIC现在也被一些外接的传感器所使用，因此在嵌入式领域已经无需再纠结是内部总线还是外部总线，毕竟为了满足需求很多原有的协议已经进行的改进使得传输距离更远，抗干扰性更强了，也有更多曾经的内部总线被在外部所使用了。</p>
<p>通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保在通信过程中数据顺利地传送到确定的地方。</p>
<p><em>因为总线的种类实在太多，各种总线的衍生品层出不穷，这边就不详细列举，以下仅仅将目前嵌入式/微机上面最为常见的通信方式列举出来。</em></p>
<a id="more"></a>
<h3 id="串行总线和并行总线"><a href="#串行总线和并行总线" class="headerlink" title="串行总线和并行总线"></a>串行总线和并行总线</h3><p>采用串行传输方式的总线被成为串行总线，一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位传送，传按位顺序进行，最少只需一根传输线即可完成，成本低但送速度慢。串行通讯的距离可以从几米到几千米。 根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。信息只能单向传送为单工；信息能双向传送但不能同时双向传送称为半双工；信息能够同时双向传送则称为全双工。</p>
<p>串口形容一下就是一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但是并不是说并口快，由于8位通道之间的互相干扰（串扰），传输时速度就受到了限制，传输容易出错。串口没有互相干扰。并口同时发送的数据量大，但要比串口慢。串口硬盘就是这样被人们重视的。</p>
<p>采用并行传输方式的总线被成为并行总线，并行通讯通常可以一次传送8bit、16bit、32bit甚至更高的位数，相应地就需要8根、16根、32根信号线，同时也需要加入更多的信号地线。比如传统的PATA线路有40根线，其中有16根信号线和7根信号地线，其他为各种控制线，一次可以传送2Byte的数据。并行通讯中，数据信号中无法携带时钟信息（需要时钟信息，是为了确保一次发送的为一组相关数据，当始终跳转一次的时候，再发送下一租数据，如果缺少始终信息，而多组数据的传输有快有慢的话，则所有数据会串扰，通讯毫无意义。而串行通讯则没有这样的问题，一个个位发送，最终只需按照协议整合数据即可，当然也有部分穿行通信协议利用时钟来实现附加的操作），为了保证各对信号线上的信号时序一致，并行设备需要严格同步时钟信号，或者采用额外的时钟信号线。</p>
<p>通过串行通讯与并行通讯的对比，可以看出：串行通讯很简单，但是相对速度低，抗干扰能力强（可以用在长距离通讯），成本低；并行通讯比较复杂，但是相对速度高，成本高（需要更多的线），抗干扰能力弱（传输距离短）。</p>
<h3 id="同步通信和异步通信"><a href="#同步通信和异步通信" class="headerlink" title="同步通信和异步通信"></a>同步通信和异步通信</h3><p>异步通信就是发送方在任意时刻都可以发送数据，前提是接收端已经做好了接受数据的准备（如果没有做好接受准备，数据肯定发送失败），也正是因为发送方的不确定性，所以接收方要时时刻刻的准备好接受数据，同时由于每次发送数据时间间隔的不确定性，所以，在每次发送数据时都要使用明确的界定符来标示数据（字符）的开始和结束位置，可以想象这种通信方式效率很低。虽然异步通信效率低，但是对设备的要求不高，通信设备简单。异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，<strong>字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</strong></p>
<p>同步通信和异步通信相反，就是主机在进行通信前要先建立同步，即要使用相同的时钟频率，发送方的发送频率和接受方的接受频率要同步。</p>
<p>除了时间频率的不同外，异步通信和同步通信之间的区别还是发送数据的表示形式，异步通信一般发送单位是字符，同步通信发送单位是比特流（数据帧），但是这不是绝对的，异步通信有时也使用帧来通信。同步通讯进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是自同步，后者是外同步。事实上目前大多是采用异步通讯，极少数是采用同步通讯的。</p>
<h3 id="单工，全双工和半双工"><a href="#单工，全双工和半双工" class="headerlink" title="单工，全双工和半双工"></a>单工，全双工和半双工</h3><ul>
<li>如果在通信过程的任意时刻，信息只能由一方A传到另一方B，则称为单工。</li>
<li>如果在任意时刻，信息既可由A传到B，又能由B传A，但只能由一个方向上的传输存在（即不能同时传输）,称为半双工传输。</li>
<li>如果在任意时刻，线路上存在A到B和B到A的双向信号传输，则称为全双工。</li>
</ul>
<h3 id="串口通信-（见详细文章）"><a href="#串口通信-（见详细文章）" class="headerlink" title="串口通信 （见详细文章）"></a>串口通信 （见详细文章）</h3><p>串行接口是一种可以将接受来自CPU的并行数据字符转换为连续的串行数据流发送出去，同时可将接受的串行数据流转换为并行的数据字符供给CPU的器件。一般完成这种功能的电路，我们称为串行接口电路。曾经PC之间进行串口通信可以说是标配，很多老式电脑上面可以看到DB25的接头，但后来逐渐被DB9取代，早期鼠标打印机都通过串口进行数据传输的，但现在逐渐被USB和网络所取代，DB9的串口接头在PC和笔记本上面也较少能够看到了。做嵌入式开发可以看到有个DB9的串口标准接口，串口对于开发人员输入输出调试等有着至关重要的作用。串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等，现在串口一般在工业嵌入式领域使用。</p>
<p>在使用串口通信时最重要的参数：波特率，数据位，停止位，奇偶校验位。</p>
<p>同步通信和异步通信：异步通信是计算机通信中最常用的数据信息传输方式。它是以字符为单位进行传输的，字符之间没有固定的时间间隔要求，而每个字符中的各位则以固定的时间传送。</p>
<h4 id="RS-232-C"><a href="#RS-232-C" class="headerlink" title="RS-232-C"></a>RS-232-C</h4><p>传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座（DB25），后来使用简化为9芯D型插座（DB9），现在应用中25芯插头座已很少采用。目前一般可以见到的串口接头都为DB9的232接口，</p>
<ul>
<li>RS-232串口通信最远距离是50英尺，约为15m</li>
<li>RS-232可做到双向传输，全双工通讯，最高传输速率20kbps</li>
<li>RS-232C上传送的数字量采用负逻辑，且与地对称：逻辑1：-3 ～-15V  逻辑0：+3～+15V （）</li>
</ul>
<h4 id="RS-485"><a href="#RS-485" class="headerlink" title="RS-485"></a>RS-485</h4><p>232串口在实际使用已经用处不大，但基于232发展出来的485等串口设备仍然被广泛使用，RS-485（EIA-485标准）是RS-422的改进，因为它增加了设备的个数，从10个增加到32个，同时定义了在最大设备个数情况下的电气特性，以保证足够的信号电压。有了多个设备的能力，你可以使用一个单个RS-485口建立设备网络。</p>
<p>因为都是串口通信，所以本质两者是相差无几的，但耗材少，抗干扰强等特点让RS485在目前的工业领域仍然被广泛使用，这边主要列举出不同：</p>
<ul>
<li>从接线上，RS232是三线制，RS485是两线制</li>
<li>从传输距离上，RS232只能传输15米，RS485最远可以传输1200米</li>
<li>从速率上，RS232是全双工传输，RS485是半双工传输</li>
<li>从协议层上，RS232只支持点对点通讯(1:1)，RS485支持总线形式通讯（1:N）</li>
</ul>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>SPI是串行外设接口（Serial Peripheral Interface）的缩写。SPI，是一种高速的，<strong>全双工</strong>，<strong>同步</strong>的通信总线，并且在芯片的管脚上只占用<strong>四根线</strong>，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，如今越来越多的芯片集成了这种通信协议，比如AT91RM9200，stm32f103等。</p>
<h3 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h3><p>IIC 即Inter-Integrated Circuit(集成电路总线），这种总线类型是由飞利浦半导体公司在八十年代初设计出来的一种简单、双向、二线制、同步串行总线，主要是用来连接整体电路(ICS) ，IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口，如今越来越多的芯片集成了这种通信协议，比如stm32f103，EFM32等。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/wind19/article/details/7433249" target="_blank" rel="external">http://blog.csdn.net/wind19/article/details/7433249</a><br><a href="http://baike.baidu.com/view/185322.htm" target="_blank" rel="external">http://baike.baidu.com/view/185322.htm</a><br><a href="http://www.cnblogs.com/mylinux/p/4078576.html" target="_blank" rel="external">http://www.cnblogs.com/mylinux/p/4078576.html</a><br><a href="http://baike.baidu.com/view/716175.htm" target="_blank" rel="external">http://baike.baidu.com/view/716175.htm</a><br><a href="https://www.zhihu.com/question/29033993" target="_blank" rel="external">https://www.zhihu.com/question/29033993</a><br><a href="http://www.cnblogs.com/general001/articles/2344079.html" target="_blank" rel="external">http://www.cnblogs.com/general001/articles/2344079.html</a><br><a href="http://blog.csdn.net/weiqifa0/article/details/8845281" target="_blank" rel="external">http://blog.csdn.net/weiqifa0/article/details/8845281</a><br><a href="http://www.cnblogs.com/jason-lu/articles/3171870.html" target="_blank" rel="external">http://www.cnblogs.com/jason-lu/articles/3171870.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2016年底计划表]]></title>
      <url>http://noparkinghere.top/2016/10/17/2016/2016-10-17-2016%E5%B9%B4%E5%BA%95%E8%AE%A1%E5%88%92%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>2016转眼又快结束，这个月加上国庆休假一下子又过去了半个多月，直到今天才开始上班。今年除了工作上面的几个项目进一步完善外，这边为16年最后几个月制定一个小计划：</p>
<ul>
<li>按照自己的风格，为神州王开发板写一套完整的学习案例，并同步到github。</li>
<li>学习研究python，以视频文档和案例学习为主。</li>
<li>装修自己的blog</li>
</ul>
<a id="more"></a>
<hr>
<p>只完成了部分计划，大多数未能完成。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Note 7 的一些个人看法]]></title>
      <url>http://noparkinghere.top/2016/10/16/2016/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><em>本文是一篇杂谈笔记，一直比较关注科技圈多年，喜欢各种电子产品，且能够DIY或者修理一些小东西，虽然对三星这家公司一直缺乏好感，但还是吐槽一番。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/1.jpg" alt=""></p>
<p>最近闹的比较火的三星Note 7手榴弹事件，终于在这两天落下了帷幕，最终三星将中国市场和海外市场同等对待，停售并回收所有该款机型，无需退还相关赠送配件，允许用户退换或者置换手机，并作出一系列相关补偿。事情看起来似乎是皆大欢喜，恶势力最终向国人低头。</p>
<p>但换而言之，通过三星的一些列举动不得不说是：<strong>搬起石头砸自己的脚</strong>。首先三星和苹果一直是占据高端手机市场几乎所有份额的，三星早些时候在12年以前可以说是国内最最畅销的手机厂家。原因是：产品线广，覆盖低中高多个销售人群，品牌大众认可度高，国内缺乏有力的竞争对手，那时候小米，华为等也才刚刚起步没多久。三星的衰亡也恰恰因为这些原因，首先，13年以后，国内主打性价比性能的手机层出不穷，而三星天然的重广告轻研发的基因，也让它的中低端机型用户体验奇差无比。国内中低端市场逐渐被国产手机厂家占领，三星从此排名一落千丈，且这几年似乎已经从中国主流消费者眼中销声匿迹了。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-10-16-note-7-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/2.jpg" alt=""></p>
<p>三星的再次复兴应该是从galaxy S6开始的，虽然中低端市场挫败，但高端市场推出曲面屏，防水等一些列更加满足用户差别需求的产品，让三星在多个方面包括：拍照成像等都成为了市面上面最好的手机。而这次Note 7更加是来势汹汹的，wacom顶尖手绘笔技术，红魔识别，高成像画质等等众多功能，确实让三星这次绝对有秒杀市面一切手机的资本。但恰恰是这颗手榴弹毁了三星，手机本身是一个附加的用户产品，意义在于让用户更加方便的交流通信，没有手机我们一样可以完成很多事情，一样可以活，而手机本身仅仅是个工具为了方便交流，所以一切的附加属性再好的用户体验都离不开工具本身的属性，而如果这个工具需要大家冒着生命危险去使用，那又有哪个人不会望而却步呢？！有人说一个产品不能有任何的马虎，三星这次就是一个螺丝没上的好导致满盘皆输，事实上三星这次不仅仅是一个螺丝的问题，民用产品本身不会要求精益求精，苹果也有天线门，各家手机也会有各种问题等，三星这次是躺在了最不该出问题的事件上面，试想：一个手机被旅客禁止携带，简直是闻所未闻。</p>
<p>抛开国外市场，暂且不说，其实在国内尚且没有发生重大变故的前提下，三星最该去做好各种公关，积极响应用户号召，和国外市场一视同仁，直接退换机型，这样，虽然会有一定的经济损失，但一定可以建立一个更好的口碑市场。其实中国用户很好打发，尤其是国人有“伸手不打笑脸人”的思想，中国人一直有种奇怪的认知，不在乎你犯错，但你认错的态度一定要诚恳，很多时候甚至媒体艺人喜欢拿这些来炒作自己。三星如果这次一开始就积极认错，最终大多数国人会这样认为：不愧是三星，和别的国际厂家就是不一样，能够做到一视同仁，即便产品本身没有问题都可以为用户考虑，这样的大公司值得信赖。而反观这次，三星是被中国用户“逼着”去承认自己的错误，三星国行用的香港的电池可能确实是没有问题，但国内用户关注的早已不是电池的问题，而是区别对待的问题，只要有个别用户愿意，没有问题也可以把你整出问题，而这种调查出来的<em>真相</em>又有多少人愿意去相信？只会不断请权威机构证明，陷入死循环。而中国政府这个时候如果帮三星澄清无意是打自己的脸。三星如果还想在中国混，必然不得不向消费者低头，所有不得不说，在有这么多区别对待海内外市场公司的前科下，三星还范这种错误，无疑让人很难理解。</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 手机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多种电平的区分]]></title>
      <url>http://noparkinghere.top/2016/10/09/2016-10-09-%E5%A4%9A%E7%A7%8D%E7%94%B5%E5%B9%B3%E7%9A%84%E5%8C%BA%E5%88%86/</url>
      <content type="html"><![CDATA[<p><strong>电平</strong>就是指电路中两点或几点在相同阻抗下电量的相对比值，即电量水平。常用逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。</p>
<h3 id="TTL电平"><a href="#TTL电平" class="headerlink" title="TTL电平"></a>TTL电平</h3><p>TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑”1”，0V等价于逻辑”0”，这被称做TTL(晶体管-晶体管逻辑电平)信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。</p>
<p>TTL集成电路的全名是晶体管-晶体管逻辑集成电路(Transistor-Transistor Logic)，按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。</p>
<ul>
<li>5V TTL和5V CMOS逻辑电平是通用的逻辑电平。</li>
<li>3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。</li>
<li>低电压的逻辑电平还有2.5V和1.8V两种。</li>
</ul>
<a id="more"></a>
<h3 id="CMOS电平"><a href="#CMOS电平" class="headerlink" title="CMOS电平"></a>CMOS电平</h3><p>与CMOS管<br>1.CMOS是场效应管构成，TTL为双极晶体管构成<br>　　2.CMOS的逻辑电平范围比较大（3～15V），TTL只能在5V下工作<br>　　3.CMOS的高低电平之间相差比较大、抗干扰性强，TTL则相差小，抗干扰能力差<br>　　4.CMOS功耗很小，TTL功耗较大（1～5mA/门）<br>　　5.CMOS的工作频率较TTL略低，但是高速CMOS速度与TTL差不多相当</p>
<h3 id="RS232电平"><a href="#RS232电平" class="headerlink" title="RS232电平"></a>RS232电平</h3><p>电脑的串口是标准RS232电平，最高电压 可达 +15V 或 -15V</p>
<h3 id="RS485电平"><a href="#RS485电平" class="headerlink" title="RS485电平"></a>RS485电平</h3><blockquote>
<p>参考链接：<br><a href="http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO" target="_blank" rel="external">http://baike.baidu.com/link?url=UVcbZUUncOJC2yUDXBsf57HftheFOg6HGbIJ44CWrfuYCFaNZWefP8lWY9ra71kli9F_YalPAgV8h83yDpP_hJFk4yaasIizwquDUBaXWeO</a><br><a href="http://www.21ic.com/jichuzhishi/analog/questions/2013-10-23/194453.html" target="_blank" rel="external">http://www.21ic.com/jichuzhishi/analog/questions/2013-10-23/194453.html</a><br><a href="http://xfjane.spaces.eepw.com.cn/articles/article/item/70265" target="_blank" rel="external">http://xfjane.spaces.eepw.com.cn/articles/article/item/70265</a><br><a href="http://www.21ic.com/jichuzhishi/analog/questions/2013-05-17/181650.html" target="_blank" rel="external">http://www.21ic.com/jichuzhishi/analog/questions/2013-05-17/181650.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[传输速率]]></title>
      <url>http://noparkinghere.top/2016/10/02/2016/2016-10-02-%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87/</url>
      <content type="html"><![CDATA[<p>数据传输过程中常常会涉及到传输速率，这边详细区分和介绍下波特率和比特率的区别。另一种说法是：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。码元，承载信息量的基本信号单位。</p>
<h3 id="码元："><a href="#码元：" class="headerlink" title="码元："></a>码元：</h3><p>书面解释：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。 而这个间隔被称为码元长度。值得注意的是当码元的离散状态有大于 2 个时（如M大于2个） 时，此时码元为M进制码元。</p>
<p>码元通俗的说就是信号，一个数字脉冲就是一个码元。但事实这种解释不够全面，同一个时间段，信号可以变化3次，也可以变化1次。实际上，正如码元的定义一样，码元是与时间相联系的。这边的时间并不是一个明确的时间，例如：串口通信时，双方约定波特率为 9600（9600bps），则代表一秒钟传输 9600 个位（bit），这时每个码元所在的时间片段就约为1/9600s。再例如：I2C 的传输速率最大为 400Kbps，而 I2C 的通信更加的自由，实际使用过程中，双方并不会事先指定好通信速度，而是采用一根单独的SCL总线来限定通信的速度即码元所间隔的时间，在SDA保持恒定的情况下，SCL总线每次变化电平时的这段时间间隔就作为一个码元所在的时间片段。</p>
<p>通过定义可以看出，通常来所说的码元就是表示二进制码元，当用一个码元传输一个多重含义的数据时，码元还是码元，但我们称其为 M 进制码元。但实际我们也可以设计一个M进制的码元，举个栗子：假如基带信号是 7536154210…..，直接发送，则每个码元作为（八进制）码元传输，这样一个码元相当于8个不同的待识别状态数据。（每个码元有 8 种状态，实际早期为何不使用 10 进制来定义计算机就是因为，一个数据包含的意义越多，越难解析识别，也越容易出错，会增加设计的复杂度，很显然，远距离通讯一般都还是采用二进制码元较多）。而大多数计算机都只能传输2进制数值，假如基带信号是 101011000110111010…..，如果直接发送，则每个码元携带一个比特的信息（每个码元只有 2 种状态），但是如果将信号中的三个比特编为一组，即 101，011，000，110，111，010……，三个比特同样可以表述 8 种不同的排列，我们可以用不同的调制方法来表示这种信，如 8 种不同的振幅，频率，相位等，如果采用相位调制，相位 ϕ0 表示 000，ϕ1 表示 001，以此类推，那么接收端如果收到相位是ϕ0的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号（每个码元有 8 种状态，每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难）。</p>
<p>根据上述内容总结：一个以 m 波特传送信号的线路，其传送二进制数据的速率不一定是 m 比特/秒，因为每个信号可以运载几个比特，例如，若使用 0、1、2、3、4、5、6、7 共 8 个电平级，则需要  ，即 3 个比特来表示一个信号值，因而这种条件下比特率将是波特率的3倍。某系统每秒钟传送 2400 个码元，则该系统的传码率为 2400 波特或 2400B。但要注意，码元传输速率仅仅表征单位时间内传送码元的数目，而没有限定这时的码元是何种进制，因统一系统的各点上可能采用不同的进制，故给出码元速率时必须说明码元的进制和该速率在系统中的位置。</p>
<p>常用进制（或键位数）的码元有： 8 进制（也称 8 键制）数字码元键盘，10 进制数字码元键盘，5 进制笔画数字码元键盘，还有 26 进制字母码元键盘，26进制部件字母码元键盘，还有韩文的 28 进制字母码元键盘，俄文的 33 进制字母码元键盘，以及中国维文的 30 进制字母码元键盘等。</p>
<a id="more"></a>
<h3 id="比特率："><a href="#比特率：" class="headerlink" title="比特率："></a>比特率：</h3><p>在电信行业，码率，比特率或数据传输速率指在一个数据传送系统中，单位时间内通过设备比特、字符、块等的平均量。通常使用比特每秒或字节每秒两单位的复合形式度量。比特率在数字信道中，比特率是数字信号的传输速率（需要注意的是比特率是一个传输速度的单位），比特率显然是以 bit 位作为最小传输量的，不要和 Byte 字节进行混淆。它用单位时间内传输的二进制代码的有效位(bit)数来表示，其单位为每秒比特数 bit/s(bps)、每秒千比特数(Kbps)或每秒兆比特数(Mbps)来表示(此处K和M分别为 1000 和 1000000，而不是涉及计算机存储器容量时的1024和1048576)，而为何这边换算不是以1024为单位，而是以1000为单位呢，值得一提的是，人类世界习惯于使用十进制来换算，一般除了计算机对存储单元采用 1024K=1000M 这种换算方式外，人类社会中的大多数的换算方法都是采用1000代表1K，最为常见的现象就是买回来的硬盘厂家生产会以 1000 作为一个单位级，而插上电脑后会以 1024 作为一个单位级，因此硬盘等设备插入电脑往往都会比说明上面小很多，传输速率比特率这个单位在使用k是从来都是代表 1000 的，不幸的是，人们常常错误地用 K 代替 Ki。</p>
<p>k 与 Ki 分别表示 kilo-（千） 与 kibi-（二进制千） 。作为前缀使用时， k 表示 1,000，Ki 表示1,024，因为“Ki”来源于它在计算机方面 210 = 1,024 的使用。不幸的是，人们常常错误地用 K 代替 Ki。此外，不知晓其中微妙差别的广大公众，常常不加区别地使用“Kbps”与“Kibps”，造成了混乱。总之，使用“Kibps”通常是正确的。</p>
<p>b 代表 bit（比特），B 代表 byte（字节），1 字节 即 8 比特。这会导致混淆。比如当“1M（1 Meg，1 兆）网络连接”字样出现在广告上时，它常常表示 1 Mib/s（mebibit per second，二进制兆比特每秒）或者 1.049 Mb/s（megabit per second，兆比特每秒），即可能达到的最大下载速度实际上仅为 128 KiB/s（kibibyte per second，二进制千字节每秒）或者 131 kB/s（kilobyte per second，千字节每秒）。</p>
<h3 id="波特率："><a href="#波特率：" class="headerlink" title="波特率："></a>波特率：</h3><p>指在电子通信领域，鲍（Baud）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1 鲍即指每秒传输 1 个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。“鲍”（Baud）本身已是速率，所以不需要写成 Baud Rate（Rate 是赘字）。单位“鲍”本身就已经是代表每秒的调制数，以“鲍每秒”（Baud per second）为单位是一种常见的错误。</p>
<p><strong>波特率有时候会同比特率混淆</strong>，实际上后者是对信息传输速率（传信率）的度量。波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。因此信息传输速率即比特率在数值上和波特率有这样的关系：I = S × log2 (N)  其中I为传信率，S为波特率，N为每个符号负载的信息量，而 log2 (N) 以比特为单位。</p>
<p>以 RS232 为例，典型的“鲍”是 300, 1200, 2400, 9600, 19200, 115200 等，假设目前“鲍”为 9600， 则此RS232的比特率计算为I = S × log2 (N) = 9600×log2 (2) = 9600bps。</p>
<p>电路传输信号是靠在一定的时间段内，波形的变化来识别每一位（英文单位bit）信息的，那么<br>这一位信息的波形就叫作码元。  当用一个码元传输多个比特位时，码元还是码元，但我们称其为M进制码元。</p>
<blockquote>
<p>参考链接：<br><a href="http://1992zhong.blog.51cto.com/3963309/1167100" target="_blank" rel="external">http://1992zhong.blog.51cto.com/3963309/1167100</a><br><a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下安装搜狗输入法]]></title>
      <url>http://noparkinghere.top/2016/10/01/2016/2016-10-01-ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>一个系统输入法很重要，尤其对于中文输入法来说，而国内目前而言，肯定是搜狗的输入法最本土化，制作的也最出众了，主要还是有网络词库的功能，除了无法实现账户登录同步外，其他基本和windows没有任何区别。</p>
<p>搜狗输入法的配置针对不同的系统有时还真有点小麻烦，本来是不打算写这篇文章的，因为之前的几次配置都是轻松的完成了，但这次就花了个吧小时都没搞定，主要原因还是对ubuntu图形界面一些设置位置无法找到，加上搜狗输入依赖诸如fcitx之类的软件并不能即装即用。错误往往出在某一部做的不够完善，下面列举出详细安装配置步骤。</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ul>
<li>从<a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="external">官网</a>下载下来<a href="http://cdn2.ime.sogou.com/dl/index/1475147394/sogoupinyin_2.1.0.0082_amd64.deb?st=C24ANiLdi7HwWFenlPkG-w&amp;e=1476682538&amp;fn=sogoupinyin_2.1.0.0082_amd64.deb" target="_blank" rel="external">sogou for linux</a></li>
<li>注意搜狗拼音依赖于fcitx框架，但这边使用的是ubuntu 16.04已经预装了fcitx，如果是更老的版本则需要手动安装fcitx，<a href="http://pinyin.sogou.com/linux/help.php" target="_blank" rel="external">安装方法</a>。</li>
<li>接下来需要选择默认的键盘输入系统，在ubuntu的所有设置（All Settings）中选择语言支持（Language Support）将Keyboard input method system：fcitx。</li>
<li>配置fcitx，可以通过ubuntu的软件直接打开，也可以终端输入运行fcitx-config-gtk3。使用左下角的添加按钮，手动添加sogou输入法，<em>注意：当前输入法如果不是中文，则需要手动将默认勾选的only show current language去掉，然后才可以找出搜狗拼音，同时需要保留一个默认的英文输入法</em>。</li>
<li>完成以上步骤后，基本完成了搜狗拼音的安装，已经可以简单的使用了。</li>
</ul>
<a id="more"></a>
<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><ul>
<li>隐藏状态栏</li>
<li>中英文切换使用ctrl键，切换时保留输入窗口字符上屏，个人<a href="http:/noparkinghere.github.io/2016/10/01/2016/2016-10-01-ubuntu下安装搜狗输入法" target="_blank" rel="external">将ctrl和caps lock进行互换</a>了，这样切换起来更加方便</li>
<li>候选词9个，模糊拼音等 </li>
</ul>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>每次开机重启后，第一次使用搜狗都会出现无法加载，只是一个小框显示正在输入，不载入搜狗的皮肤也不显示中文，然后等几秒钟状态栏会切换一次fcitx，再切换回搜狗拼音，就可以使用了。有没有什么解决问题的办法？系统是ubuntu16.04，WM用的是awesome。</p>
<p><em>如果有兴趣，也可以去搜狗拼音的论坛看一下，但有价值的帖子较少，论坛比较混杂。</em></p>
<p><strong>(2016-10-30)上述问题已经解决，具体方法：</strong></p>
<ul>
<li>查看fcitx帮助文档，得知该软件是个汉字管理软件，因此将fcitx -d加入开启自启动进程。</li>
<li>使用ps -aux | grep fcitx和ps -aux | grep sogou查看当前运行的进程。</li>
<li>在任意地方开始使用搜狗输入法一段时间，然后再次执行ps -aux | grep fcitx和ps -aux | grep sogou，将该指令和上次执行过的比对，发现上次执行缺少sogou-qimpanel，人为将该指令加入到awesome的rc.lua开机单次执行中去。</li>
</ul>
<p><strong>搜狗拼音输入法 v2.1.0.0082 存在 bug：</strong></p>
<ul>
<li>该版本存在较大的问题，主要是输入中文 jinjin 时，软件会自动崩溃，需要重启 fcitx 和 搜狗拼音</li>
</ul>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115" target="_blank" rel="external">http://pinyin.sogou.com/bbs/forum.php?mod=forumdisplay&amp;fid=115</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GP22芯片详解]]></title>
      <url>http://noparkinghere.top/2016/09/30/2016-09-30-GP22%E8%8A%AF%E7%89%87%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>GP22是一款工业计算时间的芯片，由于其精度高在几十ps级别，所以被广泛的应用在气表水表上面。本人由于工作上面的原因，有机会接触到这款芯片，但该芯片的研究学习并不简单，由于有多个寄存器，再加上寄存器的配置复用位数很多，所以注定这款芯片不简单，另外一些模拟数字电路，晶振校准能耗，采样精度等等各种功能很是繁杂，所以可以说这款芯片已经是类似于51单片机这种需要学习研究一下的芯片了。这篇文章将不断地总结记录，在使用这种芯片的重点，已经一些问题的总结。</p>
<a id="more"></a>
<hr>
<blockquote>
<p>参考链接：</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）机器人工程师学习计划]]></title>
      <url>http://noparkinghere.top/2016/09/28/2016/2016-09-28-%EF%BC%88%E8%BD%AC%EF%BC%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p><em>本文是转载的一篇知乎专栏上的文章，写的相当好。可惜当年上学的时候无人指点，浪费了太多的光影。</em></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">作者：YY硕</div><div class="line">链接：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">22266788</span></div><div class="line">来源：知乎</div><div class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></blockquote>
<p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p>
<p>两年前，我在知乎回答如何定义「机器人」？ - YY硕的回答中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？ - YY硕的回答我说到传感器是和物理世界交互的基础。后来，我又在知乎回答有哪些与控制、机器人等相关的 quotes？ - YY硕的回答中提到莫拉维克悖论（Moravec’s paradox），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p>
<p>把之前的回答再翻出来是为了支持以下观点：机器人学的核心问题是做好和物理世界的交互。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p>
<p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的课程分类方式（<a href="http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：" target="_blank" rel="external">http://www.ri.cmu.edu/education/COSAug2016.pdf），机器人学有四个核心领域：</a></p>
<p>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。<br>认知。人工智能、知识表达、规划、任务调度、机器学习等。<br>行为。运动学、动力学、控制、manipulation和locomotion等。<br>数学基础。最优估计、微分几何、计算几何、运筹学等。<br>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p>
<p>一些可能有争议性的观点：</p>
<ol>
<li><p>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</p>
</li>
<li><p>机器人学是屠龙之术。这话是Ninebot创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</p>
</li>
<li><p>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</p>
</li>
</ol>
<p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p>
<p>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间6-8个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p>
<p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p>
<p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p>
<a id="more"></a>
<hr>
<blockquote>
<h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2></blockquote>
<p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的VPN，先确保自己能上Google，不要心疼VPN的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail账号，再注册stackoverflow账号，再注册github的账号，再注册CSDN账号，注册完登录上去逛逛，暂时先不要问为什么。</p>
<p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p>
<p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p>
<p>网上有很多对于如何学好线性代数的讨论，比如知乎问题如何理解线性代数？ - 数学学习。Matrix67大神的文章随记：我们需要怎样的数学教育？也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做《Linear Algebra Done Wrong》（<a href="https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done" target="_blank" rel="external">https://www.math.brown.edu/~treil/papers/LADW/book.pdf），我比较喜欢的是Done</a> Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是麻省理工公开课：线性代数。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p>
<p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p>
<p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是麻省理工学院公开课：计算机科学及编程导论，比较好的Python开发学习环境是Anacoda (<a href="http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。" target="_blank" rel="external">http://www.continuum.io/downloads)。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</a></p>
<p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p>
<p>学习C我个人入门用的是清华大学出版的《C++语言程序设计》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。" target="_blank" rel="external">http://songjinshan.com/akabook/zh/index.html，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</a></p>
<p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（The leading OS for PC, tablet, phone and cloud）。原因是机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p>
<p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（Makefile详解（超级好）_mingw吧）这篇文章看。</p>
<p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS<code>（ROS.org | Powering the world&#39;s robots）</code>里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="http://www.w3schools.com/，把网站左侧的“Learn" target="_blank" rel="external">http://www.w3schools.com/，把网站左侧的“Learn</a> HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上three.js / examples跪着看看热闹。</p>
<p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[转]MIT牛人解说数学体系，另一个是前Goolge研究员吴军博士写的《数学之美》（数学之美 (豆瓣)）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p>
<hr>
<blockquote>
<h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h2></blockquote>
<p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p>
<p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？ - YY硕的回答里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p>
<p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p>
<p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p>
<p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p>
<p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p>
<p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p>
<p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买Arduino STEM educational Robot kits Building Platform的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p>
<p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加RoboMasters。</p>
<p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p>
<p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p>
<p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如6条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p>
<p>另外你其他方面的能力也不能落下。大二结束的时候，你的Linux应该用的很熟练了，除了makefile，你也用起了cmake。你也应该开始理解Github存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了Github上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p>
<p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用Java或C++教授。在面向对象的程序课里面，一定要积累3000行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p>
<p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（Mathematica 到底有多厉害？ - Wolfram Mathematica），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control" target="_blank" rel="external">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（Control</a> of an Inverted Pendulum on a Cart）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p>
<p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p>
<hr>
<blockquote>
<h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h2></blockquote>
<p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p>
<p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p>
<p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（OpenCV | OpenCV）了。</p>
<p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 @Liu Top的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p>
<p>第一步：自己调一个小四轴飞起来<br>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 首页-第七实验室 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p>
<p>第二步：看硬件图、读代码<br>chiplab7的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7淘宝掌柜的又很认真负责，我学用的时候，发现代码有bug和看不懂的地方，都可以直接找掌柜问。</p>
<p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环PID控制，基本都是基础的基础了。</p>
<p>第三步：小修小改加深理解<br>chiplab7的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个20块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p>
<p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解PID控制的方式，而且chiplab7的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p>
<p>第四步：理解核心的数学和控制知识<br>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。<br>姿态解算和控制解算涉及的知识有：</p>
<ol>
<li>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。<br>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</li>
<li>自动控制原理。讲PID的书和文章就多了去了，没有太多复杂的书。</li>
<li>线性估计基本原理。其实就是互补滤波：Reading a IMU Without Kalman: The Complementary Filter 。拿这个关键词百度各种搜就会了。<br>第五步：重头开始造轮子<br>知乎著名网友vczh曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读STM32的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做PCB layout、制板自己焊元件，全套花不了1000块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</li>
</ol>
<p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters机器人的变形。</p>
<p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p>
<p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p>
<p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32上，有freeRTOS，uCOS，Vxworks这么几种实时操作系统；Linux是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上Google和CSDN去查大神们的介绍。</p>
<p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式Linux平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式Linux系统在里面，一定要尽早顶起来路由器，代码定时提交SVN或者git。</p>
<p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆RoboMasters比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p>
<p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p>
<p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p>
<p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p>
<p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。" target="_blank" rel="external">http://www.topologywithouttears.net/），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</a></p>
<p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明”det(AB) = det(A)det(B)”，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p>
<hr>
<blockquote>
<h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h2></blockquote>
<p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p>
<p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p>
<ol>
<li><p>概率机器人学，<a href="https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623" target="_blank" rel="external">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></p>
</li>
<li><p>凸优化，<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf" target="_blank" rel="external">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</a></p>
</li>
<li><p>线性系统理论，<a href="https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579" target="_blank" rel="external">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></p>
</li>
<li><p>Multiple View Geometry in Computer Vision，Multiple View Geometry in Computer Vision</p>
</li>
<li><p>线性估计，<a href="https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642" target="_blank" rel="external">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></p>
</li>
<li><p>《机器学习》，周志华老师的书。</p>
</li>
<li><p>An Invitation to 3-D Vision，<a href="https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf" target="_blank" rel="external">https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf</a></p>
</li>
<li><p>Modern Control Systems，<a href="https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580" target="_blank" rel="external">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></p>
</li>
<li><p>Rigid Body Dynamics，<a href="http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。" target="_blank" rel="external">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</a></p>
</li>
<li><p>Feedback Systems: An Introduction for Scientists and Engineers，FBSwiki</p>
</li>
</ol>
<p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p>
<p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p>
<p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p>
<p>ROS的可视化工具Rviz里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p>
<p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p>
<p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐Draw Freely | Inkscape，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p>
<p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己Github链接（如果你按我说的，大学第一天就申请Github账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p>
<p>关于毕业设计的选题，我推荐这么几个：</p>
<ol>
<li><p>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</p>
</li>
<li><p>手写四旋翼飞行器基于GPS的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU原理、轨迹生成和优化等。</p>
</li>
<li><p>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID控制、IMU原理等。</p>
</li>
<li><p>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</p>
</li>
<li><p>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</p>
</li>
</ol>
<p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D打印结构，大四要多给自己留时间去看书和写代码。</p>
<p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p>
<hr>
<blockquote>
<h2 id="研究生一年级"><a href="#研究生一年级" class="headerlink" title="研究生一年级"></a>研究生一年级</h2></blockquote>
<p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。</p>
<p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p>
<p>如果做控制系统的研究，3、8、9、10一定要精读。</p>
<p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p>
<p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书Stochastic models estimation and control（<a href="https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。" target="_blank" rel="external">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）。</a></p>
<p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（Parallel Tracking and Mapping for Small AR Workspaces (PTAM)），ROS的标配VO（viso2_ros - ROS Wiki），SVO（GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry），LSD-SLAM（<a href="http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub" target="_blank" rel="external">http://vision.in.tum.de/research/vslam/lsdslam）ORB-SLAM（GitHub</a> - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：机器人 - 标签。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。" target="_blank" rel="external">https://github.com/hcdth011/ROS-Hydro-SLAM，就在ROS上实现了几种定位算法的对比。</a></p>
<p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p>
<p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答RoboMasters2015夏令营是怎样的？ - YY硕的回答里吹过一波M100，前面说过的今年夏令营的知乎回答参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新里也有人帮我吹了一波。</p>
<p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p>
<p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。上面提到的《Convex Optimization》<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient" target="_blank" rel="external">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient</a> descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p>
<p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书Stochastic models estimation and control（<a href="https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。" target="_blank" rel="external">https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf）也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</a></p>
<p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包MoveIt! Motion Planning Framework，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（Denavit），这个东西我并不太会。我只会向同学们推荐我导师的著作《A mathematical introduction to robotic manipulation》（<a href="http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。" target="_blank" rel="external">http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf）。</a></p>
<p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p>
<p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章An elementary introduction to groups and representations的前50页（<a href="http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。" target="_blank" rel="external">http://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf）。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</a></p>
<p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p>
<hr>
<blockquote>
<h2 id="研究生二年级"><a href="#研究生二年级" class="headerlink" title="研究生二年级"></a>研究生二年级</h2></blockquote>
<p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p>
<p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p>
<p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p>
<p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p>
<p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie" target="_blank" rel="external">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie</a> Shen的工作。</p>
<p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（New ‘deep learning’ technique enables robot mastery of skills via trial and error），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神@戴泓楷@周佳骥。</p>
<p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成PPT讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p>
<p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p>
<p>结束语</p>
<p>我从2008年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python还是很小众的语言，Ubuntu 8.04还很不稳定，Chrome还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了ROS的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于手机的一些个人看法]]></title>
      <url>http://noparkinghere.top/2016/09/28/2016-09-28-%E5%85%B3%E4%BA%8E%E6%89%8B%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>个人一直很喜欢电子产品，且关于电子科技类新闻较多，近几年来可以说每日必看，曾经也经常混迹于各大论坛贴吧微博等。本文当然仅仅代表本人（一个非专业人事）对各个手机厂家品牌的一些看法，文章可能不会一次性写完，会随着我对手机了解成都的不断加深而更新本文。</p>
<a id="more"></a>
<p>To be continued…</p>
<hr>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git的配置及相关插件]]></title>
      <url>http://noparkinghere.top/2016/09/28/2016-09-28-git%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>一个好的工具，需要不断的打磨和熟悉使用技巧才可以把它用的炉火纯青，git同样如此，本文主要是推荐一些git常用的配置以及配套的一些工具。</p>
<h3 id="git的相关配置："><a href="#git的相关配置：" class="headerlink" title="git的相关配置："></a>git的相关配置：</h3><h4 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h4><a id="more"></a>
<h3 id="推荐的git插件："><a href="#推荐的git插件：" class="headerlink" title="推荐的git插件："></a>推荐的git插件：</h3><h4 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h4><p>首先推荐<a href="http://jonas.nitro.dk/tig/" target="_blank" rel="external">tig</a>（名字刚好和git相反），是一个专门针对git的小软件，官方这么介绍<em>text-mode interface for Git</em>。</p>
<p>推荐可以访问<a href="https://github.com/jonas/tig" target="_blank" rel="external">tig的github页面</a>,里面有相关的下载安装说明。</p>
<ul>
<li>软件能够恨清晰的看到你的版本目录结构</li>
</ul>
<h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><h4 id="小乌龟插件"><a href="#小乌龟插件" class="headerlink" title="小乌龟插件"></a>小乌龟插件</h4><h4 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h4>]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过git管理一个工程]]></title>
      <url>http://noparkinghere.top/2016/09/28/2016/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>GIT虽然能够实现各种版本控制，且功能强大，可以做到随时切换版本，回退等各种功能，但过多的分支，无效的分支，杂乱的提交，无意义的命名等等问题，往往会让像我这样的初学者，异常头痛，网络上关于git的往往都是指导你各个命令如何去用，部分命令的使用场景等，但却缺少一个完整工程项目的管理步骤。部分大神的确总结出了自己的使用习惯，但却不是作为教程来陈述的，下面我会将自己的一些习惯进行总结，后续可能遇到更好的也还会不断的更改。</p>
<p>下面是一张团队协作示意图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/0.png" alt=""></p>
<p>通过这张图，我们可以初步了解git的工作流程，接下来将以这张图为基础，进行详细分析论述。</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>个人的GIT使用习惯，注意：不在master上面轻易进行提交，一般所有的工作步骤都放在develop分支上面进行，不做无意义的提交，所有提交最起码是能够通过编译的版本，有一定程度上的修改优化，且每次提交必须付上详细的commit说明。基于develop，如果平行进行多种不同类型版本的开发，则所有都建立相应的新分支dev_name，而基于dev_name，每个开发人员再次建立各自的分支，只有在完成相关开发后将各自分支合并到dev_name中。通过测试多个dev_name，选择最终确定的方案，将develop分支合并到某条dev_name上，继续开发，后续如果在遇到类似问题，继续重复上述步骤。默认的master分支只用来快速合并develop分支来确定发行版，对所有发行版都加入tag(release_name)。简单来说就是：GIT不断创建分支，master用来合并develop分支作为发行版发布；develop分支用来合并dev_name分支作为开发的主要分支；dev_name合并所有开发人员的各个提交的分支，在没有dev_name的情况下（即只有一个develop分支），develop分支用来合并所有开发人员的各个提交的分支。</p>
<p><strong>git控制版本的过程就是分支不断提交合并的过程。</strong></p>
<a id="more"></a>
<h3 id="版本控制步骤："><a href="#版本控制步骤：" class="headerlink" title="版本控制步骤："></a>版本控制步骤：</h3><ul>
<li>对项目初始化版本库（注意不能是裸库，裸库只能远程下载查看，无法本地查看，类似的github和git服务就是这种裸库）</li>
<li>编辑好相应的.gitignore文件，该文件用来忽略一些文件，不让提交，一般可以是非必要的工程文件，编译生成的文件等。（.git目录下也存在类似.gitignore的忽略文件，但该文件不能被提交和push，因此强烈建议使用.gitignore）</li>
<li>进行第一次空工程的提交，主要将.gitignore提交给master。</li>
<li>建立分支develop，将工作分支切换到develop上。</li>
<li>进行相应的程序编辑和编译，完成后，提交版本库。（因为上面已经checkout到了develop，所以默认的提交就是到develop，不进行分支切换的话，以后默认也都在这个分支上面进行。）</li>
<li>假如这时候需要建立多个版本进行分别开发，这时候需要建立多个dev_name分支（注意这边是建议对所有版本都建立新的分支，作为develop的分支进行开发测试，而develop只用于最后对他们做合并。），需要开发哪个版本就切换到哪条dev_name分支上面进行开发提交。</li>
<li>假设多个版本开发测试完毕，用户需要某个功能的测试版本，则给该分支的某个版本再建立新分支test_release，然后打上tag标记，可以简单发布。</li>
<li>然而项目仍然需要推进，最终你需要在所有测试版本中选择出最优的一个合并到develop分支上，做接下来的开发。</li>
<li>在develop分支上进一步进行开发，假设现在不再仅仅是你一个人接手这个项目，而是多个人的团队，则需要基于develop建立多个分支，让每个单独负责其中的一个分支。每个人所要进行的工作都各自在自己的分支上面进行。假如这时团队成员都各自任务完成了，所有人都提交版本，这时则由组长专门将所有分支再次逐个合并到develop分支上，当然这部分可能会有冲突，需要手动合并。</li>
<li>假如再次需要建立多个版本进行分别开发测试，这时同上述步骤一只，再次建立多个dev_name分支，然后基于每个dev_name，为每个组员生成多个dev_name的子分支，每个组员各负责一条子分支。组员完成工作后，各个分支的负责人再次将把所有分支合并到各自的dev_name上，当所有版本测试完毕后，组长再次将所有dev_name合并<br>develop上。</li>
<li>如此，开发过程中反复进行上述建立分支合并分支的操作。最终需要发布正式版本的时候，组长将develop的内容快速合并到master分支上，然后为这个节点打上tag（如：v1.0）。注意：master分支只用来快速合并和发布版本。</li>
</ul>
<p>上述步骤详细的导图：<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-28-%E9%80%9A%E8%BF%87git%E7%AE%A1%E7%90%86%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B/master.png" alt=""></p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href="http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_" target="_blank" rel="external">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows和虚拟机中的ubuntu实现文件共享]]></title>
      <url>http://noparkinghere.top/2016/09/26/2016/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>国内很多用户习惯于使用 windows 系类操作系统，然而其中部分人员需要使用 ubuntu 进行一些开发测试，但他们并不想完全脱离 windows 系统，这时候虚拟机满足了他们的需求，虚拟机以安装配置简单，镜像还原起来方便安全，而被广大学习爱好者所喜爱。但有些时候，需要将真实机中的一些文档或者数据传输到虚拟机中，而如何实现虚拟机同真实机的共享往往是一些初学者头痛的事情。下面我列举出几种方法，可以满足解决这些问题。</p>
<p><em>以下的大多数方法，同样不仅适用于虚拟机和真实机之间交换文件，同样适用于同一个交换机/路由器下的不同主机进行通讯。</em></p>
<h3 id="通过网盘进行传输"><a href="#通过网盘进行传输" class="headerlink" title="通过网盘进行传输"></a>通过网盘进行传输</h3><p>首先可以参照我之前写的<em>桥接、nat、host-only 上网方式的区别</em>里面介绍了如何配置虚拟机上网，一般虚拟机上方较为方便，如：vmware 或者 virtualbox 之类的都可以一键安装系统，即便手动安装，通过虚拟机拓展工具也都可以补全网卡显示上网的。如果对你所使用的linux发行版不是太熟悉，且极少传输文件的话，可以使用这种方法。推荐使用百度云之类的网盘，先将本地数据文件上传，然后再通过 linux 中的浏览器将数据文件下载下来。这种方式的好处是无需学习，没有门槛，不需要了解任何 linux 的知识，只需要当做一个桌面系统使用即可，坏处显而易见：1.依赖外网，2.机密文件不方便上传，3.必须上传下载，大型文件速度慢。</p>
<a id="more"></a>
<h3 id="进行以下几种方法前建议先关闭-linux-和-windows-的防火墙"><a href="#进行以下几种方法前建议先关闭-linux-和-windows-的防火墙" class="headerlink" title="进行以下几种方法前建议先关闭 linux 和 windows 的防火墙"></a><strong>进行以下几种方法前建议先关闭 linux 和 windows 的防火墙</strong></h3><h3 id="通过虚拟机扩展直接拖动"><a href="#通过虚拟机扩展直接拖动" class="headerlink" title="通过虚拟机扩展直接拖动"></a>通过虚拟机扩展直接拖动</h3><p>一般虚拟机中的 linux 安装扩展插件就可以直接将 windows 下的文件托进linux去了，或者将 linux 的文件拖到 windows 下，但前提要求是：<strong>需要虚拟机和操作系统的内核版本兼容，各方面切合度高，能够完美支持的情况下，最好使用虚拟机要和两个操作系统都是同一时期发型的，推荐是使用新版 windows，最新版虚拟机还有最新发行版的 linux 系统。</strong></p>
<h3 id="通过scp命令"><a href="#通过scp命令" class="headerlink" title="通过scp命令"></a>通过scp命令</h3><p>Linux 与 Linux 之间传送文件，使用 scp 命令，这是一种基于 ssh 的方式，因此<strong>两个系统都必须要支持ssh协议</strong>，安装方式：</p>
<ul>
<li>ubuntu：<code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code>重启ssh服务，其他发行版该命令未必适用。查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的sshd和ssh-agent如果未打开则运行指令名字。</li>
<li>windows系统本身不支持ssh协议，所以，要想上面的命令成功执行，必须在windows客户端安装ssh for windows的客户端软件，比如WinSCP（开源），winsshd，使windows系统支持ssh协议才行。</li>
</ul>
<p>从linux系统复制文件到windows系统：<br><code>scp /tmp/a.txt administrator@192.168.3.181:/d:/</code></p>
<p>在linux环境下，将windows下的文件复制到linux系统中：<br><code>scp  administrator@192.168.3.181:/d:/test/config.ips  /tmp</code></p>
<p><em>。scp的方法于只安装了 CLI 的 linux 版本使用，所有操作无需图形界面，且能够在 linux 下完成。另外该方法也并非任何地方都能够完成，和虚拟机扩展类似，对系统环境有一定要求，尤其是一定要找到可用的 windows 下的 ssh 协议，往往是 linux 的 ssh 完美运行，但无法登陆 windows。</em></p>
<h3 id="通过-WinSCP-软件"><a href="#通过-WinSCP-软件" class="headerlink" title="通过 WinSCP 软件"></a>通过 WinSCP 软件</h3><p>该软件主要就是实现同一网段内的 windows 和 linux 的数据互传，本质上应该和scp命令原理是相同的，好处是图形化界面操作简单，登陆后无需再输入指令。WinSCP 是一个支持 SSH（Secure SHell）的 SCP（Secure CoPy）文件传输软件。只要文件主机支持 SSH 协定，你就可以安心的下载、上传文件。他的操作界面是参考NC（Norton Commander）的双视窗排列方式，使用起来不会有太大的困难。在 WinSCP 中，一般的文件操作都没有问题，如：复制、移动、更名文件或文件夹等。</p>
<p>输入主机名，用户名，密码，点击保存。通过下图中的界面，实现登陆：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.jpg" alt=""></p>
<p><em>第一登陆的时候，会告诉你服务器的主秘钥不再缓存中，确认修改后，即可远程登陆，另外如果使用root用户的话，新安装的ubuntu系统需要设置 root 密码，以及修改ssh的配置文件：<code>sudo vi /etc/ssh/sshd-config</code>，将 PermitRootLogin 修改为 yes。重启ssh服务：<code>sudo /etc/init.d/ssh restart</code></em></p>
<p>文件的上传与下载跟 Windows 的资源管理器差不多了，如果要编辑目录或文件，只要右键就会出相应的可选的项目。下图为登陆后的资源管理界面：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-26-windows7%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84ubuntu%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg" alt=""></p>
<h3 id="通过虚拟机共享文件夹的方式"><a href="#通过虚拟机共享文件夹的方式" class="headerlink" title="通过虚拟机共享文件夹的方式"></a>通过虚拟机共享文件夹的方式</h3><h4 id="安装-VMware-tools-或者-virtualboxaddition-等工具"><a href="#安装-VMware-tools-或者-virtualboxaddition-等工具" class="headerlink" title="安装 VMware tools 或者 virtualboxaddition 等工具"></a>安装 VMware tools 或者 virtualboxaddition 等工具</h4><ul>
<li>在VMware 虚拟机界面，点 VM-&gt;Install VMware Tools。之后，点击 Ubuntu 窗口中主文件 按钮然后再左边会看见设备里有 VMware tools 文件夹，双击之，并且解压其中的压缩文件，把它拷贝到主文件夹</li>
<li>打开 Terminal 终端，进入解压的文件夹中，输入以下命令：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo tar zxf VMwareTools-xxx<span class="selector-class">.tar</span><span class="selector-class">.gz</span> (注：xxx为版本号)</div><div class="line">cd /vmware-tools-distrib</div><div class="line">sudo ./vmware-install<span class="selector-class">.pl</span></div><div class="line">安装过程中一直按enter即可，或者输入【】提示yes和no，直到安装完毕。</div></pre></td></tr></table></figure>
<ul>
<li>查看结果：lsmod | grep vmblock</li>
</ul>
<h4 id="设置共享文件夹的目录"><a href="#设置共享文件夹的目录" class="headerlink" title="设置共享文件夹的目录"></a>设置共享文件夹的目录</h4><ul>
<li>将 Ubuntu 关机（power off），否则不能添加共享文件夹</li>
<li>在 VMware 虚拟机窗口，选择VM-&gt;Settings-&gt;Options-&gt;Shared Folders</li>
<li>点右边的 Add，点Next-&gt;选择 Win7 共享目录的路径，然后点 Next-&gt; 选中 Enable this share-&gt;Finish</li>
<li>在 VM-&gt;Settings-&gt;Options-&gt;Shared Folders 窗口的右边，Folder sharing 栏里选择 Always enabled</li>
<li>点 OK 确定退出</li>
</ul>
<h4 id="在-Ubuntu-虚拟机下安装插件"><a href="#在-Ubuntu-虚拟机下安装插件" class="headerlink" title="在 Ubuntu 虚拟机下安装插件"></a>在 Ubuntu 虚拟机下安装插件</h4><ul>
<li>执行 sudo apt-get install open-vm-dkms (注：如果无法查到open-vm-dkms，则可能更名为：open-vm-tools-dkms)</li>
<li>执行 sudo mount -t vmhgfs .host:/ /mnt/hgfs </li>
<li>cd /mnt/hgfs</li>
</ul>
<p>注意：即便完成了这个方法的所有步骤也未必能够完成共享文件夹，同虚<em>拟机扩展直接拖动</em>类似，该方法对系统和虚拟机切合度要求较高，vmtools 和 ubuntu 内核存在版本不兼容的问题，mount 经常支持不够好。也就是说同样的方法，相同的步骤，有的人轻松就可以实现，有的需要不断的去修补 linux 的脚本头文件等，当然解决是一定可以解决，但往往较为麻烦，如果该方法不行，建议尝试其他方法。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><em>通过 scp 命令</em>和<em>通过虚拟机共享文件夹的方式</em>并不推荐，建议首先尝试安装虚拟机扩展工具，如果可以直接拖拽文件则问题已解决，无需参考文章中的方法，如果不行的话，推荐通过 WinSCP 软件来操作，适用的场景多且不容易出错，本人尝试过如 centos 6.5，ubuntu 16.04 等多个主流操作系统，均可以实现传输。</p>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://huangfuff.blog.51cto.com/2632203/1604500" target="_blank" rel="external">http://huangfuff.blog.51cto.com/2632203/1604500</a><br><a href="https://my.oschina.net/u/811744/blog/179229" target="_blank" rel="external">https://my.oschina.net/u/811744/blog/179229</a><br><a href="https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/" target="_blank" rel="external">https://www.centos.bz/2011/03/windows-linux-transfer-data-tool-winscp/</a><br><a href="http://blog.csdn.net/warringah1/article/details/8927437" target="_blank" rel="external">http://blog.csdn.net/warringah1/article/details/8927437</a><br><a href="http://fancyseeker.github.io/2013/12/31/ssh_connect/" target="_blank" rel="external">http://fancyseeker.github.io/2013/12/31/ssh_connect/</a><br><a href="http://blog.csdn.net/lulitianyu/article/details/50446015" target="_blank" rel="external">http://blog.csdn.net/lulitianyu/article/details/50446015</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[字符编码]]></title>
      <url>http://noparkinghere.top/2016/09/22/2016/2016-09-22-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>字符编码（英语：Character encoding）、字集码是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。计算机中的字符编码算是一个历史遗留性问题，因为各个国家种族对应着不同的问题，以及各个组织机构推出不同的标准，因此现在计算机中的字符编码格式繁多。</p>
<p>打开某网页，或者用记事本打开某文本文件时，我们可能会看到一堆的乱码如”бЇЯАзЪСЯ”、”�????????”，出现这种问题，往往是我们选用的字符编码不对。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。也就是说，我们在计算机中存储数据时，字母 ‘a’ 需要用什么二进制来表示，这便称为”编码”；反之，将存储在计算机中的二进制数解析显示出来，称为”解码”，如同密码学中的加密和解密。而如果在解码过程中我们使用了错误的规则，则会导致解码错误 ‘a’ 变成了 ‘0’。</p>
<p>字符集（Charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>字符编码（Character Encoding）：是一套法则，使用该法则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。通常人们用符号集合（一般情况下就是文字）来表达信息。而以计算机为基础的信息处理系统则是利用元件（硬件）不同状态的组合来存储和处理信息的。元件不同状态的组合能代表数字系统的数字，因此字符编码就是将符号转换为计算机可以接受的数字系统的数，称为数字代码。</p>
<h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>常见字符编码为：ASCII,GB2312,UTF-8,Unicode,Big5等，下面我们对其中一些详细阐述。</p>
<h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p>ASCII（1963年）和EBCDIC（1964年）这样的字符集逐渐成为标准。最早的时候计算机ASCII码只能表示256个符号（含控制符号），这个字符集表示英文字母足够。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，我们通常成为扩展 ASCII 码，其使用 8位（bits）表示一个字符，共256字符。</p>
<p>一般标准 ASCII 码是每个学计算机的人必须知道和了解的，对常用的一些字符所表示的二进制能够非常熟悉，例如：(0-9)-&gt;(0x30-0x39) (A-Z)-&gt;(0x41-0x5A) (a-z)-&gt;(0x61-7A) NULL-&gt;(0x00) 等。</p>
<p>虽然 ASCII 的使用范围很广，但表示汉字、日语、韩语就不太够用了，汉字常用字有3000多个。这些字符集的局限很快就变得明显，于是人们开发了许多方法来扩展它们，于是就有了其他一些新兴字符集的出现。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-22-字符编码/1.png" alt=""></p>
<h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>计算机发明之处及后面很长一段时间，只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。但对于亚洲众多国家来说并不适用，当计算机传入我国后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。</p>
<p>于是国内指定了国标 GB2312（中国国家标准简体中文字符集），全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312编码通行于中国大陆；新加坡等地也采用此编码。</p>
<p>中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-22-字符编码/2.png" alt=""></p>
<p>GB2312 定义的规则如下：一个小于 127 的字符的意义与原来相同（即：兼容 ASCII 码标准），但两个大于 127 的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从 0xA1 用到 0xF7，后面一个字节（低字节）从 0xA1 到 0xFE，这样我们就可以组合出大约 7000 多个简体汉字了，GB2312 是对 ASCII 的中文扩展。</p>
<p>在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在 127 号以下的那些就叫”半角”字符了，也就不难看出为何我们平时选用全角输入数字字母时，会发现样式变宽了，占用了多个位置，这也是因为采用全角后，每个字符占用了两个字节，一般我应该要避免使用这种情况输入。</p>
<p>GB2312 后来发现还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-22-字符编码/3.jpg" alt=""></p>
<h4 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h4><p>Big5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13,060个汉字。Big5虽普及于台湾、香港与澳门等繁体中文通行区，但长期以来并非当地的国家标准，而只是业界标准。Big5码是一套双字节字符集，使用了双八码存储方法，以两个字节来安放一个字。第一个字节称为”高位字节”，第二个字节称为”低位字节”。”高位字节”使用了0x81-0xFE，”低位字节”使用了0x40-0x7E，及0xA1-0xFE。这边不再对该编码做过多的介绍。</p>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p>
<p>Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</p>
<p>从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的一个字符（并不是一个字节，而是两个字节）。在unicode中，一个字符就是两个字节，一个汉字不再类似于 GB2312 中当作两个字符来处理了。</p>
<p>unicode同样有着自身的问题，一个是，如何才能区别 unicode 和 ascii 。计算机如何知道三个字节表示一个符号，而不是分别表示三个符号呢？二是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于过去计算机来说存储空间极为珍贵，而这样做无疑造成了极大的浪费，文本文件的大小会因此大出两三倍，这是难以接受的。</p>
<p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了。UTF-8 就是每次8个位传输数据，而UTF-16就是每次16个位传输。UTF-8 就是在互联网上使用最广的一种 unicode 的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>
<p><strong>可以这样理解：Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。</strong></p>
<h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</p>
<p><strong>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</strong></p>
<p>UTF-8 的编码规则很简单：</p>
<ul>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 unicode 码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</li>
<li>对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li>
</ul>
<p>下面是对比 Unicode 和 UTF-8 的对比：</p>
<table>
<thead>
<tr>
<th>Unicode 符号范围</th>
<th>UTF-8 编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>(十六进制)</td>
<td>（二进制）</td>
</tr>
<tr>
<td>0000 0000-0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080-0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800-0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000-0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，”严”的 UTF-8 编码是 “11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>
<h3 id="BOM头"><a href="#BOM头" class="headerlink" title="BOM头"></a>BOM头</h3><p>UTF-8 本来是兼容性最好的编码，但 Windows 偏要加 BOM 于是经常出问题。</p>
<p>在 utf-8 编码文件中 BOM 在文件头部，占用三个字节，用来标识该文件属于 utf-8 编码，现在已经有很多软件识别 BOM 头，但还是有些不能识别 BOM 头，比如 PHP 就不能识别 BOM 头，这也就是用记事本编辑 utf-8 编码的 PHP 文件后，就会报错的原因。</p>
<p>在windows环境下，用记事本打开任何一个文本文件，另存为utf-8格式后，这样文件就自动被加上了BOM头信息。含BOM头的文件，在文件开头处多出三个字节 0xefbbbf。</p>
<p>windows 下一般不建议使用记事本打开文本文件，就如上面所提到的原因，记事本会加入 BOM 头，与此同时，记事本在处理其他平台传过来的文本时还有其他问题，因此计算机工作者，编辑文本时，推荐使用 notepad++ 或者 editplus。这些软件都可以兼容多个平台的文本文件，同时编辑能力强，打开速度快，能够直接各种格式的编码。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">https://www.zhihu.com/question/20650946</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</a><br><a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</a><br><a href="http://baike.baidu.com/link?url=HknfN5Mei0ekD1hoPPs-U1osSOA1tDDFYkfPfNa05SNX36LbaAh4ctHt_2XhefTVW03ZCRLaBw1dYpY6iG3-ea" target="_blank" rel="external">http://baike.baidu.com/link?url=HknfN5Mei0ekD1hoPPs-U1osSOA1tDDFYkfPfNa05SNX36LbaAh4ctHt_2XhefTVW03ZCRLaBw1dYpY6iG3-ea</a><br><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">https://www.zhihu.com/question/23374078</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a><br><a href="http://www.cnblogs.com/lfire/archive/2012/11/20/2778939.html" target="_blank" rel="external">http://www.cnblogs.com/lfire/archive/2012/11/20/2778939.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows 7个人使用环境配置]]></title>
      <url>http://noparkinghere.top/2016/09/20/2016/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>windows 7作为个人使用最久的一个系统，无论是稳定性美观程度等等都相当优秀，虽然windows是商业软件，源代码不开放定制性差，但通过一些日常的配置，配合常用的软件还是能够将它打造成一个个性化很强用起来恨顺畅的系统。本人因为工作需要经常会用到windows系统，另外周围也有不少朋友都用的这个系统，所以这边着重总结个人的一些常用配置，以及推荐一些非专业类软件。通过本文的文章和截图，后续重装系统，也能够轻松对照配置修改回来。</p>
<p><strong>假设你已经安装完了系统，这一个纯净版（非ghost版本，一般我都是安装这个版本）的windows 7，桌面仅有一个垃圾桶，没有其他软件。</strong></p>
<h3 id="windows-配置"><a href="#windows-配置" class="headerlink" title="windows 配置"></a>windows 配置</h3><h4 id="配置任务栏"><a href="#配置任务栏" class="headerlink" title="配置任务栏"></a>配置任务栏</h4><p>个人习惯采用小图标，窄任务栏，这样的好处是屏幕可以显示更多的内容。见下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png" alt=""></p>
<h4 id="修改窗体颜色"><a href="#修改窗体颜色" class="headerlink" title="修改窗体颜色"></a>修改窗体颜色</h4><p>一是为了美观，修改aero的透明窗体颜色，可以让窗体和任务栏，另外改变窗体颜色外观可以起到护眼的作用。见下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png" alt=""></p>
<h4 id="修改显示器颜色"><a href="#修改显示器颜色" class="headerlink" title="修改显示器颜色"></a>修改显示器颜色</h4><p>如果是台式机显示器，则显示器上面的配置按键可以进行手动修改，无需参照下面方式，下列方式主要适用于笔记本软件调节的方式，见下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png" alt=""></p>
<p><em>通过调整这些参数可以过滤部分蓝光效果，让颜色显暖色更易于护眼，当然这样做的坏处就是整体颜色失真，观看电影视频时候观感下降，另外如果设计图片视频时会对你有较大的影响，这边也可以使用第三方软件更加智能的调节，软件部分会推荐介绍该软件。</em></p>
<h4 id="电池管理"><a href="#电池管理" class="headerlink" title="电池管理"></a>电池管理</h4><p>这边针对笔记本在会待机，合上盖子会休眠等进行修改。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png" alt=""></p>
<h4 id="修改输入法的切换按键"><a href="#修改输入法的切换按键" class="headerlink" title="修改输入法的切换按键"></a>修改输入法的切换按键</h4><p><em>实现该功能的目的主要是切换中英文输入法，在使用ctrl或者shift切换时，很明显这两个键的位置远不如caps按起来方便，且shift往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而caps作为大小写时用起来相当罕见。大写完全可以用shift代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。<strong>这边将右ctrl和caps进行功能对调。</strong></em></p>
<p>打开注册表，在运行（win+R）中输入regedit，注册表位置：[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的Key，名叫：Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入如下的值：</div><div class="line">　　00,00,00,00</div><div class="line">　　00,00,00,00</div><div class="line">　　03,00,00,00</div><div class="line">　　3A,00,1D,E0</div><div class="line">　　1D,E0,3A,00</div><div class="line">　　00,00,00,00</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png" alt=""></p>
<p><strong>详细内容可以参见我的另外一篇专门介绍按键互换的文章。</strong></p>
<a id="more"></a>
<h3 id="常用基础软件"><a href="#常用基础软件" class="headerlink" title="常用基础软件"></a>常用基础软件</h3><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p><em>windows 自带的记事本，记事本的问题较多，例如：WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP来说，BOM是个大麻烦。所以windows下如果适用记事本会给跨平台编码带来巨大的麻烦，一旦出现很难发现和解决。另外记事本的编辑能力弱，可读性差等特点，也让大伙儿一致的决定抛弃这个软件。下面推荐两款比较好的文本编辑软件，无论是查看普通文本编辑，还是要少量的修改代码，这个两个软件都是不错的选择。</em></p>
<ul>
<li>editplus</li>
</ul>
<p>本人一般都用这个来编辑普通文件，如.txt,.md等需要阅读的文件，一般不需要怎么配置即可轻松上手使用，功能很强大，但个人主要用作查阅写说明文档等，一般不会对它单独定制。总之一点，这个软件配合上面我设置的窗口调色，用起来就是阅读舒服，写起来顺畅。但<strong>该软件是商业软件，需要付费使用。</strong></p>
<ul>
<li>notepad++</li>
</ul>
<p>windows下最喜欢的一款编辑器，功能强大，可定制性强，运行速度快，占用资源小，免费开源软件，可以说众多优点集一身。一般我只会对它进行简单的配置即可，主要用来修改文件代码。当然你也可以只用它即可，无需使用上面的editplus，因为个人将颜色调整为暗黑色，不易于阅读文本文字，所以同时安装了这两个软件。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png" alt=""></p>
<h4 id="输入法-有详细文章"><a href="#输入法-有详细文章" class="headerlink" title="输入法(有详细文章)"></a>输入法(有详细文章)</h4><p>选择<strong>搜狗或者qq拼音精简版</strong>，这两个都是不错的选择，百度占用资源较大，且，另外一些配置设置不够人性化，使用起来较麻烦，需要注意的是，拼音中开启两个功能：</p>
<ul>
<li>按ctrl按键切换中英文输入，上述设置了<em>键盘映射</em>，需要开启这个功能才可以。</li>
<li>安装截图插件，qq简版的截图功能较差，无法自动命名，可以选择搜狗拼音。</li>
</ul>
<p><em>主要强调的是windows下输入法的配置，因为完全使用第三方输入中的中英文，所以不再需要自带的输入法了，具体参见如下图片：</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png" alt=""></p>
<h4 id="检索软件"><a href="#检索软件" class="headerlink" title="检索软件"></a>检索软件</h4><p>也是个强烈推荐的一款可以快速检索的软件，软件特点如下：</p>
<ul>
<li>占用资源较大，长期占用一定的内存，且会影响开机时间，但现在内存都很大，这点可以接收，开机根据个人情况，一般无所谓，如果是固态硬盘，那就更没有什么影响了。</li>
<li>类似于linux下的locate命令吧，将所有文件信息生成一个数据库，然后每次搜索时能够快速定位，但当日修改的文件，信息更新的未必及时。</li>
</ul>
<p>国内软件中可以选用<em>稻田搜搜</em>,该软件界面好看，该有的功能也都有，但不支持通配符搜索，另外占用资源貌似也比较大。这边主要推荐使用 everything 这个老牌搜索软件，软件虽然小，但可定制性相当强，个人配置如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e1.png" alt=""><br>上图可见布局，右侧预览效果相当强大。</p>
<p>下面是一些我个人的定制，仅供参考：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-09-20-windows-7%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e8.png" alt=""></p>
<h4 id="金山词霸"><a href="#金山词霸" class="headerlink" title="金山词霸"></a>金山词霸</h4><p>一款查单词较方便的软件，这边不推荐有道，是因为有道现在广告泛滥了，金山词霸还拥有离线版本，如果在公司不方便上网一样可以使用，之所以推荐客户端版本的字典，主要是他们都可以捕捉桌面词汇，不限于浏览器或者PDF文档等，我一般设置：</p>
<ul>
<li>双击alt将字典调出</li>
<li>选中单词双击ctrl调出解释</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/20650946" target="_blank" rel="external">https://www.zhihu.com/question/20650946</a><br><a href="http://www.huangbowei.com/archives/92.html" target="_blank" rel="external">http://www.huangbowei.com/archives/92.html</a><br><a href="http://baike.baidu.com/subview/126558/5073180.htm" target="_blank" rel="external">http://baike.baidu.com/subview/126558/5073180.htm</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 系统安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu搭建wordpress服务]]></title>
      <url>http://noparkinghere.top/2016/09/14/2016/2016-09-14-ubuntu%E6%90%AD%E5%BB%BAwordpress%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><em><a href="https://cn.wordpress.org/" target="_blank" rel="external">wordpress</a> 是目前比较流行的博客模板，精美的外观强可定制性收到了国内外很多bloger的亲睐，之前在虚拟机的ubuntu_server上面搭建过这个环境，个人所使用的blog是基于jekyll的静态页面，所以对wordpress不是特别了解，这边以腾讯云的ubuntu服务器为基础搭建自己的wordpress服务，当然现在很多云服务已经支持一键搭建wordpress的功能，但据说“访问速度和灵活性会受到很大影响”，这边有兴趣的朋友可以自己去尝试一下。</em></p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><ul>
<li>需要搭建一个服务器，首先需要选定自己使用哪些服务套件，这边我选用LAMP套装，即linux(ubuntu), apache2.0, mysql, php(wordpress)。</li>
</ul>
<a id="more"></a>
<h3 id="详细安装步骤"><a href="#详细安装步骤" class="headerlink" title="详细安装步骤"></a>详细安装步骤</h3><h4 id="1-检查电脑是否安装了这些服务。"><a href="#1-检查电脑是否安装了这些服务。" class="headerlink" title="1.检查电脑是否安装了这些服务。"></a>1.检查电脑是否安装了这些服务。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dpkg <span class="_">-l</span> | grep apache</div><div class="line">dpkg <span class="_">-l</span> | grep php</div><div class="line">dpkg <span class="_">-l</span> | grep mysql</div></pre></td></tr></table></figure>
<h4 id="2-根据提示信息，如果没有安装则补安装。"><a href="#2-根据提示信息，如果没有安装则补安装。" class="headerlink" title="2.根据提示信息，如果没有安装则补安装。"></a>2.根据提示信息，如果没有安装则补安装。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install apache2 mysql-server php5 libapache2-mod-php5</div><div class="line">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>
<h4 id="3-让apache、php支持mysql"><a href="#3-让apache、php支持mysql" class="headerlink" title="3.让apache、php支持mysql"></a>3.让apache、php支持mysql</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libapache2-mod-auth-mysql php5-mysql</div><div class="line">重启apache服务 `sudo /etc/init.d/apache2 restart`</div></pre></td></tr></table></figure>
<h4 id="4-安装phpMyAdmin"><a href="#4-安装phpMyAdmin" class="headerlink" title="4.安装phpMyAdmin"></a>4.安装phpMyAdmin</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install phpmyadmin</div><div class="line">此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹。</div><div class="line">进入/var/www文件夹，在该目录下执行如下操作:</div><div class="line">sudo ln <span class="_">-s</span> /usr/share/phpmyadmin</div></pre></td></tr></table></figure>
<h4 id="5-为Wordpress新建mysql数据库"><a href="#5-为Wordpress新建mysql数据库" class="headerlink" title="5.为Wordpress新建mysql数据库"></a>5.<a href="https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E7.AC.AC.E4.BA.8C.E6.AD.A5.EF.BC.9A.E5.88.9B.E5.BB.BAWordPress.E6.95.B0.E6.8D.AE.E5.BA.93.E5.92.8C.E4.B8.80.E4.B8.AA.E7.94.A8.E6.88.B7" target="_blank" rel="external">为Wordpress新建mysql数据库</a></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ mysql -u root -p	// 登陆管理数据库</div><div class="line">Enter password:</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 5340 to server version: 3.23.54</div><div class="line"> </div><div class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> help. Type <span class="string">'\c'</span> to clear the buffer.</div><div class="line"> </div><div class="line">mysql&gt; CREATE DATABASE blog;	// 创建数据库名称</div><div class="line">Query OK, 1 row affected (0.00 sec)</div><div class="line"> </div><div class="line">mysql&gt; GRANT ALL PRIVILEGES ON blog.* TO <span class="string">"demon"</span>@<span class="string">"hostname"</span> // 受理权限</div><div class="line">    -&gt; IDENTIFIED BY <span class="string">"password"</span>;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">  </div><div class="line">mysql&gt; FLUSH PRIVILEGES;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div><div class="line"></div><div class="line">mysql&gt; EXIT</div><div class="line">Bye</div><div class="line">$</div></pre></td></tr></table></figure>
<hr>
<p>to be continued…</p>
<blockquote>
<p>参考链接：<br><a href="https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php" target="_blank" rel="external">https://codex.wordpress.org/zh-cn:%E5%AE%89%E8%A3%85WordPress#.E6.AD.A5.E9.AA.A43:.E8.AE.BE.E7.BD.AEwp-config.php</a><br><a href="http://www.jianshu.com/p/7e6566b613a7" target="_blank" rel="external">http://www.jianshu.com/p/7e6566b613a7</a><br><a href="http://www.jianshu.com/p/26d9e752994e" target="_blank" rel="external">http://www.jianshu.com/p/26d9e752994e</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络监控工具wireshark]]></title>
      <url>http://noparkinghere.top/2016/09/12/2016-09-12-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7wireshark/</url>
      <content type="html"><![CDATA[<h3 id="wireshark简介"><a href="#wireshark简介" class="headerlink" title="wireshark简介"></a>wireshark简介</h3><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。在过去，网络封包分析软件是非常昂贵的，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一。</p>
<a id="more"></a>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="linux下的安装"><a href="#linux下的安装" class="headerlink" title="linux下的安装"></a>linux下的安装</h4><p>首先，安装只要一个命令行(由于之前装过了，所以没有在安装什么了)：sudo apt-get install wireshark 。已经将wireshark安装完毕，接下来我没就可以通过：终端输入wireshark 用来启动它的图形界面。<br>然而，dumpcap需要root权限才能使用的,以普通用户打开Wireshark，Wireshark当然没有权限使用dumpcap进行截取封包。虽然可以用:sudo wireshark来完成。但是，以sudo的方式用root打开Wireshark显然是不安全的，也不是很方便，因为得到的封包数据也属于root用户。于是，我们提供下面的方法来完成普通用户下的操作。</p>
<ul>
<li>添加wireshark用户组<code>sudo groupadd  wireshark</code>，一般软件安装完成后，可能已经自动帮你生成了这个组。</li>
<li>将dumpcap程序更改为所属组为wireshark用户组<code>sudo chgrp wireshark /usr/bin/dumpcap</code></li>
<li>让wireshark用户组有root权限使用dumpcap即更改dumpcap的科执行权限，赋予所属组执行权限 <code>sudo chmod 4755 /usr/bin/dumpcap</code></li>
<li>将需要使用的普通用户名加入wireshark用户组，我的用户是“demon”（需要根据具体用户名修改！在#前面可以找到哟），则需要使用命令：<code>sudo gpasswd -a demon wireshark</code></li>
</ul>
<p>通过以上步骤就可以以普通用户登陆打开Wireshark，也会有权限进行抓包了。</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><blockquote>
<p>参考链接：<br><a href="http://fangxin.blog.51cto.com/1125131/735178" target="_blank" rel="external">http://fangxin.blog.51cto.com/1125131/735178</a><br><a href="http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_5d527ff00100dwph.html</a><br><a href="https://openmaniak.com/cn/wireshark_filters.php" target="_blank" rel="external">https://openmaniak.com/cn/wireshark_filters.php</a><br><a href="http://www.jianshu.com/p/400d4430a74a" target="_blank" rel="external">http://www.jianshu.com/p/400d4430a74a</a><br><a href="https://wiki.wireshark.org/CaptureSetup/CapturePrivileges" target="_blank" rel="external">https://wiki.wireshark.org/CaptureSetup/CapturePrivileges</a><br><a href="https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup" target="_blank" rel="external">https://anonscm.debian.org/viewvc/collab-maint/ext-maint/wireshark/trunk/debian/README.Debian?view=markup</a><br><a href="http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html" target="_blank" rel="external">http://jingyan.baidu.com/article/c74d60009d992f0f6a595de6.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux基本命令汇总]]></title>
      <url>http://noparkinghere.top/2016/09/06/2016/2016-09-06-linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p><em>本文主要学习总结，使用 linux CLI 的基本命令，这边不以任何发行版为例，介绍的是绝大多数 linux 发行版上面都会含有的 CLI 软件，需要注意的是，这边是以完整安装为基础的，部分命令可能在最小安装上面无法使用。目前 安装 linux CLI 后可以使用的命令超过上千个，但最常用的命令一般只有 80 个左右，由于篇幅有限，本文会选取 80 个中的几十个最基本必须掌握的命令进行罗列和简介，不会展开详解，详细内容还是需要查看 manual 或者借助搜索引擎。</em></p>
<p>shell 命令的一般格式为：command [option] [arguments]。具体如下：</p>
<ul>
<li>command 表示命令，command 事实上是一个可执行的软件，实上 linux 中所谓的命令绝大多数是预装的软件，因为地址被写入了全局，因此可以直接通过软件名来调用该软件。</li>
<li>option 表示选项，命令行中，选项是包含一个或者多个字母的字符串，一般在选项前有一个“-”用于区分参数，如：-l，-s等，这些都是设计程序时就已经被写在软件中的，用于方便用户选择软件执行的模式，选项这个词是并不是平白无故的，因为只有设计软件时被采用的一些字符才可以被称为选项，因此使用某个命令时，我们重点需要查看有哪些选项可以使用，以及使用后会有什么样的效果。</li>
<li>arguments 为参数，很多命令都可以接受参数，参数就是选项后紧跟的一个或多个字符串，这些字符串制定了命令的操作对象，如文件或者目录等。如：ls -al  /etc ，这边 /etc 就是一个参数，而 -al 则是一个选项。</li>
</ul>
<p><strong>因为 linux 中的每个软件都是不同开发者提供的，因此表示一种功能模式的参数却往往不尽相同，如：有的递归是 -r 而有的是 -R 等等。因此你如果需要使用某个软件时，需要以 manual 为准，而不是想当然的认为某个选项一定表示某个功能。</strong></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件管理主要包含了，复制，移动，更改路径等等</p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>显示指定工作目录下的内容，常用参数：</p>
<ul>
<li>-a 可以显示全部内容包含隐藏文件。</li>
<li>-l 用于列出文件的详细信息。</li>
</ul>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>打印当前工作目录（print working directory），使用该命令后，你所在工作目录的绝对路径将会被打印出来。</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>改变当前工作目录（change directory），后面可以用绝对路径或者相对路径。</p>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建新目录，一般为 <code>mkdir + 目录名</code>。</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>将文件从一个位置移到另一个位置，可以用绝对路径或者相对路径，如：mv source /tmp/source 表示将当前目录下的 source 文件移到根目录下的 tmp 文件夹中。值得注意的是，mv 可以用来重命名，linux 中往往是通过 mv 来更改文件名称的。</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp 命令的格式类似于 mv 命令，但相比而言会比 mv 多不少选项/模式，常用参数如： -r 用于递归复制文件夹中的内容。</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除命令，用于删除文件等，一般常用 -rf 用于强制递归删除文件夹等。</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>用于改变文件的时间戳（timestamp），注意该命令是改变文件时间的，并不是用来创建文件的，之所以我们用它来创建文件仅是因为在改变文件时间戳时，如果该文件不存在 touch 会新建一个空白的文件，所以创建文件是 touch 的一个附加功能。所以我们就不难理解在 touch 一个已经存在的文件时，原文件不会被改动，改动的是该文件的时间。</p>
<h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>ln 用来生成链接文件，提到链接，相信用过电脑的朋友对 windows 下的快捷方式都会有影响，在 linux 中我们将 windows 中的快捷方式称为软连接。</p>
<p>linux 下有两种链接：</p>
<ul>
<li>硬链接：文件 A 是文件 B 的硬链接，则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode 节点上的链接数增加一，每删除一个对应的文件名，inode 节点上的链接数减一，直到为 0，inode 节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A 删除的只是 A 这个文件名，而 A 对应的数据块（文件）只有在 inode 节点链接数减少为 0 的时候才会被系统回收。我们这边提到的是  inode 节点，而并非路径，注意这点和软链接的区别。</li>
<li>软链接：等同于 windows 的快捷方式，A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到B的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。注意：软链接的 A 和 B 是对应的不同 inode 的，而 A 存储的仅是 B 的路径（并不是 inode 的信息），因此我们如果删除 B 文件后，A 会找不到链接方向，而如果我们再创建 B 后，A 又会有了新的目标，而事实上，再次创建的 B 和原来不是同一个 inode，已经和原来的 B 没有任何联系了。</li>
</ul>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>直接使用该命令可以查看文件类型的详细信息，linux 中是不强制要求有后缀名的，但通过 file 我们可以看出文件类型。</p>
<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查找某指令名称/内置程序的完整路径。如：which updatedb –&gt; /usr/bin/updatedb。</p>
<h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>只能用于查找二进制文件，源文件以及用户手册文件。因此 whereis 搜索出来的内容要比 which 多些。</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>普通的查找命令，用于查找某个名称文件，后面可以跟多个选项，格式为 <code>find+路径+选项+文件名</code>，如 <code>find . -name a.c</code> 即查找当前目录下名称为 a.c 的文件，find 最大的特点就是速度慢，其次 find 查找如果不适用通配符的话默认为精确查找，这点注意和 locate 有很大的不同，因此查找以 ad 开头的文件需要执行：<code>find . -name ad*</code>。</p>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>find 每次会在目录下进行真正的搜索，一般这样做时间长，效率低。Linux 上更加优异的搜索命令，locate 会直接定位某个文件的位置，原理是 locate 寻找文件是通过  /var/lib/mlocate/ 数据库中的内容查找，不用去硬盘中检索，但往往新的变动对 locate 查找的数据库更新不及时，这是我们需要用 updatedb 命令手动更新（updatedb 需要 root 权限），locate 是默认为 <code>*name*</code> 的查找方式。如果需要精确查找，需要使用如下格式：<code>locate -b &#39;\NAME&#39;</code></p>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>passwd 用户修改用户密码，后面如果加用户名的话，可以直接修改该用户的登入密码，前提是你必须知道该原始登入密码。</p>
<h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>su 主要用于改变用户登入身份，即快速切换登入用户，普通用户切换需要输入登录用户的密码，root 可以任意切换别的用户。</p>
<h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>显示登录的所有用户的信息，whoami 只显示自己的登录信息，而 uname 表示的是打印系统信息和用户名等无关。</p>
<h4 id="w"><a href="#w" class="headerlink" title="w"></a>w</h4><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Linux中set,env和export这三个命令的区别</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>命令显示当前shell的变量，包括当前用户的变量;</p>
<h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>命令显示当前用户的变量;</p>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>命令显示当前导出成用户变量的shell变量。</p>
<p>每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，</p>
<p>但shell自己的变量不同shell是不同的，比如BASH_ARGC， BASH等，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p>
<a id="more"></a>
<h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><h4 id="zip、unzip"><a href="#zip、unzip" class="headerlink" title="zip、unzip"></a>zip、unzip</h4><p>zip 打包压缩文件，zip 是一种比较古老的压缩方式，各个个系统平台上面都基本支持，但压缩率较低。</p>
<h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>当你使用 gzip 迚行压缩时，在预设的状态下原本的档案会被压缩成为 .gz 结尾的文件， 源文件就不再存在了。gzip 要比 zip 压缩效率高的多，但使用 windows 时，gz 文件未必可以被解压。</p>
<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>bzip2 则比 gzip 更加先进，可以提供更高的压缩比，用法基本和 gzip 一致。</p>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>虽然 gzip 和 bzip2 也能够针对目录来进行压缩， 不过，这两个命令对目录的压缩指的是<strong>将目录内的所有档案 “分别” 迚行压缩</strong>，而一般我们其实是需要一个进行过打包和压缩过的文件。tar 可以将多个目录或者文件打包成一个大的文件，同时还可以调用 gzip/bzip 对打包文件进行压缩。</p>
<h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>该命令的功能是 转换并且复制一个文件。</p>
<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><h3 id="终端和文件查看"><a href="#终端和文件查看" class="headerlink" title="终端和文件查看"></a>终端和文件查看</h3><h4 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h4><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><h3 id="系统信息查看："><a href="#系统信息查看：" class="headerlink" title="系统信息查看："></a>系统信息查看：</h3><p><em>注意：以下命令如果在ubuntu下可能都需要root权限才可以执行。</em></p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul>
<li>lscpu : 查看的是cpu的统计信息.</li>
<li>cat /proc/cpuinfo : 可以知道每个cpu信息，如每个CPU的型号，主频等。</li>
</ul>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li>cat /proc/meminfo : 查看内存详细使用</li>
<li>free -m : 概要查看内存情况</li>
<li>grep MemTotal /proc/meminfo ： 查看内存总量 </li>
<li>grep MemFree /proc/meminfo ：  查看空闲内存量 </li>
</ul>
<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><ul>
<li>lsblk ： 查看硬盘和分区分布</li>
<li>fdisk -l ： 如果要看硬盘和分区的详细信息</li>
<li>df -h ： 查看各分区使用情况 </li>
<li>cat /proc/loadavg ： 查看系统负载磁盘和分区 </li>
</ul>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><ul>
<li>lspci | grep -i ‘eth’ ： 查看网卡硬件信息</li>
<li>ifconfig -a ： 查看系统的所有网络接口</li>
<li>route -n : 查看路由表 </li>
</ul>
<h4 id="其他硬件信息"><a href="#其他硬件信息" class="headerlink" title="其他硬件信息"></a>其他硬件信息</h4><ul>
<li>lspci ： 查看pci信息，即主板所有硬件槽信息。</li>
<li>dmidecode -t bios ： 查看bios信息</li>
<li>dmidecode -q : dmidecode以一种可读的方式dump出机器的DMI(Desktop Management Interface)信息。这些信息包括了硬件以及BIOS，既可以得到当前的配置，也可以得到系统支持的最大配置，比如说支持的最大内存数等。</li>
<li>dmesg | grep IDE ： 查看启动时IDE设备检测状况网络 </li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>uname -a 或 cat /proc/version ： 查看内核/操作系统/CPU信息 </li>
<li>lsb_release -a 或 cat /etc/issue（此命令也适用于所有的Linux发行版)： 查看Linux系统版本</li>
<li>head -n 1 /etc/issue ： 查看操作系统版本 </li>
<li>lsmod ： 列出加载的内核模块 </li>
<li>hostname ： 查看计算机名 </li>
<li>free -m ： 查看内存使用量和交换区使用量 </li>
<li>uptime ： 查看系统运行时间、用户数、负载 </li>
<li>ps -ef ： 查看所有进程 </li>
<li>top ： 实时显示进程状态用户 </li>
<li>w ： 查看活动用户 </li>
<li>id &lt;用户名&gt; : 查看指定用户信息 </li>
<li>last : 查看用户登录日志 </li>
<li>cut -d: -f1 /etc/passwd : 查看系统所有用户 </li>
<li>cut -d: -f1 /etc/group : 查看系统所有组 </li>
<li>crontab -l : 查看当前用户的计划任务服务 </li>
<li>chkconfig –list : 列出所有系统服务 </li>
<li>chkconfig –list | grep on : 列出所有启动的系统服务程序 </li>
</ul>
<h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>显示或者修改系统时间和日期，只有超级用户可以用 date 设置时间，一般用户只可以显示时间。</p>
<h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><h4 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h4><h4 id="last"><a href="#last" class="headerlink" title="last"></a>last</h4><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><h3 id="分屏功能"><a href="#分屏功能" class="headerlink" title="分屏功能"></a>分屏功能</h3><p>xrandr 命令，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享，图形界面的分屏控制大都是调用 xrandr 这个软件。</p>
<h3 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h3><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><h3 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h3><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><h3 id="mount、unmount"><a href="#mount、unmount" class="headerlink" title="mount、unmount"></a>mount、unmount</h3><h3 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h3><h3 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h3><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://www.2cto.com/os/201306/223758.html" target="_blank" rel="external">http://www.2cto.com/os/201306/223758.html</a><br><a href="http://www.ha97.com/2987.html" target="_blank" rel="external">http://www.ha97.com/2987.html</a><br><a href="http://blog.csdn.net/lhf_tiger/article/details/7102753" target="_blank" rel="external">http://blog.csdn.net/lhf_tiger/article/details/7102753</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git问题总结FAQ]]></title>
      <url>http://noparkinghere.top/2016/08/28/2016/2016-08-28-git%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93FAQ/</url>
      <content type="html"><![CDATA[<p>git 的使用过程真心不容易，尤其对于我这样没有其他版本控制器使用经验，且比较容易丢三落四的的初学者。按照网上所给的步骤操作，一旦漏做了一些步骤，或者做错了一些步骤，所引起的问题也是致命的，虽然肯定有解决问题的办法，但往往会引起分支结构混乱，经常做了一次提交然后就回不去了，或者经常不知名的无法进行提交，无法进行回退，pull失败等等。</p>
<p><strong>可见要想真正让git成为你版本控制的工具，git的工作原理必定要相当清楚，版本控制的结构要特别清晰，一单出现问题立马就知道是哪一步做错了才行。</strong></p>
<h3 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h3><h4 id="git-checkout-–-filename"><a href="#git-checkout-–-filename" class="headerlink" title="git checkout – filename:"></a>git checkout – filename:</h4><p>在文件没有stage时可以通过这个命令将该文件撤销回来。一旦文件add后用该命令不再有效。这时需要使用 git reset HEAD – filename 意味着将文件unstage出库，还原到add之前，再使用git checkout – filename撤销文件。而如果你使用git checkout HEAD – filename 则直接会丢弃掉stage中的暂存内容，将文件还原。</p>
<a id="more"></a>
<h4 id="git-push-u-origin-master："><a href="#git-push-u-origin-master：" class="headerlink" title="git push -u origin master："></a>git push -u origin master：</h4><p>远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<em>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</em></p>
<h4 id="从github上面拉取库的方法："><a href="#从github上面拉取库的方法：" class="headerlink" title="从github上面拉取库的方法："></a>从github上面拉取库的方法：</h4><ul>
<li>方法1：使用git clone address：如果是其他人的库address必须是一个http地址，如果是自己的库，且本地配置好了ssh，则可以通过ssh协议拉取需要的文件。<strong>值得注意这种拉取是完整拉取，会建立一个库名的文件夹。</strong>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</li>
<li>方法2：本地已经存在git库的情况下，需要在本地库目录下使用git remote add origin address 将可以把一个已有的本地仓库与之关联。git push -u origin master把当前分支master推送到远程。我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后可以简化操作使用 git push origin master。</li>
</ul>
<p><em>推荐使用方法1，直接从远程库clone下来，需要工程时直接clone下来避免没必要的合并，每次使用前可以先pull一下远程库。</em></p>
<h4 id="github的协议："><a href="#github的协议：" class="headerlink" title="github的协议："></a>github的协议：</h4><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。默认的git://使用ssh，但也可以使用https等其他协议。clone他人或者自己的版本库的时候，都可以使用https或者ssh下载，但是配置好git的ssh的话，可以本地推送免密码，https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。</p>
<h4 id="git的分支和HEAD："><a href="#git的分支和HEAD：" class="headerlink" title="git的分支和HEAD："></a>git的分支和HEAD：</h4><p>贯穿git的整个结构的核心就是分支，每个分支都有一个名称，如主分支一般名称为master，master本身类似一个指针名，永远指向了该分支的最后一次提交的版本。而HEAD则是指向了这个指针。因此在创建分支branch test时，master和test指向同一个位置，这时候如果执行checkout test，则HEAD会从指向master变成指向test（因此git的切换高效事实是指针的操作高效），对这个test的分支相关操作会建立起新的分支结构，而master仍然停留在原处，这时如果checkout master对master进一步的操作提交，会发现版本中真正的形成了两条分支结构。</p>
<h4 id="git合并分支："><a href="#git合并分支：" class="headerlink" title="git合并分支："></a>git合并分支：</h4><p>git merge “branchname”：将两个分支进行合并</p>
<ul>
<li>Fast-forward：分支合并完成后出现Fast-forward，意味着快速合并，即合并分支时分支指针仅仅是直接更改了指向，而没有出现其他增删改查的文件。<em>这种情况一般是需要合并的分支仅仅是建立了一个节点，而没有将分支扩展出去，因此可以直接快速向前合并两个分支指针。</em><br>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</li>
<li>Automatic merge failed; fix conflicts and then commit the result：这种情况虽然合并失败了，但相关文件已经进行了一些变动修改，用户手动更改好，这些文件，然后add,commit 即可完成提交以及分支合并。</li>
</ul>
<h4 id="查看分支结构："><a href="#查看分支结构：" class="headerlink" title="查看分支结构："></a>查看分支结构：</h4><ul>
<li>git log –graph –pretty=oneline –abbrev-commit</li>
<li>使用插件tig，该插件在github上面有托管，可以下载源码安装编译，注意提示需要安装一些依赖库<em>托管，可以下载源码安装编译，注意提示需要安装一些依赖库。</em>。</li>
<li>如果使用了checkout的话，使用git log则看到内容有限，这时使用git log –all可以查看所有的提交结果。</li>
<li>值得注意的是使用了git reset之后，使用git log 就无法看到最近的一些提交了，因为reset属于版本回退，相当于整个时光倒流回去了，不会在看到未发生的内容，只能通过git reflog查看库里面的所有备份内容。</li>
</ul>
<h4 id="stash的用处："><a href="#stash的用处：" class="headerlink" title="stash的用处："></a>stash的用处：</h4><p>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<ul>
<li>git stash：在git add之后可以通过stash将文件修改暂存。</li>
<li>git stash list： 查看暂存的信息。<br>一些不需要的修改也可以存入stash中，相比而言stash不像commit那么严格，可以随便存入，随便删除。</li>
</ul>
<h4 id="远程库如何操作caozuo："><a href="#远程库如何操作caozuo：" class="headerlink" title="远程库如何操作caozuo："></a>远程库如何操作caozuo：</h4><p><em>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote，返回origin。可以看出远程库也是可以有多个的。</em></p>
<p><em>实际的远程建立库一般为–bare裸库是不存在实际工程文件的，相当于.git文件直接被展开了，实际使用的时候，需要clone下来才能够看到文件内容。</em></p>
<ul>
<li>git remote -v：显示更详细的信息,可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</li>
<li>push：就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<code>git push origin master</code>，可以看到origin为远程库的名称，而master为本地需要推送的分支。在Git中，分支完全可以在本地自己，到底要不要推送则完全由你自己决定。</li>
<li>clone：从某一个位置将目录完整克隆下来，注意clone后面可以类似：<code>git clone git@github.com:hard/learngit.git</code>，也可以使用<code>git clone ~/home/gitname</code>但注意gitname必须得是个git的版本库，也就是说在里面执行过<code>git init</code>。</li>
<li>推送冲突失败：你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，则会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git会提示我们：<em>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</em>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接:<code>git branch --set-upstream dev origin/dev</code>，然后再pull。<strong>这边尤其需要每次输完指令后，看提示，有的未必会报错，但也没有执行相关操作，出现git command的时候，往往是你指令执行已经异常了。</strong></li>
</ul>
<h4 id="同步已有本地库到远程："><a href="#同步已有本地库到远程：" class="headerlink" title="同步已有本地库到远程："></a>同步已有本地库到远程：</h4><p><em>大多数时候，本地存在已有的库，而远程并没有，这个时候不能通过git clone来复制，需要通过以下的一些步骤</em></p>
<ul>
<li>删除本地的.git残留文件，如果本地已经有了git操作，但不明具体内容，则首先执行<code>rm -rf .git</code>清除掉无关内容，git的设置相当科学，几乎所有的记录信息全在.git目录下。</li>
<li>初始化这个库，<code>git init</code>这是必备步骤，建立一个空的默认库。</li>
<li>随意添加几个文件，例如：<code>echo &quot;hello world&quot; &gt;&gt; test.txt</code>，如果是实验的话可以操作本步骤，如果已有功能则跳过此步骤。</li>
<li>常规git操作，加入stage并提交，<code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code>，必备步骤，该步骤是相当于建立提交，放入到master中。</li>
<li>查看下本地库的状态：git status，一般提示，没有可提交的内容，则代表上面步骤成功了。</li>
<li>一切正常的话，将远程库与本地库建立关系：<code>git remote add origin git@ubuntu_server:/home/git/myRep.git</code>。这边的test为远程库的名称，默认一般为origin，但如果你一个项目中同时有多个库，则建议你将origin修改为其他名称。</li>
<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>
<li>推送远程分支很简单:git push origin local_branch_name:remote_branch_name,一般可以省略local分支名，则会自动推送当前分支。</li>
</ul>
<h4 id="tag和branch的区别："><a href="#tag和branch的区别：" class="headerlink" title="tag和branch的区别："></a>tag和branch的区别：</h4><p>我们可以认为tag是一个静态标签，tag一定设定后，它的位置就永远不会再改变了，tag就是哪个commit对应的一系列数字英文字符的别名。如正常情况下我们需要checkout某个提交的时候需要git log查看版本名称，然后可以使用类似git checkout a228来切换到这个版本上去。但给这个版本起了名字edition1，则这时，我们可以通过git checkout edition1直接切换这个版本，而无需再查看log。</p>
<p><strong>但一般我们不随便给任何提交打上tag，大多数情况只给某一次或几次特殊重要的提交打tag，比如发行版v1.0，测试版beta1.2等等。</strong></p>
<p>而branch则是分支，最为常见的就是master分支，注意分支实际是一个指针，分支的指向永远指向这条分支结构的最末尾端（及最后的一次提交），所以分支是会不断变动的，而tag是静态的，两者区别很明显。</p>
<h4 id="MDK工程管理出错："><a href="#MDK工程管理出错：" class="headerlink" title="MDK工程管理出错："></a>MDK工程管理出错：</h4><p>本人在工作中会使用到MDK来做一些MCU的编程开发，而MDK虽然配置简单，调试功能强大，但编辑扩展等其他功能都奇差无比。在使用git进行管理的过程中发现，MDK会对多个工程类文件进行不断修改，而这些文件，如果不进行提交的话，又会出现工程缺失文件，工程错误等现象，另外经常出现无法回退或者无法提交等现象。</p>
<p>经过查看和分析，最终发现：MDK只要打开的情况下，就会不断的对工程文件进行修改，即便你仅仅是查看没有做任何事情，因此下面推荐几种方法和技巧：</p>
<ul>
<li>gitignore中只排除MDK的编译文件。</li>
<li>每次要提交和回退的时候将MDK关闭再执行。</li>
<li>如果忘记关闭或者出现突然没法回退或者提交的情况下，git查看状态，如果仅仅是工程文件出现改动，而源文件和头文件不变的话，则直接丢弃这些修改或者将修改存入stash中，再继续要做的操作。</li>
</ul>
<h4 id="checkout和reset的区别："><a href="#checkout和reset的区别：" class="headerlink" title="checkout和reset的区别："></a>checkout和reset的区别：</h4><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对该版本进行修改，git的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果checkout到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此checkout的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>)checkout的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对head进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制head的，如果head通过checkout发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便checkout指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向master这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改HEAD指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>
<p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过reflog查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用reset后面一般加上–hard彻底回退，否则有些修改了的未建立版本的文件仍然会保留，reset是一剂后悔药，只有在万不得已的情况下才会使用，但往往reset的滥用，也会让你的分支结构混乱。</p>
<p>综上所述，可以看出checkout是用来切换版本和分支的（分支其实是特殊的版本），而reset则是用来回退版本的。通常一般都是使用checkout来操作，只有发生重大错误，无法挽救时，才会使用reset。</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）谈谈写程序与学英语]]></title>
      <url>http://noparkinghere.top/2016/08/25/2016/2016-08-25-%EF%BC%88%E8%BD%AC%EF%BC%89%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD/</url>
      <content type="html"><![CDATA[<p><em>注: 本文的作者是宋劲杉，<a href="http://songjinshan.com/blog/index.php/%E8%B0%88%E8%B0%88%E5%86%99%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%AD%A6%E8%8B%B1%E8%AF%AD%EF%BC%8D%EF%BC%8D%E8%87%B4%E4%BA%9A%E5%B5%8C%E5%B0%B1%E4%B8%9A%E7%8F%AD%E5%AD%A6%E5%91%98/" target="_blank" rel="external">原文链接</a>。转载自<a href="http://happypeter.github.io/on-english-and-prog.html" target="_blank" rel="external">网址</a></em></p>
<p>俗话说，没有金刚钻，就别揽瓷器活儿。套用到IT业，英语不行，就别做程序员。网上关于程序员学英语的文章不少，但我想谈谈我自己的看法。首先详细讨论一下为什么程序员离了英语不行，然后针对程序员应该怎么学英语说说我的体会。</p>
<p><strong>英语是计算机的母语，是程序的母语，所以必然是程序员的母语。</strong>程序中的变量名、函数名起得好不好是决定代码质量和可维护性的最关键因素。高质量的代码应该是这样的：代码基本上是自解释的（self-explanatory），不需要太多注释，不管代码的规模有多大，具有相关知识背景的读过文档的人都可以立刻上手、立刻参与维护和开发。要想使代码能够自解释，给变量和函数起个好名字很关键，很显然，只能用英文起名字，一是用汉语拼音起名字可读性很差，二是英文单词通常比汉语更expressive（看吧，如果用汉语来说，就得说“表达能力更强”、“更有表现力”这么罗嗦），由于程序的复杂性，变量和函数往往表示一些很抽象的概念，起个既准确又简洁的名字并不容易，可是很多时候，用汉语需要很多字才能说清楚的一件事，用英文一个单词再加点词形变化就能说清楚了。例如APUE上讲sleep函数的实现，其中有个变量表示“本来应该睡到某个时刻，但是提前被信号唤醒了，唤醒时与本来应该睡到的时刻相差的时间”，如果为了简洁而不求准确，这个变量名至少也得叫“未睡到”，而书中只用了一个单词unslept，非常准确、简洁地表达了这个意思。为了写程序而学英语需要学到什么水平？我认为能起出这种变量名就够水平了。很多在IT外企工作的中国人，说话写文章经常夹杂着英文单词（比我严重多了因为我不在外企），非常可以理解，确实是为了表达得更准确简洁的需要，而不是纯为了play zhuangbility。总之，要写程序必须学好英语，否则连变量名都起不好，这虽然是一个非技术问题，但却是个根本问题，比任何技术问题都重要。当然，现在很多编程语言也支持用Unicode字符给变量和函数起名，但是你见过有人用汉字写程序吗？根本不实用。有人会辩驳说一页英文翻译成中文往往只占半页，中文不是更简洁吗？但是你算算打一页英文和打半页中文哪个敲键盘次数多。另外，要读别人的代码也必须学好英语，如果你不知道unslept是由 sleep变形而来的，就体会不到其中的精妙，只有大量阅读高质量的代码，才能写出高质量的代码，创作都是从模仿开始的。</p>
<a id="more"></a>
<p><strong>说说英语对于看书学习的重要性。</strong>中文技术书和英文技术书的水平根本不在一个量级上，这是有很多原因的，不能全归结于中文书的作者水平差。最重要的是，出中文书的低回报率决定了作者不可能花太多心血在上面，你去amazon看看一本书卖多少美刀，再去chinapub看看一本书卖几块钱。老外写一本书，可以做到全书没有一个拼写错误（当然英文的拼写检查工具更完善也是部分原因），中文能找出一本没有错别字的书吗？Knuth可以悬赏让全世界读者来找磋，中文书作者有哪个敢这么做？不是因为老外态度有多认真治学有多严谨，而是因为他们赚到了，就应该拿出高质量的作品来，不然会被读者骂的。</p>
<p><strong>英文技术书的翻译质量通常很差。</strong>也不能归结于译者的水平差，我也翻译过书，也努力想译好，但真的很难译好。IT业的新名词层出不穷，像“内核”、“网络” 这种常见术语还好，稍微专一点的术语都没有统一的译名。我们在教学中发现，很多学员看书时搞不清这本书的名词A和那本书的名词B是什么区别，来问老师，才发现原来A和B就是一回事儿。这是一个单词对应多个译名的情况，还有一个译名对应多个单词的情况，比如field、domain、realm都译成 “域”，block、 bulk都译成“块”，argument、parameter都译成“参数”，attribute、property都译成“属性”，虽然这些词的意思本来就差不多，但是在一篇文章里，作者可以换着用，不同的单词表示不同的概念，翻译完了一看，都成一个概念了。英文书背后都有index，看到一半忘了某个名词是怎么定义的就可以翻index，而译文通常没有index，名词都已经乱七八糟了，没法做index。还有更发指的是，老外喜欢造词，现有的单词上加一点变化和组合（例如有人喜欢说automagically），看着心领神会，想译出来就很费劲。老外即使在技术书中也经常用一些生动的表达方式和俏皮话，而中文的书面语言非常死板，生动的表达方式只存在于口语中，如果写在书上就很不像话，这也是很难翻译的一个重要原因。看中文译本，不仅质量差，而且跟不上时代，通常一本英文书出来，至少要等一到两年才能看到中文译本。两年啊！等你看到这本书的中文译本时，这个版本都快淘汰了。</p>
<p><strong>然后说说英语在开发工作中的重要性。</strong>看书学习通常只起一个引导入门的作用，在工作中更有用的是手册、文档。学完了C语言开始写程序了，谁还会去查 K&amp;R附录中的库函数？查man page才是最有效率的。然而手册比入门书更少有中文译版，因为手册是随时变的，会随着软件版本更新，而且需要看这些开发手册的人通常不会有英文障碍，有英文障碍的人即使看了翻译的手册也写不出好程序来，所以当然没必要翻译了。<em>不管什么技术，官方的手册和技术标准才是最原始的第一手资料，看别的书都是以讹传讹，由于自然语言不可避免是有歧义的，文档中表达得不准确的地方就会被文档的读者也就是技术书的作者误解，技术书中再有表达不准确的地方又被译者误解。</em>我们小时候都玩过传话的游戏，几个人站一排，通过悄悄话传一句话，传到最后变成什么了？所以，学网络协议，就得看RFC，学ARM，就得看ARM公司的 Architecture Reference Manual，要学习C语言就得看C99，有歧义不要紧，自己去揣测原作者的意思，总比道听途说的可靠。</p>
<p>我们的学员出去面试经常被问到的一个问题就是：在开发工作中遇到问题，书和文档上都没有答案，网上搜一下也没有答案，怎么办？要我说，能看懂源代码的就去源代码中找答案，这称为hacking，不管是内核、libc还是各种framework，你调用的东西有问题都能从它的代码中找到原因。如果没有能力 hacking，或者时间紧不想去hacking，最好的办法就是去官方邮件列表和IRC问。如果英文不行就没办法了，只能去一些中文论坛：“各位大虾帮忙，小弟有一个问题求救！跪求！！在线等！！！”在线等了好几天也无人问津，或者答非所问。岂不知逛这些论坛的没有大虾，都是菜鸟，大虾们都在IRC上聊得正欢呢。我在做Qt开发时曾经有一个问题，当时在教育网，上国外网不方便，去各大中文论坛问了好几天也没人给出满意的回答，后来花钱连了国外网，去 trolltech官方新闻组提问，只等了几分钟就得到了满意的解决办法。这次经历给我留下了深刻印象，从此以后再也没有去中文论坛。</p>
<p>那么，如果现在英文水平很差，又想做程序员，应该怎么学英语呢？我下面说的方法有两个前提，一是你的英文至少达到高中毕业水平，也就是语法基本都学完了，即使用得不熟练也知道有那么回事儿，二是你希望尽快在工作中用上英语，写程序够用就行，而不是有考T考G这样的更高要求。</p>
<p>学习英语有听说读写四个方面的要求，做程序员至少需要读和写非常流畅，如果在外企工作还需要听和说的能力。技术英语和考T考G是不一样的，一是听和说不像读和写那么重要，不必担心自己是“聋哑英语”，没关系，丝毫不影响你成为编程高手，二是要求的词汇量要小得多。考T考G都要拿一本单词书背，很少有人会觉得背单词很有意思，至少我是觉得很痛苦，幸运的是看技术书不需要多少词汇量。技术书的描述对象都是局限于一个很窄的领域的，就那么几个单词翻来覆去地用，而且技术书是为了让人看懂的（不像诗是为了让人看不懂的），比较复杂的词在书中都有定义或解释。有些作者喜欢卖弄词汇量，用一些很生僻的单词，也有些作者卖弄一些典故，由于文化背景不同很难理解，不过这些通常都可以无视，不会影响阅读，还是因为技术书是为了让人看懂的。对于学习者来说，阅读能力是最重要的，等你完成了学习，成为一个合格的开发者时，需要写代码注释，需要写文档，需要通过邮件交流，写作的能力才开始重要了。所以应该首先从阅读开始练习英语。</p>
<p>现在就拿起一本英文原版书开始看吧。和学游泳一样，阅读的能力只能通过阅读本身来练习。我的经验是，不必先系统学习了单词和语法再看书，可以在看书时用到什么就补什么。我建议初学者看电子版，因为现在的词典软件都可以鼠标取词，边看边查很方便，很多勤快人喜欢把查过的单词都抄下来，我觉得没有必要，反正查字典很方便，下次再看到了就再查，多查几次总会记住的，抄下来就打断了看书的思路，而且不见得抄下来就能记住。也许是因为我这人比较懒，我用的都是懒办法。很多人不喜欢看电子书，理由是盯着屏幕看书太累，那么盯着屏幕写程序累不累？这种人显然不适合做程序员。语法不熟练怎么办？大多数情况下单词的意思都明白了就不影响阅读。技术书有时候喜欢用长句，其中可能包含各种从句，如果实在读不懂就去查语法书，同样也不需要把这种从句彻底弄明白，只要这一句能看过去就行了，以后多查几遍书，自然就掌握了。另外，技术书是说明文，通常不应该有过去时，看到过去时就需要注意了，很可能是虚拟语气，如果不注意这一点，看到的意思可能和真实的意思正好相反。</p>
<p>应该从哪本书开始看起呢？从你当前最需要学的技术书看起。看书是相当花时间的，如果能一边学英语一边学技术，这时间利用得就很有效率。比如，如果你的C语言已经学得相当好了，不要专门为了学英语去重看一遍原版的K&amp;R。市面上有一些专门的计算机英语教材，我的建议是不要看，浪费时间，nonsense。初学时最好选一本有中文译本的书，有看不懂的地方可以翻中文版来对照，但是不要相信中文的翻译，原因在前面讨论过了。如果你是初学编程，没有任何基础，我可以推荐一本英文很浅显技术也很浅显的书：<a href="http://interactivepython.org/runestone/static/thinkcspy/index.html" target="_blank" rel="external">How To Think Like a Computer Scientist</a>，有Python、Java和C++版本，可自由下载。</p>
<p>要逐渐养成良好的阅读习惯:</p>
<ul>
<li>不要每个生单词都去查，有些单词很生僻，查了也记不住，记住了也不会再见到它了，但是前面讲过，都是作者在卖弄词汇量，无视它丝毫不影响阅读，因此要学会猜测单词的意思，能不查就不查，继续贯彻“懒”的原则。</li>
<li>看书不要动口，不念出声也不行，就是不要动口，要努力在大脑中建立从词形到语义的直接映射，如果只能从词形到读音再到语义就太慢了，严重影响阅读速度。</li>
<li>努力做到每句话都从头到尾只看一遍，不许回头反复看，这一点比较难，必须注意力高度集中，经常在记忆中暂存前面半句的内容和句式才能做到，但是一旦神功练成就会成倍地提高阅读速度。</li>
<li>学会skim，就是略读，很多优秀的作者在组织材料时会给读者一些建议，比如这一段是扩展的高级话题，和主线的相关度较低，可以先skim到后面，注意不是让你skip到后面，这一段还是要读的，但是不必逐字句地读，而是抓主旨，大概讲了个什么概念（有一些下定义的句式），有哪些要点（有数字编号或bullet列表项），适用于哪些场合有哪些注意事项（有 caveat、gotcha、noteworthy这种字眼），后面可能还会碰到这个概念，虽然你没有仔细看这是个什么东西，但大体上也知道了，这样就能不影响后面的阅读，这不仅需要高度集中的注意力、熟练的语言能力，而且要有足够的背景知识去猜测性地理解。但是语言能力还是最重要的因素，我和几个同学交流过，他们也能熟练地看英文书，但是需要skim查一个东西时就觉得还是不如中文书查得快。skim的技能在查阅手册时尤其重要，没有人会像看入门书一样把上千页的手册从头到尾看一遍，都是用到哪儿就查哪儿。总之，锻炼各种阅读习惯就为了一个目的：如何在最短的时间内，在保证正确性的前提下，获取尽可能多的知识。程序员的学习时间都是非常宝贵的。</li>
</ul>
<p>以上本着“够用就好”的原则，多次提到用懒办法，但是学技术学英语这两件事不能懒，贵在坚持。要养成良好的阅读习惯也有很多东西需要坚持，其中<strong>最根本的是持续高度集中注意力，充分调动记忆能力、推理能力、猜测能力，就像考试做阅读题一样看每一段话。</strong>最根本也是最重要的，<strong>“有英文原版就不看中文版”这个原则一定要坚持。</strong>一开始看英文书可能会很慢，但只要一直坚持就会慢慢达到原来看中文书的速度，再坚持下去就会比中文书看得更有效率，因为避免了很多歧义和术语翻译的问题。有人会说，项目紧任务急，看英文资料太慢，这次就先用中文尽快解决工作中的问题吧，等以后有时间了再看英文书学习。可是什么时候才会有时间呢？工作总是一个接一个的，老板怎么会付了工资让你闲着呢？如果你有这样的困难，我的建议是干脆辞职，学好了英文再去工作。你只要想想，你的同行们在外企全英文的环境下工作，英文和技术每天都在突飞猛进，而你还在用效率极其低下的方式学习和工作，你和别人的差距不是越来越大了吗？另一方面，现在的在校学生从小学就开始抓英语，基础都很好，很多高校也逐渐重视引进原版教材，开设很多英文授课的专业课。你再不奋起直追，就不觉得以后的职业道路充满危机吗？</p>
<p>最后说说写作。刚开始练习时不要怕写错，能表达清楚自己的意思即可。我看过很多源代码和文档中的英文，一看就是中国人写的，谓语动词不分单复数，名词复数不加s，处处可见中国式英语，但是丝毫不影响我对这些编程大牛的景仰，因为其中的思想我看懂了，并且我认为很强大。我有一个朋友，中学毕业就出来混的，由于工作的性质总要跟老外打交道，他从来不惧和老外交流，虽然连一个囫囵的句子都说不出来，但总是能用中学学的那点单词让老外明白他的意思，这一点我就非常佩服。总之就是说，<em>*不要因为不知道怎么写是对的就不敢动笔写，只要敢交流，并且别人能懂你的意思，就是很有效的交流。而且随着阅读量的增加，自然能写出一手好英文，前面讲过了，创作总是从模仿开始的。不怕出错才能有一个好的开始，才能逐步练习提高，而练习的最终目的当然还是希望写好，不仅字句通顺无语法错误，还能适当修辞。</em></p>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言中宏定义存在位置]]></title>
      <url>http://noparkinghere.top/2016/08/24/2016/2016-08-24-c%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%AD%98%E5%9C%A8%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p><em>宏定义作为C语言的一个传统内容，如果使用新标准的话，一般也只用宏定义来结局编译的一些问题如：#ifndef，#if undefined()等。</em></p>
<p>宏定义究竟放在什么地方，在使用 C 语言老款编辑器情况下，一些程序大量使用宏定义，且很多程序都是将宏定义作为申明一样全部放在头文件中的，这个没有一个统一的说法，其中各有利弊，每个人风格不尽相同。</p>
<p>首先，宏定义的常量在编译的时候是作为内容直接替换的，因此这部分并不会因此占用你堆、栈等存储空间。所以这就导致无论你将宏定义放在头文件还是放在源文件中，资源消耗上面没有太大差别。差别就是在头文件和源文件中可以使用的作用域不同。</p>
<h3 id="1-放在头文件中："><a href="#1-放在头文件中：" class="headerlink" title="1. 放在头文件中："></a>1. 放在头文件中：</h3><ul>
<li>作用域更广，不仅仅对应源文件可以使用，且其他所有的源文件包含这个都可以使用，即便一些常量现在不会被使用，将来也可能会使用。</li>
<li>作用域太宽，可能会与其他文件中的某个宏定义命名冲突，需要定义较长的名字。</li>
<li>方便集中在一起进行管理，看起来代码更加显得整洁。</li>
</ul>
<a id="more"></a>
<h3 id="2-放在头文件中："><a href="#2-放在头文件中：" class="headerlink" title="2. 放在头文件中："></a>2. 放在头文件中：</h3><ul>
<li>没有统一管理，分部零散，查找较麻烦，将来一些需要引用的话，重新修改程序。</li>
<li>只作用需要使用到的范围，减少与其他文件的关联性，出错几率更低。</li>
<li>宏定义名称无所谓起多长，作用域有限，不会与其他文件冲突。</li>
<li>只将需要在其他文件中使用的宏定义放在头文件中，按需进行分配。</li>
</ul>
<p>个人建议：<br><strong>采用方法 2，将宏定义绝大多数放在 .c 文件中，只将极个别需要其他源文件引用的宏定义放在 .h 中，这可以有效控制一些源文件没必要的相关性，虽然较长的定义名也避免了出错，但为了减少耦合性，按照需求来进行分配算是一个良好的编程习惯，否则工程一旦复杂性增加难免会出现一些意想不到的问题。</strong></p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[头文件交叉引用]]></title>
      <url>http://noparkinghere.top/2016/08/24/2016/2016-08-24-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><strong>尽可能将所需要包含的头文件文件在.c文件中包含定义如：#inlcude “x.h”，除非头文件必须的部分申明出现在其他头文件中定义过的结构体或者宏定义类型，这时候没办法，只能在.h中包含.h。</strong></p>
<p>具体分析这样定义的原因：</p>
<h4 id="1-减少编译展开所需时间"><a href="#1-减少编译展开所需时间" class="headerlink" title="1. 减少编译展开所需时间"></a>1. 减少编译展开所需时间</h4><p>虽然头文件中都加入了<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ifndef __KEY_H</span></div><div class="line"><span class="comment">#define __KEY_H</span></div><div class="line">...</div><div class="line"><span class="comment">#endif</span></div></pre></td></tr></table></figure></p>
<p>一般编译不会再出现重定等错误，但是每次遇到#include的时候，都会将这段代码复制一边进行排查，而头文件多次被展开，会严重影响编译效率，且也没有什么好处。</p>
<a id="more"></a>
<h4 id="2-头文件的嵌套调用难免造成问题"><a href="#2-头文件的嵌套调用难免造成问题" class="headerlink" title="2. 头文件的嵌套调用难免造成问题"></a>2. 头文件的嵌套调用难免造成问题</h4><p>两个.c文件相互调用彼此的内容是常有的事情，这时候如果处理不善则往往会遇到未声明之类的报错，这种情况需要你小心的调整#include”x.h”文件在编译过程中第一次出现的顺序。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">举例：</div><div class="line">a.h中存在<span class="comment">#inlcude "b.h"</span></div><div class="line">b.h中存在<span class="comment">#inlcude "a.h"</span></div><div class="line">而这时候a.h依赖于 b.h,但b.h直接被先包含在了main.c文件中，这时候往往会提示编译错误，原因是a.h中的一些内容未被申明定义。</div><div class="line"></div><div class="line">具体解析：</div><div class="line">编译器在编译的过程中，如果先从main.c文件开始执行，main.c中包含有b.h，而b.h中包含有a.h则展开为：</div><div class="line"></div><div class="line">b.h(上部分极少数定义包含内容)</div><div class="line">a.h(全部内容，因为<span class="comment">#ifndef，所以b.h不会在a.h中再出现)</span></div><div class="line">b.h(绝大多数内容)</div><div class="line">因此，通过上述代码，在执行编译过程中，在编译a.h时则无法找到依赖b.h的一些相关定义。</div></pre></td></tr></table></figure></p>
<p><strong>直接将头文件文件相互写入到对方的头文件文件下这时候最容易出错。解决的办法一般是：1.将所有不需要写在头文件中的#inlcude写在#inlcude “.h”中。2.小心调整#inlcude “.h”的顺序，将需要依赖其他的那个调用放在后面，对于多次嵌套调用等情况，调整顺序时尤其需要注意顺序。</strong></p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> githubpage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu的基本使用]]></title>
      <url>http://noparkinghere.top/2016/08/15/2016/2016-08-15-ubuntu%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><em>本文专门针对ubuntu这个linux发行版而写的，对ubuntu特有一些操作进行介绍和总结。</em></p>
<h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><p>dpkg  是 Debian Packager 的简写，为 Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自 Debian 的 Linux 发行版都使用 dpkg，例如 Ubuntu Knoppix 深度linux 等。</p>
<p>dpkg是用来安装.deb文件,但不会解决模块的依赖关系,且不会关心ubuntu的软件仓库内的软件,可以用于安装本地的deb文件。</p>
<ul>
<li>安装本地软件：dpkg -i &lt;.deb file name&gt;</li>
<li>删除软件包（保留其配置信息）：dpkg -r <software></software></li>
</ul>
<p>其他一些详细操作这边就不罗列了，具体可查看 man 文件。</p>
<h3 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h3><p>apt会解决和安装模块的依赖问题,并会咨询软件仓库, 但不会安装本地的deb文件, apt是建立在dpkg之上的软件管理工具。</p>
<p><em>用过ubuntu的人都知道apt-get的方便</em></p>
<ul>
<li>远程安装软件：sudo apt-get install xxx ，远程库一般会提供不少常见的软件，当然也可以手动添加源。</li>
<li>修复安装错误：sudo apt-get install -f 常用于手动安装软件后，出现错误，一般该指令可以解决大多数的依赖关系，一般这种错误来自于使用本地安装命令 dpkg 时出现的依赖错误。</li>
<li>删除已经安装的软件：sudo apt-get remove xxx 删除一个软件包。</li>
</ul>
<a id="more"></a>
<p>除了以上的安装操作外，apt-get 还有一些清理清理升级缓存以及无用包的命令：</p>
<ul>
<li>sudo apt-get autoclean ：清理旧版本的软件缓存</li>
<li>sudo apt-get clean：清理所有软件缓存</li>
<li>sudo apt-get autoremove：删除系统不再使用的孤立软件</li>
</ul>
<h3 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h3><p>在/etc/rc.local中可以加入ubuntu的开机自启内容。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考网址：<br><a href="http://my.oschina.net/zhangqingcai/blog/23994" target="_blank" rel="external">http://my.oschina.net/zhangqingcai/blog/23994</a><br><a href="http://blog.csdn.net/baixiaoshi/article/details/43529649" target="_blank" rel="external">http://blog.csdn.net/baixiaoshi/article/details/43529649</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C编程规范]]></title>
      <url>http://noparkinghere.top/2016/08/11/2016/2016-08-11-C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p><em>文章阐述了一些个人使用 C 编程时的习惯，主要参考一些网传的文档，固件库以及多个工程。</em></p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><strong>结构体类型和函数的标识符一般用大驼峰式书写格式，普通变量和结构体变量的标识符则多用小驼峰式书写格式，但在此基础之上进行一定的改进不完全沿用。</strong></p>
<h4 id="宏定义的命名全部采用大写，单词之间用隔开，要求常量名只含有大写字母和下划线，且常量名用英文表达其意思不得使用拼音，当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。"><a href="#宏定义的命名全部采用大写，单词之间用隔开，要求常量名只含有大写字母和下划线，且常量名用英文表达其意思不得使用拼音，当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。" class="headerlink" title="宏定义的命名全部采用大写，单词之间用隔开，要求常量名只含有大写字母和下划线，且常量名用英文表达其意思不得使用拼音，当需要由多个单词表示时，单词与单词之间必须采用连字符”“连接。"></a>宏定义的命名全部采用大写，单词之间用<em>隔开，要求常量名只含有大写字母和下划线，且常量名用英文表达其意思不得使用拼音，当需要由多个单词表示时，单词与单词之间必须采用连字符”</em>“连接。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line"><span class="comment">#define ERR_FILE_NOT_FOUND</span></div></pre></td></tr></table></figure>
<h4 id="全局变量、静态变量、常量尽可能的详细描述，普通局部变量和成员变量尽可能的书写简单；变量的描述都普遍按照小驼峰的方式。"><a href="#全局变量、静态变量、常量尽可能的详细描述，普通局部变量和成员变量尽可能的书写简单；变量的描述都普遍按照小驼峰的方式。" class="headerlink" title="全局变量、静态变量、常量尽可能的详细描述，普通局部变量和成员变量尽可能的书写简单；变量的描述都普遍按照小驼峰的方式。"></a>全局变量、静态变量、常量尽可能的详细描述，普通局部变量和成员变量尽可能的书写简单；变量的描述都普遍按照小驼峰的方式。</h4><p><em>这种命名法的出发点是把变量名按：属性+类型+对象描述的顺序组合起来：</em></p>
<a id="more"></a>
<ul>
<li>硬件相关部分：</li>
</ul>
<p>由于 C 语言很多时候面向硬件开发，这边规定，硬件相关的名称全部大写，后面用“_”隔开，如：</p>
<ul>
<li>属性部分：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g_ ：全局变量，如一个全局的长型变量定义为 g_lFailCount</div><div class="line">s_ ：静态变量，如一个静态的指针变量定义为 s_plPerv_Inst</div><div class="line">c_ ：常量，const 的变量 示例：const char* c_szFileName</div></pre></td></tr></table></figure>
<ul>
<li>类型部分：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">bool 用b开头 b标志寄存器 </div><div class="line"></div><div class="line">int 用 i  32位开头 iCount </div><div class="line">long  int 用l开头 lSum </div><div class="line">char  用c开头 cCount </div><div class="line"><span class="built_in">float</span> 用f开头 fAvg </div><div class="line">double 用d开头 dDeta </div><div class="line"></div><div class="line">unsigned  char / byte(字节) 用by开头 </div><div class="line">unsigned  int(WORD) 用w开头 wCount </div><div class="line">unsigned  long  int(DWORD) 用dw开头 dwBroad </div><div class="line"></div><div class="line">字符串 用s开头 sFileName </div><div class="line"></div><div class="line">注意：以上所有类型只有在和属性部分（g_，s_，c_等）一起使用。</div><div class="line"></div><div class="line">数组 arr：如一个 int 型数组应该表示为 arriStat。</div><div class="line">指针 p：pData</div><div class="line">对一重指针变量的基本原则为：“p”+变量类型前缀+命名，如一个<span class="built_in">float</span>*型应该表示为pfStat。对二重指针变量的基本规则为：“pp”+变量类型前缀+命名。对三重指针变量的基本规则为：“ppp”+变量类型前缀+命名。 </div><div class="line"></div><div class="line">注意：虽然上面的基本类型不在局部变量中沿用，但是数组和指针类型在局部变量中也要使用，但不加入其他基本类型的符号。</div></pre></td></tr></table></figure>
<p><strong>普通局部变量，尽量做到简洁明了，毕竟函数较短，能够轻松查看原型，因此这边一般都采用直接小写的方式，尽量通过一个单词来表述意思，只有在用到指针和数组时才会加入前缀，且后面命名用大写，如：arrMember, pScore 等等。</strong></p>
<ul>
<li>描述部分：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">最大　Max		最小　M<span class="keyword">in</span>		初始化　Init		临时变量　T（或Temp）</div><div class="line">源对象　Src		目的对象　Dest</div></pre></td></tr></table></figure>
<h4 id="枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。"><a href="#枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用-EM-大写字母类似宏定义的形式，申明为枚举型的变量使用以-em-为头的驼峰式命名-枚举变量本身就类似于常量-。" class="headerlink" title="枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。"></a>枚举型命名类型名采用驼峰命名法，前面加EM前缀，其中的变量采用 EM_+ 大写字母类似宏定义的形式，申明为枚举型的变量使用以 em 为头的驼峰式命名(枚举变量本身就类似于常量)。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">如： </div><div class="line">enum EMDays </div><div class="line">&#123; </div><div class="line">	EM_DAYS_MONDAY; </div><div class="line">	EM_DAYS_TUESDAY; </div><div class="line">	…… </div><div class="line">&#125;; </div><div class="line">EMDays  emToday;</div></pre></td></tr></table></figure>
<h4 id="结构体、类、共用体的命名规则统一采用大驼峰式命名法，结构体类型定义时在前面需要加上-Stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量采用小驼峰式命名和普通变量一致。（函数与结构体变量方便区分，固都采用大驼峰式）"><a href="#结构体、类、共用体的命名规则统一采用大驼峰式命名法，结构体类型定义时在前面需要加上-Stru-前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量采用小驼峰式命名和普通变量一致。（函数与结构体变量方便区分，固都采用大驼峰式）" class="headerlink" title="结构体、类、共用体的命名规则统一采用大驼峰式命名法，结构体类型定义时在前面需要加上 Stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量采用小驼峰式命名和普通变量一致。（函数与结构体变量方便区分，固都采用大驼峰式）"></a>结构体、类、共用体的命名规则统一采用大驼峰式命名法，结构体类型定义时在前面需要加上 Stru 前缀，结构体变量初始化申明的时候直接采用大驼峰式即可，其成员变量采用小驼峰式命名和普通变量一致。（函数与结构体变量方便区分，固都采用大驼峰式）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">typedef struct</div><div class="line">&#123; </div><div class="line">	char *pNodeNext;</div><div class="line">	char *pNodePreview;</div><div class="line">&#125;StruStudentNode; </div><div class="line">StruStudentNode  StudentNode;</div></pre></td></tr></table></figure>
<h4 id="函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，I2C-init，delay-us-硬件控制，非软件延时-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）"><a href="#函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC-Configuration，I2C-init，delay-us-硬件控制，非软件延时-硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）" class="headerlink" title="函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如NVIC_Configuration，I2C_init，delay_us(硬件控制，非软件延时) 硬件设备相关的使用下划线，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）"></a>函数的命名规则一般采用大驼峰式，命名采用“主动宾”或者“动宾”结构，与结构体变量虽然同样采用大驼峰式，但通过使用方法和命名方便进行区分。同时部分特殊函数可以采用其他命名规则，如<code>NVIC_Configuration，I2C_init，delay_us(硬件控制，非软件延时) 硬件设备相关的使用下划线</code>，以此来区分哪些是特殊函数（函数与结构体方便区分采用大驼峰式）</h4><p><strong>函数参数命名规范 :</strong></p>
<ul>
<li>参数名称的命名参照变量命名规范。</li>
<li>为了提高程序的运行效率，减少参数占用的堆栈，传递大结构的参数，一律采用指针或引用方式传递。</li>
<li>为了便于其他程序员识别某个指针参数是入口参数还是出口参数，同时便于编译器检查错误，应该在入口参数前加入const标志。 </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">int CmCopyString(const char * c_pcSource, char* pcDest) </div><div class="line">&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>普通函数与中断调用函数区别命名，普通函数如果需要设定控制终中断函数则命名以Set开头通过修改中断函数中的全局变量判定条件来控制中断执行，而中断功能函数只能被中断调用，不可直接被普通函数调用(包括主函数)，命名以 Run 开头。</li>
</ul>
<h4 id="硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写"><a href="#硬件设备名称函数命名参考-stm32-固件库命名法则：外设名称在前面全部大写" class="headerlink" title="硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写"></a>硬件设备名称函数命名参考 stm32 固件库命名法则：外设名称在前面全部大写</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">如：</div><div class="line">void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)</div><div class="line">&#123;</div><div class="line">	/* Check the parameters */</div><div class="line">	assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</div><div class="line"></div><div class="line">	/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */</div><div class="line">	SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。"><a href="#除了编译开关-头文件等特殊应用，应避免使用-EXAMPLETEST-之类以下划线开始和结尾的定义。" class="headerlink" title="除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLETEST 之类以下划线开始和结尾的定义。"></a>除了编译开关/头文件等特殊应用，应避免使用 _EXAMPLE<em>TEST</em> 之类以下划线开始和结尾的定义。</h4><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><h4 id="文件名全部使用小写字母、下划线和数字，多个具体含义的单词中用-隔开，不得出现大写字母等任何其他字符。"><a href="#文件名全部使用小写字母、下划线和数字，多个具体含义的单词中用-隔开，不得出现大写字母等任何其他字符。" class="headerlink" title="文件名全部使用小写字母、下划线和数字，多个具体含义的单词中用_隔开，不得出现大写字母等任何其他字符。"></a>文件名全部使用小写字母、下划线和数字，多个具体含义的单词中用_隔开，不得出现大写字母等任何其他字符。</h4><ul>
<li>Linux 系统是大小写敏感的，如果文件名只有大小写不同，则跨平台就会出问题。</li>
<li>小写文件名通常比大写文件名更易读，比如 accessibility.txt 就比 ACCESSIBILITY.TXT 易读。</li>
<li>某些系统会生成一些预置的用户目录，采用首字母大写的目录名。比如，Ubuntu 在用户主目录会默认生成Downloads、 Pictures、Documents等目录。</li>
<li>文件名全部小写，还有利于命令行操作。比如，某些命令可以不使用-i参数了。</li>
</ul>
<h4 id="命名具备意义"><a href="#命名具备意义" class="headerlink" title="命名具备意义"></a>命名具备意义</h4><p>文件名(包括动态库、组件、控件、工程文件等)的命名规范,文件名的命名要求表达出文件的内容，要求文件名的长度不得少于5个字母，严禁使用象 file1,myfile 之类的文件名。</p>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><h4 id="文件注释：-使用-整体注释，不得采用-行注释"><a href="#文件注释：-使用-整体注释，不得采用-行注释" class="headerlink" title="文件注释：(使用 /*...*/ 整体注释，不得采用 // 行注释)"></a>文件注释：(使用 <code>/*...*/</code> 整体注释，不得采用 <code>//</code> 行注释)</h4><p>每个文件，都必须具备文件注释，可以不完全具备下面的内容，但至少要具备：文件名、版权、简述。</p>
<p><em>详细格式如下：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/********************* Copyright(C)  20xx  company********************</div><div class="line">	File name:	 	// 文件名</div><div class="line">	Author: 		// 作者、</div><div class="line">	Version:		// 版本</div><div class="line">	Date: 			// 完成日期</div><div class="line">	Description: 	// 用于详细说明此程序文件完成的主要功能，与其他模块</div><div class="line">					// 或函数的接口，输出值、取值范围、含义及参数间的控</div><div class="line">					// 制、顺序、独立或依赖等关系</div><div class="line">	License:		// 版权协议</div><div class="line">	Others: 		// 其它内容的说明</div><div class="line">	Function List: 	// 主要函数列表，每条记录应包括函数名及功能简要说明</div><div class="line">					1. ....</div><div class="line">	History: 		// 修改历史记录列表，每条修改记录应包括修改日期、修改</div><div class="line">					// 者及修改内容简述</div><div class="line">	&lt;author&gt; 		&lt;time&gt;	 	&lt;version &gt; 		&lt;desc&gt;</div><div class="line">	Name1			20xx.x.x		Vx.x		//修改的内容</div><div class="line"></div><div class="line">*************************************************/</div></pre></td></tr></table></figure>
<p><em>例：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/************************************ Copyright (C)  2015  HS ***********************************</div><div class="line">	File name：    	channel.c</div><div class="line">	Author: 		name</div><div class="line">	version:			V1.0</div><div class="line">	Description:		实现多个通道的脉冲发送</div><div class="line">	Others:</div><div class="line">	Function List:</div><div class="line">					void GetChanCtrl(void);</div><div class="line">					void SetNormalMode(void);</div><div class="line">					void SetImMode(void);</div><div class="line">					void CtrlPulse(u8 g_byComRev);</div><div class="line">					void SetTimeMode(void);</div><div class="line">					u16 ScanfValue(void);</div><div class="line">					u32 ScanfTime(void);</div><div class="line">					void CtrlChannel(void);</div><div class="line">					void InitChannel(void);</div><div class="line">					void RunNormal(void);</div><div class="line">					void RunPulse(void);</div><div class="line">					void RunMode(void);</div><div class="line">	History:</div><div class="line">	&lt;author&gt; 		&lt;time&gt;	 	&lt;version &gt; 		&lt;desc&gt;</div><div class="line">Name1			2015.6.1		V1.1		修复xx问题</div><div class="line">**************************************************************************************************/</div></pre></td></tr></table></figure>
<h4 id="函数注释：-使用-整体注释，不得采用-行注释"><a href="#函数注释：-使用-整体注释，不得采用-行注释" class="headerlink" title="函数注释：(使用 /*...*/ 整体注释，不得采用 // 行注释)"></a>函数注释：(使用 <code>/*...*/</code> 整体注释，不得采用 <code>//</code> 行注释)</h4><p>要求每个函数都需要有注释，但格式不做强制要求，功能复杂的函数必须具备：函数描述、参数说明、返回值；较为简短的函数可以简述功能。</p>
<p><em>以下为一个比较详细的格式说明：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**************************************************************************</div><div class="line">	Function: 			// 函数名称</div><div class="line">	Description: 		// 函数功能、性能等的描述</div><div class="line">	Calls: 				// 被本函数调用的函数清单</div><div class="line">	Called By:		 	// 调用本函数的函数清单</div><div class="line">	Table Accessed: 	// 被访问的表（此项仅对于牵扯到数据库操作的程序）</div><div class="line">	Table Updated: 		// 被修改的表（此项仅对于牵扯到数据库操作的程序）</div><div class="line">	Input: 				// 输入参数说明，包括每个参数的作</div><div class="line">						// 用、取值说明及参数间关系。</div><div class="line">	Output: 			// 对输出参数的说明。</div><div class="line">	Return: 			// 函数返回值的说明</div><div class="line">	Others: 			// 其它说明</div><div class="line">**************************************************************************/</div></pre></td></tr></table></figure>
<p><em>参考案例：</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/************************************************************************</div><div class="line">	Function: 		InitChannel</div><div class="line">	Description: 	启动初始化所有通道</div><div class="line">	Calls: 			TIM_DeInit</div><div class="line">					TIM3_Int_Init</div><div class="line">	Called By:		main()</div><div class="line">	Input: 			无</div><div class="line">	Output: 		让所有通道输出低电平</div><div class="line">	Return: 		无</div><div class="line">************************************************************************/</div></pre></td></tr></table></figure>
<h4 id="程序块注释："><a href="#程序块注释：" class="headerlink" title="程序块注释："></a>程序块注释：</h4><p><em>一般的程序块注释如 for，while 之类的注释在前面，程序排版整齐，并方便注释的阅读与理解，将注释与其上面的代码用空一行隔开，且该程序块与下面的代码也应该用空一行(使用/\</em>…*/整体注释，不得采用//行注释)*</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">例：</div><div class="line">void example_fun( void )</div><div class="line">&#123;</div><div class="line">	/* code one comments */</div><div class="line">	CodeBlock One</div><div class="line"></div><div class="line">	/* code two comments */</div><div class="line">	CodeBlock Two</div><div class="line"></div><div class="line">	/* code three comments */</div><div class="line">	CodeBlock Three</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-对于单行代码注释如：函数调用、变量说明等，则直接在行后使用-注释。"><a href="#边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则-详见命名规范-对于单行代码注释如：函数调用、变量说明等，则直接在行后使用-注释。" class="headerlink" title="边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),对于单行代码注释如：函数调用、变量说明等，则直接在行后使用 // 注释。"></a>边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。命名一般要采用自注释的命名规则(详见命名规范),对于单行代码注释如：函数调用、变量说明等，则直接在行后使用 <code>//</code> 注释。</h4><blockquote>
<p>参考链接：<br><a href="http://itec.hust.edu.cn/~xujing/cpp/common-cpp/text-book/C-coding-rules-simple.pdf" target="_blank" rel="external">http://itec.hust.edu.cn/~xujing/cpp/common-cpp/text-book/C-coding-rules-simple.pdf</a><br><a href="https://github.com/ruanyf/document-style-guide" target="_blank" rel="external">https://github.com/ruanyf/document-style-guide</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常规的通讯校验]]></title>
      <url>http://noparkinghere.top/2016/08/06/2016-08-06-%E5%B8%B8%E8%A7%84%E7%9A%84%E9%80%9A%E8%AE%AF%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/liyuanbhu/article/details/7882789" target="_blank" rel="external">http://blog.csdn.net/liyuanbhu/article/details/7882789</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GPIO口详解]]></title>
      <url>http://noparkinghere.top/2016/08/03/2016/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>在做 MCU 编程开发的时候，GPIO 可以说是最基础也是最重要的部分，MCU 的学习研究无非就是三点：高低电频，输入输出，通讯协议。而GPIO可以说贯穿始终，在模拟一些通讯协议时，GPIO 所采用的模式错误，往往会引起各种意想不到的问题。</em></p>
<p>对于不同的计算机体系结构，设备可能是端口映射，也可能是内存映射的。如果系统结构支持独立的 IO 地址空间，并且是端口映射，就必须使用汇编语言完成实际对设备的控制，因为 C 语言并没有提供真正的“端口”的概念。如果是内存映射，那就方便的多了。比如像寄存器A（地址假定为0x48000000）写入数据0x01，那么就可以这样设置了，<code>#define A (*(volatile unsigned long *)0x48000000) A = 0x01;</code>这种通过宏定义某个存储空间，然后对该空间写入数据的过程是最为常见的。</p>
<h3 id="GPIO-模式："><a href="#GPIO-模式：" class="headerlink" title="GPIO 模式："></a>GPIO 模式：</h3><p>不同的 MCU 会提供不同的模式选择，一般 GPIO 的模式无外乎以下几种：推挽输出，开漏输出，浮空输入,上拉/下拉输入，模拟口，复用功能等等。</p>
<p>而实际使用中，</p>
<h4 id="通用推挽输出（push-pull）："><a href="#通用推挽输出（push-pull）：" class="headerlink" title="通用推挽输出（push-pull）："></a>通用推挽输出（push-pull）：</h4><p>在功率放大器电路中大量采用推挽放大器电路，这种电路中用两只三极管构成一级放大器电路，两只三极管分别放大输入信号的正半周和负半周，即用一只三极管放大信号的正半周，用另一只三极管放大信号的负半周，两只三极管输出的半周信号在放大器负载上合并后得到一个完整周期的输出信号。原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/8b82b9014a90f6037a3d50aa3a12b31bb151ed4a.jpg" alt=""></p>
<p>推挽放大器电路中，一只三极管工作在导通、放大状态时，另一只三极管处于截止状态，当输入信号变化到另一个半周后，原先导通、放大的三极管进入截止，而原先截止的三极管进入导通、放大状态，两只三极管在不断地交替导通放大和截止变化，所以称为<strong>推挽放大器</strong>。</p>
<p><em>这种电路主要用于低功耗情况下能输出较大功率的交流信号，通常用于低频放大电路设计中。可增强输出的负载能力。这种输出结构带负载能力较强，你驱动个LED灯什么的操作IO口可以用推挽输出。</em></p>
<a id="more"></a>
<h4 id="开漏输出（open-drain）"><a href="#开漏输出（open-drain）" class="headerlink" title="开漏输出（open drain）:"></a>开漏输出（open drain）:</h4><p>输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行。原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-08-03-gpio%E5%8F%A3%E8%AF%A6%E8%A7%A3/DeepinScrot-2019.png" alt=""></p>
<p>开漏输出只有外部有上拉电阻时，才有可能输出高电平。当外部无上拉电阻时，该口不能输出高电平，处于悬空状态，或只可以输出低电平。开漏的主要用处：</p>
<ul>
<li>芯片的 Open drain 输出是设计用于”线或” (wire AND) 逻辑的，就是说当多个漏极开路器件的输出连在一起的时候，只要是其中一个导通，输出就为‘0’。这个特性被广泛用于串行总线电路。</li>
<li>可以用于如继电器之类只吸入电流的负载, 或驱动比你的芯片电源电压高的负载，吸电流能力较强，但是输出能力不如推挽输出较弱，（一般如果单一驱动的话，大都选用推挽输出。）</li>
<li>对于一些需要防止干扰的操作，如：不希望单片机的上拉电阻对外部电路（如ADC）产生任何影响。</li>
</ul>
<p>open-drain 是漏极开路输出的意思，相当于集电极开路(open-collector)输出，即 ttl 中的集电极开路（oc）输出。一般用于线或、线与，也有的用于电流驱动。open-drain 是对 mos 管而言，open-collector 是对双极型管而言，在用法上没啥区别。OC 门的输出就是开漏输出；OD(open-collector) 门的输出也是开漏输出（实际是开集）。TTL 电路有集电极开路 OC 门，MOS 管也有和集电极对应的漏极开路的 OD 门，它的输出就叫做开漏输出。它可以吸收很大的电流，但是不能向外输出电流。所以，为了能输入和输出电流，它使用的时候要跟电源和上拉电阻一齐用。因此在 MCU 中我们就用开漏来表示本身无上拉能力，高阻抗的这种功能。</p>
<h4 id="上拉-下拉输入"><a href="#上拉-下拉输入" class="headerlink" title="上拉/下拉输入"></a>上拉/下拉输入</h4><p>上拉就是输入高电平，然后接一个上拉电阻（起保护作用），需要知道上拉就表示该端口在默认情况下输入为高电平；同理，下拉就是默认情况输入低电平。</p>
<p>这边上下拉比较好理解，而且一般的单片机都可以配置成这种功能，有关上下拉，可能一些人不会太在意，认为并不会有多大影响，但是一个稳定的产品配置上下拉很重要，而且，如果你需要考虑功能的话，那就更加需要注意这点。</p>
<h4 id="复用功能"><a href="#复用功能" class="headerlink" title="复用功能"></a>复用功能</h4><p>新款的 MCU 中为了实现某些特殊的功能，如 uart，I2C 通讯等，加入了复用功能这种 IO 模式，GPIO 需要使用复用功能，然后配置相关的寄存器才可以开启这些功能，但是，也并不绝对，一些 MCU 即便使用其他模式，开启相关功能后，仍然是可以使用这些特殊功能的。</p>
<p>但需要注意的是，个人认为 MCU 采用复用功能的模式，是为了安全，防止你错误的配置 GPIO 口，然后可能会导致 IO 口烧坏，所以如果你对相关功能需要的 GPIO 状态不是太熟悉的话，如果需要使用 MCU 寄存器来配置 GPIO 口，则最好按照规定将 GPIO 口配置为复用功能。</p>
<p>这边关于通讯协议就不另外展开叙述，详细可以参考一些案例，尤其是需要模拟通讯协议输出时，一定要以芯片手册为准，部分网上流传的例程可能 IO 口配置是错误的，短时间没有问题，但不利于长久使用。</p>
<blockquote>
<p>参考链接：<br><a href="https://wenku.baidu.com/view/50417ea6f524ccbff121845c.html" target="_blank" rel="external">https://wenku.baidu.com/view/50417ea6f524ccbff121845c.html</a><br><a href="http://blog.csdn.net/ybhuangfugui/article/details/52953533" target="_blank" rel="external">http://blog.csdn.net/ybhuangfugui/article/details/52953533</a><br><a href="http://blog.csdn.net/kevinhg/article/details/17490273" target="_blank" rel="external">http://blog.csdn.net/kevinhg/article/details/17490273</a><br><a href="http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9" target="_blank" rel="external">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=2288&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href="http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9" target="_blank" rel="external">http://www.openedv.com/forum.php?mod=viewthread&amp;tid=67623&amp;highlight=%CD%C6%CD%EC%2B%BF%AA%C2%A9</a><br><a href="http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html" target="_blank" rel="external">http://jingyan.baidu.com/article/5225f26b047a5ee6fa0908f6.html</a><br><a href="http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3" target="_blank" rel="external">http://zhidao.baidu.com/link?url=ZnvwHHE10-0UZ8hPRvLczpw7-qZolpNolBuT0TsGZHEjDMxmZeYz5QsOYUybxc7OBMSiPOfZx_401s5KlEIQKcrUZPqSaOTMX4yrEgfsbX3</a><br><a href="http://blog.chinaunix.net/uid-23065002-id-3885199.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-23065002-id-3885199.html</a><br><a href="http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe" target="_blank" rel="external">http://wenku.baidu.com/link?url=9BSyigTdzjcZ73LWkfGOhzfxyD1oDhVHMS0ykLUG1sMp9lUbY9yGhL2hsqIKPaX47fdcfDwRxLnfu46m_Z4y0_HGE6XPk_8VSpE38ztCFIe</a><br><a href="http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093" target="_blank" rel="external">http://www.9mcu.com/9mcubbs/forum.php?mod=viewthread&amp;tid=951093</a><br><a href="https://wenku.baidu.com/view/131592ba1a37f111f1855b79" target="_blank" rel="external">https://wenku.baidu.com/view/131592ba1a37f111f1855b79</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[架设自己的git服务]]></title>
      <url>http://noparkinghere.top/2016/07/29/2016/2016-07-29-%E6%9E%B6%E8%AE%BE%E8%87%AA%E5%B7%B1%E7%9A%84git%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><em>本实验使用的是实体机 ubuntu 16.04 和虚拟机 virtualbox 搭建 ubuntu—server 16.04 系统进行连接，其中用 ubuntu-server 搭建 git，实体机 ubuntu desktop 连接 ubuntu-server，后续如果有其他环境也会逐一补充。</em></p>
<p><strong>这边暂时没有在实体机上面尝试，先列举出在虚拟机上面架设 git 服务器</strong></p>
<h3 id="使用-ssh-登陆-ubuntu-server"><a href="#使用-ssh-登陆-ubuntu-server" class="headerlink" title="使用 ssh 登陆 ubuntu-server"></a>使用 ssh 登陆 ubuntu-server</h3><h4 id="ping-通两个系统："><a href="#ping-通两个系统：" class="headerlink" title="ping 通两个系统："></a>ping 通两个系统：</h4><p>看是否可以 ping 通两个系统，首先查看 ip 地址，<code>ifconfig</code>， 例如主机是： 192.168.18.60 ，虚拟机是 192.168.18.202。则在主机中 ping 192.168.18.60 ，当然事情往往并不会一帆风顺，很多设置的时候，为了可以链接外网，虚拟机选用了 NAT 模式。<em>貌似该模式无法使用ssh服务，虚拟机可以 ping 通主机，但主机无法 ping 通虚拟机。</em>这时候可以使用几种方法：</p>
<ul>
<li>更改虚拟机模式为桥接模式，弃用原来的 NAT 模式。</li>
<li>使用实体机中的虚拟机网卡与虚拟机进行交互，但貌似 ubuntu 下面并无法找到这块虚拟网卡，解决办法可以手动建立一个虚拟网卡。</li>
<li>创建一个新的链接方式，通过这个桥接到实体机，然后通过 NAT 访问外网。<em>这边详细介绍这种方式</em></li>
</ul>
<p>详细步骤：</p>
<ul>
<li>使用 virtualbox 新建一个新的 adapter，选用 bridge adapter。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-2011.png" alt=""></p>
<ul>
<li>重启虚拟机系统，或者重启网络服务 <code>sudo /etc/init.d/networking restart</code> ，ifconfig -a 查看所有网卡，可以看到虚拟机中有一个网卡 enp0s8 并没有被使用，这个就是刚刚新建的那个桥接网卡。</li>
<li>设置该网卡，修改/etc/network/interfaces文件，如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4326.png" alt=""></p>
<ul>
<li><p>重启网络服务 <code>sudo /etc/init.d/networking restart</code>，ifconfig 查看网卡。如下图：<br>-<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-4534.png" alt=""></p>
</li>
<li><p>接着基本就可以尝试 ping 通两个系统了，实体机中使用 ping 192.168.18.202，虚拟机中 ping 192.168.18.60 。如果仍然不行可以尝试关闭防火墙：<code>sudo ufw disable</code>。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="尝试ssh服务："><a href="#尝试ssh服务：" class="headerlink" title="尝试ssh服务："></a>尝试ssh服务：</h4><p><em>本步骤主要是建立链接，安装 ssh 服务，然后连接实体机可以登陆 ubuntu-server。因为这边 git 采用了 ssh 与服务器进行交互，所以 ssh 在这边是必须的。</em></p>
<ul>
<li>实体机和虚拟机，两个操作系统必须要同时安装 ssh 服务，如果只有实体机安装会出现链接失败。安装指令都是： <code>sudo apt-get install ssh或sudo apt-get install openssh-server</code>，<code>sudo /etc/init.d/ssh restart</code> 重启 ssh 服务。</li>
<li>查看ssh服务是否启动, <code>ps –e | grep ssh</code>，响应的 sshd 和 ssh-agent 如果未打开则运行指令名字。</li>
<li>修改实体机的 ip 配置文件 <code>/ect/hosts</code>，加入如下行： <code>192.168.18.202 ubuntu_server</code>，ubuntu_server 是你的虚拟机的主机名称，而 ubuntu_server 以后将代替 192.168.18.202 出现。如果你的虚拟机名不是 ubuntu_server ,可以修改 /etc/hostname 中的名称。</li>
<li>通过以上设置后，你的主机基本可以通过 ssh 访问虚拟机了，你可以在虚拟机新建一个用户 adduser git，然后实体机可以使用如下命令 <code>ssh git@ubuntu_server 或者 ssh git@192.168.18.202</code> 进行登陆，输入密码就可以进行相关操作了。</li>
</ul>
<p>补充：<em>如果 ssh 还不能登录上，就修改 sshd 的默认配置，例如： ssh 出现 permission denied (publickey) 问题:</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">修改 /etc/ssh/sshd-config 文件.</div><div class="line">将其中的 PermitRootLogin no 修改为 yes</div><div class="line">PubkeyAuthentication yes 修改为 no</div><div class="line">AuthorizedKeysFile .ssh/authorized_keys 前面加上<span class="comment">#屏蔽掉，</span></div><div class="line">PasswordAuthentication no 修改为 yes 就可以了。*</div></pre></td></tr></table></figure>
<h3 id="git虚拟服务器搭建："><a href="#git虚拟服务器搭建：" class="headerlink" title="git虚拟服务器搭建："></a>git虚拟服务器搭建：</h3><p><em>安装 git，可以使用命令 <code>sudo apt-get install git-core</code> 或者 `sudo apt-get install git</em>` 。</p>
<ul>
<li>在实体机上，我们使用命令： ssh-keygen –t rsa 生成密钥。秘钥在当前用户目录的 .ssh 目录下。</li>
<li>在虚拟机的 git 目录下新建一个 .ssh 目录</li>
<li>在 .ssh 目录下，我们可以看到 id_rsa 和 id_rsa.pub 文件，id_rsa.pub 为公钥，我们 通过命令 <code>scp /home/git/.ssh/id_rsa.pub git@ubuntu_server:/home/git/.ssh/authorized_keys</code>将实体机上生成的公钥拷贝到虚拟机的git账户目录下上。如果是要添加公钥可以使用使用命令 <code>cat /home/git/id_rsa.pub&gt;&gt;/home/git/.ssh/authorized_keys</code></li>
<li>使用命令 <code>git –-bare init /home/git/myRep.git</code> ,初始化化仓库。<strong>注意一定需要建立一个 –bare 的裸库。</strong></li>
</ul>
<h4 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h4><p><em>我们可以使用 <code>git clone git@gitServer:/home/git/myRep.git</code> 直接将库克隆下来，但一般推荐，在将本地库与远程库建立链接具体步骤如下：</em></p>
<ul>
<li>在实体机中新建一个文件夹， <code>mkdir test</code> ，进入该文件夹 <code>cd test</code></li>
<li>初始化这个库， <code>git init</code>。</li>
<li>随意添加几个文件，例如： <code>echo &quot;hello world&quot; &gt;&gt; test.txt</code></li>
<li>常规git操作，加入stage并提交， <code>git add .  &amp;&amp;  git commit -m &quot;test&quot;</code></li>
<li>查看下本地库的状态： git status</li>
<li>一切正常的话，将远程库与本地库建立关系： <code>git remote add test git@ubuntu_server:/home/git/myRep.git</code>。这边的 test 为远程库的名称，默认一般为 origin，但如果你一个项目中同时有多个库，则建议你修改 origin 名称。</li>
<li><code>git remote –v</code>，可查看版本库的网址，以及相关的库名称</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-29-git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/DeepinScrot-1126.png" alt=""></p>
<ul>
<li>可以通过 <code>git push test master</code> 进行推送，注意这边远程库名为test而并不是默认的origin。也可以通过<code>git pull test master</code>对虚拟机中的远程库进行拉取。<em>注意因为不是默认名称，所以直接使用 git  push 或者 pull 会报错。</em></li>
</ul>
<p><strong>注意严格按照上面步骤执行，git 操作，一步错，可能就需要你删除 .git 以及 git remote remove test 等相关系列的操作，或者可以删除整个目录重新开始。值得注意的是， git 建立出来的每个库是相互独立的，除非全局设置，否则在添加远程库或者修改其他设置时，都不会对其他库有任何影响。</strong></p>
<p><strong>建立好库，并且也 push 等操作都成功了，但查看虚拟机中远程库的源文件却发现招不到任何一个文件，事实上， git 远程裸库仅仅保存修改记录和分支，并不是用来查看的，只有当你 clone 或者 pull 之后才可以查看某条分支的完整结构。</strong></p>
<blockquote>
<p>参考链接：<br><a href="http://developer.51cto.com/art/201507/483448.htm" target="_blank" rel="external">http://developer.51cto.com/art/201507/483448.htm</a><br><a href="http://blog.sina.com.cn/s/blog_6ab9984801011k81.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6ab9984801011k81.html</a><br><a href="http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n" target="_blank" rel="external">http://stackoverflow.com/questions/20252294/ssh-could-not-resolve-hostname-hostname-nodename-nor-servname-provided-or-n</a><br><a href="http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html" target="_blank" rel="external">http://www.cnblogs.com/xdzone/archive/2011/03/09/1978327.html</a><br><a href="http://blog.csdn.net/zht666/article/details/9340633" target="_blank" rel="external">http://blog.csdn.net/zht666/article/details/9340633</a><br><a href="http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html</a><br><a href="http://bbs.csdn.net/topics/390158779" target="_blank" rel="external">http://bbs.csdn.net/topics/390158779</a><br><a href="http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/" target="_blank" rel="external">http://blog.163.com/danshiming@126/blog/static/109412748201251211140194/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多个发行版linux使用体验]]></title>
      <url>http://noparkinghere.top/2016/07/27/2016-07-27-%E5%A4%9A%E4%B8%AA%E5%8F%91%E8%A1%8C%E7%89%88linux%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p><em>本文主要记录自己使用多个linux的发行版的一些感受体验，会包括CLI和GUI的一些体验。本文具有一定的主观性，仅供参考。</em></p>
<p>发行版包括：ubuntu，debian，centOS，openSUSE等<br>窗口管理器包括：gnome，kde，awesome等</p>
<a id="more"></a>
<hr>
<p>To be continued…</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 使用体验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[桥接、NAT、Host-only上网方式的区别]]></title>
      <url>http://noparkinghere.top/2016/07/25/2016/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><em>经常使用虚拟机的小伙伴们都遇到过网络链接过程中的各种问题，仔细查看设置会发现有：桥接、NAT、Host-only 等设置，vmware 等虚拟机后还会自动生成vmnet1和vmnet8，初学者可能会一头雾水，为啥只有两个？不是三种模式吗？另外每个模式代表什么？他们又有什么区别？无论是 vmware 还是 vitualbox 这些内容都大同小异，而 vmware 中看起来可能会更加直观些，这边以windows下的安装使用为例，进行深入的详解。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/0.png" alt=""></p>
<p><strong>本文会尽可能详细地总结和罗列出三者的含义和区别，以及虚拟机中该如何配置他们更加合适。</strong></p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接:"></a>桥接:</h3><p>简而言之桥接就是指：<strong>就是通过一台设备（可能不止一个）把几个网络串起来形成的连接</strong>。这边主要介绍虚拟机所采用的桥接方式，虚拟出来的操作系统就像是局域网中的一独立的主机，它可以通过路由器网线访问网内任何一台机器。不过虚拟机需要占用你同一个网段的一个 IP 地址，当且仅当虚拟机和实体机在同一个网段，两者才可以进行通信，如：<em>虚拟机 IP：192.168.1.101，实体机 IP：192.168.1.100</em>。</p>
<p>在桥接模式下，例如在 windows 下使用 vmware 时，明显看到会生成多个虚拟网卡出来，但却没有一个网卡是属于桥接的，原因是虚拟机采用桥接方式时，是不需要虚拟网卡的，这时候<em>虚拟机操作系统和实体机操作系统同时使用真实网卡工作，然后真是网卡发送数据出去，而如果虚拟机发送数据给真实机，则数据流向是：<strong>虚拟机系统-&gt;真实网卡-&gt;路由器-&gt;真实网卡-&gt;实体机系统</strong>，不难看出同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em></p>
<p>通过上述内容发现，桥接必须经过真实网卡和路由器，因此当你的电脑没有链接有线网或者无线网的话，你的实体机是无法和虚拟机进行交互的，即便看起来两者很近也不行。<em>而选用桥接还是 NAT 等方式是在虚拟机软件中选定，进入虚拟的操作系统后，所有的设置和真实电脑没有本质区别，如果路由器允许自动分配 IP 地址，则操作系统设置为自动获取 IP 即可，如果不能自动分配，也可以在操作系统中手动分配 IP 地址。另外值得注意的是</em>某些公司路由器绑定了电脑 mac 地址和 IP 地址，这时候虚拟机中的桥接也相当于一个真实电脑，也需要完成相关的绑定才可以访问网络。*</p>
<p>可以看出：如果你想利用VMware在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。下面举个栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的 wanip 就不理会了，这个 ip 是动态获取的，而一般lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的 ip 是:</div><div class="line"></div><div class="line">A: 192.168.1.100/255.255.255.0,  B: 192.168.1.101/255.255.255.0,  C: 192.168.1.102/255.255.255.0,  D: 192.168.1.103/255.255.255.0</div><div class="line"></div><div class="line">那么虚拟机的 ip 可以设置的 ip 地址是 192.168.1.2-192.168.1.99, 192.168.1.104-192.168.1.254 (网络地址 0 和 1 的除外，再除去 ABCD 四个人的 ip 地址)</div><div class="line"></div><div class="line">那么虚拟机的 ip 地址可以设置为 192.168.1.98/255.255.255.0,设置了这个 ip 地址，ABCD 这四个人就可以通过 192.168.1.98 访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是 192.168.1.1 了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个 dns 服务器，我们可以简单点，把 dns 服务器地址配置为 google 的 dns 服务器 :8.8.8.8，到此，虚拟机就可以上网了。</div></pre></td></tr></table></figure>
<p>综上所述，<em>同一个数据经过网卡在路由器上面绕了一圈又回到了网卡。</em>而虚拟机的桥接也只在其他电脑需要访问你电脑的虚拟机时，或者你虚拟机需要访问其他外部设备时才有相关需求*，一般情况还是建议配置成操作方便使用简单的 NAT 方式。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt=""></p>
<a id="more"></a>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT:"></a>NAT:</h3><p><em>NAT模式实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。虚拟机发送数据给实体机：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统</strong>（可以发现是不经过真实网卡的流程简单很多）；虚拟机访问外网：<strong>虚拟机系统-&gt;虚拟网卡-&gt;实体机系统-&gt;真实网卡-&gt;路由器-&gt;外网</strong> 。</em></p>
<p>虚拟机借助 NAT (网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT 模式中，虚拟机的网卡和真实网卡的网络，不需要在同一个网络，虚拟机的网卡的网段可以理解：路由器所在网段之下的一个子网段。</p>
<p>采用NAT模式最大的优势是虚拟系统接入互联网非常简单，你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可。如果你想利用VMWare安装一个新的虚拟系统，在虚拟系统中不用进行任何手工配置就能直接访问互联网，建议你采用NAT模式。而缺点是： NAT 模式下，虚拟机仅仅可以同路由器下网段中的一台真实机通讯，而这台真实机就是安装虚拟机的这台电脑，之所以可以通讯是因为这台电脑本身充当了虚拟机的路由器，相当于路由器的 192.168.1.1 这个地址，而你在 vmware 下的网卡管理中是可以看到这个地址的。这边再补充一点：<em>采用NAT模式时，虚拟机和实体机交互并不是直接进行的，首先虚拟机操作系统访问虚拟网卡 VMnet8 （地址如： 192.188.1.33），然后这个虚拟网卡会再将数据提交给真实机操作系统VMware Network Adapter VMnet8（地址： 192.188.1.1）而地址（192.188.1.33 和 192.188.1.1）实际都是由虚拟机软件 vmware 提供的，具体的交互细节不作研究。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt=""></p>
<h3 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only:"></a>Host-only:</h3><p>在 Host-Only 模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实 Host-Only 网络和 NAT 网络很相似，不同的地方就是 Host-Only 网络没有 NAT 服务，所以虚拟网络不能连接到 Internet 。主机和虚拟机之间的通信是通过 VMware Network Adepter VMnet1 虚拟网卡来实现的。</p>
<p>Host-Only 的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为 VMnet1 网段提供路由功能，那就需要使用RRAS，而不能使用 XP 或 2000 的 ICS，因为 ICS 会把内网的 IP 地址改为 192.168.0.1，但虚拟机是不会给 VMnet1 虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/3.png" alt=""></p>
<h3 id="windows下的vmware："><a href="#windows下的vmware：" class="headerlink" title="windows下的vmware："></a>windows下的vmware：</h3><p>VMware 的几个虚拟设备：</p>
<ul>
<li>VMnet0：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；</li>
<li>VMnet1：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；</li>
<li>VMnet8：这是 VMware 用于虚拟NAT网络下的虚拟交换机；</li>
<li>VMware Network Adapter VMnet1：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；</li>
<li>VMware Network Adapter VMnet8：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-25-%E6%A1%A5%E6%8E%A5%E3%80%81nat%E3%80%81host-only%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/4.png" alt=""></p>
<p><em>事实上，根据上面对三种常见模式的详细，基本上应该已经有了清晰的认识，知道如何配置虚拟机网卡了。</em></p>
<h3 id="配置建议："><a href="#配置建议：" class="headerlink" title="配置建议："></a>配置建议：</h3><p>在普通常规虚拟机联网时，采用 NAT 的模式，一般 virtualbox 中默认就为该模式，也默认就帮设置好了网络，用户直接安装完虚拟机操作系统即可上网，如果不行通过安装相关扩展工具即可。如果不小心将如上图所示的Virtual Network Editor 中的内容或者第一张图所示中的网卡配置改乱了，则可以点击上图左下角的 Restore Default 恢复网络设置。</p>
<p>需要特殊使用情况，虚拟机需要连接其他实体设备时，采用桥接模式，需要注意的是：如果路由器无法自动分配IP地址，桥接需要配置 IP 地址，先查看网关地址，然后找一个无法 ping 通的 IP 地址，设置成静态 IP。</p>
<p>Host-only 模式暂时没有怎么用过，一般而言就是为了只让虚拟机和实体机链接使用，也为了屏蔽外部网络的干扰，创建一个纯净的内部实验环境，如果你需要在虚拟机中构建一台服务器，实验搭建服务环境的话，可以先设置成这种模式。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/bloghome/article/details/4487497" target="_blank" rel="external">http://blog.csdn.net/bloghome/article/details/4487497</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html</a><br><a href="http://os.51cto.com/art/201003/186914.htm" target="_blank" rel="external">http://os.51cto.com/art/201003/186914.htm</a><br><a href="http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html" target="_blank" rel="external">http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 问题总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[githubpage+jekyll搭建博客]]></title>
      <url>http://noparkinghere.top/2016/07/21/2016/2016-07-21-githubpage-jekyll%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>使用 githubpage+jekyll 搭建博客也有半年时间了，这篇文章早该写好，但一致迟迟没有下笔。怎么说呢，githubpage+jekyll 搭建博客的静态博客，操作起来可视化成都较低，缺少 wordpress 等知名博客酷炫的管理后台，也很少能够找到炫酷的模板（文章下方链接给出了 jekyll 的一些模板），以上缺点也是显而易见，简而言之就是 jekyll 的界面丑陋用起来麻烦。但因为 githubpage 是 jekyll 提供的服务，所以好处就是 jekyll 文件无需每次本地编译，直接 push 到 github 上面，就可以生成页面，另外本地也会同时保存一份完整的源文件，书写时只需要按照 markdown 语法码字，更换平台博客搬家更是轻松。</p>
<a id="more"></a>
<hr>
<p><em>本来是打算自己写一些文章的，但由于网上有关这一块的博客内容都已经极为详细，因此不再另外累述，详细可以参考下方链接。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/" target="_blank" rel="external">http://www.perfectlyrandom.org/2014/06/29/adding-disqus-to-your-jekyll-powered-github-pages/</a><br><a href="http://jekyll.com.cn/" target="_blank" rel="external">http://jekyll.com.cn/</a><br><a href="http://playingfingers.com/2016/03/26/build-a-blog/" target="_blank" rel="external">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href="https://github.com/jekyll/jekyll/wiki/sites" target="_blank" rel="external">https://github.com/jekyll/jekyll/wiki/sites</a><br><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html</a><br><a href="http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">http://www.cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> githubpage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows7安装详解]]></title>
      <url>http://noparkinghere.top/2016/07/16/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><em>早在上学时,就安装过很多次win7,老是说,win7出了略微的比xp多占用了点资源外,确实好用。外观美观，性能也算不错。</em></p>
<h3 id="windows-7简介："><a href="#windows-7简介：" class="headerlink" title="windows 7简介："></a>windows 7简介：</h3><p>Windows 7 是由微软公司（Microsoft）开发的操作系统，版本有：入门版（Starter）、家庭普通版（Home Basic）、家庭高级版（Home Premium）、专业版（Professional）、企业版（Enterprise）（非零售）、旗舰版（Ultimate）。Windows 7 的设计主要围绕五个重点——针对笔记本电脑的特有设计；基于应用服务的设计；用户的个性化；视听娱乐的优化；用户易用性的新引擎。 跳跃列表，系统故障快速修复等，这些新功能令Windows 7成为比较美观易用的操作系统。</p>
<h3 id="必要的软件下载："><a href="#必要的软件下载：" class="headerlink" title="必要的软件下载："></a>必要的软件下载：</h3><ul>
<li>[windows 7 64位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</code></li>
<li>[windows 7 32位]<br><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/</code></li>
<li><a href="https://pan.baidu.com/s/1o8GRTb0" target="_blank" rel="external">大白菜windows PE</a></li>
<li><a href="https://pan.baidu.com/s/1micuzrE" target="_blank" rel="external">驱动精灵2015网卡版</a></li>
</ul>
<a id="more"></a>
<h3 id="windows-PE安装步骤："><a href="#windows-PE安装步骤：" class="headerlink" title="windows PE安装步骤："></a>windows PE安装步骤：</h3><ul>
<li>安装软件</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-53-18.png" alt="1"></p>
<ul>
<li><p>点击上图中的<em>请选择</em>，选中你的优盘，<strong>注意一定要是格式化的优盘，看大小和名称，千万不能选错，否则里面数据会全部丢失</strong>。</p>
</li>
<li><p>选中后直接点击一键制作usb启动盘，其他不需要修改，同图上即可。</p>
</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_10-54-24.png" alt="2"></p>
<ul>
<li>等待5分钟左右的时间，制作完成，弹出的提示信息点击否。</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/BaiduShurufa_2016-7-18_11-23-6.png" alt="3"></p>
<ul>
<li>到这边，优盘的PE制作则已经完成。</li>
</ul>
<h3 id="PC引导设置："><a href="#PC引导设置：" class="headerlink" title="PC引导设置："></a>PC引导设置：</h3><p>UEFI :这边不讨论 UEFI 下的安装，如果你的电脑设置为了 UEFI，则直接在改成传统设置。</p>
<p><strong>BIOS:传统设置，在主板中改成Legacy BIOS，则切换到这个模式。</strong></p>
<h4 id="BIOS下的设置步骤："><a href="#BIOS下的设置步骤：" class="headerlink" title="BIOS下的设置步骤："></a>BIOS下的设置步骤：</h4><ul>
<li>方法1：可以在 BIOS 中设置启动顺序，将优盘 HDD 或者你的优盘名称对应的那个选项移到最上方。</li>
<li>方法2：如果电脑开启了快速启动的选项，则可以一键选择引导的盘符，例如戴尔的一般是 F12 选项。</li>
</ul>
<h3 id="系统分区操作"><a href="#系统分区操作" class="headerlink" title="系统分区操作"></a>系统分区操作</h3><p><em>分区涉及到的学问很多，对于一个系统来说分区以及文件系统类型很重要。</em></p>
<p><em>这边以windows系统为例，大概简单介绍下：</em><br><strong>windows 系统现在主要使用的是 ntfs 和 fat32 两种格式，fat32 在大文件传输，以及分区容量多有限制，但是兼容性较好，所以我们优盘就格式化成了 fat32 格式。而 ntfs 格式现在 PC 上面普遍选用这种格式，我们的系统也会格式化成这种格式。</strong></p>
<h4 id="进入windowsPE系统"><a href="#进入windowsPE系统" class="headerlink" title="进入windowsPE系统"></a>进入windowsPE系统</h4><ul>
<li>安装时选择 12. 安装原版 win 系统</li>
<li>再选择 04. 进去后使用点击安装</li>
<li>进入 windows PE 系统</li>
</ul>
<h4 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h4><ul>
<li>前提是确保已经进入了 windows PE 系统之后。</li>
<li>打开桌面上的分区工具，可以使用推荐分区方式，建议所有软件都安装在 C 盘。</li>
<li>新建分区，点击<strong>快速分区</strong></li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111Z2E6.jpg" alt="新建分区"></p>
<ul>
<li>在弹出的窗口中选择“分区数目”，在高级设置中可以设置磁盘格式、大小、卷标以及主分区，修改完成后点击“确定”即可；如下图所示：（注意分区的大小，按照我上面提出的第一个是主分区至少40G，文件系统为NTFS，如果是总大小为120G的固态硬盘，可以只分两到三个区，对齐分区到此扇区的倍数选择4096。）</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411191b25.jpg" alt=""></p>
<ul>
<li>接着系统会弹出警告的提示窗口，我们确认无误后，单击“是”即可；如下图所示：</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G411193B09.jpg" alt=""></p>
<ul>
<li>接下来系统会自动的进行格式化分区。</li>
</ul>
<p><img src="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-16-windows7%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/2-140G4111953b7.jpg" alt=""></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">安装在 C 盘的原因：如果重装系统的话，很多软件虽然仍然能用，但未必用起来稳定，加上软件默认的安装位置也是 C 盘，下次如果升级不注意可能会装重复，较少一部分软件是只能安装在C盘使用的，现在硬盘容量大，和系统装在一起不会有影响，另外重装系统的时候格 C 盘可以一次性清理干净,总而言之，个人认为装在C盘较好。（32 位 win7 的 C 盘分区在 40G 左右，64 位 win7 的 C 盘分区为 50-60G）。</div><div class="line"></div><div class="line">一般分区最多为 4 个分区，但后续的分区表中仍然能够存储其他分区，所以并不仅仅限于 4 个。windows 下的分区多半是一个主分区，和一个扩展分区，注意主分区就是 C 盘，用来安装操作系统的，扩展分区就是所有其他盘的总和，扩展分区是不可以直接使用的，因此分完扩展分区后，需要进一步将扩展分区分成多个逻辑分区，值得注意的是主分区可以有最多四个，但扩展分区有且只能有一个。</div><div class="line"></div><div class="line">格式化的时候扇区大小选择 4096，根据某些测评机构的数据，现在操作系统尤其是 windows 以及固态硬盘的情况下 4K 对齐能够有效的提升硬盘的各种性能。4K 对齐意味这大文件占用更少的扇区个数，数据在检索读取时往往会更快，但这无疑也是一种牺牲空间来换取时间的结果。</div></pre></td></tr></table></figure>
<h3 id="正式安装windows-7系统"><a href="#正式安装windows-7系统" class="headerlink" title="正式安装windows 7系统"></a>正式安装windows 7系统</h3><p><em>在 windowsPE 的环境下，且确定以上操作都没有错误的话，这一步反而是最简单的一步</em></p>
<ul>
<li>将下载好了的 windows 镜像文件复制到你刚刚分区完的电脑中，<strong>一定要复制过去，不能通过优盘加载读取，另外复制在除了 C 盘以外的任意盘上面。</strong></li>
<li>安装方法1：复制完成后，直接双击这个文件，windows PE 会自动加载，这时候回到根目录会看到多出了一个类似光盘的盘，点击进入，然后找到可执行文件双击打卡，按照步骤一步步安装即可。</li>
<li>安装方法2：使用大白菜 PE 装机工具，浏览到选择哪个 windows 镜像文件，选择 C 盘点击确定即可。</li>
<li>系统会重启两次，这个过程不用过分担忧。大约 10-20 分钟后，系统自动安装完成。</li>
</ul>
<p><em>如果以上操作不能完成，可以参考该<a href="http://www.dabaicai.tv/videos/2015/0424/941.html" target="_blank" rel="external">视频</a></em></p>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><p><em>对于一个系统而言，固然应用软件很重要，但它们都依赖于一个良好的驱动环境。</em>刚装完的windows，尤其我们安装的是纯净版，这时候缺少很多驱动程序，可能上不了网，也显示效果很差，下面我们一一来解决。</p>
<ul>
<li>安装我们上面提供的驱动精灵完整版，安装完后进行一次检查，它会帮你自动更新你的网卡驱动。（不排除特殊超极本仍然没法更新驱动，这时候使用能够联网的电脑，去官网搜索型号，下载最新网卡驱动。）</li>
<li>如果第一步能够解决上网问题，则进行这一步，使用驱动精灵联网更新驱动，必备的驱动是 intel 组件，网卡驱动以及显卡驱动，这边推荐再安装更新一个 usb 驱动，如果你的键盘比较特殊也可以更新键盘驱动，其他驱动看个人喜好而定。</li>
</ul>
<p><strong>至此整个的windows 7安装基本写完，如果不是很清晰的，后续可能会补充说明。</strong></p>
<hr>
<blockquote>
<p><a href="http://www.dabaicai.tv/" target="_blank" rel="external">http://www.dabaicai.tv/</a><br><a href="http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra" target="_blank" rel="external">http://baike.baidu.com/link?url=AcECxARhjvZl-2381l31s4okBHXbuwj-GMoeTeKF_O-oqOVU2ESvN94HpOZ2xOEpCsEljGO1KUybDtqUeE4kra</a><br><a href="http://www.laomaotao.org/lmtjc/245.html" target="_blank" rel="external">http://www.laomaotao.org/lmtjc/245.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 系统安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）github_markdown]]></title>
      <url>http://noparkinghere.top/2016/07/15/2016/2016-07-05-%EF%BC%88%E8%BD%AC%EF%BC%89github_markdown/</url>
      <content type="html"><![CDATA[<p><em>本内容主要例举了github适用的markdown语法，类似于基于基础markdown定制的语法特性，并非适用于所有的其他markdown编辑器，尤其是下述表情包基本上其他编辑器都不一定能够支持，本人使用的是atom外加一些github的插件，基本能够显示大多数内容，但仍由部分不能支持，另外本文的主要适用范围：<strong>在新建项目工程，书写readme时使用，其他如github page或者其他一些站点的markdown页面请勿参考本文。</strong></em></p>
<h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a><a href="https://github.com/guodongxiaren/README" target="_blank" rel="external">实现效果</a></h4><a id="more"></a>
<h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/guodongxiaren" target="_blank" rel="external">源码地址</a></h4><hr>
<blockquote>
<p>参考链接：<br><a href="https://github.com/guodongxiaren/README" target="_blank" rel="external">https://github.com/guodongxiaren/README</a> （正文原始地址）<br><a href="https://raw.githubusercontent.com/noparkinghere/README/master/README.md" target="_blank" rel="external">https://raw.githubusercontent.com/noparkinghere/README/master/README.md</a><br><a href="http://blog.csdn.net/wqvbjhc/article/details/27349209" target="_blank" rel="external">http://blog.csdn.net/wqvbjhc/article/details/27349209</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[atom使用总结]]></title>
      <url>http://noparkinghere.top/2016/07/15/2016/2016-07-15-atom%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Atom 是 Github 出的一款免费跨平台的 IDE，软件 15 年发布，至今时间较短，国内有一些文章或者帖子介绍该软件，但为数不多。笔者最初写也只是为了写文章而想在 linux 下找一款友好的 markdown 编辑器，翻阅了很多都不尽如人意，最后无意中发现了这款软件。Atom 的特点简而言之就是功能强大，但启动速度慢，如果你是 ssd 的话，这基本上没什么影响。<em>文章最下方的参考链接都写的比较详细，值得拿来参考阅读。</em></p>
<h3 id="Atom简介："><a href="#Atom简介：" class="headerlink" title="Atom简介："></a>Atom简介：</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-15-atom使用总结/1.png" alt=""></p>
<p>Atom 是 github 专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持 CSS，HTML，JavaScript 等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。继承了 SublimeText 和 vim 的众多优点（除了占用资源，和开启速度慢，当然现在内存越来越不值钱，以及固态硬盘速度奇快，这些都会是问题），很大程度上不仅如此。据称，在目前 IDE 如此之多的情况下，开发这个软件是为了替代 vim（当然这么宣传也可能只是噱头，但 atom 确实扩展性强且容易配置），让更新更优秀的功能能够被体验，因此事实上 Atom 这款软件中是包含了 vim 模式的，当然用惯了 vim 的大神未必服。另外 Atom 在 web 前端相当出名，基本来说具备 SublimeText 的大多数功能，且更加现代化无广告，你无限将其配置成任何你需要的环境（如：C/C++ 开发环境，python 开发环境，markdown 写作软件等等），可见，现在学习使用这款软件无论是功能性能还是面向将来都是值得的。</p>
<p>这边给出几个最主要的链接：<a href="https://atom.io/" target="_blank" rel="external">atom官网</a>，<a href="https://atom.io/packages" target="_blank" rel="external">atom插件中心</a>，<a href="http://flight-manual.atom.io/" target="_blank" rel="external">atom官方手册英文版</a>，<a href="https://atom-china.org/" target="_blank" rel="external">atom中文社区</a>，<a href="https://github.com/atom/atom" target="_blank" rel="external">atom源码</a>。</p>
<h3 id="快捷键的使用"><a href="#快捷键的使用" class="headerlink" title="快捷键的使用:"></a>快捷键的使用:</h3><p>atom 的很多操作方式都和 chrome 等软件类似，如果习惯使用这些软件的人会觉得很得心应手，例如：ctrl+w 关闭标签页，ctrl+shift+t 重新打开之前关闭的标签等等。</p>
<p>ctrl+.  :  调用按键查看器<br>ctrl+\  :  文件目录结构管理<br>ctrl+,  :  setting设置<br>ctrl-shift-M : Markdown预览</p>
<a id="more"></a>
<h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><p>使用快捷键 ctrl+, 打开 setting 设置，左侧的最下方可以看到 Open Config Folder，在这里如果你对 atom 有比较深入的理解，完全可以修改所有的配置参数。如： packages 中一般存放了你自己安装插件的全大多数文件，而像 keymap.scon 中则可以设置自己需要的快捷键。</p>
<p>可以说极少有 IDE 能够像 atom 直接开放出这么多的定制功能，但能够使用他们的前提是你对它足够的了解，所以最好的途径还是去仔细阅读官方手册。</p>
<h3 id="插件指南："><a href="#插件指南：" class="headerlink" title="插件指南："></a>插件指南：</h3><p>有关 atom 的插件，可以使用 settings 中的自带搜索安装，也可以使用 apm install “packages” 安装插件，使用 apm remove “packages” 删除插件，所有的 package 一般都会有很详细的安装说明，注意仔细研读，一般推荐使用 apm install “packages” 方式安装插件，同时我们可以使用 apm update 进行插件的升级。</p>
<p>考虑到伟大的 GFW，部分通过上面两种方法还是无法安装的小伙伴，可以访问<a href="https://atom.io/packages" target="_blank" rel="external">atom插件中心</a>，需要找到插件在git上的下载地址（如果 atom 插件中心也无法访问，则直接去 github 上搜索）。将项目下载下来，解压后，文件夹移动到 <code>yourpath/.atom/packages/</code> 下，打开到该插件文件夹目录下，在该目录下执行 <code>apm install</code> ，之后你就可以在插件管理中看到新的插件出现了。</p>
<p>值得注意的是，各个插件虽然功能强大，但是也都会对 atom 进行一些定制，一些插件可能同事占用了某个快捷键，本身有冲突，所以在使用插件时，需要看一下里面的配置以及官方的说明，<strong>难能可贵的是：所有插件安装后都可以点击插件名打开相关网页，上面附带有详细的帮助和使用说明，另外你也可以直接在<a href="https://atom.io/packages" target="_blank" rel="external">官方网址</a>搜索自己想要的插件。</strong></p>
<ul>
<li><a href="https://atom.io/packages/sync-settings" target="_blank" rel="external">Sync-setttings</a> (插件-备份神器),可以将你配置的atom环境备份到github上面，换电脑时，可以方便移植。自带的说明写的相当详细，注意<em> new personal access token 中激活 Gist -&gt; create gists，但最好其他选项都不要打开，可能会引起插件无法读取加载。具体原因不明，如果你知道请在下面留言，或者发邮件给博主。</em></li>
<li><a href="https://atom.io/packages/activate-power-mode" target="_blank" rel="external">activate-power-mode</a> 貌似真没有什么实际作用，但的的确确是个装逼必备的神器，效果酷炫。</li>
<li><a href="https://atom.io/packages/vim-mode" target="_blank" rel="external">vim-mode</a>，顾名思义是在 atom 下使用 vim 一些操作。由于本人不是很精通 vim，只会一些正常的按键操作，所以作为日常编辑时，感觉还行。但这个插件用的应该不是太多，毕竟是 atom 官方的插件，但却要手动安装下载。</li>
<li>autocomplete-paths:文件路径自动提示。</li>
<li>gpp-compiler:C/C++ 的编译器，可以通过快捷键直接调用这些功能，让atom成为一款真正的 C 开发环境。</li>
<li>markdown-writer：书写 markdown 的强化工具</li>
<li>markdown-scroll-sync：目前最佳的 markdown 预览工具</li>
<li>python-tools：python 辅助开发工具</li>
</ul>
<p><strong>注意：同样的插件可能在 windows 和 linux 下的支持是不一样的，部分插件只支持 windows ，部分插件在 linux 中可能功能会更多，具体要参见开发者写的插件说明。</strong></p>
<h3 id="windows下的安装"><a href="#windows下的安装" class="headerlink" title="windows下的安装"></a>windows下的安装</h3><p>atom 的强大就在于跨平台的使用，可以让你在不同的平台有着几乎一样的编程体验。windows 下的安装大致可以分为两个版本，一个是 .exe/.msi 安装方式，需要.net工具包才能顺利安装，另外也可以下载解压包，可以免安装直接使用。</p>
<p>在dos 下通过cmd命令安装插件：</p>
<ul>
<li>打开 dos 窗口 window 可用快捷键 win+r  再输入cmd</li>
<li>输入 apm install “packages” 如果 apm 不能识别请用 npm install “packages”。</li>
</ul>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="failed-to-activate-the-package-cannot-find-module-“loe-random”"><a href="#failed-to-activate-the-package-cannot-find-module-“loe-random”" class="headerlink" title="failed to activate the package : cannot find module “loe.random”"></a>failed to activate the package : cannot find module “loe.random”</h4><p>执行 npm install loe.random（你缺失哪一个 module，你就用那个 module 替代代码中的位置）</p>
<h4 id="一行内容书写过多，阅读不方便，无法自动缩转到下一行。"><a href="#一行内容书写过多，阅读不方便，无法自动缩转到下一行。" class="headerlink" title="一行内容书写过多，阅读不方便，无法自动缩转到下一行。"></a>一行内容书写过多，阅读不方便，无法自动缩转到下一行。</h4><p>插件 language text 中的 soft wrap 等相关选项。</p>
<hr>
<p><em>补充：目前我主要使用 atom 写一些 markdown 文章，其他的一些操作都是偶尔使用，程序调试等还是会借助其他专门的 IDE，atom 的一些功能特性还没有全部摸清，后续有新的发现还会再补充。</em></p>
<p>To be continued…</p>
<blockquote>
<p>参考链接（建议查看，很多内容文章没复述）：<br><a href="http://www.07net01.com/2015/08/893825.html" target="_blank" rel="external">http://www.07net01.com/2015/08/893825.html</a><br><a href="http://www.jianshu.com/p/dd97cbb3c22d" target="_blank" rel="external">http://www.jianshu.com/p/dd97cbb3c22d</a><br><a href="http://www.jianshu.com/p/508d540ca9c3" target="_blank" rel="external">http://www.jianshu.com/p/508d540ca9c3</a><br><a href="http://www.hackbase.com/article-206939-1.html" target="_blank" rel="external">http://www.hackbase.com/article-206939-1.html</a><br><a href="http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;" target="_blank" rel="external">http://www.hackbase.com/portal.php?mod=view&amp;aid=206939&amp;page=1&amp;</a><br><a href="http://www.jianshu.com/p/55d6cbc175a9" target="_blank" rel="external">http://www.jianshu.com/p/55d6cbc175a9</a><br><a href="https://www.zhihu.com/question/22867204" target="_blank" rel="external">https://www.zhihu.com/question/22867204</a><br><a href="http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html" target="_blank" rel="external">http://jingyan.baidu.com/article/375c8e19c3105a25f2a22901.html</a><br><a href="http://www.cnblogs.com/20145221GQ/p/5334762.html" target="_blank" rel="external">http://www.cnblogs.com/20145221GQ/p/5334762.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Caps_Lock与右Ctrl互换]]></title>
      <url>http://noparkinghere.top/2016/07/14/2016/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p><em>实现该功能的目的主要是切换中英文输入法，在使用 ctrl 或者 shift 切换时，很明显这两个键的位置远不如caps按起来方便，且 shift 往往作为大小写功能使用，用来作为切换中英文输入会恨混乱，而 caps 作为大小写时用起来相当罕见，作为中文输入来说更可以说完全是鸡肋的功能。大写完全可以用 shift 代替的用户群中，无疑是占用了一个最好的位置，却几乎完全被遗忘的一个按键。下面将会总结一个既保留 Caps_Lock 键功能，又可以充分利用这个最好位置的按键映射方法。</em></p>
<h3 id="linux系统下的实现"><a href="#linux系统下的实现" class="headerlink" title="linux系统下的实现"></a>linux系统下的实现</h3><h4 id="按键值查询"><a href="#按键值查询" class="headerlink" title="按键值查询"></a>按键值查询</h4><p>linux 下可以通过命令小程序对绝大多数按键值进行查找，要想修改键值映射, 先要知道按键的键值. 用如下命令查看: <code>xev | grep keycode</code>。</p>
<p>同时我们可以查看需要映射的按键的映射名称：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">例如, 执行命令查看 Menu 键相关的按键名:</div><div class="line"></div><div class="line">xmodmap -pke | grep menu -i</div><div class="line">显示结果为:</div><div class="line"></div><div class="line">keycode 135 = Menu NoSymbol Menu</div><div class="line">keycode 147 = XF86MenuKB NoSymbol XF86MenuKB</div></pre></td></tr></table></figure>
<p>比如想把键盘的右边的 Alt 改为 Menu : <code>xmodmap -e &quot;keycode 108=Menu&quot;</code>，简而言之 xmodmap 程序就是用来控制系统按键的，需要详细了解这个软件的操作，可以查看帮助文档。</p>
<a id="more"></a>
<h4 id="将Caps-Lock和键盘右边的Ctrl调换"><a href="#将Caps-Lock和键盘右边的Ctrl调换" class="headerlink" title="将Caps_Lock和键盘右边的Ctrl调换"></a>将Caps_Lock和键盘右边的Ctrl调换</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">remove Lock = Caps_Lock</div><div class="line">remove Control = Control_R</div><div class="line">keysym Control_R = Caps_Lock</div><div class="line">keysym Caps_Lock = Control_R</div><div class="line">add Lock = Caps_Lock</div><div class="line">add Control = Control_R</div></pre></td></tr></table></figure>
<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效。实际上，每次开机启动后，系统会通过 xmodmap 程序自动加载 .Xmodmap 程序，也就是一次创建更改 .Xmodmap 文件，终身配置有效。</p>
<p><strong>注意:完成上述步骤即可，以下步骤为最初设置时,出现的问题,可以忽略不看。</strong></p>
<h4 id="加入开机自启"><a href="#加入开机自启" class="headerlink" title="加入开机自启"></a>加入开机自启</h4><p>同大多数开机自启并没有太大区别，将<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>写入到 /etc/rc.local 中即可。该方法经常失效，不是太灵验，因此我设置了快捷键 ctrl+space ，每次按下这个快捷键时，会自动执行<code>xmodmap ~/.xmodmap  2&gt;/dev/null</code>。</p>
<p>解决:由于上面命名错误, .Xmodmap 文件的首字母是大写，因此加载总是出错，另外使用 <code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code> 命令后，每次无需再加入启动项了，一次配置成功即可。</p>
<h3 id="windows下的更换按键"><a href="#windows下的更换按键" class="headerlink" title="windows下的更换按键"></a>windows下的更换按键</h3><p>打开注册表，在运行（win+R）中输入 regedit ，注册表位置：[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]  （注意： KeyBoard Layout, 而不是 KeyBoard Layouts）如果没有此键，就新建一个二进制值的 Key，名叫： Scancode Map（注意名称不能够写错，错一个字母都没法实现功能）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入如下的值：</div><div class="line">　　00,00,00,00</div><div class="line">　　00,00,00,00</div><div class="line">　　03,00,00,00</div><div class="line">　　3A,00,1D,E0</div><div class="line">　　1D,E0,3A,00</div><div class="line">　　00,00,00,00</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-14-Caps_Lock%E4%B8%8E%E5%8F%B3Ctrl%E4%BA%92%E6%8D%A2/BaiduShurufa_2016-8-10_14-5-24.png" alt=""></p>
<h4 id="windows-各个键位值的参考："><a href="#windows-各个键位值的参考：" class="headerlink" title="windows 各个键位值的参考："></a>windows 各个键位值的参考：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">　　Escape 01 00</div><div class="line">　　Tab 0F 00</div><div class="line">　　Caps Lock 3A 00</div><div class="line">　　Left Alt 38 00</div><div class="line">　　Left Ctrl 1D 00</div><div class="line">　　Left Shift 2A 00</div><div class="line">　　Left Windows 5B E0</div><div class="line">　　Right Alt 38 E0</div><div class="line">　　Right Ctrl 1D E0</div><div class="line">　　Right Shift 36 00</div><div class="line">　　Right Windows 5C E0</div><div class="line">　　Backspace 0E 00</div><div class="line">　　Delete 53 E0</div><div class="line">　　Enter 1C 00</div><div class="line">　　Space 39 00</div><div class="line">　　Insert 52 E0</div><div class="line">　　HOME 47 E0</div><div class="line">　　End 4F E0</div><div class="line">　　Num Lock 45 00</div><div class="line">　　Page Down 51 E0</div><div class="line">　　Page Up 49 E0</div><div class="line">　　Scroll Lock 46 00</div></pre></td></tr></table></figure>
<p>以上 windows 的按键更改仅在 windows 7 下实验过，其他系统有待验证。</p>
<blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/xiaobaibuhei/p/3629133.html" target="_blank" rel="external">http://www.cnblogs.com/xiaobaibuhei/p/3629133.html</a><br><a href="http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/" target="_blank" rel="external">http://hanjc.me/post/2015-09-14-win7-exchange-capslock-and-ctrl/</a><br><a href="http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html" target="_blank" rel="external">http://www.mikewootc.com/wiki/linux/usage/linux_xmodmap_change_keyboard_map.html</a><br><a href="http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html" target="_blank" rel="external">http://baohaojun.github.io/blog/2015/01/12/0-How-to-swap-Escape-and-Caps-Lock-on-mainstream-PCs.html</a><br><a href="http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html" target="_blank" rel="external">http://www.xiaozhou.net/exchange_ctrl_and_capslock_key-2012-07-20.html</a><br><a href="http://xahlee.info/kbd/linux_make_capslock_esc_key.html" target="_blank" rel="external">http://xahlee.info/kbd/linux_make_capslock_esc_key.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jlink相关问题汇总]]></title>
      <url>http://noparkinghere.top/2016/07/12/2016/2016-07-12-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<h3 id="jlink简介"><a href="#jlink简介" class="headerlink" title="jlink简介"></a>jlink简介</h3><h3 id="MDK如何让jlink不跳出升级"><a href="#MDK如何让jlink不跳出升级" class="headerlink" title="MDK如何让jlink不跳出升级"></a>MDK如何让jlink不跳出升级</h3><p>有三种方法(注意盗版的 jlink 谨慎升级),推荐方法3。</p>
<ol>
<li>升级 Keil 自带的 J-link 程序,新版本 jlink 的一般盗版的 v8 都没法直接升级。</li>
<li>使用之前版本 keil 自带的 J-link 驱动替换掉现在的,也就是将 ..\Keil\ARM\Segger 文件夹替换为老版本的,这样里面的 J-Link 驱动也是老版本的,就不会提示 J-Link 更新了,这种需要有之前的 keil 才可以,如果是直接安装新版的 keil 5 默认自带为 4.8 的版本。</li>
<li>卸载 segger，下载了比较新的驱动重新安装，并将 segger/jlinkarm_v440 目录下的 jlinkarm。dll 拷贝到 keil/arm/segger 的目录下。再次使用 MDK，提示升级，确定升级，但这次升级后，jlink 确实可以识别。这个版本需要注意的是 jlink 的版本必须在 4.4 以后(如 4.1x 的复制 jlinkarm.dll 软件会出错),另外复制前做好 jlinkarm.dll 的备份。</li>
</ol>
<a id="more"></a>
<h3 id="JLINK刷固件步骤"><a href="#JLINK刷固件步骤" class="headerlink" title="JLINK刷固件步骤"></a>JLINK刷固件步骤</h3><p><em>如果通过上面的方法,结果盗版jlink变板砖了,可以使用下面方法重新烧录固件。</em></p>
<h4 id="清除原有固件-烧录新固件"><a href="#清除原有固件-烧录新固件" class="headerlink" title="清除原有固件,烧录新固件"></a>清除原有固件,烧录新固件</h4><ul>
<li>下载安装提供的相关软件: jlink, Install AT91-ISP v1.13, 以及固件。</li>
<li>按照说明文档一步步操作,烧录固件,<strong>步骤先后顺序一定要完全一致,如果失败则重复多次</strong>。<a href="https://github.com/noparkinghere/blog.github.io/raw/gh-pages/_post/2016/2016-07-13-jlink%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/JLinkV8%E5%9B%BA%E4%BB%B6%E7%83%A7%E5%BD%95%E6%8C%87%E5%AF%BC.pdf" title="JLinkV8固件烧录指导" target="_blank" rel="external">JLinkV8固件烧录指导</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### 升级方法:</span></div><div class="line">- 使用XP的环境, win7 大多都不行。</div><div class="line">- 打开 jLink <span class="built_in">command</span> 软件,注意不要升级固件。</div><div class="line">- 在命令行下输入: Exec SetSN=XXXXXXXX  回车。**注：XXXXXXXX 为你自己想要的 SN,SN 必须是8个数字。**</div><div class="line">- 关闭 jLink <span class="built_in">command</span> 软件再从新打开。即可生效。</div><div class="line">*注意:只能设置一次 SN,设置前请想好你的SN。*</div><div class="line"></div><div class="line">然后就可以正常升级了。</div></pre></td></tr></table></figure>
<h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><h4 id="MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！"><a href="#MDK-用-JTAG-仿真器下载代码时，提示-cannot-load-flash-device-description！" class="headerlink" title="MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！"></a>MDK 用 JTAG 仿真器下载代码时，提示 cannot load flash device description！</h4><ul>
<li>如果 jlink 链接没有问题,且能够找到芯片的话,一般为 flash programming algorithm 丢失。<br><a href="http://www.openedv.com/posts/list/50048.htm" target="_blank" rel="external">参考网址 </a></li>
</ul>
<blockquote>
<p>参考链接:<br><a href="http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu" target="_blank" rel="external">http://zhidao.baidu.com/link?url=jM6YRhn1aPQe7uPfdmIDP9-_k4Hl8XTWvAnBMJV0TE176gUBb5kGXK_XksirP6xdXkUkMofUD5YIhrNbYTxiBBQpSKZ_4QJWjj64vJT7xXu</a><br><a href="http://www.openedv.com/posts/list/50048.htm" target="_blank" rel="external">http://www.openedv.com/posts/list/50048.htm</a></p>
</blockquote>
<hr>
<p>TO be continued…</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vpn服务]]></title>
      <url>http://noparkinghere.top/2016/07/12/2016/2016-07-12-vpn%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>这篇文章的初稿是在一年前写的，今天简书通知我之前上传的一篇有关 ss 的文章竟然被强制下架了，让我突然想起以前写过这样一篇文章，ss 在国内查封的十分严重，百度几乎找不到任何有关的内容，而 VPN 在市面上算是广为流传，今天（2017-03-20）再次把文章拿出来总结下。</p>
<p>由于众所周知的原因，国内用户被强大的 GFW 保（lan）护（jie）而无法访问外网，或者即便可以访问，也会遇到访问速度慢，网页无法刷新等问题。因此如果你要访问谷歌，Facebook，需要去国外厂家查找某方面的资料等，就一定需要学会翻墙上网，该方面的能力甚至已经算是软件从业/科研人员的基本素养，因此一般也将翻墙称作科学上网。本文主要介绍使用付费 VPN 的方式来绕过 GFW 的过滤，让小伙伴们能够轻松畅游天地，无拘无束。</p>
<h3 id="推荐-VPN"><a href="#推荐-VPN" class="headerlink" title="推荐 VPN"></a>推荐 VPN</h3><p>如果你偶然需要访问下国外的网站，一般可以到网上试用免费的 VPN，几乎所有的 VPN 提供商都免费提供了试用 IP 地址，试用的账号大多是 1h 更换一次密码，速度仅能够访问网页。</p>
<p>购买付费 VPN 的时候，一定需要谨慎，由于众所周知的法律盲区或者说是非法的原因，VPN 一般都缺少市场规范和管控，简而言之就是本身就不合法，因此很多网站出售 VPN 可能存在诈骗或被查封的可能性。本文推荐的是一个老牌 VPN，经营多年，信誉各方面都有的保障，具备速度快，链接稳定，站点多，软件跨平台，支持市面上各种操作系统等有点。</p>
<p>这边首推国内最出名的 <a href="http://gjsq.me/web" target="_blank" rel="external">Green VPN</a>，域名经常会被查封，以上给出的这个网址一般会自动跳转，大多数情况不会变化。Green VPN 的费用一般在 ￥150/year 左右，可以两个客户端同时使用，特点是使用起来方便，速度稳定，一般带宽在 4M 以上，但不能长期链接，每天可能会断线一次。Green VPN 算是一家老牌的 VPN 了，价格虽然不算最便宜，但稳定性服务等都比较有保证，市面上面冒充 Green VPN 诈骗的也比较多，购买时需要当心注意。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/1.png" alt=""></p>
<p><a href="http://gjsq.me/web" target="_blank" rel="external">Green VPN</a> 官方给出了最详细的指导教程，使用前可以先观看图文教程，步骤详细，而且都配置简单。</p>
<p>VPN 的加密效果一般，还是有很大几率被监控到的，因此使用时，需要谨慎，切勿发表一些激动言论，谨防家中水表。</p>
<a id="more"></a>
<h3 id="linux-下的-VPN-配置"><a href="#linux-下的-VPN-配置" class="headerlink" title="linux 下的 VPN 配置"></a>linux 下的 VPN 配置</h3><p>Green VPN 上面的参考文档很多，其实已经给出了详细步骤，一般采用<a href="https://www.getgreenjsq.co/shiyong/67.html" target="_blank" rel="external">Ubuntu 设置方法 (PPTP)配置</a>，该步骤也适用于其他地方购买的 VPN，下面列出详细设置：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/4.png" alt=""></p>
<p>网关填写服务器地址，该地址是 VPN 网站提供给你的连接地址，用户名密码填写在 VPN 网站注册的信息，验证通过即可登录，但有时连接未必稳定，需要尝试多次才可以连接成功。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-12-vpn推荐/7.png" alt=""></p>
<h3 id="VPN-和-ssh-兼容"><a href="#VPN-和-ssh-兼容" class="headerlink" title="VPN 和 ssh 兼容"></a>VPN 和 ssh 兼容</h3><p>VPN 的所用的协议和 SSH 协议是互不兼容的，也就是说，如果你登陆了 VPN ，这时使用 SSH 命令想完成一些操作的话，会出现不响应的状况。如果遇到这种问题可以参考本博客的<strong>linux下ssh通过VPN推送失败</strong>文章。</p>
<h3 id="VPN-的开机自启动"><a href="#VPN-的开机自启动" class="headerlink" title="VPN 的开机自启动"></a>VPN 的开机自启动</h3><p>linux 下 VPN 的开机自启还没有找到，windows 等其他平台都有客户端可以很容易设置开机自启。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>VPN 相比 ss 而言，更加容易使用，无需具备太多的电脑知识，但 VPN 加密不如 ss，更容易被监控到。</p>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="https://www.getgreenjsq.co/shiyong/67.html" target="_blank" rel="external">https://www.getgreenjsq.co/shiyong/67.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux正常学习办公]]></title>
      <url>http://noparkinghere.top/2016/07/11/2016/2016-07-11-linux%E6%AD%A3%E5%B8%B8%E5%AD%A6%E4%B9%A0%E5%8A%9E%E5%85%AC/</url>
      <content type="html"><![CDATA[<p>本文章在于总结自己如何使用 linux 完成正常的办公学习。linux 向来以它的可定制性强，稳定性高而出名，但 linux 常用领域大多也只限制在个别的一些如服务器领域，而民用领域即便是安卓系统也是 linux 经过层层封装之后的产物，早已逝去了该系统的原汁原味。linux 从发展至今也已经有了20多年的历史，但桌面版本一致被大家诟病，非专业人事不能使用，自从 ubuntu 这个发行版出来后，确实可以说是降低了新人使用的门槛，但是这个发行版的 GUI 定制性差，不够稳定等一系列的问题也让用户体验直线下降。这边我是以 ubuntu 的系统为基础采用 awesome 这儿 WM 进行图形化管理，目前已经使用了一年的时间，整体体验还算是良好。</p>
<blockquote>
<h2 id="系统选择："><a href="#系统选择：" class="headerlink" title="系统选择："></a>系统选择：</h2></blockquote>
<h3 id="为何选择ubuntu？"><a href="#为何选择ubuntu？" class="headerlink" title="为何选择ubuntu？"></a>为何选择ubuntu？</h3><p><em>现如今linux发行版很多，但真如ubuntu一样的美观，稳定又方便的真不多。说一下我用过的各个系统的体验吧：</em></p>
<ul>
<li>centOS 系统不够美观，本身使命就是等同 REDHAT 用于服务器的，虽然可以预装的软件比较多，但大都是用于开发及运维的。</li>
<li>arch 更像是一个 geek 玩的玩具，更新频率过快，该版本接触不是过多，但用于正常工作生活的系统，没有人愿意一天折腾几次吧？用不上一年就非得重装的吧？</li>
<li>deepin 这个是一个国产 linux，也只用过很短的一段时间，就界面各方面而言，感觉还是满美观，满人性化的，但用户太少，社区看起来也不是太活跃，虽然好像也是基于debian的衍生产品，但还是再观望一段时间再说吧。</li>
<li>ubuntu 出来时间也比较久了，本身一直专注于做桌面系统，gnome 的一整套组建目前来看也比较完善，各种自带软件，用户体验都还不错，有些甚至比 MS 的更好用。当然作为一个正常办公学习使用的人来说，最满意的还是 apt-get 可以直接管理获取各种资源了。也就是说，如果你是需要用 linux 来办公学习，写写程序的话，ubuntu 应该来说会是首选。</li>
</ul>
<a id="more"></a>
<h3 id="为何选择-awesome？"><a href="#为何选择-awesome？" class="headerlink" title="为何选择 awesome？"></a>为何选择 awesome？</h3><ul>
<li><p>gnome 的不稳定<em>ubuntu 下的 gnome 如果作为日常使用的话，很难满足要求，虽然经过这么多年的发展，但仍然会经常出现不响应。</em>试问，如果一个 GUI 连基本的稳定都没法保障，即便功能再完善，外观再美，用户长久用下来，最终会抛弃她。使用 gnome 两周，尽管尝试着去更改设置了不少东西，但度过了最开始的新奇感后，永无止境的不响应，从错误中恢复等等，最终让我还是选择更换一个新的图形化用户界面。</p>
</li>
<li><p>awesome 的轻便小巧，且可定制话极强（当然其他 linux 也都可以定制，只不过，其他的起点过高，对于普通用户而言，上手不易），awesome 即便是新手，在 github 上找个模板，稍加摸索也可以定制出自己满意的 GUI。</p>
</li>
</ul>
<blockquote>
<h2 id="linux-软件："><a href="#linux-软件：" class="headerlink" title="linux 软件："></a>linux 软件：</h2></blockquote>
<p>虽然 linux 上面的软件没有 windows 的丰富，在娱乐上面可能有所欠缺，但办公学习上面的并不少且功能大都很强大，下面我们介绍一些 linux 上最常用的软件，基本可以让你的 PC 不再需要安装 windows。</p>
<h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><h4 id="chrome"><a href="#chrome" class="headerlink" title="chrome:"></a>chrome:</h4><p>这个不做过多解释，简而言之就是好用，chrome 支持多个平台，而且用户体验都相近，关键 linux 下的 chrome 还相当稳定，远胜过 ubuntu 下自带的 firefox 等浏览器，使用体验可能更甚于 windows 下的 chrome。插件扩展等功能应有尽有。chrome 的使用和技巧内容很多，关于 chrome 可以参考本博客中专门的文章。</p>
<h4 id="thunar"><a href="#thunar" class="headerlink" title="thunar"></a>thunar</h4><p>一款占用资源少，功能强大的文件管理器，支持文件批量命名等等操作。</p>
<h4 id="virtualbox"><a href="#virtualbox" class="headerlink" title="virtualbox:"></a>virtualbox:</h4><p>算是使用 windows 软件的必备工具了，虽然说 wine 等也可以使用 windows 软件但不稳定也存在配置麻烦，这边还是推荐如果有需要用 windows 软件的时候可以使用虚拟机 virtualbox，目前电脑配置都极好，如果你是 i3 标压 CPU 和 8G 及以上的内存，在 virtualbox 下使用 windows 7 运行 Photoshop，下载文件，浏览网站，编辑文档，观看视频等都是没有问题的。当然这边并不提倡都在虚拟机中操作，否则我们安装 linux 就没有意义了，目前个人而言，除了需要迅雷，百度云下载大文件，以及 Photoshop 作图，其他基本上都可以在 linux 下解决。</p>
<h4 id="deepin-scrot截图："><a href="#deepin-scrot截图：" class="headerlink" title="deepin-scrot截图："></a>deepin-scrot截图：</h4><p>效果虽然可以达到 windows 下的截图工具大部分功能，但不够稳定。速度慢，虽然截图功能不是什么大的应用，但奈何之前在 win 平台下的截图都太好用了，暂时还没有在 linux 平台下面找到能够完全满意的截图软件。</p>
<h4 id="gthumb"><a href="#gthumb" class="headerlink" title="gthumb:"></a>gthumb:</h4><p>一款轻巧好用的图片查看编辑工具，基本具备大多数常用功能，但仍然不能算是满足日常工作需要，最起码标记涂鸦功能都没有。</p>
<h4 id="分屏功能"><a href="#分屏功能" class="headerlink" title="分屏功能"></a>分屏功能</h4><p>xrandr命令，这是一个命令行软件，并非图形界面软件，但很实用，用于分屏驱动多个显示器，一般是底层控制的，虽然是显示功能，但分屏并非GUI的独享。</p>
<ul>
<li>输出当前可用设备：xrandr</li>
<li>选用你需要使用的设备：xrandr –output HDMI1 –auto ,这边 HDMI1 就是上一条之前命令列出来的设备名称，模式选用自动，一般不会要在配置。</li>
</ul>
<h4 id="uget"><a href="#uget" class="headerlink" title="uget"></a>uget</h4><p>uget 工具类似于 windows 下的迅雷，但它调用其他的工具来下载，uget 仅是提供了一个图形界面，这边推荐使用 uget+aria2c 可以让你的速度飞起，比迅雷还要快很多。</p>
<h4 id="搜狗拼音"><a href="#搜狗拼音" class="headerlink" title="搜狗拼音"></a>搜狗拼音</h4><p>国内最出名的输入法，虽然之前用 windows 时，一直没用过他家的产品，发现只有这家提供了 linux 的版本，除了不支持账号登录外，其他该有的功能基本上都有。</p>
<h3 id="办公学习"><a href="#办公学习" class="headerlink" title="办公学习"></a>办公学习</h3><h4 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h4><p>linux 上面可以安装 openoffice，而 openoffice 类似于 Microsoft office 该有的功能也都有，但就是界面丑了点，这边我推荐国产的 WPS，让人惊喜的是这款软件目前除了账户同步功能没有，其他基本上和 windows 版本的没有太多区别。</p>
<h4 id="福昕阅读器"><a href="#福昕阅读器" class="headerlink" title="福昕阅读器"></a>福昕阅读器</h4><p>同样是一款国产的办公软件，这款软件特点是速度快，界面简洁，UI 风格和 windows 上区别还蛮大，目前只发现了英文版的。</p>
<h4 id="xmind"><a href="#xmind" class="headerlink" title="xmind:"></a>xmind:</h4><p>一款和 freemind 类似的思维导图软件，该软件是国产的一款开源商业软件，linux 上面体验和 windows 上略有差别，但该有的功能基本都有。</p>
<h4 id="teamview"><a href="#teamview" class="headerlink" title="teamview"></a>teamview</h4><p>跨平台的远程协助软件，功能性能相当强大，甩开 qq 远程桌面好几条街。</p>
<h4 id="录屏软件recordmydesktop"><a href="#录屏软件recordmydesktop" class="headerlink" title="录屏软件recordmydesktop"></a><a href="http://jingyan.baidu.com/article/7908e85c91f834af491ad241.html" target="_blank" rel="external">录屏软件recordmydesktop</a></h4><p>这边主要是本人用不到这个，不做详细介绍。</p>
<h3 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h3><h4 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h4><p>网易算是国内比较良心的厂家，网易云音乐可以说是国产众多软件中体验效果最好的，支持账号登录等所有功能，和 windows 版本以及 Android 版本没有发现差别。</p>
<h4 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h4><p>steam 这个游戏平台还是很出名，自从 steam 可以在 linux 上使用后，基本解决了 linux 没有娱乐的问题，当然注意，并不是每个 steam 平台的游戏都支持 linux，值得庆幸的是 dota2 是支持 linux 的，我的电脑是 2 代 i5 CPU + gt450 显卡 + 普通机械硬盘，运行 dota2 画质中等以下体验没有问题。</p>
<h3 id="开发套件："><a href="#开发套件：" class="headerlink" title="开发套件："></a>开发套件：</h3><h4 id="atom"><a href="#atom" class="headerlink" title="atom:"></a>atom:</h4><p>github 出品，算是现代 IDE 中的一个精品吧，结合了 vim 和 sublimeTEXT 一些特征特点，优缺点可谓见仁见智，反正在我看来vim能够实现的它也都可以实现，长期使用 vim mod 插件，且各种第三方插件应有尽有。</p>
<h4 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h4><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><h4 id="Qt-creator"><a href="#Qt-creator" class="headerlink" title="Qt creator"></a>Qt creator</h4><p><em>linux 可以说天生就适合程序元做开发的，各种比 windows 更加清晰，且基本上主流的 IDE 都可以找到对应的版本，这边就不详细介绍了。</em></p>
<h3 id="专业软件"><a href="#专业软件" class="headerlink" title="专业软件"></a>专业软件</h3><p>CAD : LibreCAD、FreeCAD、DraftSight等，推荐 DraftSight 可以完全兼容 AutoCAD。</p>
<p>Protel ：Eagle、Kicad、gEDA、Fritzing等，各有优缺点，推荐 KiCAD 。</p>
<blockquote>
<h2 id="私人定制："><a href="#私人定制：" class="headerlink" title="私人定制："></a>私人定制：</h2></blockquote>
<p>私人订制主要是基于以上的系统和 GUI，为了完成更好的体验效果和方便操作，所以个人增加了一些小功能。</p>
<h4 id="输入法，Caps-Lock-与右-Ctrl-互换（有相关详细文章）"><a href="#输入法，Caps-Lock-与右-Ctrl-互换（有相关详细文章）" class="headerlink" title="输入法，Caps_Lock 与右 Ctrl 互换（有相关详细文章）"></a>输入法，Caps_Lock 与右 Ctrl 互换（有相关详细文章）</h4><p>在当前的用户根目录下～创建 .Xmodmap 文件(尤其注意:这边名称是Xmodmap首字母大写,很多教程都忽略了这个问题,往往导致配置出来有问题)，书写内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">remove Lock = Caps_Lock</div><div class="line">remove Control = Control_R</div><div class="line">keysym Control_R = Caps_Lock</div><div class="line">keysym Caps_Lock = Control_R</div><div class="line">add Lock = Caps_Lock</div><div class="line">add Control = Control_R</div></pre></td></tr></table></figure>
<p>这样，caps lock 和 ctrl 就都是 ctrl 的功能。执行下<code>xmodmap ~/.Xmodmap  2&gt;/dev/null</code>即可立即生效，每次开机启动系统会自动加载.Xmodmap，无需相关设置。</p>
<h4 id="github-网站可以同时使用-ssh-和-VPN（有相关详细文章）"><a href="#github-网站可以同时使用-ssh-和-VPN（有相关详细文章）" class="headerlink" title="github 网站可以同时使用 ssh 和 VPN（有相关详细文章）"></a>github 网站可以同时使用 ssh 和 VPN（有相关详细文章）</h4><p><code>sudo ip route add 192.30.252.0/22 via 192.168.18.1 dev eno1</code> 命令作用主要是过滤部分IP地址，让他们直接从路由器网关发送，而不从 VPN 上面走，通过上面 ifconfig 可以看到本机被路由器分配的ip地址为 192.168.18.60，而 eno1 为计算机在访问外网中的实体网卡。通过谷歌搜索网站查看到 github 实际推送的ip地址为： 192.30.252.0/22</p>
<h4 id="关闭笔记本中的触摸板（有相关详细文章）"><a href="#关闭笔记本中的触摸板（有相关详细文章）" class="headerlink" title="关闭笔记本中的触摸板（有相关详细文章）"></a>关闭笔记本中的触摸板（有相关详细文章）</h4><ul>
<li>sudo rmmod psmouse    这个是禁用触摸板</li>
<li>sudo modprobe psmouse 这个是启用触摸板</li>
</ul>
<h4 id="gnome-下调网络管理小控件"><a href="#gnome-下调网络管理小控件" class="headerlink" title="gnome 下调网络管理小控件"></a>gnome 下调网络管理小控件</h4><p>ubuntu 的 GUI 在状态栏提供了一个网络管理的小工具，这边如果使用 awesome 可使用 nm-applet 命令将该工具打开，可以每次开机时自动启动该命令。</p>
<hr>
<p><em>国外的不少软件基本上都有 linux 版本的，如 skype，teamview 等等，这边国内人毕竟不常用就不详细介绍了。linux下向来不缺少优秀的办公学习开发类软件，很多软件都是开源项目，需要大家共同去维护，只要你需要，想得到的功能，基本都可以在网上找到。这边推荐可以阅读很多年前的一篇文章<a href="http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html" target="_blank" rel="external">完全用Linux工作-王垠</a>。</em></p>
<blockquote>
<p>参考链接：<br><a href="http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html" target="_blank" rel="external">http://www.cnblogs.com/skyseraph/archive/2010/10/30/1865280.html</a><br><a href="https://awesome.naquadah.org" target="_blank" rel="external">https://awesome.naquadah.org</a><br><a href="http://www.hahack.com/tools/awesome/" target="_blank" rel="external">http://www.hahack.com/tools/awesome/</a><br><a href="https://www.gitbook.com/book/voluong/awesome-linux-software/details" target="_blank" rel="external">https://www.gitbook.com/book/voluong/awesome-linux-software/details</a><br><a href="https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/" target="_blank" rel="external">https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/</a><br><a href="https://zhidao.baidu.com/question/512979028.html" target="_blank" rel="external">https://zhidao.baidu.com/question/512979028.html</a><br><a href="http://www.mintos.org/skill/linux-autocad-draftsight.html" target="_blank" rel="external">http://www.mintos.org/skill/linux-autocad-draftsight.html</a></p>
</blockquote>
<hr>
<p>To be continued…</p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用指令详解]]></title>
      <url>http://noparkinghere.top/2016/07/11/2016/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>用git这个版本控制器也有一段时间了，但奈何一直停留在初浅的使用阶段，对诸如：分支，远程库，log，reflog，pull，clone等命令一直无法清晰的认识，仅仅是简单的add，commit，push，出了问题再查找。<br>始终无法串接成自有的知识体系，git 作为当下最流行的版本控制器，不得不说我对她真是既爱又恨，喜欢她的小巧高效功能强大；恨上手困难，虽然也有了一些简单易懂的教程，但在在实际使用时，始终不能形成自己的知识体系，原因可能还是项目中实际用的过少，这篇文章，会花一段时间，详细的介绍git的大概工作过程，对一些常用命令精简的介绍，然后从我个人的角度来认识git，总结自己的经验。*</p>
<a id="more"></a>
<p><strong>这篇文章的过程意在记录自己使用git的学习经历，并不断的总结推荐一些良好的配置以及相关软件。</strong></p>
<h3 id="GIT介绍："><a href="#GIT介绍：" class="headerlink" title="GIT介绍："></a>GIT介绍：</h3><p>Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 的读音为/gɪt/。Git 是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<h4 id="版本控制器介绍："><a href="#版本控制器介绍：" class="headerlink" title="版本控制器介绍："></a>版本控制器介绍：</h4><p>版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。这种方法是工程图（engineering drawings）维护（maintenance）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推等等。</p>
<h4 id="GIT特点："><a href="#GIT特点：" class="headerlink" title="GIT特点："></a>GIT特点：</h4><p><em>GIT 采用分支的结构形式来记录所有文本的修改，可以看出分支和指针是 git 的核心，git 因为指针的高速切换而高效。所有的分支名都是指针，且该指针无条件的指向这条分支的最末端，例如：master指针永远指向 master 这条分支的最后一个节点，而HEAD指针则指向的是当前位置，即用户目前所在的工作位置。在 git 的工作过程中最主要使用的是：add,commit,log,checkout 这几个命令，而诸如 reflog，reset 等其实用的并不算多，如果有远程库的话还需要注意 pull,push,remote。</em></p>
<h3 id="常用GIT指令："><a href="#常用GIT指令：" class="headerlink" title="常用GIT指令："></a>常用GIT指令：</h3><ul>
<li><p>git add filename:将相关文件加入到暂存区stage中，注意有新文件的话，add步骤不能少。如果是一个人做的项目，一般如果整个项目加入可以使用git add . 或者git add * 。</p>
</li>
<li><p>git commit -m “commment”：git 的版本提交，执行完这步骤，你就完成了版本的创建提交了，也是最常用的步骤。<em>建议：使用git commit -m 即可，去配置文件中修改 editor，这样可以调用如 vim 之类的编辑器，否则备注写起来麻烦，且字数有限制。</em></p>
</li>
<li><p>git branch：查看分支结构，git 的颇有c语言和数据结构的风格，整个 git 的版本控制，类似于一颗数，可以不断创建新的分支，然后分支名称类似于一个 tag 指针，始终指向分支的末尾处，而head这个指针指向的地方就是当前你所能看到的处在的版本位置，<strong>严格的来说并不是指向当前，而是上一个提交了的版本的位置，当前如果做了一些修改，而没去提交，则使用reset会回到上一个提交的版本，修改的内容会丢失</strong>。</p>
</li>
<li><p><strong>git checkout</strong>(<em>该命令的理解贯穿git的始终，如果理解不精准，往往会遇到很多莫名其妙的错误。)</em>：<strong>用于控制head指针所指向的位置</strong>，也就是说控制当前用户的工作位置。该指令尤为重要，<strong>一般都是通过checkout找到过去的某个版本，然后在该位置创建分支结构，再进行相应修改。</strong>(<em>注意是切换HEAD的位置，此时仅仅用于查看该版本，而如果你没有在该位置建立新的分支，则无法对改版本进行修改，git 的所有修改都是基于分支进行的，每条枝干的前后各个版本都是存在强关联性的，所有枝干的后一个节点都是基于前一个节点建立的，如果 checkout 到前一个节点对它进行了破坏，则后面也必然会受影响，这种情况一般是不允许发生的，因此 checkout 的每次修改都是要求该节点必须要重新开枝散叶，这样新的修改会在新的枝干上面进行，不会影响原有的内容。</em>) checkout 的好处在于不会破坏原有的分支结构，可以任意在整个的目录树上面对 head 进行移动，方便用户查看各个版本。（<strong>再次注意：checkout只是用来控制 head 的，如果 head 通过 checkout 发生了移动，不再指向原有分支的末尾如：master，则必须建立新分支，才可以对文件进行提交修改。另外即便 checkout 指向原有分支的末尾，但如果是版本号的话也是没法进行修改的，必须要是指向 master 这个分支名才可以进行修改，类似于HEAD必须指向指针才可以，而不是指向某一个节点，这一点有指针操作经验的话，较容易理解。</strong>），<em>checkout – filename：回退某一个文件，注意需要加–，这一步并不是更改 HEAD 指向，而仅仅是回退某一个错误修改了的文件，这也是撤销修改文件最常用的命令。</em></p>
</li>
<li><p>git reset “branchname/editionnum”：事实上这个指令很少用的，或者说谨慎使用，一旦使用了就会破坏原有的分支结构，reset 是一个回退功能，会将原有的分支剪掉，虽然仍然可以通过 reflog 查找出版本信息，强制指向某个回退之前的版本，但这并不是该有的操作，且很可能因为误操作造成更大麻烦。建议：<em>只有在确定很清楚自己要进行的操作和上次提交错误的情况下使用该指令，其他时候都不使用。</em>版本回退使用 reset 后面一般加上 –hard 彻底回退，否则有些修改了的未建立版本的文件仍然会保留。</p>
</li>
<li><p>git merge “branchname”：将两个分支进行合并，也是比较常用的操作，如果没有文件冲突，一般 git 会快速自动合并，如果有冲突，会需要你进行比较手动修改冲突，合并的过程是当前HEAD指向的分支名，会跳转到 branchname 的位置。</p>
</li>
<li><p>git branch -d dev：合并分支后，可以将被合并了的分支号删除。</p>
</li>
<li><p>git tag ：这个也是个比较有用的方法，毕竟版本号是一大串随机数字，即便只要输入前 4 个，你也很难记得，对某个特别的版本加入 tag 标签名，之后可以直接使用 <code>git checkout tagname</code> 来指向该版本。</p>
</li>
<li>git diff : 将当前所有状态同指令后面对应的版本状态进行比较。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/1.jpg" alt=""></p>
<h3 id="概念分析"><a href="#概念分析" class="headerlink" title="概念分析"></a>概念分析</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>HEAD : 这是当前分支版本顶端的别名，也就是在当前分支你最近的一个提交，即 HEAD 的本质是一次已经进行过的提交（commit）。</li>
<li>Index : 也被称为 staging area，是指一整套即将被下一个提交的文件集合，他也是将成为HEAD的父亲的那个commit，index 实际是通过 add 等生成的即将被提交的区域。</li>
<li>Working Copy : 代表你正在工作的那个文件集，Working Copy 是当前你工作目录的状态。</li>
</ul>
<h4 id="具体执行区别："><a href="#具体执行区别：" class="headerlink" title="具体执行区别："></a>具体执行区别：</h4><ul>
<li>当你第一次 checkout 一个分支，HEAD 就指向当前分支的最近一个 commit。在 HEAD 中的文件集（实际上他们从技术上不是文件，他们是 blobs，但是为了讨论的方便我们就简化认为他们就是一些文件）和在 index 中的文件集是相同的，在 working copy 的文件集和 HEAD,index 中的文件集是完全相同的。所有三者(HEAD,INDEX(STAGING),WORKING COPY)都是相同的状态。</li>
<li>当你对一个文件执行一次修改，你的 working copy 不再和index,HEAD 相同。</li>
<li>当你执行一个git add,它就stages the file in the index，你的working copy和index区是相同的，但是他们和HEAD区是不同的。</li>
<li>当你执行一个git commit,GIT就创建一个新的commit，随后HEAD就指向这个新的commit，而index,working copy的状态和HEAD就又完全匹配相同了。</li>
</ul>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>如果你仔细研究 reset 命令本身就知道，它本身做的事情就是重置 HEAD (当前分支的版本顶端）到另外一个 commit。假设我们有一个分支（名称本身无所谓，所以我们就简单称为”super-duper-feature”分支吧），图形化表示如下：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/1.png" alt=""></p>
<p>如果我们执行：<code>git reset HEAD</code> 任何事情都不会发生，这是因为我们告诉GIT重置这个分支到HEAD，而这个正是它现在所在的位置。<code>git reset HEAD~1</code> 当我们再执行上面的命令时（HEAD~1是 “the commit right before HEAD” 的别名，或者说：put differently “HEAD’s parent”），我们的分支将会如下所示</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/2.png" alt=""></p>
<p>如果我们执行git reset HEAD~2,则意味着将HEAD从顶端的commit往下移动两个更早的commit。</p>
<ul>
<li>soft ： –soft 参数告诉 Git 重置 HEAD 到另外一个 commit，但也到此为止。如果你指定 –soft 参数，Git 将停止在那里而什么也不会根本变化。这意味着 index,working copy 都不会做任何变化，所有的在 original HEAD 和你重置到的那个 commit 之间的所有变更集都放在 stage(index) 区域中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/3.png" alt=""></p>
<ul>
<li>hard ： –hard 参数将会 blow out everything.它将重置HEAD返回到另外一个 commit (取决于~12的参数），重置 index 以便反映 HEAD 的变化，并且重置 working copy 也使得其完全匹配起来。这是一个比较危险的动作，具有破坏性，数据因此可能会丢失！如果真是发生了数据丢失又希望找回来，那么只有使用：git reflog 命令了。makes everything match the commit you have reset to.你的所有本地修改将丢失。如果我们希望彻底丢掉本地修改但是又不希望更改branch所指向的commit，则执行 <code>git reset --hard = git reset --hard HEAD</code>； i.e. don’t change the branch but get rid of all local changes. 另外一个场景是简单地移动 branch 从一个到另一个 commit 而保持 index/work 区域同步。这将确实令你丢失你的工作，因为它将修改你的 work tree！</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/4.png" alt=""></p>
<ul>
<li>mixed(default）：–mixed 是 reset 的默认参数，也就是当你不指定任何参数时的参数。它将重置HEAD 到另外一个 commit,并且重置 index 以便和 HEAD 相匹配，但是也到此为止。working copy 不会被更改。所有该 branch 上从 original HEAD（commit）到你重置到的那个 commit 之间的所有变更将作为 local modifications 保存在 working area 中，（被标示为 local modification or untracked via git status)，但是并未 staged 的状态，你可以重新检视然后再做修改和 commit。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/5.png" alt=""></p>
<h4 id="简述分支策略："><a href="#简述分支策略：" class="headerlink" title="简述分支策略："></a>简述分支策略：</h4><p><strong>在实际开发中，我们应该按照几个基本原则进行分支管理：</strong></p>
<ul>
<li>master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>
<li>干活都在 dev 分支上，也就是说，dev分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本；</li>
<li>每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。</li>
</ul>
<p><strong>团队合作示意图：</strong></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/0.png" alt=""></p>
<blockquote>
<p>参考链接：<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br><a href="http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_" target="_blank" rel="external">http://baike.baidu.com/link?url=weNC33XuaXOCTBp5s3WeZVu-Z9LP41KY_M6_WdGxAJZpJs_sq7jcgZ-3B01u2EiqfK6gb0L6s3-IDiWp1cVgF_</a><br><a href="http://www.cnblogs.com/kidsitcn/p/4513297.html" target="_blank" rel="external">http://www.cnblogs.com/kidsitcn/p/4513297.html</a><br><a href="http://maiyang.github.io/git/2016/04/21/git-reset-checkout-revert" target="_blank" rel="external">http://maiyang.github.io/git/2016/04/21/git-reset-checkout-revert</a><br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%EF%BC%9AReset%E3%80%81Checkout%E3%80%81Revert%E7%9A%84%E9%80%89%E6%8B%A9" target="_blank" rel="external">https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%EF%BC%9AReset%E3%80%81Checkout%E3%80%81Revert%E7%9A%84%E9%80%89%E6%8B%A9</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（转）回车、换行、和文件末尾空行]]></title>
      <url>http://noparkinghere.top/2016/07/11/2016/2016-07-11-%EF%BC%88%E8%BD%AC%EF%BC%89%E5%9B%9E%E8%BD%A6%E3%80%81%E6%8D%A2%E8%A1%8C%E3%80%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE%E7%A9%BA%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h2 id="回车和换行"><a href="#回车和换行" class="headerlink" title="回车和换行"></a>回车和换行</h2><p>回车 (Carriage Return) 和换行 (Line Feed) 的区别，<a href="http://stackoverflow.com/questions/1761051/difference-between-n-and-r" target="_blank" rel="external">这里</a>有一个历史原因可参考：</p>
<blockquote>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做”回车”，告诉打字机把打印头定位在左边界；另一个叫做”换行”，告诉打字机把纸向下移一行。</p>
</blockquote>
<p>发明计算机时，这个概念被沿用下来，但因为条件的限制和设计者的喜好，有了一些分歧：</p>
<ul>
<li>Unix 系统里，每行结尾只有”&lt;换行&gt;”，即 “\n”</li>
<li>Windows 系统里面，每行结尾是”&lt;回车&gt;&lt;换行&gt;”，即 “\r\n”</li>
<li>在老的 Mac 系统里，每行结尾是”&lt;回车&gt;”，即 “\r”</li>
</ul>
<p>我们来验证一下，我在 Windows 下用记事本新建一个文本文件，它的二进制编码如下：</p>
<pre><code>//源文件内容
hello
hello2

//二进制内容
0000000: 6865 6c6c 6f0d 0a68 656c 6c6f 32         hello..hello2
</code></pre><p>同样在 Mac 下用 Vim 新建一个：</p>
<pre><code>//源文件内容
hello
hello2

//二进制内容
0000000: 6865 6c6c 6f0a 6865 6c6c 6f32 0a         hello.hello2.
</code></pre><p><code>0a</code>是 LF 的 ASCII 编码, <code>0d</code>是 CR 的 ASCII 编码。区别很明显了</p>
<ul>
<li>Mac 下的文本文件在 Windows 下打开会成为一行，因为 Windows 只认识 <code>\r\n</code>，也就是 <code>0d0a</code></li>
<li>Windows 下的文本文件在 Mac 下打开，Vim 中会在每行末尾显示一个 <code>^M</code>，(不是两个字符组成的)</li>
</ul>
<a id="more"></a>
<h2 id="文件末尾空行"><a href="#文件末尾空行" class="headerlink" title="文件末尾空行"></a>文件末尾空行</h2><p><a href="https://zh.wikipedia.org/zh-sg/POSIX" target="_blank" rel="external">POSIX</a>对行的<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_206" target="_blank" rel="external">定义</a>如下：</p>
<blockquote>
<p>3.206 Line</p>
<p>A sequence of zero or more non- <newline\> characters plus a terminating <newline\> character.</newline\></newline\></p>
<p>行是由0个或者多个非 “换行” 符的字符组成，并且以 “换行” 符结尾。</p>
</blockquote>
<p>这样做有什么好处呢，举个例子：</p>
<pre><code>//hello.c
#include head.h
print(&apos;hello&apos;)

//world.c
#include tail.h
print(&apos;hello&apos;)
</code></pre><p>如果这两个文件都按 POSIX 规范来写， 在<code>cat *.c</code>之后，是没有问题的：</p>
<pre><code>//cat.c

#include head.h
print(&apos;hello&apos;)
#include tail.h
print(&apos;hello&apos;)
</code></pre><p>如果缺少最后一行的换行符（如 Windows 文件那样的定义），<code>cat</code>之后，就有问题了：</p>
<pre><code>//error.c

#include head.h
print(&apos;hello&apos;)#include tail.h
print(&apos;hello&apos;)
</code></pre><p>所以，从这点去理解 POSIX 对行的定义，非常合理，对于任意文件的拼接，也各自保持了文件的完整性。</p>
<p>不遵守标准带来的则是：在一些编辑器下面，比如 Sublime，他把<code>\n</code>的当做了行之间的分隔符，于是文件最后一行的<code>\n</code>就看上去成了一个新的空行，这就是错误解读标准造成的，拼接文件时也会产生不必要的麻烦，比如上例。</p>
<h2 id="No-new-line-at-end-of-file"><a href="#No-new-line-at-end-of-file" class="headerlink" title="\ No new line at end of file"></a>\ No new line at end of file</h2><p>基于上面的原因，再去看 git diff 的<code>\ No new line at end of file</code>信息，就很好解释了。</p>
<p>各编辑器对于换行符的理解偏差，导致的文件确实发生了变化，多了或少了最后的<code>0a</code>，那么对于 diff 程序来说，这当然是不可忽略的，但因为<code>0a</code>是不可见字符，并且是长久以来的历史原因，所以 diff 程序有个专门的标记来说明这个变化，就是：</p>
<p><code>\ No new line at end of file</code></p>
<p>各编辑器也有相应的办法去解决这个问题，比如 Sublime，在<code>Default/Preferences.sublime-settings</code>中设置：</p>
<pre><code>// Set to true to ensure the last line of the file ends in a newline
// character when saving
&quot;ensure_newline_at_eof_on_save&quot;: true,
</code></pre><p>所以，请遵守规范。</p>
]]></content>
      
        <categories>
            
            <category> 转载文章 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MDK5安装及配置]]></title>
      <url>http://noparkinghere.top/2016/07/11/2016/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="MDK简介"><a href="#MDK简介" class="headerlink" title="MDK简介"></a>MDK简介</h3><blockquote>
<p>Keil MDK，也称MDK-ARM，Realview MDK、I-MDK、uVision4 等。Keil C51 是美国 Keil Software 公司出品的 51 系列兼容单片机 C 语言软件开发系统，被 ARM（英国）公司收购，作为在 51 单片机时代相当流行的一个软件。</p>
</blockquote>
<p><em>而如果你是一个嵌入式工作者，尤其是主要使用ST或者飞思卡尔等工业产品为主的芯片，在国内的话可以说你的选择要么是keil要么就是IAR。keil作为一个IDE来说编辑功能缺失恨薄弱，但是硬件调试能力还是毋容置疑的，而keil配置简单容易上手，该有的功能操作也都具备，本文主要讲述作者的一些keil配置及习惯。</em></p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>界面友好，上手简单</li>
<li>被ARM公司收购，编辑ARM相对友好，仿真功能十分强大</li>
<li>官方提供各种芯片的启动代码，仿真库</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>自带编辑功能薄弱</li>
<li>不支持/极少支持第三方插件</li>
</ul>
<a id="more"></a>
<h3 id="KEIL-5配置"><a href="#KEIL-5配置" class="headerlink" title="KEIL 5配置"></a>KEIL 5配置</h3><h4 id="界面配置"><a href="#界面配置" class="headerlink" title="界面配置"></a>界面配置</h4><ul>
<li>Keil 5及之后的版本缺少相关的原件类库，需要额外安装。可以从官网下载芯片库</li>
<li><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture1.png" alt=""></p>
</li>
<li><p>Keil 4.6及之后的版本对中文字体支持依旧很差，通过修改成GB2312的简体中文编码，可以让注释的中文字体不会拆分，但默认的Courier New - 10不能够良好的显示所有字体，直接通过修改GB2312会形成字体锯齿化，缺少虚化的过渡。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture2.png" alt=""></p>
<ul>
<li>通过尝试多种字体以及添加fonts文件，发现要么中文字体显示不错，英文不行，要么英文显示不错，中文不行，很多情况代码字体偏大或者偏小，最终个人觉得较好的配置界面如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture5.png" alt=""></p>
<ul>
<li>如果需要修改背景颜色，需要对c/c++ Editor files 下的text，number等所有的background进行修改。配置如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture7.png" alt=""></p>
<ul>
<li>光标指向向的颜色修改如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture8.png" alt=""></p>
<ul>
<li>菜单栏view下面的所有工具栏颜色是跟随系统变化的，可以采用如果腾讯软件管家之类的工具开启护眼模式。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture9.png" alt=""></p>
<h4 id="KEIL建立单片机工程文件注意事项：："><a href="#KEIL建立单片机工程文件注意事项：：" class="headerlink" title="KEIL建立单片机工程文件注意事项：："></a>KEIL建立单片机工程文件注意事项：：</h4><ul>
<li>注意KEIL的配置详细可以参考“Keil 5配置”文档。</li>
<li>工程文件建立目录结构需清晰可参考下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture10.png" alt=""></p>
<p>该工具条中主要存放的是项目中需要使用到的C文件（注意并不包含任何头文件），只有加入这个工具中得.c文件才会进行项目的编译。<br>下面仅作参考，根据个人的习惯而定制，相关存放内容说明：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">CORE</span>：存放<span class="selector-tag">SOC</span>相关代码，包含<span class="selector-class">.s</span>启动文件，<span class="selector-tag">CMSIS</span>的部分<span class="selector-class">.c</span>文件以及<span class="selector-tag">CPU</span>相关的底层核心文件</div><div class="line"><span class="selector-tag">FWLIB</span>：固件库，厂方提供的标准固件库，用于调用外设的函数。</div><div class="line"><span class="selector-tag">BSP</span>：操作系统与芯片的中间层</div><div class="line"><span class="selector-tag">USER</span>：用户自己写的函数文件，包括<span class="selector-tag">main</span>和用户定制的功能函数</div><div class="line"><span class="selector-tag">OS</span>：具体名称为操作系统名称，可以是<span class="selector-tag">UCOS</span>，<span class="selector-tag">uclinux</span>等等嵌入式操作系统</div><div class="line"><span class="selector-tag">README</span>：整个工程的相关项目说明</div></pre></td></tr></table></figure></p>
<ul>
<li>新建工程重点配置Define和Include Paths，如下图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture12.png" alt=""></p>
<p><em>需强调的是 Define 中的选项不能少，这些选项一般都是如：stm32f10x.h（芯片寄存器定义文件） 或者内核中的宏定义，可以用来进行芯片选型等操作，可以用查找工具全局查找，会发现相关的 #ifdef 语句。本质上面来说，Define 加入的内容就相当于在 c 文件中手动的写入 #define xxx 语句。<br>Include Paths 中定义的都是头文件所在的路径，注意是头文件的路经，这边 ..\CMSIS 等都是使用 windows 下相对路径的格式，如果头文件不在 Include Paths 下的路经中，则编译器无法找到相关头文件，会编译失败。</em></p>
<p><strong>其他注意点：</strong><br>C99Mode如果不勾选，默认可能会使用C89的编译器，一些如 bool 类型或者定义申明可能会无法编译，C89对老版本兼容性更好，但C99加入的许多新特性让编程更“合理”。具体根据自己项目需求而定。</p>
<ul>
<li>Debug 中进行相关模拟仿真下载器设置。一定要记得仿真设置 Reset and Run</li>
</ul>
<p>有仿真器的话，使用右边的仿真器选项，没有的话，则使用模拟。仿真器种类繁多，最常用的比如 JLINK，和 keil ulink 之类的，一些公司也会推出自己的仿真器，如silabs uda等</p>
<p><em>最好勾选setting-&gt;flash download下的Reset and Run，这样可以无需重新上电即可运行程序。</em></p>
<p>JLink 在连接 STM32F439 时，在勾选或者不勾选 Verify Code Download 时可能会出现下载错误，可能会是板子设计缺陷或者JLink版本过高。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-11-MDK5%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/Picture11.png" alt=""></p>
<ul>
<li><p>Utilities：将Use Debug Driver勾选或者手动设置成相同的调试器。</p>
</li>
<li><p>移植程序注意重点：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Project 的 USER 中一定要把 .c 源文件添加进去 </div><div class="line">FWLIB一定要记得添加 stm32f10x_xxx 相关的外设库文件</div><div class="line">Stm32xxx_conf.h 中需取消相关注释</div><div class="line">用户定义的.h头文件需加入 <span class="comment">#include "stm32f10x.h"，且不需要加入 Stm32xxx_conf.h 因为该头文件已经在 #include "stm32f10x.h" 中包含了。</span></div><div class="line">添加用户自定义 .c 文件时，记得把其头文件写入到 main 函数所在文件中</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://www.jb51.net/os/windows/211837.html" target="_blank" rel="external">http://www.jb51.net/os/windows/211837.html</a><br><a href="http://comm.chinaaet.com/adi/blogdetail/32471.html" target="_blank" rel="external">http://comm.chinaaet.com/adi/blogdetail/32471.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stm32F439案例汇总]]></title>
      <url>http://noparkinghere.top/2016/07/11/2016/2016-07-11-%E7%A5%9E%E5%B7%9Estm32%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><em>使用神州开发板，stm32F439芯片，但由于某种原因，配备资料(尤其是案例)并不齐全，且2014年之后相关网站也暂停了访问<br>本工程目的，只要是深入学习研究这块芯片，通过参考其他M4内核的历程，将这块开发板的相关案例完善，同时去除原历程中<br>模糊，难懂冗余的案例，尽量做到代码规范，案例可取，便于进一步的学习研究。</em></p>
<blockquote>
<p>www.armjishu.com(无法访问)</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用芯片为stm32F439IG，市面基于这块M4内核的st芯片比较少，一般多为407</li>
<li>烧录工具位jlink或ulink，正常情况下为jlink</li>
<li>开发板的原理图可见根目录，该开发板可以在某宝找到。</li>
</ul>
<a id="more"></a>
<h3 id="案例列表"><a href="#案例列表" class="headerlink" title="案例列表"></a>案例列表</h3><ul>
<li>实验0 Template工程模板</li>
<li>实验1 跑马灯</li>
<li>实验2 蜂鸣器</li>
<li>实验3 按键和外部中断</li>
<li>实验4 看门狗（独立和窗口）</li>
<li>实验5 待机唤醒</li>
<li>实验6 串口通讯（232和485）</li>
<li>实验7 定时器中断（含有RTC，SYSTICK，TIM）</li>
<li>实验8 PWM输出和输入捕获</li>
</ul>
<h3 id="注意说明"><a href="#注意说明" class="headerlink" title="注意说明"></a>注意说明</h3><h3 id="详细地址"><a href="#详细地址" class="headerlink" title="详细地址"></a>详细地址</h3><blockquote>
<p><a href="https://github.com/noparkinghere/stm32_test" target="_blank" rel="external">https://github.com/noparkinghere/stm32_test</a></p>
</blockquote>
<hr>
<p><em>未完待续</em></p>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub_Page页面无法更新]]></title>
      <url>http://noparkinghere.top/2016/07/11/2016/2016-07-11-github-page%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<h3 id="详细问题："><a href="#详细问题：" class="headerlink" title="详细问题："></a>详细问题：</h3><ul>
<li>文章会在github的工程目录中出现，但github page中首页和存档都无法显示。</li>
<li>仔细查看过套用的html等模板，未能发现有问题。</li>
<li>连续多次都是某一次推送下，突然问题就解决了。</li>
<li>通过github page提供的jekyll服务进行更新文章时，经常会出现文章已经上传到了github的远程库中，但github page却无法显示内容出来，这样的问题出现了很多差，但不断的上传或者某一次传输一个文章，突然就成功了。</li>
</ul>
<a id="more"></a>
<h3 id="具体原因："><a href="#具体原因：" class="headerlink" title="具体原因："></a>具体原因：</h3><p>GitHub_Page 使用的是jekyll服务生成page页面的。由于jekyll 3（github目前的jekyll版本）默认对于认定为”未来”的post，是不生成的，详情可以参考<a href="http://jekyllrb.com/docs/upgrading/2-to-3/#future-posts" target="_blank" rel="external">Future posts - Jekyll</a>。这极有可能与github服务在美国有关,本人使用的是VPN在美国，不知道是否对此也有影响。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul>
<li>网上说可以修改feed.xml文件，具体看参考链接。（本人没有实验成功）</li>
<li>我使用的方法改写时间：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">layout: <span class="string">"post"</span></div><div class="line">title: <span class="string">"GitHub_Page页面无法更新"</span></div><div class="line">tags: <span class="string">"问题总结"</span></div><div class="line">category: <span class="string">"read"</span></div><div class="line">date: <span class="string">"2016-07-11 18:00"</span></div><div class="line">---</div><div class="line">将date中的时间改写，可以将18:00改为1:00，这样也能够有效解决问题。</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="https://segmentfault.com/q/1010000004584816" target="_blank" rel="external">https://segmentfault.com/q/1010000004584816</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 问题总结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chrome使用技巧]]></title>
      <url>http://noparkinghere.top/2016/07/10/2016/2016-07-10-chrome%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p><em>使用chrome虽然有好些年了，但其中的技巧种种，真的明白的并不多，本文着重总结chrome在日常使用中的一些快捷键，插件以及各种小技巧。</em></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-10-chrome使用技巧/1.jpg" alt=""></p>
<p>Chrome其实有很多版本：</p>
<ul>
<li>Stable Channel（稳定版／正式版）： 这个版本是大部分人安装的普通版，为追求稳定的普通用户使用。</li>
<li>Beta Channel（测试版）： 正式版发布前的公开测试所用，版本上的新功能不会作太多修改，主要为安全上的测试，可能会存在不稳定情况，适合喜欢较稳定又可尝鲜的朋友下载使用。本版本安装后会覆盖稳定版。<br>其他版本：Dev Channel（开发版），Canary Build（构造版）这边不做详细说明。</li>
</ul>
<p>Chromium 是 Google 为发展自家的浏览器 Google Chrome 而做的开源项目，所以 Chromium 相当于 Google Chrome 的工程版或称实验版（尽管Google Chrome自身也有β版阶段），新功能会率先在 Chromium 上实现，待验证后才会应用在 Google Chrome 上。这边可以认为 Chromium 类似于谷歌发型的公版安卓系统，各家厂商，可以将 Chromium 修改定制，然后放入到自家的浏览器中。目前国内的主流浏览器大都是基于 Chromium 开发，同时兼容 IE 内核，如：360极速，遨游，猎豹，世界之窗极速版等等。</p>
<a id="more"></a>
<h3 id="基本快捷操作："><a href="#基本快捷操作：" class="headerlink" title="基本快捷操作："></a>基本快捷操作：</h3><p>对于太过复杂和不常用的，这边不会列出来，以下都为切实实用的快捷操作。</p>
<ul>
<li>鼠标中击键点击链接，则会新标签打开该链接，并且不切换到新标签；Ctrl+Shift 的同时点击链接，新标签页中打开链接并切换到刚打开的标签页；Shift 的同时点击链接，新窗口中打开链接。</li>
<li>同时按 Ctrl 和 +，或者按住 Ctrl 键并向上滚动鼠标滚轮。 放大网页上的所有内容；同时按 Ctrl 和 -，或者按住 Ctrl 键并向下滚动鼠标滚轮；Ctrl+0 将网页上的所有内容都恢复到正常大小。 </li>
<li>Ctrl+Tab 或 Ctrl+PgDown 切换到下一个标签页； Ctrl+Shift+Tab或 Ctrl+PgUp 切换到上一个标签页。 </li>
<li>Ctrl+N 打开新窗口</li>
<li>Ctrl+T 打开新标签页</li>
<li>Ctrl+O，然后选择文件 在谷歌浏览器中打开计算机上的文件</li>
<li><strong>Ctrl+Shift+N 在隐身模式下打开新窗口</strong></li>
<li><strong>Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</strong></li>
<li>Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口，一般也可以使用鼠标中击键点击标签关闭该页面。</li>
<li>Ctrl+H 查看”历史记录”页</li>
<li>Ctrl+J 查看”下载”页</li>
<li><strong>Shift+Escape 查看任务管理器</strong></li>
<li>F5 或 Ctrl+R 重新加载当前网页。Ctrl+F5 或 Ctrl+Shift+R 重新加载当前网页，忽略缓存的内容。</li>
<li>Ctrl+F 打开”在网页上查找”框</li>
<li>Ctrl+U 查看源代码</li>
<li>Ctrl+D 将当前网页加入书签</li>
<li>Ctrl+P 打印当前网页。这里有个小技巧，Ctrl+P后选择更改… 另存为PDF可将当前页面保存为pdf格式。</li>
<li><strong>Ctrl+0 将网页上的所有内容都恢复到正常大小</strong></li>
<li>ctrl+shift+T：这个快捷键组合可以打开你上次关闭的 tab 或者上次关闭窗口里面所有的 tab。</li>
<li>按 Backspace 键，或同时按 Alt 和向左箭头键，转到当前标签页浏览历史记录中的上一页；按 Shift+Backspace，或同时按 Alt 和向右箭头键。 转到当前标签页浏览历史记录中的下一页。 </li>
<li>F12/ctrl+shift+C 打开页面调试工具；Ctrl+Shift+J 打开开发者工具 console；Ctrl+U 打开当前网页的源代码。</li>
<li>F11 在全屏模式下打开网页。再按一次F11即可退出全屏模式。  </li>
<li>Shift+Delete 地址栏中跳出错误链接记录，选中该地址，使用这个快捷将浏览历史记录中删除所选条目，下次就不会再有这个提示内容了。  </li>
<li>Alt+F或Alt+E或F10 打开Chrome菜单 ，以自定义和控制Google Chrome中的设置。</li>
<li>Shift+Esc 打开 chrome 任务管理器。</li>
</ul>
<p><strong><a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans" target="_blank" rel="external">更加详细的快捷键参考地址</a></strong></p>
<p><em>另外一些快捷按键，不是特别方面，可以采用 crxMouse Chrome Gestures 之类的手势工具加以设置。</em></p>
<h3 id="扩展插件："><a href="#扩展插件：" class="headerlink" title="扩展插件："></a>扩展插件：</h3><p>chrome 的强大之处就在于它丰富的插件，本人 chrome 常用的插件有大概 50 多个，每次更换电脑时，chrome 都会自动帮你同步插件，但注意很多插件有隐藏功能会可能修改你的一些默认配置。</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-07-10-chrome使用技巧/2.png" alt=""></p>
<h4 id="必备插件："><a href="#必备插件：" class="headerlink" title="必备插件："></a>必备插件：</h4><ul>
<li>广告拦截：adblock plus 和 adblock pro，可以手动添加拦截，可以自动拦截，两个插件基本可以拦截腾讯视频的广告，但很多其他网站上的广告拦截不了。小黄瓜视频广告拦截，这个貌似可以拦截绝大多数的国内视频广告，但也存在一些副作用。</li>
<li>infinity new tab： 相当好用的一款tab插件，提供了不少针对chrome的扩展功能，重新规划了书签，扩展入口，历史记录等功能。Momentum：同infinity new tab类似，界面美观，但功能不够强大。</li>
<li>crxMouse Chrome Gestures：一款必备的定制手势的插件，可以自定义多种手势操作，功能强大，反应快捷。</li>
<li>Google Translate：一个小插件，用户体验不够好，提供了太多语言的选项，往往常用不是特别好，没有语言直接切换功能。翰林英汉双解词典：功能强大较多，但手动查找叫繁琐。</li>
<li>惠惠购物助手：国内可以直观的购物比价的一个插件</li>
<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>
<li>Checker Plus for Gmail：很优秀的一款gmail邮箱插件，可以只支持gmail，其他邮箱并没有一款如此优秀的插件。</li>
<li>有道云笔记网页剪报：快速将内容转入有道云笔记中。</li>
<li>Google Docs，sheet，slides：谷歌的office套件，基于web开发的，无须本地下载，功能齐全，线上可以实行多人同时阅览修改。</li>
<li>wechat： 可以登陆微信的一个app，版本太多，但只有个别几个比较好用。</li>
<li>internet-download-manager： 嫌弃 chrome 默认下载器功能太少，占用地方的话，可以使用这个插件。</li>
</ul>
<h4 id="Github插件"><a href="#Github插件" class="headerlink" title="Github插件"></a>Github插件</h4><ul>
<li>GitHub Mate 这个插件使得单文件下载更加轻松，并且还提供了一些其他功能。</li>
<li>Isometric Contributions 这个插件允许你在普通的 Github 贡献表与等距像素艺术版之间切换。</li>
<li>Sourcegraph Chrome 扩展允许你像使用一个很好的 IDE 那样浏览源代码。它为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接。 </li>
<li>ZenHub 是一个 Github 的本地项目管理工具，可以无缝的集成。</li>
<li>GitHub Linker 是一个可以链接到 NPM、bower、Composer &amp; Duo 依赖等项目主页的 Chrome 插件。</li>
<li>Github.Expandinizr 满屏显示项目</li>
<li>Avatars for Github 自动的为 GitHub 新闻和 Feed 页面添加显示用户头像。</li>
<li>Octotree 会为 Github 页面添加侧边栏，在浏览器中显示项目的目录结构，对于那些经常需要在 GitHub 阅读源代码的人非常有用。</li>
</ul>
<h4 id="图像插件"><a href="#图像插件" class="headerlink" title="图像插件"></a>图像插件</h4><ul>
<li>Fatkun图片批量下载：可以将一个或多个页面中的所有图片打包批量下载。对于</li>
<li>capture page，Capture, Explain and Send Screenshots：多功能的网页截图软件，所要的网页截图功能，这两款插件基本上全覆盖。</li>
<li>Pixlr Editor：在线版的photoshop，不解释。</li>
<li>ColorZilla：页面取色插件，速度快，功能强大。</li>
<li>hover zoom：鼠标悬停后自动放大图片，无论是浏览图片网站还是购物都是上佳的选择</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>IP-Address：可以显示IP地址的小插件。</li>
<li>Proxy SwitchyOmega：科学上网必备插件，可以同 shadowsocks 相互配合使用（可以参考我另外关于 shadowsocks 的文章）。</li>
<li>Marxico：书写markdown的一款chrome工具，可以本地使用，但不是免费，虽然界面美观，但大都基于web。</li>
</ul>
<h4 id="chrome-插件推荐网站"><a href="#chrome-插件推荐网站" class="headerlink" title="chrome 插件推荐网站"></a>chrome 插件推荐网站</h4><blockquote>
<p><a href="http://www.cnplugins.com/" target="_blank" rel="external">http://www.cnplugins.com/</a><br><a href="http://chromecj.com/" target="_blank" rel="external">http://chromecj.com/</a></p>
</blockquote>
<p>这些网站不仅会定期推荐一些 chrome 的插件，甚至还可以提供<a href="https://chrome.google.com/webstore/category/extensions?utm_source=chrome-ntp-icon" target="_blank" rel="external">官方商城</a>的应用下载（帮助不能科学上网的朋友），但是需要自己手动安装，另外对于从这些第三方网站下载下来的插件安全性方面没有保证，使用的话需谨慎。</p>
<h3 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a>小技巧：</h3><ul>
<li>在网页标签处，单击鼠标中间键即可关闭网页，国内用户大都喜欢双击关闭页面，但大多数浏览器都支持中击关闭页面</li>
<li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容,  Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容，但一般<strong>按住 ctrl 键转动鼠标滚轮实现页面缩放</strong>, <strong>Ctrl+0  将网页上的所有内容都恢复到正常大小</strong>。</li>
<li>地址栏输入错误内容后，每次提示错误内容很麻烦，可以如下操作，地址栏中选中你要删除的网址，按 shift+delete 就可以删除 chrome 浏览器地址栏输入过的记录，以免每次都自动补全错误地址。</li>
<li>Ctrl+Shift+N 在隐身模式下打开新窗口，隐身模式，是不会保存任何历史等记录的，默认也不会加载任何插件，但可以通过扩展插件手动设置某些插件在隐身下工作。</li>
<li>chrome批量删除书签:1.网址栏输入：<code>chrome://bookmarks</code> 2.<code>ctrl + A Delete</code>，但是注意这种方法仅仅删除了本地的书签，服务器的书签仍然存在，一单登陆账户仍然会同步过来。</li>
<li>多台电脑数据重复冗余时，可以删除chrome的远程同步内容，打开设置，高级同步中点击了解更多，会出来chrome帮助网址，仔细阅读可以发现<a href="https://support.google.com/chrome/answer/1181035?hl=en&amp;ref_topic=3421437" target="_blank" rel="external">网址</a>，可以清空云端设置，然后整理好本地内容，登陆账户重新上传本地同步。</li>
<li>地址栏就是个计算器，输入你需要计算的公式（无需回车），下方直接出结果，非常方便，常用，输入方式<strong>参考一般编程的公式输入方式</strong>。</li>
<li>F12 按下后 ，刷新按钮可以右键或长按来选择刷新方式，普通刷新、硬性刷新和清空缓存硬性刷新。</li>
<li>地址栏输入某网址，按 tab 键，对于像 baidu zhihu 这种自带检索能力的网址，直接可以完成站内检索，同样支持这样做的网址还有，taobao，优酷，土豆，stackoverflow，github等，似乎有搜索功能的知名网站都可以。</li>
<li>删除某网站保留的账户名和密码：打开设置-&gt;显示更多设置-&gt;管理密码，在以保存密码中搜索你需要删除的网站，最后将保存信息删除。</li>
</ul>
<h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><p>chrome 的强大毋容置疑，与其说它是一个浏览网页的小工具，我们倒不如说它自己本身就是一个操作系统（只不过暂时依赖下层操作系统），事实上 Google 也确实基于网络应用开发了 chrome OS （一个完全独立的操作系统）。chrome 自己建立了完整的生态体系，各种强大的设置应用商城等等层出不穷，我们可以看做是一个网络操作系统，那么到底 chrome 隐藏了多少小秘密?打开( chrome://chrome-urls/ )查看chrome内部页面吧。</p>
<p>地址栏输入：chrome://chrome-urls/ 即可显示 Chrome URLs 列表，如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">List of Chrome URLs</div><div class="line"></div><div class="line">chrome://accessibility</div><div class="line">chrome://appcache-internals</div><div class="line">chrome://apps</div><div class="line">chrome://blob-internals</div><div class="line">chrome://bookmarks</div><div class="line">chrome://cache</div><div class="line">chrome://chrome</div><div class="line">chrome://chrome-urls</div><div class="line">chrome://components</div><div class="line">chrome://crashes</div><div class="line">chrome://credits</div><div class="line">chrome://devices</div><div class="line">chrome://dns</div><div class="line">chrome://downloads</div><div class="line">chrome://extensions</div><div class="line">chrome://flags</div><div class="line">chrome://flash</div><div class="line">chrome://gcm-internals</div><div class="line">chrome://gpu</div><div class="line">chrome://<span class="built_in">help</span></div><div class="line">chrome://histograms</div><div class="line">chrome://<span class="built_in">history</span></div><div class="line">chrome://indexeddb-internals</div><div class="line">chrome://inspect</div><div class="line">chrome://invalidations</div><div class="line">chrome://ipc</div><div class="line">chrome://media-internals</div><div class="line">chrome://memory</div><div class="line">chrome://memory-internals</div><div class="line">chrome://nacl</div><div class="line">chrome://net-internals</div><div class="line">chrome://newtab</div><div class="line">chrome://omnibox</div><div class="line">chrome://plugins</div><div class="line">chrome://policy</div><div class="line">chrome://predictors</div><div class="line">chrome://<span class="built_in">print</span></div><div class="line">chrome://profiler</div><div class="line">chrome://quota-internals</div><div class="line">chrome://serviceworker-internals</div><div class="line">chrome://settings</div><div class="line">chrome://signin-internals</div><div class="line">chrome://stats</div><div class="line">chrome://sync-internals</div><div class="line">chrome://system</div><div class="line">chrome://terms</div><div class="line">chrome://tracing</div><div class="line">chrome://translate-internals</div><div class="line">chrome://user-actions</div><div class="line">chrome://version</div><div class="line">chrome://view-http-cache</div><div class="line">chrome://webrtc-internals</div><div class="line">chrome://webrtc-logs</div><div class="line">For Debug</div><div class="line"></div><div class="line">The following pages are <span class="keyword">for</span> debugging purposes only. Because they crash or hang the renderer, they are not linked directly; you can <span class="built_in">type</span> them into the address bar <span class="keyword">if</span> you need them.</div><div class="line"></div><div class="line">chrome://crash</div><div class="line">chrome://<span class="built_in">kill</span></div><div class="line">chrome://hang</div><div class="line">chrome://shorthang</div><div class="line">chrome://gpuclean</div><div class="line">chrome://gpucrash</div><div class="line">chrome://gpuhang</div><div class="line">chrome://ppapiflashcrash</div><div class="line">chrome://ppapiflashhang</div><div class="line">chrome://quit/</div><div class="line">chrome://restart/</div></pre></td></tr></table></figure>
<ul>
<li>chrome://flags/#overlay-scrollbars 重叠式滚动条，开启后滚动条会自动缩放带有动画效果。</li>
<li>保存网页本地阅读： 输入 <code>chrome://flags/</code> 然后开启 Save Page as MHTML 按照提示重启 chrome 之后右击网页保存即可。</li>
</ul>
<hr>
<p>To be continued…</p>
<blockquote>
<p>参考链接：<br><a href="http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html" target="_blank" rel="external">http://jingyan.baidu.com/article/359911f516583d57fe0306ae.html</a><br><a href="http://zhidao.baidu.com/question/502291145.html" target="_blank" rel="external">http://zhidao.baidu.com/question/502291145.html</a><br><a href="http://www.igooda.cn/jzjl/201604061075.html" target="_blank" rel="external">http://www.igooda.cn/jzjl/201604061075.html</a><br><a href="http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html" target="_blank" rel="external">http://jingyan.baidu.com/article/37bce2be1403ce1003f3a26d.html</a><br><a href="https://www.zhihu.com/question/28531079?sort=created&amp;page=2" target="_blank" rel="external">https://www.zhihu.com/question/28531079?sort=created&amp;page=2</a><br><a href="https://www.zhihu.com/question/34682699" target="_blank" rel="external">https://www.zhihu.com/question/34682699</a><br><a href="http://www.cnblogs.com/constantince/p/4565261.html" target="_blank" rel="external">http://www.cnblogs.com/constantince/p/4565261.html</a><br><a href="https://www.zhihu.com/question/28531079" target="_blank" rel="external">https://www.zhihu.com/question/28531079</a><br><a href="http://tieba.baidu.com/p/3677249170" target="_blank" rel="external">http://tieba.baidu.com/p/3677249170</a><br><a href="http://www.ghacks.net/2012/09/04/list-of-chrome-urls-and-their-purpose/" target="_blank" rel="external">http://www.ghacks.net/2012/09/04/list-of-chrome-urls-and-their-purpose/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下的virtualbox安装配置]]></title>
      <url>http://noparkinghere.top/2016/07/07/2016/2016-07-07-linux%E4%B8%8B%E7%9A%84virtualbox%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h3><p>随着计算机技术的发展，硬件配置越来越高，跨平台软件，手机以及浏览器越来越强大，目前可以说<br>linux下除了大型游戏意外，其他的办公学习娱乐基本都可以解决，比如：</p>
<a id="more"></a>
<ul>
<li>购物可以电脑浏览，手机支付（很多win用户，估计也不怎么用u盾了）。</li>
<li>音乐可以使用百度，qq在线音乐。</li>
<li>至于编程等开发工具更是齐全。</li>
</ul>
<p>但仍然难免会有一些windows程序需要用户操心，个人主要需用使用的windows产品有：<br><em>迅雷，百度云，photoshop，illustrator，U盘系统制作工具等</em></p>
<p>解决办法主要有：</p>
<ul>
<li>wine提供windows的类库，是软件windows软件直接可以在linux上面运行</li>
<li>使用虚拟机，在linux上面虚拟一个windows xp出来，提供一定的硬件资源，运行需要使用的软件</li>
</ul>
<p><strong>这边我们选择虚拟机virtualbox，主要该软件开源小巧，且现在硬件强大，对资源的开销可以接收，外加wine向来不是太稳定，出现问题的几率高。</strong></p>
<h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><ul>
<li>ubuntu 16.04 终端输入： lsb_release -a</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>步骤如下：</p>
<ol>
<li>需要安装Oracle Virtualbox</li>
</ol>
<p>可以使用sudo apt-get install virutalbox 安装</p>
<p>也可以通过官网下载地址：<code>https://www.virtualbox.org/wiki/Downloads</code></p>
<p>安装增强包的方法介绍：<code>http://gaoke0820.blog.163.com/blog/static/21664965201332802833510/</code></p>
<ol>
<li>安装完之后，U盘识别</li>
</ol>
<p><em>如果如VirtualBox客户机挂载U盘中设置后，linux中还不能挂载u盘，而使用sudo启动virtualbox后里面的客户机可以挂载U盘，原因为 普通用户没有使用USB设备权限。</em></p>
<p>2.1 方法1：</p>
<p>让GUEST识别USB设备</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo gedit   /etc/fstab</div><div class="line"></div><div class="line">在末尾加上</div><div class="line"><span class="comment"># the USB group</span></div><div class="line"><span class="comment"># 对所有用户开放USB设备的读写权限</span></div><div class="line">none /proc/bus/usb usbfs devmode=666 0 0</div><div class="line">然后就可以使用的USB设备了。</div></pre></td></tr></table></figure>
<p><em>但是把USB设备的读写权限开放给所有用户的方式在一些情况下不太安全</em></p>
<p>2.2 方法2：</p>
<p>将用户名添加到vboxusers组,重启或注销后即可解决.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo adduser usrname vboxusers</div><div class="line"></div><div class="line">然后再输入：cat /etc/group |grep vboxusers</div><div class="line">这时可以看到显示：</div><div class="line">vboxusers:x:129:demon,hello</div></pre></td></tr></table></figure>
<p><em>该方法使用后，基本能够使用，但使用之前每次需要手动添加设备</em></p>
<p>2.3 方法3：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">增加用户组usbfs</div><div class="line"><span class="variable">$sudo</span> groupadd usbfs</div><div class="line"></div><div class="line">查看usbfs用户组的gid</div><div class="line">$ cat /etc/group | grep usbfs</div><div class="line">usbfs:x:1002:</div><div class="line"></div><div class="line">把当前用户增加到usbfs组</div><div class="line">sudo adduser demon usbfs</div></pre></td></tr></table></figure>
<p>为USB设备重新设置权限,编辑/etc/fstab文件，添加下面两行，注意你的gid可能不是1002</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> $   sudo gedit /etc/fstab</div><div class="line">在末尾加上</div><div class="line"><span class="comment"># 1002 is the USB group IDI</span></div><div class="line">none /proc/bus/usb usbfs devgid=1002,devmode=774 0 0</div></pre></td></tr></table></figure>
<p>重新启动后，应该就可以在客户机中使用USB设备了。</p>
<p>方法：插入一个USB设备后，如U盘、鼠标，右键点击虚拟机里右下脚的USB图标，选择已经识别的U盘，就可以正常使用了。<br>注意： 在客户机里使用USB设备前要先在主机里卸载。</p>
<p>﻿</p>
<ol>
<li>在virtualbox里启动USB控制器</li>
</ol>
<ol>
<li>打开虚拟机，这时在虚拟机的设备-分配USB设备中就可以看到USB设备了</li>
</ol>
<blockquote>
<p>相关参考：<br><a href="http://blog.csdn.net/rongyongfeikai2/article/details/21795741" target="_blank" rel="external">http://blog.csdn.net/rongyongfeikai2/article/details/21795741</a><br><a href="http://www.linuxidc.com/Linux/2012-01/52502.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-01/52502.htm</a><br><a href="http://xuantan.iteye.com/blog/1130808" target="_blank" rel="external">http://xuantan.iteye.com/blog/1130808</a><br><a href="http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php" target="_blank" rel="external">http://www.iteedu.com/os/linux/mklinuxdiary/ch1tools/2.php</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github本地推送]]></title>
      <url>http://noparkinghere.top/2016/07/05/2016/2016-07-05-github%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/</url>
      <content type="html"><![CDATA[<h3 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h3><ul>
<li>ubuntu 16.04 终端输入： lsb_release -a</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>git 和 ssh</li>
</ul>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p><strong>github一般支持http和ssh两种传输协议（可能还有其他的，作为菜鸟暂时不作研究），而使用clone的时候，可以选择两者之一，生成地址，直接选用http的话，<br>不需要输入密码和验证，如果采用ssh则需要将上传到github上面的公钥和本地的私钥进行匹配，验证成功后才能进行相关一系列的操作。</strong></p>
<ul>
<li><p>安装git 和 ssh <code>sudo apt-get install git ssh</code></p>
</li>
<li><p>为了和Github的远程仓库进行传输，需要进行SSH加密设置。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"&#123;name@site.com&#125;"</span>    // 用你的邮箱替换&#123;name@site.com&#125;</div><div class="line">可以不输入其他信息，一直敲回车直到命令完成。</div><div class="line">这时你的用户目录下会出现名为.ssh 的文件夹（默认隐藏），点进去能看到 id_rsa 和 id_rsa.pub 两个文件，其中 id_rsa 是私钥，不能让怪人拿走， id_rsa.pub 是公钥，无需保密</div></pre></td></tr></table></figure>
<ul>
<li><p>登录Github，点击右上角头像下的Settings -&gt; SSH and GPG keys -&gt; New SSH key ,在title中输入名称，Key中输入公钥（id_rsa.pub中的所有内容）</p>
</li>
<li><p>终端下面设置git</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"&#123;name&#125;"</span>    // 用你的名字代替&#123;name&#125;</div><div class="line">git config --global user.email <span class="string">"&#123;name@site.com&#125;"</span>    // 用你的邮箱替换&#123;name@site.com&#125;</div></pre></td></tr></table></figure>
<ul>
<li>打开你需要下载目录，使用ssh协议远程下载你的项目</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> Documents</div><div class="line">git <span class="built_in">clone</span> git@github.com:xxx/yyy.git</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://playingfingers.com/2016/03/26/build-a-blog/#ssh" target="_blank" rel="external">http://playingfingers.com/2016/03/26/build-a-blog/#ssh</a><br><a href="http://www.yiibai.com/git/git_environment.html" target="_blank" rel="external">http://www.yiibai.com/git/git_environment.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下文件查找]]></title>
      <url>http://noparkinghere.top/2016/07/01/2016/2016-07-01-linux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>linux 使用 CLI 的情况下，如果要查找文件还是很方便的，本身提供了多个搜索查找工具，这边主要列出一般随系统自带的工具：”find”；”locate”；”whereis”；”which”；”type”，这几个工具，一般绝大多数 linux 发行版都会自带；linux 是一个小而美的系统，基于 linux 内核之上，肯定还有一些发行版或者个人会提供一些更加强大的检索工具，这边不做详细介绍。</p>
<h3 id="1-find"><a href="#1-find" class="headerlink" title="1. find"></a>1. find</h3><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。<br>find的使用格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</div><div class="line">&lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。</div><div class="line">&lt;指定条件&gt;： 所要搜索的文件的特征。</div><div class="line">&lt;指定动作&gt;： 对搜索结果进行特定的处理。</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">find的使用实例：</div><div class="line">$ find . -name <span class="string">'my*'</span></div><div class="line">搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。</div><div class="line">$ find / -name <span class="string">'my*'</span> -ls</div><div class="line">搜索根目录中，所有文件名以my开头的文件，并显示它们的详细信息。</div><div class="line">$ find . -type f -mmin -10</div><div class="line">搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</div></pre></td></tr></table></figure>
<p>注意：find 每次会遍历你索要搜索的路径，然后查找文件名，另外 find 后面如果直接跟文件名如： find . -name myfile 则只会查找文件名为 myfile 的文件，如果需要搜索 myfile1 等文件，则需要加入 * 通配符。</p>
<h3 id="2-locate"><a href="#2-locate" class="headerlink" title="2. locate"></a>2. locate</h3><p>locate 命令其实是 “find -name” 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，<strong>先使用 updatedb 命令</strong>，手动更新数据库，ubuntu 下需要使用 sudo 才可以更新该数据库。</p>
<p>locate 相当于快速检索的 <code>find -name &quot;*name*&quot;</code> 写法，默认就带入模糊查找的功能，如果需要精准查找需要 <code>locate -b &#39;\NAME&#39;</code> man 文档中有详细描述。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">locate命令的使用实例：</div><div class="line">$ locate /etc/sh</div><div class="line">搜索etc目录下所有以sh开头的文件。</div><div class="line">$ locate ~/m</div><div class="line">搜索用户主目录下，所有以m开头的文件。</div><div class="line">$ locate -i ~/m</div><div class="line">搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</div></pre></td></tr></table></figure>
<h3 id="3-whereis"><a href="#3-whereis" class="headerlink" title="3. whereis"></a>3. whereis</h3><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">whereis命令的使用实例：</div><div class="line">$ whereis grep</div></pre></td></tr></table></figure>
<h3 id="4-which"><a href="#4-which" class="headerlink" title="4. which"></a>4. which</h3><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">which</span>命令的使用实例：</div><div class="line">$ <span class="built_in">which</span> grep</div></pre></td></tr></table></figure>
<h3 id="5-type"><a href="#5-type" class="headerlink" title="5. type"></a>5. type</h3><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。<br>type命令的使用实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">type</span> <span class="built_in">cd</span></div><div class="line">系统会提示，<span class="built_in">cd</span>是shell的自带命令（build-in）。</div><div class="line">$ <span class="built_in">type</span> grep</div><div class="line">系统会提示，grep是一个外部命令，并显示该命令的路径。</div><div class="line">$ <span class="built_in">type</span> -p grep</div><div class="line">加上-p参数后，就相当于<span class="built_in">which</span>命令。</div></pre></td></tr></table></figure>
<blockquote>
<p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html</a><br><a href="http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm" target="_blank" rel="external">http://jingyan.baidu.com/article/335530dab6fe0919ca41c365.htm</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[u盘安装XP系统]]></title>
      <url>http://noparkinghere.top/2016/06/30/2016/2016-06-30-windowsXP%E7%BA%AF%E5%87%80%E7%89%88%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>如果仅需要优盘安装XP可以直接查看Windows XP安装部分</strong></p>
</blockquote>
<h3 id="1-Why-XP"><a href="#1-Why-XP" class="headerlink" title="1.Why XP?"></a>1.Why XP?</h3><p>windows XP 这个系统微软早已停止服务了，一般现在也不再会有人会想着安装这个系统了。作为已经安装过各种系统多次的人而言，老实说我也只有最初不太懂电脑的中学时候用过XP，自从09年win7出来后，就开始转战 win7 了，个人写这篇文章主要出于以下几种原因：</p>
<ul>
<li>这个系统相当稳定，占用资源很少，可以作为老旧机器的不二选择。</li>
<li>个人工作学习完全使用 Ubuntu 系统了，时不时会用 windows 平台下面的软件如：迅雷，百度云，photoshop 等，现在机器性能强劲，virtualbox 下的 xp 运行这些中小型软件完全没任何问题。</li>
<li>XP 安装与其他软件比较为特殊，通过文章的总结，下次便于参考。</li>
</ul>
<a id="more"></a>
<h4 id="windows-XP简介："><a href="#windows-XP简介：" class="headerlink" title="windows XP简介："></a>windows XP简介：</h4><p>Windows XP，是微软公司（Microsoft）推出的供个人电脑使用的操作系统，包括商用及家用的台式电脑等。Windows XP率先使用双列菜单，为之后的Windows 版本的开始菜单提供了基础。其名字 “XP” 的意思是英文中的 “体验（Experience）”，现已退役，如果你在结束支持后继续使用 Windows XP，那么你的电脑仍可工作，但它可能更容易受到安全风险与病毒的攻击。</p>
<p><em>我们这边以纯净版的sp3中文专业版为例。</em></p>
<h3 id="2-常规系统安装方法"><a href="#2-常规系统安装方法" class="headerlink" title="2.常规系统安装方法"></a>2.常规系统安装方法</h3><h4 id="2-1光驱安装"><a href="#2-1光驱安装" class="headerlink" title="2.1光驱安装"></a>2.1光驱安装</h4><p>以往的系统安装大多使用光驱安装，而电脑的 BIOS 引导项也都有光驱引导，但随着上网本，超极本等的流行，越来越多的电脑为了节省空间将光驱给去掉了。</p>
<p>事实也是如此，光驱读取速度慢，且网络如此发达，现在很多厂家现在也都不再提供光盘，而是通过官方网站自行获取相关软件及驱动程序，或者直接提供优盘（优盘越来越廉价）。</p>
<p><em>光盘安装简单，但不作为本文的重点，以下将不会再涉及。</em></p>
<h4 id="2-2优盘安装"><a href="#2-2优盘安装" class="headerlink" title="2.2优盘安装"></a>2.2优盘安装</h4><h5 id="2-2-1windows下的PE安装方式"><a href="#2-2-1windows下的PE安装方式" class="headerlink" title="2.2.1windows下的PE安装方式"></a>2.2.1windows下的PE安装方式</h5><p>大多数 windows 的产品都可以将优盘制作成一个 PE 启动盘，然后通过这个启动程序，引导需要安装的 ISO 文件，最终完成安装。</p>
<h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>通过 pe，在安装系统之前，可以执行相关备份，分区等操作。</li>
<li>一次 pe 制作，下次可以重复反复使用，pe 一般通过软件制作在优盘中，很多都形成单独分区，不会影响优盘的正常使用。</li>
<li>通过 pe 可以执行一些辅助的操作，可以将 pe 作为一个系统软件，即便不需要安装系统，可以通过 pe 做一些事情。</li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>不同的 windows 系统，对应的 pe 不一样！！！没错确确实实不一样，例如： xp 的 pe 就基本上不可能帮你安装 win7 ，同样 win7 的 pe 也不可能让你安装的上 win10 或者 winXP 。</li>
<li>现在 pe 越做越复杂，对于只需要安装系统的新手来说，弄清楚里面 ghost 安装，原版安装，优盘一键安装这都很费力。</li>
</ul>
<h6 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h6><ul>
<li>pe 安装虽然可以解决大多数问题，但毕竟太过冗余，而且不同的系统安装还需要不同的PE，另外对于linux等其他系统也完全没办法解决。</li>
</ul>
<h5 id="2-2-2ultraISO制作u盘安装盘"><a href="#2-2-2ultraISO制作u盘安装盘" class="headerlink" title="2.2.2ultraISO制作u盘安装盘"></a>2.2.2ultraISO制作u盘安装盘</h5><p>注意 ultraISO 并非一个免费的软件，且免费版本的功能极为有限，这边提供ultraISO大容量版安装程序：<code>http://pan.baidu.com/s/1hrXbQ7q</code></p>
<h3 id="3-Windows-XP安装"><a href="#3-Windows-XP安装" class="headerlink" title="3.Windows XP安装"></a>3.Windows XP安装</h3><p>xp的安装同以上安装略有不同，原因根据查找可能是xp本身系统是不完全支持优盘引导的，所以在制作优盘XP引导时，如果仅仅使用ultraISO是很可能无法成功的。如下图：</p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/1.jpg" alt=""></p>
<p>为了解决这个问题，我们通过另外一个软件 WinSetupFromUSB 来制作 XP 优盘引导。</p>
<p>使用 WinSetupFromUSB 只需要下载一个 6.5MB 的绿色软件就可以制作好 windowsXP 的安装U盘，方便简捷。WinSetupFromUSB 不仅支持 WindowsXP 的，还支持 Win7/Vista 安装U盘的制作。</p>
<h4 id="3-1准备工具："><a href="#3-1准备工具：" class="headerlink" title="3.1准备工具："></a>3.1准备工具：</h4><ul>
<li>1G 以上 U 盘一枚，XP安装程序约为700M</li>
<li>WinSetupFromUSB 1.0 beta7：<br><code>http://pan.baidu.com/s/1geXdWyR</code><br><code>http://download.csdn.net/detail/littlefang/3664196</code></li>
<li>下载 Windows XP 安装光盘或镜像：<br><code>http://pan.baidu.com/s/1bNeMp4</code></li>
</ul>
<h4 id="3-2制作步骤："><a href="#3-2制作步骤：" class="headerlink" title="3.2制作步骤："></a>3.2制作步骤：</h4><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/2.gif" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/3.gif" alt=""></p>
<ul>
<li>在 3 BootOption 栏目中选择 XP/BartPE bootable[NTLDR]，在 4 FILESYSTEM and OVERRIDES中选择 NTFS和BOOT as HDD，然后点击 6 Prepare Drive</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/4.gif" alt=""></p>
<ul>
<li>开始写入引导文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/5.gif" alt=""></p>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/6.gif" alt=""></p>
<ul>
<li>待窗口关闭后返回 RMPrepUSB 界面，点击 exit 退出</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/7.gif" alt=""></p>
<ul>
<li>指定安装文件路径回到 WinSetupFromUSB 主界面，选中 Windows 2000/XP/2003 Setup，指定安装盘所在盘符（I386文件夹的父目录），我使用虚拟光驱把xp的镜像加载到E盘。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/8.gif" alt=""></p>
<ul>
<li>等待启动 U 盘制作完毕，这个过程极为漫长，参考资料说 10 分钟，但实际用了 40 分钟左右。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/9.gif" alt=""></p>
<ul>
<li>完毕就绪</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/10.gif" alt=""></p>
<h4 id="3-3安装步骤："><a href="#3-3安装步骤：" class="headerlink" title="3.3安装步骤："></a>3.3安装步骤：</h4><ul>
<li><p>开始安装系统，相关 bios 设置这边不详细列出，电脑的厂家不一样，设置也不相同，快速设置功能未必打开，全功能的 bios 设置一般台式机为 delete 按键，笔记本可能是 F2,F10,F12 等根据主板型号而定，修改 bios 主要是为了修改引导方式，电脑一般加载系统会从硬盘进行引导，如果你想从优盘或者光盘引导系统的话，就需要在 boot 中将优盘或者光盘放在最高的优先级（第一位）。这边我们因为使用优盘安装，所以将优盘放在最上面即可。注意：如果你电脑打开了快速设置，一般可以直接选择优盘进行引导，而如果你的电脑是 Lenovo 等在主板中启用了安全功能，则需要讲该功能关闭才可以修改 bios 的引导方式，另外 UEFI 模式这边也需要改成 BIOS/legacy 模式。</p>
</li>
<li><p>XP安装界面，如果是全新硬盘，需要分区等操作，先使用 winPE 等工具，安装位置选择 C 盘（主分区）默认选项安装即可。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-30-windowsXP纯净版安装/11.gif" alt=""></p>
<ul>
<li>现在 CPU 和硬盘普遍读取速度快，XP 可能显示需要安装 30 分钟以上，但实际一个固态硬盘 +intel i5 以上的处理体只需要5分钟左右即可安装完毕。</li>
</ul>
<h4 id="3-4后续补充："><a href="#3-4后续补充：" class="headerlink" title="3.4后续补充："></a>3.4后续补充：</h4><ul>
<li>因为安装的是纯净版的 XP，因此极有可能会缺少相关驱动程序，尤其是网卡驱动，因此建议系统安装完毕后，使用驱动精灵（网卡版）将网卡驱动补全，进一步将所有需要的驱动下载安装，如果比较冷门的旧机器建议可以去官网下载驱动，主要需要安装的是网卡，intel 相关和显卡驱动，其他驱动程序不会有太大的影响。</li>
</ul>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/littlefang/article/details/6851864" target="_blank" rel="external">http://blog.csdn.net/littlefang/article/details/6851864</a><br><a href="http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html" target="_blank" rel="external">http://jingyan.baidu.com/article/ca2d939df51697eb6d31ce10.html</a><br><a href="http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4a22a65a0101e0tz.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux的下载工具]]></title>
      <url>http://noparkinghere.top/2016/06/29/2016/2016-06-29-linux%E4%B8%8B%E7%9A%84%E4%B8%8B%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>linux命令行下载外网文件或内网进行大文件传输，经常使用的文本下载工具wget、curl，今天给大家推荐支持Linux命令行多线程、断点续传下载工具axel和myget。</p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><h4 id="Linux系统如何查看版本信息"><a href="#Linux系统如何查看版本信息" class="headerlink" title="Linux系统如何查看版本信息"></a>Linux系统如何查看版本信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">输入<span class="string">"uname -a "</span>,可显示电脑以及操作系统的相关信息。</div><div class="line">Linux系统如何查看版本信息</div><div class="line">输入<span class="string">"cat /proc/version"</span>,说明正在运行的内核版本。</div><div class="line">Linux系统如何查看版本信息</div><div class="line">输入<span class="string">"cat /etc/issue"</span>, 显示的是发行版本信息</div><div class="line">Linux系统如何查看版本信息</div><div class="line">lsb_release <span class="_">-a</span> (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</div><div class="line">Linux系统如何查看版本信息</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="查看本机的信息"><a href="#查看本机的信息" class="headerlink" title="查看本机的信息"></a>查看本机的信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># lsb_release -a(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)</span></div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<h3 id="下载工具安装、使用方法介绍"><a href="#下载工具安装、使用方法介绍" class="headerlink" title="下载工具安装、使用方法介绍"></a>下载工具安装、使用方法介绍</h3><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><ul>
<li>ubuntu安装请运行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sudo apt-get install wget</span></div><div class="line">wget版本信息</div><div class="line"><span class="comment"># wget -V</span></div><div class="line">GNU Wget 1.17.1 built on linux-gnu.</div></pre></td></tr></table></figure>
<ul>
<li>此工具比较常用，使用方法、参数略</li>
</ul>
<h4 id="Axel-下载-安装"><a href="#Axel-下载-安装" class="headerlink" title="Axel 下载 安装"></a>Axel 下载 安装</h4><ul>
<li>官方站点<a href="http://axel.alioth.debian.org/" target="_blank" rel="external">http://axel.alioth.debian.org/</a></li>
<li>安装axel</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sudo apt-get install axel</span></div><div class="line">axel版本</div><div class="line"><span class="comment"># axel -V</span></div><div class="line">Axel version 2.5 (Linux)</div><div class="line"></div><div class="line">Copyright 2001-2007 Wilmer van der Gaast,</div><div class="line">          2015      Joao Eriberto Mota Filho,</div><div class="line">                    and others.</div><div class="line">Please, see the CREDITS file.</div></pre></td></tr></table></figure>
<ul>
<li>axel命令使用方法：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">axel [选项参数] url1 [url2] [url……]</div><div class="line">axel 参数：</div><div class="line">--max-speed=x    <span class="comment">#限速值最高速度</span></div><div class="line"> <span class="_">-s</span> x</div><div class="line">Specify maximum speed (bytes per second)</div><div class="line"> --num-connections=x</div><div class="line"> -n x <span class="comment">#连接数</span></div><div class="line">Specify maximum number of connections</div><div class="line"> --output=f <span class="comment">#下载为本地文件</span></div><div class="line"> -o f</div><div class="line">Specify <span class="built_in">local</span> output file</div><div class="line"> --search[=x] <span class="comment">#搜索镜像</span></div><div class="line"> -S [x]</div><div class="line">Search <span class="keyword">for</span> mirrors and download from x servers</div><div class="line"> --header=x  </div><div class="line"> -H x     <span class="comment">#添加头文件字符串</span></div><div class="line">Add header string</div><div class="line"> --user-agent=x <span class="comment">#设置UA</span></div><div class="line"> -U x  </div><div class="line">Set user agent</div><div class="line"> --no-proxy     <span class="comment">#不使用代理服务器</span></div><div class="line"> -N  </div><div class="line">Just don<span class="string">'t use any proxy server --quiet  </span></div><div class="line"> --quiet, -q  </div><div class="line">No output to stdout. #静默模式，不输出到标准输出  </div><div class="line">--verbose  </div><div class="line"> -v  </div><div class="line">More status information #更多状态信息  </div><div class="line"> --alternate  </div><div class="line"> --help #帮助  </div><div class="line"> -h  </div><div class="line">--version #版本  </div><div class="line"> -V</div></pre></td></tr></table></figure>
<h4 id="myget-下载、安装"><a href="#myget-下载、安装" class="headerlink" title="myget 下载、安装"></a>myget 下载、安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget http://myget.sourceforge.net/release/myget-0.1.2.tar.gz</div><div class="line">tar -zxvf myget-0.1.2.tar.gz</div><div class="line"><span class="built_in">cd</span> myget-0.1.2</div><div class="line"><span class="comment"># ./configure &amp;&amp; make &amp;&amp; make install</span></div><div class="line">mytget版本，注意myget命令为mytget</div><div class="line"><span class="comment"># mytget -v</span></div><div class="line">myget 0.1.1</div></pre></td></tr></table></figure>
<ul>
<li>命令mytget用法</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mytget [选项] [url]</div><div class="line">参数</div><div class="line"> -b, --debug          Show the debug message <span class="comment">#看调试信息</span></div><div class="line"> -c, --count=num      Set the retry count to [num], no <span class="built_in">limit</span> when <span class="string">"0"</span>, the default is <span class="string">"99"</span> <span class="comment">#设置重试次数，0为无限，默认是99次。</span></div><div class="line"> <span class="_">-d</span>, --directory=dir Set the <span class="built_in">local</span> direcotry to [dir], the default is <span class="string">"."</span> <span class="comment">#指定下载本地目录，默认是当前目录</span></div><div class="line"> <span class="_">-f</span>, --file=file      Rename the file to [file] <span class="comment">#重命名下载到本地的文件名</span></div><div class="line"> -h, --help           A brief summary of all the options <span class="comment">#简短的帮助摘要</span></div><div class="line"> -i, --interval=num   Set the ftp retry interval to [num] seconds, the default is <span class="string">"5"</span> <span class="comment">#设置ftp重试间隔，单位s，默认5秒</span></div><div class="line"> -n, --number=num     Use [num] connections instead of the default (4) <span class="comment">#指定连接数，默认4</span></div><div class="line"> -r, --referer=URL    Include `Referer: [URL]<span class="string">' header in HTTP request. #包含请求头 Referer</span></div><div class="line"> -t, --timeout=num    Set the connection timeout to [num] seconds, the default is "30" #设置连接超时时间，默认30秒</div><div class="line"> -v, --version        Show the version of the myget and exit #查看版本信息</div><div class="line"> -x, --proxy=URL      Set the proxy [URL]  #设置代理</div></pre></td></tr></table></figure>
<h3 id="wget、axel、myget测试下载速度对比"><a href="#wget、axel、myget测试下载速度对比" class="headerlink" title="wget、axel、myget测试下载速度对比"></a>wget、axel、myget测试下载速度对比</h3><h4 id="下载速度对比"><a href="#下载速度对比" class="headerlink" title="下载速度对比"></a>下载速度对比</h4><p>说明：同一台机器下载同一个数据源链接</p>
<ul>
<li>wget下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 09:29:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div></pre></td></tr></table></figure>
<ul>
<li>axel下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso.0</div><div class="line">Starting download</div><div class="line"></div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 382.3KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 610.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 826.5KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1003.1KB/s]</div><div class="line">略</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2055.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2074.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2093.6KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2111.0KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... ...</div><div class="line">Downloaded 2693.8 kilobytes <span class="keyword">in</span> 1 second. (2113.05 KB/s)</div><div class="line"><span class="comment"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</span></div></pre></td></tr></table></figure>
<ul>
<li>axel  使用10个线程下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Starting download</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 440.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 707.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 935.1KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1138.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1310.5KB/s]</div><div class="line">略</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2180.3KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2196.9KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [2189.7KB/s]</div><div class="line">[ 0%] .......... .......... .........</div><div class="line">Downloaded 4139.5 kilobytes <span class="keyword">in</span> 1 second. (2176.65 KB/s)</div></pre></td></tr></table></figure>
<h4 id="myget下载"><a href="#myget下载" class="headerlink" title="myget下载"></a>myget下载</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Filesize: 4.1G</div><div class="line"> 0% [                       &gt;                       &gt;                       &gt;                         ] [ 27M] [2.5M/s] [ETA:26:58]</div></pre></td></tr></table></figure>
<ul>
<li>myget指定10个线程下载</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># mytget -n <span class="number">10</span> http://url/iso/Centos/x86_64/CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso</span></div><div class="line"><span class="keyword">Begin </span>to download: CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso</span></div><div class="line"><span class="symbol">Filesize</span>: <span class="number">4</span>.<span class="number">1</span>G</div><div class="line"> <span class="number">0</span>% [        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;        &gt;         &gt;         &gt;          ] [ <span class="number">39</span>M] [<span class="number">2</span>.<span class="number">6</span>M/s] [ETA:<span class="number">26</span>:<span class="number">27</span>]</div><div class="line"># ll CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso.mg\!</span></div><div class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">4353378404</span> <span class="keyword">Mar </span><span class="number">11</span> <span class="number">12</span>:<span class="number">53</span> CentOS-<span class="number">6</span>.<span class="number">4</span>-x86_64-<span class="keyword">bin-DVD1.iso.mg!</span></div><div class="line">下载速度对比结论：axel、myget支持多线程，且速度较快都在<span class="number">2</span>M。</div></pre></td></tr></table></figure>
<h3 id="断点续传对比测试"><a href="#断点续传对比测试" class="headerlink" title="断点续传对比测试"></a>断点续传对比测试</h3><h4 id="axel"><a href="#axel" class="headerlink" title="axel"></a>axel</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Starting download</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 491.8KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [ 748.4KB/s]</div><div class="line">[ 0%] .......... .......... .......... .......... .......... [1007.5KB/s]</div><div class="line">略</div><div class="line">[ 1%] .......... ........... .......... .......... .......... [2509.3KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [2509.5KB/s]</div><div class="line">[ 1%] .......... .......... .......... ....</div><div class="line">Downloaded 45.3 megabytes <span class="keyword">in</span> 18 seconds. (2510.95 KB/s)</div><div class="line">中止下载，进度已经到1%，下载了45.3mb</div></pre></td></tr></table></figure>
<ul>
<li>再次运行下载命令，继续从1%断点续传</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># axel -n 10 http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Initializing download: http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">File size: 4353378304 bytes</div><div class="line">Opening output file CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">State file found: 47549233 bytes downloaded, 4305829071 to go.</div><div class="line">Starting download</div><div class="line">        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,...... .......... [ 314.4KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [ 603.0KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [ 839.7KB/s]</div><div class="line">               略</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [1547.1KB/s]</div><div class="line">[ 1%] .......... .......... .......... .......... .......... [1548.8KB/s]</div><div class="line"><span class="comment"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</span></div></pre></td></tr></table></figure>
<h4 id="wget-1"><a href="#wget-1" class="headerlink" title="wget"></a>wget</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 09:51:46-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div><div class="line"> 1% [                                                                               ] 47,760,647 1.49M/s eta 47m 42s</div></pre></td></tr></table></figure>
<ul>
<li>wget在进度1%中止已经下载47,760,647，再次运行命令，重新开始下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 09:53:24-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso.1<span class="string">'</span></div><div class="line"> 0% [                                                                               ] 1,032,445   1.21M/s</div></pre></td></tr></table></figure>
<ul>
<li>wget直接运行不支持断点续传</li>
</ul>
<p><code># rm -f CentOS-6.4-x86_64-bin-DVD1.iso*</code></p>
<ul>
<li>wget重新测试使其支持断点续传</li>
</ul>
<p><code># wget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">--2013-03-11 12:40:15-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: 4353378304 (4.1G) [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div><div class="line"> 1% [&gt;                                                                                          ] 52,620,206  1.57M/s eta 44m 58s</div><div class="line">在进度1%，已经下载52,620,206处停止</div></pre></td></tr></table></figure>
<ul>
<li>wget 加-c再次下载，支持断点续传</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">--2013-03-11 12:40:56-- http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Connecting to 10.0.251.154:80... connected.</div><div class="line">HTTP request sent, awaiting response... 206 Partial Content</div><div class="line">Length: 4353378304 (4.1G), 4300661972 (4.0G) remaining [application/octet-stream]</div><div class="line">Saving to: `CentOS-6.4-x86_64-bin-DVD1.iso<span class="string">'</span></div><div class="line"> 1% [+                                                                                          ] 59,663,080 1.59M/s eta 44m 14s</div><div class="line"># rm -f CentOS-6.4-x86_64-bin-DVD1.iso.mg\!</div></pre></td></tr></table></figure>
<p>4.3 myget</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Filesize: 4.1G</div><div class="line"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 45M] [2.1M/s] [ETA:33:06]</div><div class="line">下载进度到1% 文件大小45M</div><div class="line"><span class="comment"># ll CentOS-6.4-x86_64-bin-DVD1.iso.mg\!</span></div><div class="line">-rw-r--r-- 1 root root 4353378404 Mar 11 12:54 CentOS-6.4-x86_64-bin-DVD1.iso.mg!</div><div class="line">再次执行命令，直接从进度1%开始下载</div><div class="line"><span class="comment"># mytget http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso</span></div><div class="line">Begin to download: CentOS-6.4-x86_64-bin-DVD1.iso</div><div class="line">Filesize: 4.1G</div><div class="line"> 1% [                       &gt;                       &gt;                        &gt;                        ] [ 51M] [2.9M/s] [ETA:23:57]</div></pre></td></tr></table></figure>
<p><strong>断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。<br>综上对比推荐大家工作中使用axel或myget提高效率，个人比较喜欢axel。<br>注意内网传输根据隧道带宽进行限速，别影响线上生产服务数据传输。</strong></p>
<h3 id="aria2c-The-ultra-fast-download-utility"><a href="#aria2c-The-ultra-fast-download-utility" class="headerlink" title="aria2c (The ultra fast download utility)"></a>aria2c (The ultra fast download utility)</h3><p>强烈推荐这个下载工具，可以说是 linux 下的下载神器，速度比 windows 下的迅雷还要快不少。aria2c 并不仅是一个简单的下载工具，里面配置选项相当多，另外也有不少 GUI 工具支持 aria2c 这边不做详细的介绍，具体可以参考本博客中的 Aria2 详解这篇文章。</p>
<p><em>未完待续</em></p>
<blockquote>
<p>相关链接：<br><a href="http://dreamway.blog.51cto.com/1281816/1151886" target="_blank" rel="external">http://dreamway.blog.51cto.com/1281816/1151886</a> (centos版本)<br><a href="http://sydi.org/posts/linux/aria2c-usage-sample-cns.html" target="_blank" rel="external">http://sydi.org/posts/linux/aria2c-usage-sample-cns.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下ssh通过VPN推送失败]]></title>
      <url>http://noparkinghere.top/2016/06/28/2016/2016-06-28-linux%E4%B8%8Bssh%E9%80%9A%E8%BF%87VPN%E6%8E%A8%E9%80%81%E5%A4%B1%E8%B4%A5/</url>
      <content type="html"><![CDATA[<p>本文主要用于解决 VPN 和 SSH 两者冲突不兼容的问题。</p>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。</p>
<p>VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p>
<p>VPN的协议分类主要有三种，PPTP、L2TP和IPSec，其中PPTP和L2TP协议工作在OSI模型的第二层，又称为二层隧道协议；IPSec是第三层隧道协议。</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。windows 通过安装 putty等软件可以帮助安装 ssh 协议。</p>
<a id="more"></a>
<h3 id="在VPN下使用SSH服务"><a href="#在VPN下使用SSH服务" class="headerlink" title="在VPN下使用SSH服务"></a>在VPN下使用SSH服务</h3><h4 id="github使用ssh协议："><a href="#github使用ssh协议：" class="headerlink" title="github使用ssh协议："></a>github使用ssh协议：</h4><ul>
<li><p>我们可以本地推送而免输入账户名密码，这里不作为本文重点，相关网址教程如下：</p>
<blockquote>
<p><a href="http://playingfingers.com/2016/03/26/build-a-blog/" target="_blank" rel="external">http://playingfingers.com/2016/03/26/build-a-blog/</a><br><a href="http://beiyuu.com/github-pages" target="_blank" rel="external">http://beiyuu.com/github-pages</a><br><a href="http://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="external">http://www.cnblogs.com/ayseeing/p/3572582.html</a><br><a href="http://blog.csdn.net/renfufei/article/details/37725057/" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/37725057/</a></p>
</blockquote>
</li>
</ul>
<h4 id="SSH无法推送"><a href="#SSH无法推送" class="headerlink" title="SSH无法推送:"></a>SSH无法推送:</h4><ul>
<li><p>当一切操作就绪后，会偶然出现无法通过SSH推送：</p>
<blockquote>
<p>等待很长时间后，显示超时！</p>
</blockquote>
</li>
</ul>
<h4 id="原理及方案："><a href="#原理及方案：" class="headerlink" title="原理及方案："></a>原理及方案：</h4><ul>
<li><strong>通过排查发现主要是由于链接的VPN引起的，SSH协议和VPN本身存在不兼容，要想解决可以通过底层设置让需要使用SSH协议的IP地址不经过VPN服务器，由电脑主机网卡直接访问。</strong></li>
</ul>
<h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ul>
<li>查看网卡情况</li>
</ul>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入指令：ifconfig</div><div class="line">下面出现的ppp0就是虚拟出来的VPN网卡。</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-28-linux下ssh通过VPN推送失败/2016-06-23-remarkable-install.png" alt=""></p>
<ul>
<li>查看ip列表,查看有哪些设置过了的IP地址</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route <span class="built_in">list</span></div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-28-linux下ssh通过VPN推送失败/DeepinScrot-3457.png" alt=""></p>
<ul>
<li>获取目标网站IP地址</li>
</ul>
<p><em>最简单的可以通过ping命令如下</em></p>
<p>ping www.github.com 终端返回：64 bytes from github.com (192.30.252.131): icmp_seq=1 ttl=54 time=210 ms，一般来说192.30.252.131 则为我们目标IP地址。但可能push的地址不一定是同一个地址。即便通过<code>nslookup + 详细网址</code>也未必能够获取真正推送的ip地址。最终通过谷歌搜索<a href="https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/" target="_blank" rel="external">网站</a>查看到github实际推送过程中ip地址为：192.30.252.0/22，（这边另外推荐可以使用wireshark进行抓包查看网络服务）</p>
<ul>
<li>将目标域名的IP地址加入到主机网卡中， 192.168.18.1为路由器网关的地址，通过上面ifconfig可以看到本机被路由器分配的ip地址为192.168.18.60，而eno1为计算机在访问外网中的实体网卡。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ip route add <span class="number">192.30</span><span class="number">.252</span><span class="number">.0</span>/<span class="number">22</span> via <span class="number">192.168</span><span class="number">.18</span><span class="number">.1</span> dev eno1</div></pre></td></tr></table></figure>
<ul>
<li>再次查看ip列表,查看有哪些设置过了的IP地址</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route <span class="built_in">list</span></div></pre></td></tr></table></figure>
<ul>
<li>最终完成推送<br><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-28-linux下ssh通过VPN推送失败/DeepinScrot-3044.png" alt=""></li>
</ul>
<hr>
<blockquote>
<p>参考网址：<br><a href="https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/" target="_blank" rel="external">https://help.github.com/articles/what-ip-addresses-does-github-use-that-i-should-whitelist/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于英国的独立日]]></title>
      <url>http://noparkinghere.top/2016/06/27/2016/2016-06-27-%E5%85%B3%E4%BA%8E%E8%8B%B1%E5%9B%BD%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%97%A5/</url>
      <content type="html"><![CDATA[<blockquote>
<p>6.24日英国通过公投，最终确认脱离欧盟。</p>
<p><a href="http://money.sohu.com/20160620/n455207391.shtml" target="_blank" rel="external">http://money.sohu.com/20160620/n455207391.shtml</a></p>
</blockquote>
<h3 id="英国和欧盟多年的友谊最终到了尽头"><a href="#英国和欧盟多年的友谊最终到了尽头" class="headerlink" title="英国和欧盟多年的友谊最终到了尽头"></a>英国和欧盟多年的友谊最终到了尽头</h3><p>不得不让人唏嘘，数十年的结盟，说散就散了，也许很多人英国人自己都难以相信这以现实。而如果要说英国与欧盟的矛盾，主要也是：</p>
<ul>
<li>英国自身条件优越，几个有钱的大哥后面跟了一群要钱的小弟，试想谁都不愿意。</li>
<li>欧盟这些年变得越来越大，不仅变得臃肿了，而且想要扩张自己的权利，很可能是想真正建立集权。</li>
<li>无非是难民问题，某些地区经过美国的打击，以及欧盟的被忽悠跟在后面起哄，最终越来越动荡，也使得难民潮不绝。</li>
</ul>
<p>虽说如此，另一方面英国通过欧盟也实实在在获得了很多好处，有些东西，一旦拥有了，就再也无法摆脱，英国大概也是如此，因为欧盟，伦敦成了世界的经济中心，也因为欧盟，英国有将近一半的公司来自于欧洲各国。英国的繁荣昌盛很大一部分程度是来自于其他各国对它的输入的，其实这和中国的上海并没有多大的区别，一个底子好地理位置好的地方可以成为经济贸易的中心，但这种荣耀并非属于你一个人的。英国认为要不断的去救济其他国家，拖累了自己，这看起来多么滑稽可笑，试想如果没有其他国家的支持，又怎么会有你今天的繁华呢？！就经济发展而言，英国离开欧盟可以相当于自断臂膀，相信未来很长一段时间，英国经济发展都在难有起色。与欧盟相比，所谓的英联邦，从过去到现在又真的有给英国经济带来过什么吗？</p>
<p>事实上欧洲也有很多国家发展的不错，也没有加入欧盟。很多人认为脱欧并代表不了什么。这就好比，如果你从来没有拥有过，你就也不会在乎你失去了什么。中国现在改革开放了，但如果说现在再次闭关锁国，在回到改革开放前，老百姓会受得了吗？！</p>
<blockquote>
<p><a href="http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj" target="_blank" rel="external">http://news.163.com/16/0627/01/BQHGTUAS00014JB6.html?bdsj</a></p>
</blockquote>
<a id="more"></a>
<h3 id="英国人请愿二次公投"><a href="#英国人请愿二次公投" class="headerlink" title="英国人请愿二次公投"></a>英国人请愿二次公投</h3><p>英国数百位万人请愿二次公投，很多人觉得是一个滑稽可笑的事情，但却细思极恐。公投象征了什么？无意象征了人民群众掌权，权力来自于人民的象征，人民决定国家命运的象征。一直以来，很多中国人也都羡慕美国投票选总统，但事实真的如此吗？英国作为金百年最发达的国家，人民群众的文化教育生活水平，不所谓不高吧？但仍然很多人将投票作为儿戏，很多人投票结束后采取谷歌搜索什么是欧盟？脱欧意味着什么？不得不说，卡梅隆真是相信自己的人民，而事实上历来都是：真理掌握在少数人手中，只有10%的人去统治90%的人的命运。将命运作为儿戏，权力不知道利用的人哪儿都用，中外也并没有区别。民众的倾向，一般也只会考虑到自己，什么对自己不好，往往最让他们印象深刻，所以看到难民影响他们生活了，就会有许多人投票要脱欧，却没有去想过，脱欧后谁来给他们供给廉价又可口的早餐，谁来为一些受理给欧盟的专利版权买单？</p>
<p>试想，如果中国人也拥有了公投，自己决定国家命运的权力！那会是什么样的乱象？！</p>
]]></content>
      
        <categories>
            
            <category> 个人观点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下安装remarkable]]></title>
      <url>http://noparkinghere.top/2016/06/23/2016/2016-06-23-remarkable-install/</url>
      <content type="html"><![CDATA[<h3 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h3><p><img src="https://raw.githubusercontent.com/noparkinghere/noparkinghere.github.io/master/img/2016-06-23-remarkable-install/remarkable.png" alt=""></p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>安装环境位ubuntu 16.04(64位)，markdown的网站无法正确的下载软件。</p>
<a id="more"></a>
<blockquote>
<p>附上其他下载地址：<a href="http://download.csdn.net/detail/ruanxingzhi/9402933" target="_blank" rel="external">http://download.csdn.net/detail/ruanxingzhi/9402933</a></p>
</blockquote>
<ol>
<li><p>下载的deb文件</p>
</li>
<li><p>使用dpkg -i remarkable**.deb 命令安装</p>
</li>
<li><p>安装过程出现缺失错误，使用sudo apt-get install -f 修复依赖关系，最终软件能够正确安装</p>
</li>
<li><p>如果出现了步骤3的情况，则重新执行步骤2</p>
</li>
<li><p>新版ubuntu系统出现错误：<br><code>GLib.Error: gtk-builder-error-quark: /usr/share/remarkable/ui/RemarkableWindow.ui:835:58 Object with ID  not found (13)</code></p>
</li>
</ol>
<ul>
<li>编辑 /usr/share/remarkable/ui/RemarkableWindow.ui将834~842之间的代码注释掉即可以解决问题：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!--</div><div class="line">                &lt;child&gt;</div><div class="line">                  &lt;object class=<span class="string">"GtkMenuItem"</span> id=<span class="string">"mnu_about"</span>&gt;</div><div class="line">                    &lt;property name=<span class="string">"related_action"</span>/&gt;</div><div class="line">                    &lt;property name=<span class="string">"visible"</span>&gt;True&lt;/property&gt;</div><div class="line">                    &lt;property name=<span class="string">"can_focus"</span>&gt;False&lt;/property&gt;</div><div class="line">                    &lt;property name=<span class="string">"label"</span> translatable=<span class="string">"yes"</span>&gt;About&lt;/property&gt;</div><div class="line">                    &lt;property name=<span class="string">"use_underline"</span>&gt;True&lt;/property&gt;</div><div class="line">                  &lt;/object&gt;</div><div class="line">                &lt;/child&gt;</div><div class="line">--&gt;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>安装软件显得较为简单，主要是出错之后的解决方法，因为软件较为小众，国内只能搜到两篇外文译稿，出错后也只能通过谷歌去一个个尝试解决办法。</li>
<li>该软件虽然较为轻巧，启动速度快，基本功能有，但个人仍然选择了atom（github提供的一款软件）作为markdown的常用书写环境，另外linux下也推荐可以使用chrome下的马克飞象插件或者直接使用<code>https://maxiang.io/</code>在线编辑。当然如果是vim高手，这些软件都没有必要。</li>
</ul>
<hr>
<blockquote>
<h4 id="参考网址："><a href="#参考网址：" class="headerlink" title="参考网址："></a>参考网址：</h4><p><a href="https://github.com/remarkableapp/Remarkable-Linux/issues/14" target="_blank" rel="external">https://github.com/remarkableapp/Remarkable-Linux/issues/14</a><br><a href="https://linux.cn/article-3741-1.html#comment" target="_blank" rel="external">https://linux.cn/article-3741-1.html#comment</a>  </p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下的shell和终端使用]]></title>
      <url>http://noparkinghere.top/2016/04/26/2016-04-26-linux%E4%B8%8B%E7%9A%84shell%E5%92%8C%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="ZSH使用"><a href="#ZSH使用" class="headerlink" title="ZSH使用"></a>ZSH使用</h3><p><em>bash为linux和OS X传统的默认shell，但使用起来比较麻烦，缺少一些人性化的特性，而现在流行的ZSH补足了bash的这些问题，且通过<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a>可以很方便的配置，因此已经广泛的被很多人使用。下面将会对网上的资料和自我使用经验做一个详细的总结。</em></p>
<p><em>本文主要学习总结，linux下的CLI的使用技巧，不以任何发行版为例，仅仅介绍最通用的bash下的快捷操作和相关技巧，当然bash本身也可以跨平台，在诸如OS X上面默认也使用bash，同样可以参考本文。</em></p>
<h3 id="Tmux使用"><a href="#Tmux使用" class="headerlink" title="Tmux使用"></a>Tmux使用</h3><a id="more"></a>
<blockquote>
<p>参考网址：<br><a href="http://blog.jobbole.com/87584/" target="_blank" rel="external">http://blog.jobbole.com/87584/</a><br><a href="http://xiaozhou.net/build-your-go-ide-2015-07-18.html" target="_blank" rel="external">http://xiaozhou.net/build-your-go-ide-2015-07-18.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
