
<!DOCTYPE html>
<html lang="null">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hexo">
    <title>Hexo</title>
    <meta name="author" content="John Doe">
    
    
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">Hexo</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="2">
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Inicio</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">Categorías</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Etiquetas</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archivos</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">Buscar</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">Acerca de</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/16/2016/2016-11-16-keil工程的代码优化/">
                            keil工程的代码优化
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-16T16:39:00+08:00">
	
		    16 Nov 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h3 id="C项目的工程优化"><a href="#C项目的工程优化" class="headerlink" title="C项目的工程优化"></a>C项目的工程优化</h3><p>这边主要参考另外一篇文章，不仅仅是针对C语言，C++等其他一些类C语言也同样适用。我们在构建自己的项目时，主要需要考虑：宏定义，类型，全局变量等的作用范围，针对头文件的引用和复制是否有存在的必要等。只有对每个细节都了如指掌，才能够减少代码的出错，以及优化代码空间等。就目前的芯片发展而言，很多时候都是硬件性能过剩，大多数程序员已经不再考虑或者极少考虑代码如何优化节省空间等问题了，往往更加注重代码的可阅读可扩展性，这边之所以注重这个问题，主要是考虑到工控节能领域，以及很多使用的模块可能存在代码量不足，不能胜任工作等问题。</p>
<h3 id="keil"><a href="#keil" class="headerlink" title="keil"></a>keil</h3><p>keil是一款MCU的IDE，有文章介绍过详细配置和调试步骤，这边不再详细累述。因为针对的是MCU的代码优化，所以首先我们必须知道编译器生成的代码量等信息。</p>
<p>每次点击编译后，下方会出现KEIL RVMDK编译后的信息，例如：Program Size: Code=19160 RO-data=6420 RW-data=108 ZI-data=1532，这边代表我的无任何优化的前提下，keil编译生成的代码为19160个字节。</p>
<p><strong>Code是代码占用的空间；RO-data(Read Only) 是只读常量的大小，如const型；RW-data（Read Write）是初始化了的可读写变量的大小，ZI-data（Zero Initialize）是没有初始化的可读写变量的大小。ZI-data不会被算做代码里因为不会被初始化。Total ROM Size ：Code + RO Data + RW Data（ROM Size并不等于Code + RO Data，初始化不为零的 RW Data 数据本身也会占用相同大小的 ROM 和 RAM 存储单元，变量在 RAM 中，而变量的初始值存在 ROM 中） ，Total RW  Size：RW Data + ZI Data 。这边在考虑芯片的 ROM 和 RAM 选型时，注意： ROM &gt; Code + RO Data + RW Data  ， 而 RAM &gt; RW-data+ZI-data，具体我们可以查看 KDE 编译后生成的 .map文件。</strong></p>
<p><img src="https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-16-keil%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/1.png" alt=""></p>
                    
                        <a href="/2016/11/16/2016/2016-11-16-keil工程的代码优化/" class="postShorten-excerpt_link link">
                            Seguir leyendo
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/15/2016/2016-11-15-notepad-和mingw/">
                            notepad++和MinGW
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-15T16:16:00+08:00">
	
		    15 Nov 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>今天写一个换算的小程序，但无奈手头没有编译工具，归根结底为何如此麻烦还是因为windows下的开发不友好不自带常规编译器所决定的，一个简单的程序编译需要你去安装庞大的IDE等。以前用windows偶尔弄点c代码编译或者查看一些文件都是使用notepad++的，有算是比较长的一段时间了，但不久前重装了系统，notepad++虽然仅仅需要选几个皮肤，简单配置作为文本编辑器即可，但无奈MinGW如何调用已经忘了，本文列出个简要步骤，以便下次查看。</p>
<h3 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h3><p>Windows下编写C语言程序，使用如VS2010之类的IDE往往显得大材小用，并且这些集成开发环境都占用了大量的系统和硬件资源，且不如Notepad++之类的编辑器简单易用、定制性强大。最重要的一点在于学习编程的话，建议不要怕麻烦还是从最基础的学起，IDE往往屏蔽了很多的细节，并不利于初学者的学习。Linux下写C推荐可以研习emacs、vim配gcc。起初是想从网上直接找个教程按部就班执行，轻松配置完成的，但看了几个教程都不尽如人意，通过自己多次尝试最终找到了较为满意的解决方法，文章列出了部分参考网络教程的链接，下面对此详细阐述。而MinGW (Minimalist GNU for Windows)听名字就只是很强大，因为gcc的使用广泛和强大，无疑这个套件是编译的理想选择。</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><a href="https://pan.baidu.com/s/1slNDMtn">notepad++</a>只是一个文本编辑器，本身没有编译C/C++的功能。所以要想先配置，就要先装上一个编译器。MinGW是GNU开源社区面向windows用户提供的一个集成了个编译环境的软件包。一般可以通过搜索MinGW直接去官网下载安装，但官网貌似是在线安装，因此我从其他网站下载了<a href="https://pan.baidu.com/s/1bFK8TC">MinGW-5.1.6</a>离线包，安装步骤很简单，这边不具体阐述。</p>
                    
                        <a href="/2016/11/15/2016/2016-11-15-notepad-和mingw/" class="postShorten-excerpt_link link">
                            Seguir leyendo
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/10/2016/2016-11-10-美国总统诞生了/">
                            美国总统诞生了
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-10T08:53:00+08:00">
	
		    10 Nov 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>2016年11月9日，美国大选计票结果显示：共和党候选人唐纳德·特朗普已获得了276张选举人票，超过270张选举人票的获胜标准，成为美国第45位总统。</p>
<p>就在昨天美国总统诞生了，很多网络论坛称新一代总统为喷子界的骄傲。如果特朗普真如他做演讲时那样治国，无疑整个美国或者说全球会发生大的动荡，特朗普于历来总统都不太一样，就他演讲来说，几乎是完全站在美国贫民普通阶层这边的，因此我们通过谷歌各州的投票结果也可以看出，支持特朗普的几乎全是美国欠发达地区。特朗普的政治主张很反科技，甚至有点另类到要将劳动密集的行业重新带回美国，他的很多举止有点让人摸不着头脑，但也确实是针对美国一些顽疾的一剂猛药。这届美国总统是一个较大的变数，就特朗普的种种举措，可以分两点。</p>
<p>其一，特朗普能够切实的成为一个出色的总统，通过降低税收，增强了创业公司的活力，通过自动化和本地工人结合创造了更多就业，解决了民生问题等。</p>
<p>其二，将美国彻底的玩坏了，一味的打压科技公司，阻止了美国的发展，本地的一些民生政策也出现了较大的问题等。</p>
<p>当然除了以上的一些猜测，不得不怀疑，特朗普是一个彻头彻尾的骗子，不择手段上台了之后，并没有履行任何他的承诺。</p>
                    
                        <a href="/2016/11/10/2016/2016-11-10-美国总统诞生了/" class="postShorten-excerpt_link link">
                            Seguir leyendo
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/10/2016/2016-11-10-c语言工程组建/">
                            C语言工程组建
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-10T08:21:00+08:00">
	
		    10 Nov 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>每个编程语言都有自己的一些特性，如果了解的很清楚能够减少你编译的时间，减少编译所生成的文件大小，提高你程序的执行效率。虽然现在计算机发展很快，在众多高级语言中已经很少考虑这种问题，但如果是使用c语言编写一些运行在资源较紧张的芯片或编写能耗敏感的一些项目时，仔细研究每个细节，合理的组建自己的工程等还是相当必要的。</p>
                    
                        <a href="/2016/11/10/2016/2016-11-10-c语言工程组建/" class="postShorten-excerpt_link link">
                            Seguir leyendo
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/11/03/2016/2016-11-03-如何看待蓝绿大厂问鼎中国/">
                            如何看待蓝绿大厂问鼎中国
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-11-03T22:25:00+08:00">
	
		    03 Nov 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>根据IDC的数据，今年第三季度，OPPO和VIVO在中国市场的出货量再创新高，首度成为中国市场的冠亚军。OPPO和VIVO历来以低配高价而文明科技圈内，且低于红米的配置和软件优化，但却卖出几倍的价格，一味的再外观上模仿苹果，广告上轰炸观众，再加上市面上很难找到专业的评测机构来测评这两家的手机等一系列因素，因此很多人都会对这两家产品很是不屑，称他们为“蓝绿大厂，高价低配，专坑厂妹”。但本着存在即为合理的看法，OPPO和VIVO一定还是有很多可取之处的，不然不可能在竞争日益激烈的手机市场上面，站稳脚跟，国内销量先干掉小米，后挤掉华为，且业绩日益攀升。我将蓝绿厂家成功可以总结为以下几点。</p>
<hr>
<p><img src="https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/1.jpg" alt=""></p>
<h3 id="差强人意"><a href="#差强人意" class="headerlink" title="差强人意"></a>差强人意</h3><p>就产品本身而言，两家主打的功能也都基本一致：自拍，音效，快充。这几点都算是手机某一项的特色功能，但老实说都不具备特色，因为国产手机大都在这些功能上面表现的不差，下面进行详细解析。</p>
<p>在评价一个手机拍照性能时，大都以是否能够更加真实的还原场景为标准，常用的参考量为：解析力，白平衡，夜间成像能力等等。因为手机不同于单反之类的产品，毕竟机身空间有限，每次捕捉的光源数据会经过大量的加工处理才会得到样张的，所以硬件参数即便再好（光圈大，像素高），如果没有好的算法，往往会适得其反，这就是为何苹果800w摄像头可以秒杀别人1600w大光圈的原因。说完拍照来提一下自拍，自拍本身属于照骗的一个制造过程（拍的美不美，有可能你自拍出的照片你妈都不认识），摄像头要拍出真实的照片不容易，但要毁照的话，只需要进行一定的图像识别，加上特定的滤镜效果即可。市面上面除了iPhone功能单一外，其他手机大多有很强的自拍功能，什么深度磨破，瘦脸，背景虚化，多人拍照只对自己美化等，各种功能都深入到各家自身的ROM中去了，无需下载第三方软件。而OV两家因为主打自拍，所以前置摄像头像素极高，甚至超过了后置摄像头，这边到底拍的美不美，一来和你参数的选择有关，二来每个人的审美不尽相同。</p>
<p>音效是一个模糊的概念，外放的音效极少有做的好的厂家，毕竟手机越做越小，虽然芯片在不断的发展，但数字电路很难做出模拟电路电路的音效体验。最近两年的主流中高端手机都不会在音效上面大做文章，显然有一道大家无法逾越的屏障拦在前面。目前中高端手机的外放基本只能判别音量大小，音效的好坏目前主要取决于耳机以及针对耳机的一些优化，但一个好耳机动辄千元起步，除了极少数用户，目前也几乎没有谁愿意为它买单。</p>
<p>快充技术基本上在手机界已经普及（除了反应迟钝的苹果），市面上各种快充技术都不尽相同，升压，升流各种方式都有。来自高通的Quick Charge 2.0是随骁龙800开始盛行的快充技术，早在两年多前，小米4就已经实现了快充，另外MTK和麒麟处理器等也都相继推出了自身的快充技术，也就是说快充家家都有，只不过OV两家的广告让大家知道了他们手机有这个功能而已。</p>
<p>在产品上面这两家算是没有任何特长的手机厂家，首先配置差，采用的一般是骁龙最新的中低端处理器（其他国产厂家一般会在千元左右的手机机使用该处理器）；其次是软件上开发能力较弱，缺失一些必备或者特色功能（如：远程协助，微信多开等功能都缺失，虽然可以通过第三方软件实现，但毕竟安全无保障），在一些手机自带功能上面的体验不足，如手势等操作识别错误，可能与这颗CPU性能较差，或者软件优化不足有关；再者其他诸如续航和通话信号等都没太多可以圈点的。综上这些，就可以知道为啥这么多人对它很诟病。</p>
<p>软件和外观极度模仿苹果，很多交互方式和苹果一致，甚至连很多图标都一模一样，也许可以进一步满足很多人的虚荣心。</p>
<p>说完这么多缺点，下面谈一下优点，两家厂家在手机使用上面都能够满足正常的需求，对于很久没试用过其他安卓手机的用户而言，这两款手机基本能够带来舒适愉快的体验，由于从14年开始，安卓手机配置基本上已经能够满足安卓系统的要求了，所以换句话说，14年的所有高配置的手机，只要没有质量问题，且你对拍照，三防等一些附加属性没有特殊要求，重新恢复出厂设置或者耍个新系统，现在一样可以当作新机来使用。</p>
<p>举个例子：OV两家的CPU &lt; 荣耀6的CPU，OV两家的CPU &lt; MI4的CPU；OV两家的GPU &gt; 荣耀6的GPU，OV两家的GPU &lt; MI4的GPU。因此可以看出，在多任务切换体验来说（常规APP，不包含游戏，不包含系统自带软件功能），OV一般只能同时完美体验3-4个应用，荣耀6和MI3一般可以体验6-8个应用。荣耀6基本上已经不能胜任市面的中等要求的游戏（王者荣耀等），MI4和能够完全可以胜任中等要求的游戏，且可以冲击一些高负荷的游戏，OV能够胜任中等要求的游戏。</p>
<p>因为这两年CPU和GPU虽然略有提升，但大多数人很少会玩大型游戏或者运行n多个APP，对CPU和GPU的型号，好坏与否并不关心，甚至很多人觉得手机不错，自始至终并不了解自己的手机比别家的好或者差。</p>
<p>对特色功能的体验一般也仅仅限于手机重度爱好使用者，MIUI，FLYME和EMUI等各家系统很多功能虽然好用，但由于缺乏推广，普通用户并不关注，或者说从来没用过，不知道有这些功能。安卓手机从14年开始早已进入了厂商引导消费体验的阶段，普通消费者对手机已经不存在不满和需求，甚至觉得太强大，很多功能不会用，不会设置，而恰恰是厂家在帮用户思考增加哪些功能会让体验更加的完美，护眼模式，远程协助，单手模式，节电模式等都是各家厂家在提升用户体验上面的尝试。</p>
<p>综上可以看出，在手机同质化的今天，OV基本可以满足市面上面的绝大多数需求，虽然还会有误触，略微卡顿等问题，但相比过去安卓的不响应，发热，死机重启等，已经好了太多，普通消费者看个视频，玩玩小游戏完全可以满足，从苹果转来的用户会觉得便宜几千体验也差不多了多少，较为满意，而从旧款安卓低端机转过来的用户，则会认为大屏不卡顿不死机，好了太多。满足刚需就好，其他能有的功能尽量往上加，作绝大多数普通消费者能够使用的手机即可，这也是OV两家作产品的精髓。</p>
<p><img src="https://github.com/noparkinghere/noparkinghere.github.io/raw/master/_pic/2016-11-03-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%93%9D%E7%BB%BF%E5%A4%A7%E5%8E%82%E9%97%AE%E9%BC%8E%E4%B8%AD%E5%9B%BD/2.jpg" alt=""></p>
                    
                        <a href="/2016/11/03/2016/2016-11-03-如何看待蓝绿大厂问鼎中国/" class="postShorten-excerpt_link link">
                            Seguir leyendo
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/30/2016/2016-10-30-uart-spi-iic的比较/">
                            uart/spi/iic的比较
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-30T14:11:00+08:00">
	
		    30 Oct 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_50cfd0fc0101flsn.html</a></p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/30/2016/2016-10-30-uart-spi-iic的比较/#post-footer" class="postShorten-excerpt_link link">
                                Comentar y compartir
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/30/2016/2016-10-30-大端和小端/">
                            大端和小端
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-30T10:30:00+08:00">
	
		    30 Oct 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>
<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。</p>
<p><strong>端模式(Byte Endian)</strong> 是指字节在内存中的组织，所以也称它为Byte Ordering。这边所谓的端模式一般就是指大端或者小端存储，也就是每个字节的实际排放顺序，上面已经讨论过字节在内存中如何进行对齐，这边讨论字节的常见排放顺序。</p>
<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>
<p>注意：有些地方 MSB 也可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的高地位而不是字节。</p>
<h3 id="端模式-Byte-Endian-简述"><a href="#端模式-Byte-Endian-简述" class="headerlink" title="端模式(Byte Endian)简述"></a>端模式(Byte Endian)简述</h3><ul>
<li><p>大端模式：数据低位存放到地址高位。比如：存储数据0x01234567，按照0x01-&gt;1000，0x23-&gt;1001，0x45-&gt;1002，0x67-&gt;1003这种顺序存储。通讯中大都采用大段模式，因为数据通讯时，直接可以按照一个个位进行解析，无需每次调换顺序，大端模式往往在通讯中被广泛使用。</p>
</li>
<li><p>小端模式：一般也称作内存模式，数据高位存放到地址高位。比如：存储数据0x01234567，按照0x67-&gt;1000，0x45-&gt;1001，0x23-&gt;1002，0x01-&gt;1003这种顺序存储。小端比较符合人的一般思维逻辑。嵌入式芯片中目前主流就是小端模式，绝大多数ARM芯片默认也为小端模式，但可以进行更改设置，传统的51芯片为大端模式。</p>
</li>
</ul>
<p>除了大小段模式外，还有一些协议自定义的转换标准，有的协议将两个字节(16bit)作为一个整体，如：传送数据0x00010203（按照内存模式/小端模式传送）时，会解析为0x0100，0x0302，具体分析，实际上采用的是大端模式，每次传输数据时，将16个作为个整体进行解析。</p>
<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>最近阮一峰老师的博客刚好也写了一篇有关大小端的文章，老实说，大小端本人也接触很久了，但也一直较为困惑，另外时间一长每次就忘了哪个是大端哪个是小端，这边给出一些个人的理解和分析。</p>
<p>描述大小端时有一点表示的比较模糊，这边前后有两种含义：1.内存的寻址肯定是从低往高的，所以下面表示的前或者后，都是以内存作为参照，前表示内存的低地址，后表示内存高地址；2.通信过程中，传输在前表示先被传输打印过来的值，传输在后表示后被传输打印出来的值（传输的过程也需要明确一点，数据的传输打印不是被逐个挤到后面去的，而是在后面以append的形式显示，后来的数据显示在后方）。明确了这两点内容这边详细谈下大小端：</p>
<ul>
<li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。内存中低地址对应数据的高位，传输中数据高位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 78 9A 6B 这种更加符合人的阅读习惯。</li>
<li>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。内存中低地址对应数据的低位，传输中数据低位先被打印出来，因为先被打印出来（而打印按照从左往右的顺序逐个显示），所以例如：0x789A6B 就会显示为 6B 9A 78 这种更加符合人的阅读习惯。</li>
</ul>
<p>这边有些同学可能又有疑惑，为何 6B 可以解析为 6B(01101011) 而不是反过来 D6(11010110) 呢？事实上计算机在传输过程中确实有一个接近统一的标准的，无论是大端还是小端或者各种通讯协议（至少各种协议我还没有见过违背这个准则的），都满足原则：<strong>先传输字符的低位，后传输字符的高位。</strong></p>
<ul>
<li><em>以下内容引用自阮一峰老师的博客：</em>  </li>
</ul>
<blockquote>
<p>首先，为什么会有小端字节序？答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。<br>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p>
</blockquote>
<p>个人认为该内容有待斟酌，如 51 单片机就是大端模式，另外很多 ARM 的 MCU 都是默认小端，且可以用户自己设置选用大端还是小端模式的。个人认为计算机内部并不会因为大小端而影响效率，在设计芯片时应该已经决定了它的特性。小端模式在不考虑传输，人工查看的前提下，对例如：00 78 9A 6B 用 6B所对应的地址来表示 0x789A6B 这个数据数据的存储位置，也是有一定道理的。</p>
<h3 id="记忆方法"><a href="#记忆方法" class="headerlink" title="记忆方法"></a>记忆方法</h3><blockquote>
<p>在乔纳森·斯威夫特的著名讽刺小说《格列夫游记》中，小人国内部分裂成Big-endian和Little-endian两派，区别在于一派要求从鸡蛋的大头把鸡蛋打破，另一派要求从鸡蛋的小头把鸡蛋打破。斯威夫特借以讽刺英国的政党之争，在计算机工业中指数据储存顺序的分歧。</p>
</blockquote>
<p>这边首先需要有个参照物，计算机按照从低位往高位寻址这是毋容置疑的，存储时，也都是讲内存的低位用完后，指针加一，再使用更高的位。大端意味着内存的低位存储了数据的高位，小端则是内存的低位对应了数据的低位。</p>
<h3 id="测试大小端参考代码："><a href="#测试大小端参考代码：" class="headerlink" title="测试大小端参考代码："></a>测试大小端参考代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">方法1：</div><div class="line">typedef unsigned char u8;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	unsigned long int a = 0x01020304;</div><div class="line"></div><div class="line">	for (u8 i = 0; i &lt; 4; i++)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;%d&quot;, *((u8 *)&amp;a + i));  // 注意先加a的地址转换为无符号字符型再加地址，否则每次加1，地址会增加4。</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果结果为：4321则为小端模式，而1234为大端模式。</div><div class="line"></div><div class="line">方法2：</div><div class="line"></div><div class="line">typedef union</div><div class="line">&#123;</div><div class="line">	unsigned short int a;</div><div class="line">	unsigned char b;</div><div class="line">&#125;Union;</div><div class="line"></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	Union u1;</div><div class="line">	u1.a = 0x0201;</div><div class="line"></div><div class="line">	if (u1.b == 0x01)</div><div class="line">		printf(&quot;little endian\n&quot;);</div><div class="line">	else if (u1.b == 0x02)</div><div class="line">		printf(&quot;big endian\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考链接：<br><a href="http://blog.csdn.net/vvzaixian/article/details/7067221" target="_blank" rel="external">http://blog.csdn.net/vvzaixian/article/details/7067221</a><br><a href="http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml" target="_blank" rel="external">http://www.360doc.com/content/12/0413/10/1016783_203216902.shtml</a><br><a href="https://my.oschina.net/chaenomeles/blog/673091" target="_blank" rel="external">https://my.oschina.net/chaenomeles/blog/673091</a><br><a href="http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4afb1c4c010009oa.html</a><br><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/30/2016/2016-10-30-大端和小端/#post-footer" class="postShorten-excerpt_link link">
                                Comentar y compartir
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/30/2016/2016-10-30-字节对齐/">
                            字节对齐
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-30T07:32:00+08:00">
	
		    30 Oct 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p><em>大小端和字节对齐，与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</em></p>
<p>我们常常看到“alignment”， “endian”之类的字眼， 但很少有 C 语言教材提到这些概念。 实际上它们是与处理器与内存接口， 编译器类型密切相关的。与 CPU 结构有关，与编译器没关系，只与编译器的默认代码约定规则有关。只要代码约定规则一样（可在代码中加入约定命令），不同编译器编译出来结果是一样的。</p>
<h3 id="字节对齐（Byte-Alignment）"><a href="#字节对齐（Byte-Alignment）" class="headerlink" title="字节对齐（Byte Alignment）"></a>字节对齐（Byte Alignment）</h3><p>我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是 struct 数据结构的 sizeof 结果，出乎意料。为此，我们需要对对齐算法所了解。</p>
<p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p>内存地址对齐，是一种在计算机内存中排列数据、访问数据的一种方式，包含了两种相互独立又相互关联的部分：基本数据对齐和结构体数据对齐。当今的计算机在计算机内存中读写数据时都是按字(word)大小块来进行操作的(在32位系统中，数据总线宽度为32，每次能读取4字节，地址总线宽度为32，因此最大的寻址空间为2^32=4GB，但是最低2位A[0]，A[1]是不用于寻址，A[2-31]才能存储器相连，因此只能访问4的倍数地址空间，但是总的寻址空间还是2^30 <em> 字长 = 4GB，因此在内存中所有存放的基本类型数据的首地址的最低两位都是0，除结构体中的成员变量)。<strong>基本类型数据对齐就是数据在内存中的偏移地址必须等于一个字的倍数</strong>，按这种存储数据的方式，可以提升系统在读取数据时的性能。<em>*为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节，这就是结构体数据对齐</em></em>。</p>
<p>举个例子，假设计算机的字大小为4个字节，因此变量在内存中的首地址都是满足4地址对齐，CPU只能对4的倍数的地址进行读取，而每次能读取4个字节大小的数据。假设有一个整型的数据a的首地址不是4的倍数(如下图所示)，不妨设为0X00FFFFF3，则该整型数据存储在地址范围为0X00FFFFF3~0X00FFFFF6的存储空间中，而CPU每次只能对4的倍数内存地址进行读取，因此想读取a的数据，CPU要分别在0X00FFFFF0和0X00FFFFF4进行两次内存读取，而且还要对两次读取的数据进行处理才能得到a的数据，而一个程序的瓶颈往往不是CPU的速度，而是取决于内存的带宽，因为CPU得处理速度要远大于从内存中读取数据的速度，因此减少对内存空间的访问是提高程序性能的关键。从上例可以看出，采取内存地址对齐策略是提高程序性能的关键。</p>
<p>结构体(struct)是C语言中非常有用的用户自定义数据类型，而结构体类型的变量以及其各成员在内存中的又是怎样布局的呢？怎样对齐的呢？很显然<strong>结构体变量首地址必须是4字节对齐的</strong>，但是<strong>结构体的每个成员有各自默认的对齐方式</strong>，结构体中各成员在内存中出现的位置是随它们的声明顺序依次递增的，并且<strong>第一个成员的首地址等于整个结构体变量的首地址</strong>。下面列出了在Microsoft，Borland，GNU上对于X86架构32位系统的结构体成员各种类型的默认对齐方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">char(1字节)，1字节对齐</div><div class="line">short(2字节)，2字节对齐</div><div class="line">int(4字节)，4字节对齐</div><div class="line">float(4字节)，4字节对齐</div><div class="line">double(8字节)，Windows系统中8字节对齐，Linux系统中4字节对齐。</div><div class="line">*不同CPU的对其规则可能不同, 请参考手册。*</div></pre></td></tr></table></figure>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>
                    
                        <a href="/2016/10/30/2016/2016-10-30-字节对齐/" class="postShorten-excerpt_link link">
                            Seguir leyendo
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/29/2016/2016-10-29-spi通信详解/">
                            SPI通信详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-29T14:09:00+08:00">
	
		    29 Oct 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <a id="more"></a>
<blockquote>
<p>参考链接：<br><a href="http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html" target="_blank" rel="external">http://wenku.baidu.com/view/2a0a7f9869dc5022abea001d.html</a><br><a href="http://baike.baidu.com/item/SPI" target="_blank" rel="external">http://baike.baidu.com/item/SPI</a><br><a href="https://my.oschina.net/freeblues/blog/67400" target="_blank" rel="external">https://my.oschina.net/freeblues/blog/67400</a></p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/29/2016/2016-10-29-spi通信详解/#post-footer" class="postShorten-excerpt_link link">
                                Comentar y compartir
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/10/29/2016/2016-10-29-msb-和-lsb/">
                            MSB 和 LSB
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-10-29T11:23:00+08:00">
	
		    29 Oct 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>MSB 和 LSB 在计算机中的意思并不唯一确定，这边分为两种解释：</p>
<ul>
<li>MSB ： Most Significant Bit，LSB ： Least Significant Bit</li>
<li>MSB ： Most Significant Byte，LSB ： Least Significant Byte</li>
</ul>
<p>但有一点可以确定的是：MS 往往代表是重要的，而 LS 则代表不重要的，比如 传递数据 1001 时，高位的数据单位是千，肯定比低位数据单位是个来的更加重要，所以往往丢失低位数据的影响要远远小于丢失高位数据。</p>
<h3 id="高低位"><a href="#高低位" class="headerlink" title="高低位"></a>高低位</h3><p>MSB 可以代表 Most Significant Bit，LSB 则代表 Least Significant Bit 根据具体的场景来判别。在很多涉及到 SPI/IIC 通讯的芯片手册中，如：FM25W256 铁电或者 EEPROM 中，描述的 MSB/LSB 根据时序图往往可以判别代表的是高地位而不是字节。</p>
<p>一般而言，采用 Data is written MSB first 的方式会更好些，如上面所叙述的那样， MSB 代表的是<strong>重要位（Most Significant Bit</strong>，先传递重要位，能够减少重要位被丢失的可能性，目前像 I2C，SPI等通讯协议都保留了设置先传递 MSB 还是先传递 LSB 的功能，但是绝大多数的厂家的芯片手册都会注明<strong>Data is written MSB first</strong>。</p>
<p>但值得注意的是，uart 通讯中全部采用<strong>Data is written LSB first</strong>，即先传递低位数据，且芯片配置中是无法更改 uart 传递位的次序的，换言之，uart 是一种较古老的通讯协议，通讯中一定是从低位往高位传递数据。大家在使用时基本不需要考虑 MSB 和 LSB 的先写入顺序，因为已经固定死了，所有使用该设备的 232/485，上/下位机，都必须遵守这个规则。</p>
<h3 id="高低字节"><a href="#高低字节" class="headerlink" title="高低字节"></a>高低字节</h3><p>MSB 可以代表 Most Significant Byte，LSB 则代表 Least Significant Byte 根据具体的场景来判别。一般在串口通讯场景中， MSB 和 LSB 代表的是字节。</p>
<p>数据寻址时，一般读取的都是低位字节的地址（即存储数据的可能占用多个地址，但低位地址代表了这个数据的存储地址）。C 中的数据类型都是从内存的低地址向高地址扩展，取址运算”&amp;”都是取低地址。 所以就有高位地址和地位地址区别，一般来说数字大的就是高地址，数字小的是地址：比如 0x1000 相对于 0x1003 来说是低地址。数据低位和数据高位：比如 0x012345678 0x01 是数据高位（即使 Most Significant Byte，MSB 位），而 0x78 是数据低地址位（Least Significant Byte，LSB）。</p>
<p>计算机中，究竟高字节先被存储还是低字节先被存储，以及传输过程中先发送高位字节还是低位字节这个往往取决于 CPU 的结构，是大端小端问题，可以参考具体文章。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/10/29/2016/2016-10-29-msb-和-lsb/#post-footer" class="postShorten-excerpt_link link">
                                Comentar y compartir
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/page/2/">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>ARTÍCULOS RECIENTES</span>
            </a>
        </li>
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/page/4/">
                    <span>ARTÍCULOS ANTERIORES</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">página 3 de 10</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 John Doe. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">John Doe</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->



</html>
